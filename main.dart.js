// Generated by dart2js, the Dart to JavaScript compiler.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
(function($) {
function dart(){ this.x = 0 }var A = new dart;
delete A.x;
var B = new dart;
delete B.x;
var C = new dart;
delete C.x;
var D = new dart;
delete D.x;
var E = new dart;
delete E.x;
var F = new dart;
delete F.x;
var G = new dart;
delete G.x;
var H = new dart;
delete H.x;
var J = new dart;
delete J.x;
var K = new dart;
delete K.x;
var L = new dart;
delete L.x;
var M = new dart;
delete M.x;
var N = new dart;
delete N.x;
var O = new dart;
delete O.x;
var P = new dart;
delete P.x;
var Q = new dart;
delete Q.x;
var R = new dart;
delete R.x;
var S = new dart;
delete S.x;
var T = new dart;
delete T.x;
var U = new dart;
delete U.x;
var V = new dart;
delete V.x;
var W = new dart;
delete W.x;
var X = new dart;
delete X.x;
var Y = new dart;
delete Y.x;
var Z = new dart;
delete Z.x;
function Isolate() {}
init();

$ = Isolate.$isolateProperties;
var $$ = {};

// Native classes
init.mangledNames = {get$Arcade: "Arcade", get$OVERLAP_BIAS: "OVERLAP_BIAS", get$TILE_BIAS: "TILE_BIAS", get$_PIXI$__tilePattern: "_PIXI$__tilePattern", get$_PIXI$_text: "_PIXI$_text", get$_Phaser$_add: "_Phaser$_add", get$_Phaser$_bounds: "_Phaser$_bounds", get$_Phaser$_buffer: "_Phaser$_buffer", get$_Phaser$_currentBounds: "_Phaser$_currentBounds", get$_Phaser$_dirty: "_Phaser$_dirty", get$_Phaser$_duration: "_Phaser$_duration", get$_Phaser$_dx: "_Phaser$_dx", get$_Phaser$_dy: "_Phaser$_dy", get$_Phaser$_height: "_Phaser$_height", get$_Phaser$_keys: "_Phaser$_keys", get$_Phaser$_parent: "_Phaser$_parent", get$_Phaser$_width: "_Phaser$_width", get$_UID: "_UID", get$__hit: "__hit", get$__isDown: "__isDown", get$__isOver: "__isOver", get$__mouseIsDown: "__mouseIsDown", get$__stage: "__stage", get$__tilePattern: "__tilePattern", get$__touchData: "__touchData", get$_a: "_a", get$_align: "_align", get$_anchor: "_anchor", get$_angle: "_angle", get$_anims: "_anims", get$_args: "_args", get$_attachmentTime: "_attachmentTime", get$_average: "_average", get$_backgroundColor: "_backgroundColor", get$_binary: "_binary", get$_bindings: "_bindings", get$_bitmapDatas: "_bitmapDatas", get$_bitmapFont: "_bitmapFont", get$_bounds: "_bounds", get$_cache: "_cache", get$_cacheAsBitmap: "_cacheAsBitmap", get$_cacheIsDirty: "_cacheIsDirty", get$_cacheMap: "_cacheMap", get$_cachedSprite: "_cachedSprite", get$_canvas: "_canvas", get$_canvases: "_canvases", get$_capture: "_capture", get$_chainedTweens: "_chainedTweens", get$_check: "_check", get$_clearCache: "_clearCache", get$_clearWorld: "_clearWorld", get$_codeMuted: "_codeMuted", get$_codePaused: "_codePaused", get$_colorBuffer: "_colorBuffer", get$_column: "_column", get$_context: "_context", get$_counter: "_counter", get$_cr: "_cr", get$_created: "_created", get$_crop: "_crop", get$_currentBounds: "_currentBounds", get$_currentFrame: "_currentFrame", get$_currentGraphics: "_currentGraphics", get$_currentId: "_currentId", get$_currentPath: "_currentPath", get$_delayTime: "_delayTime", get$_diameter: "_diameter", get$_diff: "_diff", get$_dirty: "_dirty", get$_drag: "_drag", get$_dragPhase: "_dragPhase", get$_dragPoint: "_dragPoint", get$_draggedPointerID: "_draggedPointerID", get$_easingFunction: "_easingFunction", get$_edge: "_edge", get$_explode: "_explode", get$_fileIndex: "_fileIndex", get$_fileList: "_fileList", get$_filterArea: "_filterArea", get$_filterBlock: "_filterBlock", get$_filters: "_filters", get$_font: "_font", get$_fontSize: "_fontSize", get$_fontWeight: "_fontWeight", get$_frame: "_frame", get$_frameData: "_frameData", get$_frameDiff: "_frameDiff", get$_frameIndex: "_frameIndex", get$_frameName: "_frameName", get$_frameNames: "_frameNames", get$_frameSkip: "_frameSkip", get$_frames: "_frames", get$_glFilterTexture: "_glFilterTexture", get$_glTextures: "_glTextures", get$_graphicsData: "_graphicsData", get$_hasLoaded: "_hasLoaded", get$_height: "_height", get$_hiddenVar: "_hiddenVar", get$_highestInputPriorityID: "_highestInputPriorityID", get$_highestRenderObject: "_highestRenderObject", get$_highestRenderOrderID: "_highestRenderOrderID", get$_history: "_history", get$_holdSent: "_holdSent", get$_i: "_i", get$_images: "_images", get$_indexBuffer: "_indexBuffer", get$_interactive: "_interactive", get$_interactiveEventsAdded: "_interactiveEventsAdded", get$_interpolationFunction: "_interpolationFunction", get$_isMask: "_isMask", get$_isOnce: "_isOnce", get$_isPaused: "_isPaused", get$_isSetTimeOut: "_isSetTimeOut", get$_iterations: "_iterations", get$_json: "_json", get$_justResumed: "_justResumed", get$_k: "_k", get$_lastChild: "_lastChild", get$_len: "_len", get$_lineSpacing: "_lineSpacing", get$_listener: "_listener", get$_localPoint: "_localPoint", get$_manager: "_manager", get$_mapData: "_mapData", get$_marked: "_marked", get$_mask: "_mask", get$_maxOverlap: "_maxOverlap", get$_maxParticleScale: "_maxParticleScale", get$_mc: "_mc", get$_minParticleScale: "_minParticleScale", get$_muteVolume: "_muteVolume", get$_muted: "_muted", get$_newTick: "_newTick", get$_newVelocity1: "_newVelocity1", get$_newVelocity2: "_newVelocity2", get$_nextDrop: "_nextDrop", get$_nextOffsetCheck: "_nextOffsetCheck", get$_now: "_now", get$_object: "_object", get$_oldPosition: "_oldPosition", get$_onBoot: "_onBoot", get$_onChange: "_onChange", get$_onDecodedEventDispatched: "_onDecodedEventDispatched", get$_onDownFrameID: "_onDownFrameID", get$_onDownFrameName: "_onDownFrameName", get$_onKeyDown: "_onKeyDown", get$_onKeyPress: "_onKeyPress", get$_onKeyUp: "_onKeyUp", get$_onLoop: "_onLoop", get$_onMouseDown: "_onMouseDown", get$_onMouseMove: "_onMouseMove", get$_onMouseOut: "_onMouseOut", get$_onMouseOver: "_onMouseOver", get$_onMouseUp: "_onMouseUp", get$_onMouseWheel: "_onMouseWheel", get$_onOutFrameID: "_onOutFrameID", get$_onOutFrameName: "_onOutFrameName", get$_onOverFrameID: "_onOverFrameID", get$_onOverFrameName: "_onOverFrameName", get$_onStartCallbackFired: "_onStartCallbackFired", get$_onUpFrameID: "_onUpFrameID", get$_onUpFrameName: "_onUpFrameName", get$_onUpdateCallback: "_onUpdateCallback", get$_onUpdateCallbackContext: "_onUpdateCallbackContext", get$_outOfBoundsFired: "_outOfBoundsFired", get$_outputFrames: "_outputFrames", get$_overlap: "_overlap", get$_packIndex: "_packIndex", get$_packList: "_packList", get$_parent: "_parent", get$_pauseStartTime: "_pauseStartTime", get$_pauseStarted: "_pauseStarted", get$_pauseTotal: "_pauseTotal", get$_paused: "_paused", get$_pausedTime: "_pausedTime", get$_pendingState: "_pendingState", get$_pendingStateKey: "_pendingStateKey", get$_physics: "_physics", get$_playing: "_playing", get$_pointerData: "_pointerData", get$_pointerLockChange: "_pointerLockChange", get$_points: "_points", get$_pollCounter: "_pollCounter", get$_pool: "_pool", get$_potentials: "_potentials", get$_powerOf2: "_powerOf2", get$_prevParams: "_prevParams", get$_priority: "_priority", get$_progressChunk: "_progressChunk", get$_quantity: "_quantity", get$_radius: "_radius", get$_ready: "_ready", get$_repeat: "_repeat", get$_requiresUpdate: "_requiresUpdate", get$_reset: "_reset", get$_result: "_result", get$_results: "_results", get$_reversed: "_reversed", get$_rotationCache: "_rotationCache", get$_s: "_s", get$_scroll: "_scroll", get$_setHandCursor: "_setHandCursor", get$_shouldPropagate: "_shouldPropagate", get$_signal: "_signal", get$_sortProperty: "_sortProperty", get$_sound: "_sound", get$_sounds: "_sounds", get$_sr: "_sr", get$_stage: "_stage", get$_startHeight: "_startHeight", get$_startTime: "_startTime", get$_started: "_started", get$_stateReset: "_stateReset", get$_style: "_style", get$_temp: "_temp", get$_tempA: "_tempA", get$_tempB: "_tempB", get$_tempG: "_tempG", get$_tempLoop: "_tempLoop", get$_tempMarker: "_tempMarker", get$_tempPoint: "_tempPoint", get$_tempPosition: "_tempPosition", get$_tempR: "_tempR", get$_tempVolume: "_tempVolume", get$_text: "_text", get$_textHeight: "_textHeight", get$_textWidth: "_textWidth", get$_textures: "_textures", get$_tilemaps: "_tilemaps", get$_timeLastFrame: "_timeLastFrame", get$_timeLastSecond: "_timeLastSecond", get$_timeNextFrame: "_timeNextFrame", get$_timeOutID: "_timeOutID", get$_timer: "_timer", get$_timers: "_timers", get$_tint: "_tint", get$_total: "_total", get$_tweens: "_tweens", get$_unlockSource: "_unlockSource", get$_uvBuffer: "_uvBuffer", get$_uvs: "_uvs", get$_valuesEnd: "_valuesEnd", get$_valuesStart: "_valuesStart", get$_valuesStartRepeat: "_valuesStartRepeat", get$_velocity1: "_velocity1", get$_velocity2: "_velocity2", get$_velocityDelta: "_velocityDelta", get$_vertexBuffer: "_vertexBuffer", get$_volume: "_volume", get$_wasEnabled: "_wasEnabled", get$_webGL: "_webGL", get$_width: "_width", get$_worldAlpha: "_worldAlpha", get$_worldTransform: "_worldTransform", get$_x: "_x", get$_xhr: "_xhr", get$_y: "_y", get$_yoyo: "_yoyo", get$a: "a", get$aPositionCoord: "aPositionCoord", get$aRotation: "aRotation", get$aScale: "aScale", get$aTextureCoord: "aTextureCoord", get$aVertexPosition: "aVertexPosition", get$acceleration: "acceleration", get$active: "active", get$activePointer: "activePointer", get$add: "add", get$addToStage: "addToStage", get$advancedTiming: "advancedTiming", get$ajaxRequest: "ajaxRequest", get$align: "align", get$alive: "alive", get$allowHorizontalDrag: "allowHorizontalDrag", get$allowVerticalDrag: "allowVerticalDrag", get$alpha: "alpha", get$alphaData: "alphaData", get$altKey: "altKey", get$anchor: "anchor", get$android: "android", get$angle: "angle", get$angularDrag: "angularDrag", get$angularVelocity: "angularVelocity", get$animation: "animation", get$animationSpeed: "animationSpeed", get$animationToMixTime: "animationToMixTime", get$animations: "animations", get$antialias: "antialias", get$any: "any", get$arcade: "arcade", get$area: "area", get$args: "args", get$arora: "arora", get$array: "array", get$aspectRatio: "aspectRatio", get$assetURLs: "assetURLs", get$atLimit: "atLimit", get$atlas: "atlas", get$attachment: "attachment", get$attachmentLoader: "attachmentLoader", get$attachmentName: "attachmentName", get$attachmentNames: "attachmentNames", get$attachments: "attachments", get$attribState: "attribState", get$attributes: "attributes", get$audioData: "audioData", get$autoAlpha: "autoAlpha", get$autoCull: "autoCull", get$autoDestroy: "autoDestroy", get$autoScale: "autoScale", get$autoUpperCase: "autoUpperCase", get$autoplay: "autoplay", get$b: "b", get$backgroundColor: "backgroundColor", get$backgroundColorSplit: "backgroundColorSplit", get$backgroundColorString: "backgroundColorString", get$baseTexture: "baseTexture", get$baseURL: "baseURL", get$baseUrl: "baseUrl", get$blendMode: "blendMode", get$blendModeManager: "blendModeManager", get$blendModes: "blendModes", get$blocked: "blocked", get$blue: "blue", get$blurXFilter: "blurXFilter", get$blurYFilter: "blurYFilter", get$bodies: "bodies", get$body: "body", get$bone: "bone", get$boneData: "boneData", get$boneIndex: "boneIndex", get$bones: "bones", get$bottom: "bottom", get$bounce: "bounce", get$bounds: "bounds", get$boundsPadding: "boundsPadding", get$boundsRect: "boundsRect", get$boundsSprite: "boundsSprite", get$box2d: "box2d", get$bringToTop: "bringToTop", get$buffer: "buffer", get$button: "button", get$buttonMode: "buttonMode", get$c: "c", get$cache: "cache", get$cachedTint: "cachedTint", get$callback: "callback", get$callbackContext: "callbackContext", get$callbacks: "callbacks", get$camerOffset: "camerOffset", get$camera: "camera", get$cameraOffset: "cameraOffset", get$cancelFullscreen: "cancelFullscreen", get$canvas: "canvas", get$canvasBuffer: "canvasBuffer", get$capture: "capture", get$centerX: "centerX", get$centerY: "centerY", get$ch: "ch", get$channels: "channels", get$charCode: "charCode", get$characterHeight: "characterHeight", get$characterPerRow: "characterPerRow", get$characterSpacingX: "characterSpacingX", get$characterSpacingY: "characterSpacingY", get$characterWidth: "characterWidth", get$chars: "chars", get$checkCollision: "checkCollision", get$checkOffsetInterval: "checkOffsetInterval", get$checkWorldBounds: "checkWorldBounds", get$children: "children", get$chipmunk: "chipmunk", get$chrome: "chrome", get$chromeOS: "chromeOS", get$circle: "circle", get$classType: "classType", get$clearBeforeRender: "clearBeforeRender", get$clearDirty: "clearDirty", get$click: "click", get$clientX: "clientX", get$clientY: "clientY", get$cls: "cls", get$cocoonJS: "cocoonJS", get$collideDown: "collideDown", get$collideIndexes: "collideIndexes", get$collideLeft: "collideLeft", get$collideRight: "collideRight", get$collideUp: "collideUp", get$collideWorldBounds: "collideWorldBounds", get$collides: "collides", get$collision: "collision", get$collisionCallback: "collisionCallback", get$color: "color", get$colorArray: "colorArray", get$colorAttribute: "colorAttribute", get$colorBuffer: "colorBuffer", get$colors: "colors", get$columnWidth: "columnWidth", get$columns: "columns", get$complexPrimativeShader: "complexPrimativeShader", get$config: "config", get$connectToMaster: "connectToMaster", get$consumePointerEvent: "consumePointerEvent", get$content: "content", get$context: "context", get$contextLost: "contextLost", get$cos: "cos", get$count: "count", get$creator: "creator", get$crop: "crop", get$cropRect: "cropRect", get$crossOrigin: "crossOrigin", get$crossorigin: "crossorigin", get$crosswalk: "crosswalk", get$css3D: "css3D", get$ctrlKey: "ctrlKey", get$ctx: "ctx", get$current: "current", get$currentAlpha: "currentAlpha", get$currentAnim: "currentAnim", get$currentBaseTexture: "currentBaseTexture", get$currentBatchSize: "currentBatchSize", get$currentBlendMode: "currentBlendMode", get$currentColor: "currentColor", get$currentCursorStyle: "currentCursorStyle", get$currentFrame: "currentFrame", get$currentImageId: "currentImageId", get$currentLayer: "currentLayer", get$currentLoop: "currentLoop", get$currentMarker: "currentMarker", get$currentPointers: "currentPointers", get$currentRenderOrderID: "currentRenderOrderID", get$currentShader: "currentShader", get$currentSprite: "currentSprite", get$currentSpriteName: "currentSpriteName", get$currentTime: "currentTime", get$currentX: "currentX", get$currentY: "currentY", get$cursor: "cursor", get$curves: "curves", get$customSpacingX: "customSpacingX", get$customSpacingY: "customSpacingY", get$cw: "cw", get$d: "d", get$data: "data", get$deadzone: "deadzone", get$debug: "debug", get$debugAlpha: "debugAlpha", get$debugCallbackColor: "debugCallbackColor", get$debugColor: "debugColor", get$debugFill: "debugFill", get$debugFillColor: "debugFillColor", get$debugMap: "debugMap", get$defaultCursor: "defaultCursor", get$defaultMix: "defaultMix", get$defaultShader: "defaultShader", get$defaultSkin: "defaultSkin", get$delay: "delay", get$deltaCap: "deltaCap", get$desktop: "desktop", get$device: "device", get$dh: "dh", get$dimensions: "dimensions", get$dirty: "dirty", get$disableTextureUpload: "disableTextureUpload", get$disableVisibilityChange: "disableVisibilityChange", get$disabled: "disabled", get$displayObject: "displayObject", get$distance: "distance", get$doubleTapRate: "doubleTapRate", get$down: "down", get$downDuration: "downDuration", get$drag: "drag", get$dragFromCenter: "dragFromCenter", get$dragOffset: "dragOffset", get$draggable: "draggable", get$drawCoords: "drawCoords", get$drawCount: "drawCount", get$drawOrder: "drawOrder", get$drawing: "drawing", get$dropShadow: "dropShadow", get$dropShadowAngle: "dropShadowAngle", get$dropShadowColor: "dropShadowColor", get$dropShadowDistance: "dropShadowDistance", get$duration: "duration", get$durationMS: "durationMS", get$dw: "dw", get$dx: "dx", get$dy: "dy", get$ejecta: "ejecta", get$elapsed: "elapsed", get$emitX: "emitX", get$emitY: "emitY", get$emitters: "emitters", get$enableBody: "enableBody", get$enableBodyDebug: "enableBodyDebug", get$enabled: "enabled", get$end: "end", get$enterFullScreen: "enterFullScreen", get$enterIncorrectOrientation: "enterIncorrectOrientation", get$enterLandscape: "enterLandscape", get$enterPortrait: "enterPortrait", get$epiphany: "epiphany", get$event: "event", get$events: "events", get$exists: "exists", get$expired: "expired", get$externalNode: "externalNode", get$faceBottom: "faceBottom", get$faceLeft: "faceLeft", get$faceRight: "faceRight", get$faceTop: "faceTop", get$fastShader: "fastShader", get$fastSpriteBatch: "fastSpriteBatch", get$file: "file", get$fileSystem: "fileSystem", get$fill: "fill", get$fillAlpha: "fillAlpha", get$fillColor: "fillColor", get$filling: "filling", get$filterArea: "filterArea", get$filterManager: "filterManager", get$filterPasses: "filterPasses", get$filterStack: "filterStack", get$firefox: "firefox", get$firstgid: "firstgid", get$fixedToCamera: "fixedToCamera", get$fixedWidth: "fixedWidth", get$flipX: "flipX", get$flipY: "flipY", get$font: "font", get$fontName: "fontName", get$fontSet: "fontSet", get$fontSize: "fontSize", get$forceLandscape: "forceLandscape", get$forceOut: "forceOut", get$forcePortrait: "forcePortrait", get$forceSetTimeOut: "forceSetTimeOut", get$forceX: "forceX", get$format: "format", get$fps: "fps", get$fpsMax: "fpsMax", get$fpsMin: "fpsMin", get$fragmentSrc: "fragmentSrc", get$frame: "frame", get$frameBuffer: "frameBuffer", get$frames: "frames", get$freezeFrames: "freezeFrames", get$frequency: "frequency", get$fullScreenScaleMode: "fullScreenScaleMode", get$fullScreenTarget: "fullScreenTarget", get$fullscreen: "fullscreen", get$fullscreenKeyboard: "fullscreenKeyboard", get$g: "g", get$ga: "ga", get$gainNode: "gainNode", get$game: "game", get$getUserMedia: "getUserMedia", get$gl: "gl", get$glIndicies: "glIndicies", get$glPoints: "glPoints", get$global: "global", get$grabData: "grabData", get$gravity: "gravity", get$green: "green", get$h: "h", get$halfHeight: "halfHeight", get$halfWidth: "halfWidth", get$hasLoaded: "hasLoaded", get$hasPostRender: "hasPostRender", get$hasPostUpdate: "hasPostUpdate", get$hasPreUpdate: "hasPreUpdate", get$hasRender: "hasRender", get$hasResized: "hasResized", get$hasUpdate: "hasUpdate", get$health: "health", get$height: "height", get$heightInPixels: "heightInPixels", get$hitArea: "hitArea", get$hitCanvas: "hitCanvas", get$hitContext: "hitContext", get$holdRate: "holdRate", get$iOS: "iOS", get$iPad: "iPad", get$iPhone: "iPhone", get$iPhone4: "iPhone4", get$id: "id", get$identifier: "identifier", get$ie: "ie", get$ieVersion: "ieVersion", get$image: "image", get$imageData: "imageData", get$imageUrl: "imageUrl", get$images: "images", get$immovable: "immovable", get$incorrectOrientation: "incorrectOrientation", get$index: "index", get$indexBuffer: "indexBuffer", get$indexes: "indexes", get$indices: "indices", get$input: "input", get$interactionDOMElement: "interactionDOMElement", get$interactionManager: "interactionManager", get$interactiveChildren: "interactiveChildren", get$interactiveItems: "interactiveItems", get$isBooted: "isBooted", get$isCocoonJS: "isCocoonJS", get$isDown: "isDown", get$isDragged: "isDragged", get$isFinished: "isFinished", get$isFullScreen: "isFullScreen", get$isLandscape: "isLandscape", get$isLoaded: "isLoaded", get$isLoading: "isLoading", get$isMouse: "isMouse", get$isOut: "isOut", get$isOver: "isOver", get$isPlaying: "isPlaying", get$isRunning: "isRunning", get$isTiling: "isTiling", get$isUp: "isUp", get$json: "json", get$justPressedRate: "justPressedRate", get$justReleasedRate: "justReleasedRate", get$kernings: "kernings", get$key: "key", get$keyCode: "keyCode", get$keyboard: "keyboard", get$killOnComplete: "killOnComplete", get$l: "l", get$last: "last", get$lastIndex: "lastIndex", get$lastIndexCount: "lastIndexCount", get$lastTime: "lastTime", get$layer: "layer", get$layers: "layers", get$leaveFullScreen: "leaveFullScreen", get$leaveIncorrectOrientation: "leaveIncorrectOrientation", get$left: "left", get$length: "length", get$level: "level", get$lifespan: "lifespan", get$line: "line", get$lineAlpha: "lineAlpha", get$lineColor: "lineColor", get$lineHeight: "lineHeight", get$lineWidth: "lineWidth", get$lines: "lines", get$linux: "linux", get$listeners: "listeners", get$littleEndian: "littleEndian", get$load: "load", get$loadCount: "loadCount", get$loaded: "loaded", get$loader: "loader", get$localStorage: "localStorage", get$locked: "locked", get$loop: "loop", get$loopCount: "loopCount", get$m00: "m00", get$m01: "m01", get$m10: "m10", get$m11: "m11", get$m4a: "m4a", get$macOS: "macOS", get$magFilter: "magFilter", get$make: "make", get$map: "map", get$margin: "margin", get$markers: "markers", get$maskManager: "maskManager", get$maskPosition: "maskPosition", get$maskStack: "maskStack", get$masterGain: "masterGain", get$masterGainNode: "masterGainNode", get$math: "math", get$matrix: "matrix", get$maxAttibs: "maxAttibs", get$maxHeight: "maxHeight", get$maxIterations: "maxIterations", get$maxLevels: "maxLevels", get$maxObjects: "maxObjects", get$maxParticleAlpha: "maxParticleAlpha", get$maxParticleScale: "maxParticleScale", get$maxParticleSpeed: "maxParticleSpeed", get$maxParticles: "maxParticles", get$maxPointers: "maxPointers", get$maxRotation: "maxRotation", get$maxSize: "maxSize", get$maxVelocity: "maxVelocity", get$maxWidth: "maxWidth", get$maxX: "maxX", get$maxY: "maxY", get$memorize: "memorize", get$midori: "midori", get$minFilter: "minFilter", get$minHeight: "minHeight", get$minParticleAlpha: "minParticleAlpha", get$minParticleScale: "minParticleScale", get$minParticleSpeed: "minParticleSpeed", get$minPriorityID: "minPriorityID", get$minRotation: "minRotation", get$minWidth: "minWidth", get$mixDuration: "mixDuration", get$mixTime: "mixTime", get$mobileSafari: "mobileSafari", get$mode: "mode", get$mouse: "mouse", get$mouseDownCallback: "mouseDownCallback", get$mouseMoveCallback: "mouseMoveCallback", get$mouseOut: "mouseOut", get$mouseOutCallback: "mouseOutCallback", get$mouseOverCallback: "mouseOverCallback", get$mousePointer: "mousePointer", get$mouseUpCallback: "mouseUpCallback", get$mouseWheelCallback: "mouseWheelCallback", get$mousedown: "mousedown", get$mousemove: "mousemove", get$mouseout: "mouseout", get$mouseover: "mouseover", get$mouseoverEnabled: "mouseoverEnabled", get$mouseup: "mouseup", get$mouseupoutside: "mouseupoutside", get$moveCallback: "moveCallback", get$moveCallbacks: "moveCallbacks", get$movementX: "movementX", get$movementY: "movementY", get$moves: "moves", get$mp3: "mp3", get$msMax: "msMax", get$msMin: "msMin", get$msSinceLastClick: "msSinceLastClick", get$mspointer: "mspointer", get$multiInputOverride: "multiInputOverride", get$multiLine: "multiLine", get$name: "name", get$needToRecalculate: "needToRecalculate", get$needsUpdate: "needsUpdate", get$net: "net", get$nextTick: "nextTick", get$ninja: "ninja", get$noAudio: "noAudio", get$noFrame: "noFrame", get$nodes: "nodes", get$none: "none", get$now: "now", get$numIndices: "numIndices", get$numVerts: "numVerts", get$objects: "objects", get$offset: "offset", get$offsetVector: "offsetVector", get$offsetX: "offsetX", get$offsetY: "offsetY", get$ogg: "ogg", get$on: "on", get$onAddedToGroup: "onAddedToGroup", get$onAnimationComplete: "onAnimationComplete", get$onAnimationLoop: "onAnimationLoop", get$onAnimationStart: "onAnimationStart", get$onBlur: "onBlur", get$onComplete: "onComplete", get$onCreateCallback: "onCreateCallback", get$onDecoded: "onDecoded", get$onDown: "onDown", get$onDownCallback: "onDownCallback", get$onDownSound: "onDownSound", get$onDownSoundMarker: "onDownSoundMarker", get$onDragStart: "onDragStart", get$onDragStop: "onDragStop", get$onEnterBounds: "onEnterBounds", get$onFileComplete: "onFileComplete", get$onFileError: "onFileError", get$onFileStart: "onFileStart", get$onFocus: "onFocus", get$onHold: "onHold", get$onHoldCallback: "onHoldCallback", get$onInitCallback: "onInitCallback", get$onInputDown: "onInputDown", get$onInputOut: "onInputOut", get$onInputOver: "onInputOver", get$onInputUp: "onInputUp", get$onKilled: "onKilled", get$onLoadComplete: "onLoadComplete", get$onLoadRenderCallback: "onLoadRenderCallback", get$onLoadStart: "onLoadStart", get$onLoadUpdateCallback: "onLoadUpdateCallback", get$onLoaded: "onLoaded", get$onLoop: "onLoop", get$onMarkerComplete: "onMarkerComplete", get$onMute: "onMute", get$onOutOfBounds: "onOutOfBounds", get$onOutSound: "onOutSound", get$onOutSoundMarker: "onOutSoundMarker", get$onOverMouseOnly: "onOverMouseOnly", get$onOverSound: "onOverSound", get$onOverSoundMarker: "onOverSoundMarker", get$onPackComplete: "onPackComplete", get$onPause: "onPause", get$onPauseUpdateCallback: "onPauseUpdateCallback", get$onPausedCallback: "onPausedCallback", get$onPlay: "onPlay", get$onPreRenderCallback: "onPreRenderCallback", get$onPreloadCallback: "onPreloadCallback", get$onPressCallback: "onPressCallback", get$onProgress: "onProgress", get$onRemovedFromGroup: "onRemovedFromGroup", get$onRenderCallback: "onRenderCallback", get$onResume: "onResume", get$onResumedCallback: "onResumedCallback", get$onRevived: "onRevived", get$onShutDownCallback: "onShutDownCallback", get$onSoundDecode: "onSoundDecode", get$onSoundUnlock: "onSoundUnlock", get$onStart: "onStart", get$onStop: "onStop", get$onTap: "onTap", get$onTouchCancelListener: "onTouchCancelListener", get$onTouchEndListener: "onTouchEndListener", get$onTouchEnterListener: "onTouchEnterListener", get$onTouchLeaveListener: "onTouchLeaveListener", get$onTouchMoveListener: "onTouchMoveListener", get$onTouchStartListener: "onTouchStartListener", get$onUp: "onUp", get$onUpCallback: "onUpCallback", get$onUpSound: "onUpSound", get$onUpSoundMarker: "onUpSoundMarker", get$onUpdateCallback: "onUpdateCallback", get$opera: "opera", get$options: "options", get$opus: "opus", get$orientation: "orientation", get$orientationSprite: "orientationSprite", get$originalEvent: "originalEvent", get$originalHeight: "originalHeight", get$originalWidth: "originalWidth", get$outOfBoundsKill: "outOfBoundsKill", get$override: "override", get$p2: "p2", get$padding: "padding", get$pads: "pads", get$page: "page", get$pageAlignHorizontally: "pageAlignHorizontally", get$pageAlignVertically: "pageAlignVertically", get$pageX: "pageX", get$pageY: "pageY", get$pages: "pages", get$params: "params", get$parent: "parent", get$particleAnchor: "particleAnchor", get$particleBringToTop: "particleBringToTop", get$particleClass: "particleClass", get$particleDrag: "particleDrag", get$particleSendToBack: "particleSendToBack", get$particles: "particles", get$passes: "passes", get$pauseDuration: "pauseDuration", get$paused: "paused", get$pausedPosition: "pausedPosition", get$pausedTime: "pausedTime", get$pendingDelete: "pendingDelete", get$pendingPlayback: "pendingPlayback", get$pendingStep: "pendingStep", get$phase: "phase", get$physics: "physics", get$physicsBodyType: "physicsBodyType", get$physicsConfig: "physicsConfig", get$physicsElapsed: "physicsElapsed", get$pivot: "pivot", get$pixelPerfectAlpha: "pixelPerfectAlpha", get$pixelPerfectClick: "pixelPerfectClick", get$pixelPerfectOver: "pixelPerfectOver", get$pixelRatio: "pixelRatio", get$pixels: "pixels", get$plugins: "plugins", get$pointerId: "pointerId", get$pointerLock: "pointerLock", get$pointers: "pointers", get$points: "points", get$pollRate: "pollRate", get$pool: "pool", get$position: "position", get$positionDown: "positionDown", get$positionUp: "positionUp", get$preloadSprite: "preloadSprite", get$premultipliedAlpha: "premultipliedAlpha", get$preserveDrawingBuffer: "preserveDrawingBuffer", get$pressEvent: "pressEvent", get$prevX: "prevX", get$prevY: "prevY", get$preventDefault: "preventDefault", get$preventingRecalculate: "preventingRecalculate", get$previous: "previous", get$previousLoop: "previousLoop", get$previousTapTime: "previousTapTime", get$previousTime: "previousTime", get$primitiveShader: "primitiveShader", get$priorityID: "priorityID", get$program: "program", get$progress: "progress", get$progressFloat: "progressFloat", get$projection: "projection", get$projectionVector: "projectionVector", get$properties: "properties", get$quadTree: "quadTree", get$queue: "queue", get$quirksMode: "quirksMode", get$r: "r", get$radius: "radius", get$raf: "raf", get$rawMovementX: "rawMovementX", get$rawMovementY: "rawMovementY", get$rayStepRate: "rayStepRate", get$recordLimit: "recordLimit", get$recordPointerHistory: "recordPointerHistory", get$recordRate: "recordRate", get$red: "red", get$refresh: "refresh", get$refreshTexture: "refreshTexture", get$regionHeight: "regionHeight", get$regionOffsetX: "regionOffsetX", get$regionOffsetY: "regionOffsetY", get$regionOriginalHeight: "regionOriginalHeight", get$regionOriginalWidth: "regionOriginalWidth", get$regionWidth: "regionWidth", get$regions: "regions", get$render: "render", get$renderBuffer: "renderBuffer", get$renderOrderID: "renderOrderID", get$renderSession: "renderSession", get$renderShadow: "renderShadow", get$renderType: "renderType", get$renderable: "renderable", get$renderer: "renderer", get$rendererObject: "rendererObject", get$repeatCount: "repeatCount", get$repeats: "repeats", get$requestFullscreen: "requestFullscreen", get$resetLocked: "resetLocked", get$reverse: "reverse", get$rgba: "rgba", get$right: "right", get$rnd: "rnd", get$rotate: "rotate", get$rotation: "rotation", get$rotationDirection: "rotationDirection", get$roundPixels: "roundPixels", get$rows: "rows", get$running: "running", get$s: "s", get$s0: "s0", get$s1: "s1", get$s2: "s2", get$safari: "safari", get$safeRemove: "safeRemove", get$scale: "scale", get$scaleData: "scaleData", get$scaleFactor: "scaleFactor", get$scaleFactorInversed: "scaleFactorInversed", get$scaleMode: "scaleMode", get$scaleModel: "scaleModel", get$scaleX: "scaleX", get$scaleY: "scaleY", get$scanned: "scanned", get$scope: "scope", get$screenView: "screenView", get$screenX: "screenX", get$screenY: "screenY", get$scrollFactorX: "scrollFactorX", get$scrollFactorY: "scrollFactorY", get$shader: "shader", get$shaderManager: "shaderManager", get$shaderMap: "shaderMap", get$shaders: "shaders", get$shadowBlur: "shadowBlur", get$shadowColor: "shadowColor", get$shadowOffsetX: "shadowOffsetX", get$shadowOffsetY: "shadowOffsetY", get$shiftKey: "shiftKey", get$silk: "silk", get$sin: "sin", get$size: "size", get$skeleton: "skeleton", get$skeletonData: "skeletonData", get$skin: "skin", get$skins: "skins", get$slotContainers: "slotContainers", get$slotIndex: "slotIndex", get$slots: "slots", get$smoothProperty: "smoothProperty", get$snapOffset: "snapOffset", get$snapOffsetX: "snapOffsetX", get$snapOffsetY: "snapOffsetY", get$snapOnDrag: "snapOnDrag", get$snapOnRelease: "snapOnRelease", get$snapX: "snapX", get$snapY: "snapY", get$sound: "sound", get$source: "source", get$sourceAspectRatio: "sourceAspectRatio", get$sourceHeight: "sourceHeight", get$sourceSizeH: "sourceSizeH", get$sourceSizeW: "sourceSizeW", get$sourceWidth: "sourceWidth", get$speed: "speed", get$splits: "splits", get$sprite: "sprite", get$spriteBatch: "spriteBatch", get$spriteSourceSizeH: "spriteSourceSizeH", get$spriteSourceSizeW: "spriteSourceSizeW", get$spriteSourceSizeX: "spriteSourceSizeX", get$spriteSourceSizeY: "spriteSourceSizeY", get$sprites: "sprites", get$stage: "stage", get$stamp: "stamp", get$start: "start", get$startTime: "startTime", get$startX: "startX", get$startY: "startY", get$state: "state", get$stateData: "stateData", get$states: "states", get$stencilManager: "stencilManager", get$stencilStack: "stencilStack", get$stepCount: "stepCount", get$stepping: "stepping", get$stop: "stop", get$stopOnGameOut: "stopOnGameOut", get$stopTime: "stopTime", get$stripShader: "stripShader", get$stroke: "stroke", get$strokeThickness: "strokeThickness", get$style: "style", get$subHeight: "subHeight", get$subWidth: "subWidth", get$support32bit: "support32bit", get$tap: "tap", get$tapRate: "tapRate", get$target: "target", get$targetObject: "targetObject", get$tempAttribState: "tempAttribState", get$tempPoint: "tempPoint", get$text: "text", get$texture: "texture", get$textureBuffer: "textureBuffer", get$textureCount: "textureCount", get$textureFrame: "textureFrame", get$textureLoader: "textureLoader", get$texturePool: "texturePool", get$textureThing: "textureThing", get$textures: "textures", get$th: "th", get$tick: "tick", get$tileColor: "tileColor", get$tileHeight: "tileHeight", get$tileMargin: "tileMargin", get$tilePadding: "tilePadding", get$tilePosition: "tilePosition", get$tileProperties: "tileProperties", get$tileScale: "tileScale", get$tileScaleOffset: "tileScaleOffset", get$tileSpacing: "tileSpacing", get$tileWidth: "tileWidth", get$tiles: "tiles", get$tilesets: "tilesets", get$tilingTexture: "tilingTexture", get$time: "time", get$timeCap: "timeCap", get$timeDown: "timeDown", get$timeOut: "timeOut", get$timeOver: "timeOver", get$timeToCall: "timeToCall", get$timeUp: "timeUp", get$timelines: "timelines", get$timer: "timer", get$tint: "tint", get$tintCache: "tintCache", get$tintColor: "tintColor", get$tintedTexture: "tintedTexture", get$tl: "tl", get$total: "total", get$totalDuration: "totalDuration", get$totalTouches: "totalTouches", get$touch: "touch", get$touchCancelCallback: "touchCancelCallback", get$touchEndCallback: "touchEndCallback", get$touchEnterCallback: "touchEnterCallback", get$touchLeaveCallback: "touchLeaveCallback", get$touchLocked: "touchLocked", get$touchMoveCallback: "touchMoveCallback", get$touchStartCallback: "touchStartCallback", get$touchend: "touchend", get$touchendoutside: "touchendoutside", get$touching: "touching", get$touchmove: "touchmove", get$touchs: "touchs", get$touchstart: "touchstart", get$translationMatrix: "translationMatrix", get$transparent: "transparent", get$trident: "trident", get$tridentVersion: "tridentVersion", get$trim: "trim", get$trimmed: "trimmed", get$tw: "tw", get$tweens: "tweens", get$tx: "tx", get$ty: "ty", get$type: "type", get$typedArray: "typedArray", get$u: "u", get$u2: "u2", get$uMatrix: "uMatrix", get$uSampler: "uSampler", get$uWrap: "uWrap", get$uniforms: "uniforms", get$up: "up", get$update: "update", get$updateFrame: "updateFrame", get$updateIfVisible: "updateIfVisible", get$url: "url", get$useHandCursor: "useHandCursor", get$usingAudioTag: "usingAudioTag", get$usingWebAudio: "usingWebAudio", get$uuid: "uuid", get$uvArray: "uvArray", get$uvBuffer: "uvBuffer", get$uvs: "uvs", get$v: "v", get$v2: "v2", get$vWrap: "vWrap", get$valid: "valid", get$value: "value", get$velocity: "velocity", get$version: "version", get$vertSize: "vertSize", get$vertexArray: "vertexArray", get$vertexBuffer: "vertexBuffer", get$vertexSrc: "vertexSrc", get$vertices: "vertices", get$verticies: "verticies", get$vibration: "vibration", get$view: "view", get$visible: "visible", get$volume: "volume", get$wav: "wav", get$webApp: "webApp", get$webAudio: "webAudio", get$webGL: "webGL", get$webm: "webm", get$wheelDelta: "wheelDelta", get$width: "width", get$widthInPixels: "widthInPixels", get$windows: "windows", get$windowsPhone: "windowsPhone", get$withinGame: "withinGame", get$wordWrap: "wordWrap", get$wordWrapWidth: "wordWrapWidth", get$worker: "worker", get$world: "world", get$worldRotation: "worldRotation", get$worldScaleX: "worldScaleX", get$worldScaleY: "worldScaleY", get$worldX: "worldX", get$worldY: "worldY", get$wrap: "wrap", get$x: "x", get$x0: "x0", get$x1: "x1", get$x2: "x2", get$x3: "x3", get$xAdvance: "xAdvance", get$xOffset: "xOffset", get$y: "y", get$y0: "y0", get$y1: "y1", get$y2: "y2", get$y3: "y3", get$yOffset: "yOffset", get$z: "z"};
init.mangledGlobalNames = {AUTO: "AUTO", AUTO_PREVENT_DEFAULT: "AUTO_PREVENT_DEFAULT", AnimCache: "AnimCache", AtlasReader_replaceReg: "replaceReg", AtlasReader_splitReg: "splitReg", Atlas_Format: "Format", Atlas_TextureFilter: "TextureFilter", Atlas_TextureWrap: "TextureWrap", AttachmentType: "AttachmentType", BITMAPDATA: "BITMAPDATA", BITMAPTEXT: "BITMAPTEXT", BUTTON: "BUTTON", BaseTextureCache: "BaseTextureCache", BaseTextureCacheIdGenerator: "BaseTextureCacheIdGenerator", BitmapText__charCodeReg: "_charCodeReg", BitmapText__numReg: "_numReg", BitmapText_fonts: "fonts", BlendModes_ADD: "ADD", BlendModes_COLOR: "COLOR", BlendModes_COLOR_BURN: "COLOR_BURN", BlendModes_COLOR_DODGE: "COLOR_DODGE", BlendModes_DARKEN: "DARKEN", BlendModes_DIFFERENCE: "DIFFERENCE", BlendModes_EXCLUSION: "EXCLUSION", BlendModes_HARD_LIGHT: "HARD_LIGHT", BlendModes_HUE: "HUE", BlendModes_LIGHTEN: "LIGHTEN", BlendModes_LUMINOSITY: "LUMINOSITY", BlendModes_MULTIPLY: "MULTIPLY", BlendModes_NONE: "NONE", BlendModes_NORMAL: "NORMAL", BlendModes_OVERLAY: "OVERLAY", BlendModes_SATURATION: "SATURATION", BlendModes_SCREEN: "SCREEN", BlendModes_SOFT_LIGHT: "SOFT_LIGHT", Bone_yDown: "yDown", CANVAS: "CANVAS", CANVAS_FILTER: "CANVAS_FILTER", CANVAS_RENDERER: "CANVAS_RENDERER", Cache_BINARY: "BINARY", Cache_BITMAPDATA: "BITMAPDATA", Cache_BITMAPFONT: "BITMAPFONT", Cache_CANVAS: "CANVAS", Cache_IMAGE: "IMAGE", Cache_JSON: "JSON", Cache_PHYSICS: "PHYSICS", Cache_SOUND: "SOUND", Cache_TEXT: "TEXT", Cache_TEXTURE: "TEXTURE", Cache_TILEMAP: "TILEMAP", Camera_FOLLOW_LOCKON: "FOLLOW_LOCKON", Camera_FOLLOW_PLATFORMER: "FOLLOW_PLATFORMER", Camera_FOLLOW_TOPDOWN: "FOLLOW_TOPDOWN", Camera_FOLLOW_TOPDOWN_TIGHT: "FOLLOW_TOPDOWN_TIGHT", CanvasTinter_cacheStepsPerColorChannel: "cacheStepsPerColorChannel", CanvasTinter_canUseMultiply: "canUseMultiply", CanvasTinter_canvas: "canvas", CanvasTinter_convertTintToImage: "convertTintToImage", CanvasTinter_tintMethod: "tintMethod", DEG_TO_RAD: "DEG_TO_RAD", DOWN: "DOWN", Device_LITTLE_ENDIAN: "LITTLE_ENDIAN", ELLIPSE: "ELLIPSE", EMITTER: "EMITTER", Easing_Back: "Back", Easing_Bounce: "Bounce", Easing_Circ: "Circ", Easing_Cubic: "Cubic", Easing_Elastic: "Elastic", Easing_Exponential: "Exponential", Easing_Linear: "Linear", Easing_Quadratic: "Quadratic", Easing_Quartic: "Quartic", Easing_Quintic: "Quintic", Easing_Sinusoidal: "Sinusoidal", EmptyRectangle: "EmptyRectangle", FrameCache: "FrameCache", GAMES: "GAMES", GRAPHICS: "GRAPHICS", GROUP: "GROUP", Graphics_CIRC: "CIRC", Graphics_ELIP: "ELIP", Graphics_POLY: "POLY", Graphics_RECT: "RECT", Graphics_RREC: "RREC", Group_RETURN_CHILD: "RETURN_CHILD", Group_RETURN_NONE: "RETURN_NONE", Group_RETURN_TOTAL: "RETURN_TOTAL", Group_SORT_ASCENDING: "SORT_ASCENDING", Group_SORT_DESCENDING: "SORT_DESCENDING", HEADLESS: "HEADLESS", IMAGE: "IMAGE", INTERACTION_FREQUENCY: "INTERACTION_FREQUENCY", IdentityMatrix: "IdentityMatrix", Input_MOUSE_OVERRIDES_TOUCH: "MOUSE_OVERRIDES_TOUCH", Input_MOUSE_TOUCH_COMBINE: "MOUSE_TOUCH_COMBINE", Input_TOUCH_OVERRIDES_MOUSE: "TOUCH_OVERRIDES_MOUSE", Keyboard_A: "A", Keyboard_ALT: "ALT", Keyboard_B: "B", Keyboard_BACKSPACE: "BACKSPACE", Keyboard_BACKWARD_SLASH: "BACKWARD_SLASH", Keyboard_C: "C", Keyboard_CAPS_LOCK: "CAPS_LOCK", Keyboard_CLEAR: "CLEAR", Keyboard_CLOSED_BRACKET: "CLOSED_BRACKET", Keyboard_COLON: "COLON", Keyboard_CONTROL: "CONTROL", Keyboard_D: "D", Keyboard_DELETE: "DELETE", Keyboard_DOWN: "DOWN", Keyboard_E: "E", Keyboard_EIGHT: "EIGHT", Keyboard_END: "END", Keyboard_ENTER: "ENTER", Keyboard_EQUALS: "EQUALS", Keyboard_ESC: "ESC", Keyboard_F: "F", Keyboard_F1: "F1", Keyboard_F10: "F10", Keyboard_F11: "F11", Keyboard_F12: "F12", Keyboard_F13: "F13", Keyboard_F14: "F14", Keyboard_F15: "F15", Keyboard_F2: "F2", Keyboard_F3: "F3", Keyboard_F4: "F4", Keyboard_F5: "F5", Keyboard_F6: "F6", Keyboard_F7: "F7", Keyboard_F8: "F8", Keyboard_F9: "F9", Keyboard_FIVE: "FIVE", Keyboard_FOUR: "FOUR", Keyboard_G: "G", Keyboard_H: "H", Keyboard_HELP: "HELP", Keyboard_HOME: "HOME", Keyboard_I: "I", Keyboard_INSERT: "INSERT", Keyboard_J: "J", Keyboard_K: "K", Keyboard_L: "L", Keyboard_LEFT: "LEFT", Keyboard_M: "M", Keyboard_N: "N", Keyboard_NINE: "NINE", Keyboard_NUMPAD_0: "NUMPAD_0", Keyboard_NUMPAD_1: "NUMPAD_1", Keyboard_NUMPAD_2: "NUMPAD_2", Keyboard_NUMPAD_3: "NUMPAD_3", Keyboard_NUMPAD_4: "NUMPAD_4", Keyboard_NUMPAD_5: "NUMPAD_5", Keyboard_NUMPAD_6: "NUMPAD_6", Keyboard_NUMPAD_7: "NUMPAD_7", Keyboard_NUMPAD_8: "NUMPAD_8", Keyboard_NUMPAD_9: "NUMPAD_9", Keyboard_NUMPAD_ADD: "NUMPAD_ADD", Keyboard_NUMPAD_DECIMAL: "NUMPAD_DECIMAL", Keyboard_NUMPAD_DIVIDE: "NUMPAD_DIVIDE", Keyboard_NUMPAD_ENTER: "NUMPAD_ENTER", Keyboard_NUMPAD_MULTIPLY: "NUMPAD_MULTIPLY", Keyboard_NUMPAD_SUBTRACT: "NUMPAD_SUBTRACT", Keyboard_NUM_LOCK: "NUM_LOCK", Keyboard_O: "O", Keyboard_ONE: "ONE", Keyboard_OPEN_BRACKET: "OPEN_BRACKET", Keyboard_P: "P", Keyboard_PAGE_DOWN: "PAGE_DOWN", Keyboard_PAGE_UP: "PAGE_UP", Keyboard_Q: "Q", Keyboard_QUESTION_MARK: "QUESTION_MARK", Keyboard_QUOTES: "QUOTES", Keyboard_R: "R", Keyboard_RIGHT: "RIGHT", Keyboard_S: "S", Keyboard_SEVEN: "SEVEN", Keyboard_SHIFT: "SHIFT", Keyboard_SIX: "SIX", Keyboard_SPACEBAR: "SPACEBAR", Keyboard_T: "T", Keyboard_TAB: "TAB", Keyboard_THREE: "THREE", Keyboard_TILDE: "TILDE", Keyboard_TWO: "TWO", Keyboard_U: "U", Keyboard_UNDERSCORE: "UNDERSCORE", Keyboard_UP: "UP", Keyboard_V: "V", Keyboard_W: "W", Keyboard_X: "X", Keyboard_Y: "Y", Keyboard_Z: "Z", Keyboard_ZERO: "ZERO", LEFT: "LEFT", Loader_Format: "Format", Loader_PHYSICS_LIME_CORONA_JSON: "PHYSICS_LIME_CORONA_JSON", Loader_PHYSICS_PHASER_JSON: "PHYSICS_PHASER_JSON", Loader_TEXTURE_ATLAS_JSON_ARRAY: "TEXTURE_ATLAS_JSON_ARRAY", Loader_TEXTURE_ATLAS_JSON_HASH: "TEXTURE_ATLAS_JSON_HASH", Loader_TEXTURE_ATLAS_XML_STARLING: "TEXTURE_ATLAS_XML_STARLING", Loader_baseReg: "baseReg", Loader_resultReg: "resultReg", Loader_resultSplit: "resultSplit", Math_PI: "PI", Math_PI2: "PI2", Math_SQRT1_2: "SQRT1_2", Math_SQRT2: "SQRT2", Math__degreeToRadiansFactor: "_degreeToRadiansFactor", Math__radianToDegreesFactor: "_radianToDegreesFactor", Math_random: "random", Matrix2: "Matrix2", Mouse_LEFT_BUTTON: "LEFT_BUTTON", Mouse_MIDDLE_BUTTON: "MIDDLE_BUTTON", Mouse_NO_BUTTON: "NO_BUTTON", Mouse_RIGHT_BUTTON: "RIGHT_BUTTON", Mouse_WHEEL_DOWN: "WHEEL_DOWN", Mouse_WHEEL_UP: "WHEEL_UP", NONE: "NONE", POINTER: "POINTER", POLYGON: "POLYGON", Particles_ID: "ID", Physics_ARCADE: "ARCADE", Physics_BOX2D: "BOX2D", Physics_CHIPMUNK: "CHIPMUNK", Physics_NINJA: "NINJA", Physics_P2JS: "P2JS", PixiShader_defaultVertexSrc: "defaultVertexSrc", QuadTree__empty: "_empty", RAD_TO_DEG: "RAD_TO_DEG", RENDERTEXTURE: "RENDERTEXTURE", RETROFONT: "RETROFONT", RIGHT: "RIGHT", RandomDataGenerator_UUID: "UUID", RenderTexture_tempMatrix: "tempMatrix", RetroFont_ALIGN_CENTER: "ALIGN_CENTER", RetroFont_ALIGN_LEFT: "ALIGN_LEFT", RetroFont_ALIGN_RIGHT: "ALIGN_RIGHT", RetroFont_TEXT_SET1: "TEXT_SET1", RetroFont_TEXT_SET10: "TEXT_SET10", RetroFont_TEXT_SET11: "TEXT_SET11", RetroFont_TEXT_SET2: "TEXT_SET2", RetroFont_TEXT_SET3: "TEXT_SET3", RetroFont_TEXT_SET4: "TEXT_SET4", RetroFont_TEXT_SET5: "TEXT_SET5", RetroFont_TEXT_SET6: "TEXT_SET6", RetroFont_TEXT_SET7: "TEXT_SET7", RetroFont_TEXT_SET8: "TEXT_SET8", RetroFont_TEXT_SET9: "TEXT_SET9", SPRITE: "SPRITE", SPRITEBATCH: "SPRITEBATCH", ScaleManager_EXACT_FIT: "EXACT_FIT", ScaleManager_NO_SCALE: "NO_SCALE", ScaleManager_SHOW_ALL: "SHOW_ALL", TEXT: "TEXT", TILEMAP: "TILEMAP", TILEMAPLAYER: "TILEMAPLAYER", TILESPRITE: "TILESPRITE", Text_heightCache: "heightCache", Text_linesReg: "linesReg", Text_splitReg: "splitReg", TextureCache: "TextureCache", TextureCacheIdGenerator: "TextureCacheIdGenerator", Texture_frameUpdates: "frameUpdates", Tilemap_CSV: "CSV", Tilemap_EAST: "EAST", Tilemap_Format: "Format", Tilemap_NORTH: "NORTH", Tilemap_SOUTH: "SOUTH", Tilemap_TILED_JSON: "TILED_JSON", Tilemap_WEST: "WEST", Timer_HALF: "HALF", Timer_MINUTE: "MINUTE", Timer_QUARTER: "QUARTER", Timer_SECOND: "SECOND", UP: "UP", VERSION: "VERSION", VERSION0: "VERSION", WEBGL: "WEBGL", WEBGL_FILTER: "WEBGL_FILTER", WEBGL_RENDERER: "WEBGL_RENDERER", WebGLGraphics_graphicsDataPool: "graphicsDataPool", WebGLGraphics_last: "last", _UID: "_UID", blendModesCanvas: "blendModesCanvas", blendModesWebGL: "blendModesWebGL", defaultRenderer: "defaultRenderer", glContexts: "glContexts", requestAnimFrame: "requestAnimFrame", scaleModes_DEFAULT: "DEFAULT", scaleModes_LINEAR: "LINEAR", scaleModes_NEAREST: "NEAREST", texturesToDestroy: "texturesToDestroy", texturesToUpdate: "texturesToUpdate"};
(function(reflectionData) {
  "use strict";
  function map(x) {
    x = {x: x};
    delete x.x;
    return x;
  }
  function processStatics(descriptor) {
    for (var property in descriptor) {
      if (!hasOwnProperty.call(descriptor, property))
        continue;
      if (property === "^")
        continue;
      var element = descriptor[property];
      var firstChar = property.substring(0, 1);
      var previousProperty;
      if (firstChar === "+") {
        mangledGlobalNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
        if (element && element.length)
          init.typeInformation[previousProperty] = element;
      } else if (firstChar === "@") {
        property = property.substring(1);
        $[property]["@"] = element;
      } else if (firstChar === "*") {
        globalObject[previousProperty].$defaultValues = element;
        var optionalMethods = descriptor.$methodsWithOptionalArguments;
        if (!optionalMethods) {
          descriptor.$methodsWithOptionalArguments = optionalMethods = {};
        }
        optionalMethods[property] = previousProperty;
      } else if (typeof element === "function") {
        globalObject[previousProperty = property] = element;
        functions.push(property);
        init.globalFunctions[property] = element;
      } else if (element.constructor === Array) {
        addStubs(globalObject, element, property, true, descriptor, functions);
      } else {
        previousProperty = property;
        var newDesc = {};
        var previousProp;
        for (var prop in element) {
          if (!hasOwnProperty.call(element, prop))
            continue;
          firstChar = prop.substring(0, 1);
          if (prop === "static") {
            processStatics(init.statics[property] = element[prop]);
          } else if (firstChar === "+") {
            mangledNames[previousProp] = prop.substring(1);
            var flag = element[prop];
            if (flag > 0)
              element[previousProp].$reflectable = flag;
          } else if (firstChar === "@" && prop !== "@") {
            newDesc[prop.substring(1)]["@"] = element[prop];
          } else if (firstChar === "*") {
            newDesc[previousProp].$defaultValues = element[prop];
            var optionalMethods = newDesc.$methodsWithOptionalArguments;
            if (!optionalMethods) {
              newDesc.$methodsWithOptionalArguments = optionalMethods = {};
            }
            optionalMethods[prop] = previousProp;
          } else {
            var elem = element[prop];
            if (prop !== "^" && elem != null && elem.constructor === Array && prop !== "<>") {
              addStubs(newDesc, elem, prop, false, element, []);
            } else {
              newDesc[previousProp = prop] = elem;
            }
          }
        }
        $$[property] = [globalObject, newDesc];
        classes.push(property);
      }
    }
  }
  function addStubs(descriptor, array, name, isStatic, originalDescriptor, functions) {
    var f, funcs = [originalDescriptor[name] = descriptor[name] = f = array[0]];
    f.$stubName = name;
    functions.push(name);
    for (var index = 0; index < array.length; index += 2) {
      f = array[index + 1];
      if (typeof f != "function")
        break;
      f.$stubName = array[index + 2];
      funcs.push(f);
      if (f.$stubName) {
        originalDescriptor[f.$stubName] = descriptor[f.$stubName] = f;
        functions.push(f.$stubName);
      }
    }
    for (var i = 0; i < funcs.length; index++, i++) {
      funcs[i].$callName = array[index + 1];
    }
    var getterStubName = array[++index];
    array = array.slice(++index);
    var requiredParameterInfo = array[0];
    var requiredParameterCount = requiredParameterInfo >> 1;
    var isAccessor = (requiredParameterInfo & 1) === 1;
    var isSetter = requiredParameterInfo === 3;
    var isGetter = requiredParameterInfo === 1;
    var optionalParameterInfo = array[1];
    var optionalParameterCount = optionalParameterInfo >> 1;
    var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
    var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
    var functionTypeIndex = array[2];
    var unmangledNameIndex = 3 * optionalParameterCount + 2 * requiredParameterCount + 3;
    var isReflectable = array.length > unmangledNameIndex;
    if (getterStubName) {
      f = tearOff(funcs, array, isStatic, name, isIntercepted);
      descriptor[name].$getter = f;
      f.$getterStub = true;
      if (isStatic)
        init.globalFunctions[name] = f;
      originalDescriptor[getterStubName] = descriptor[getterStubName] = f;
      funcs.push(f);
      if (getterStubName)
        functions.push(getterStubName);
      f.$stubName = getterStubName;
      f.$callName = null;
      if (isIntercepted)
        init.interceptedNames[getterStubName] = true;
    }
    if (isReflectable) {
      for (var i = 0; i < funcs.length; i++) {
        funcs[i].$reflectable = 1;
        funcs[i].$reflectionInfo = array;
      }
      var mangledNames = isStatic ? init.mangledGlobalNames : init.mangledNames;
      var unmangledName = array[unmangledNameIndex];
      var reflectionName = unmangledName;
      if (getterStubName)
        mangledNames[getterStubName] = reflectionName;
      if (isSetter) {
        reflectionName += "=";
      } else if (!isGetter) {
        reflectionName += ":" + requiredParameterCount + ":" + optionalParameterCount;
      }
      mangledNames[name] = reflectionName;
      funcs[0].$reflectionName = reflectionName;
      funcs[0].$metadataIndex = unmangledNameIndex + 1;
      if (optionalParameterCount)
        descriptor[unmangledName + "*"] = funcs[0];
    }
  }
  function tearOffGetterNoCsp(funcs, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, reflectionInfo, name, H, null) : new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, reflectionInfo, name, H, null);
  }
  function tearOffGetterCsp(funcs, reflectionInfo, name, isIntercepted) {
    var cache = null;
    return isIntercepted ? function(x) {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [x], name);
      return new cache(this, funcs[0], x, name);
    } : function() {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [], name);
      return new cache(this, funcs[0], null, name);
    };
  }
  function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
    var cache;
    return isStatic ? function() {
      if (cache === void 0)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
      return cache;
    } : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
  }
  var functionCounter = 0;
  var tearOffGetter = typeof dart_precompiled == "function" ? tearOffGetterCsp : tearOffGetterNoCsp;
  if (!init.libraries)
    init.libraries = [];
  if (!init.mangledNames)
    init.mangledNames = map();
  if (!init.mangledGlobalNames)
    init.mangledGlobalNames = map();
  if (!init.statics)
    init.statics = map();
  if (!init.typeInformation)
    init.typeInformation = map();
  if (!init.globalFunctions)
    init.globalFunctions = map();
  if (!init.interceptedNames)
    init.interceptedNames = map();
  var libraries = init.libraries;
  var mangledNames = init.mangledNames;
  var mangledGlobalNames = init.mangledGlobalNames;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var length = reflectionData.length;
  for (var i = 0; i < length; i++) {
    var data = reflectionData[i];
    var name = data[0];
    var uri = data[1];
    var metadata = data[2];
    var globalObject = data[3];
    var descriptor = data[4];
    var isRoot = !!data[5];
    var fields = descriptor && descriptor["^"];
    if (fields instanceof Array)
      fields = fields[0];
    var classes = [];
    var functions = [];
    processStatics(descriptor);
    libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
  }
})([
["Arcade", "package:alienzed/physics/arcade/body.dart", , O, {
  "^": "",
  Body: {
    "^": "Body0;sprite@,game:Arcade$Body$game@-598,type:Arcade$Body$type*-599,enable>,offset*,position:Arcade$Body$position*-600,prev<,allowRotation,rotation@,preRotation,sourceWidth@,sourceHeight@,width:Arcade$Body$width*-601,height:Arcade$Body$height*-601,halfWidth@-601,halfHeight@-601,center<,velocity:Arcade$Body$velocity@-600,newVelocity,deltaMax,acceleration:Arcade$Body$acceleration*-600,drag:Arcade$Body$drag@-600,allowGravity<,gravity:Arcade$Body$gravity@-600,bounce:Arcade$Body$bounce@-600,maxVelocity:Arcade$Body$maxVelocity@-600,angularVelocity:Arcade$Body$angularVelocity@-601,angularAcceleration<,angularDrag:Arcade$Body$angularDrag@-601,maxAngular<,mass<,angle:Arcade$Body$angle@-601,speed:Arcade$Body$speed@-601,facing,immovable:Arcade$Body$immovable@-602,moves:Arcade$Body$moves@-602,customSeparateX<,customSeparateY<,overlapX?,overlapY?,embedded?,collideWorldBounds:Arcade$Body$collideWorldBounds@-602,checkCollision@,touching:Arcade$Body$touching@-603,wasTouching,blocked:Arcade$Body$blocked@-603,tilePadding:Arcade$Body$tilePadding@-600,safeRemove:Arcade$Body$safeRemove@-602,phase:Arcade$Body$phase@-599,_Arcade$_reset,_sx,_sy,_dx,_dy,game-598,position-600,tilePadding-600,Phaser$Body0$width-601,Phaser$Body0$height-601,velocity-600,acceleration-600,maxVelocity-600,collideWorldBounds-602,bounce-32,type-599,angularVelocity-601,gravity-600,drag-32,angularDrag-601,immovable-602,Phaser$Body0$x-601,Phaser$Body0$y-601,speed-601,blocked-603,angle-601,moves-602,phase-599,_reset-602,safeRemove-602,touching-603,Phaser$Rectangle1$x-601,Phaser$Rectangle1$y-601,Phaser$Rectangle1$width-601,Phaser$Rectangle1$height-601,x-601,y-601,width-601,height-601",
    addToWorld$0: [function() {
    }, "call$0", "get$addToWorld", 0, 0, 13, "addToWorld"],
    removeFromWorld$0: [function() {
    }, "call$0", "get$removeFromWorld", 0, 0, 13, "removeFromWorld"],
    sprite$3: function(arg0, arg1, arg2) {
      return this.sprite.call$3(arg0, arg1, arg2);
    },
    sprite$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.sprite.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    sprite$4: function(arg0, arg1, arg2, arg3) {
      return this.sprite.call$4(arg0, arg1, arg2, arg3);
    },
    enable$2: function($receiver, arg0, arg1) {
      return this.enable.call$2(arg0, arg1);
    },
    enable$1: function($receiver, arg0) {
      return this.enable.call$1(arg0);
    },
    enable$3: function($receiver, arg0, arg1, arg2) {
      return this.enable.call$3(arg0, arg1, arg2);
    },
    enable$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.enable.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    angle$0: function() {
      return this.Arcade$Body$angle.call$0();
    },
    angle$2: function(arg0, arg1) {
      return this.Arcade$Body$angle.call$2(arg0, arg1);
    },
    get$bottom: [function(_) {
      return J.$add$ns(J.get$y$x(this.Arcade$Body$position), this.Arcade$Body$height);
    }, null, null, 1, 0, 604, "bottom"],
    get$right: [function(_) {
      return J.$add$ns(J.get$x$x(this.Arcade$Body$position), this.Arcade$Body$width);
    }, null, null, 1, 0, 604, "right"],
    get$x: [function(_) {
      return J.get$x$x(this.Arcade$Body$position);
    }, null, null, 1, 0, 604, "x"],
    set$x: [function(_, value) {
      J.set$x$x(this.Arcade$Body$position, value);
    }, null, null, 3, 0, 605, 100, [], "x"],
    get$y: [function(_) {
      return J.get$y$x(this.Arcade$Body$position);
    }, null, null, 1, 0, 604, "y"],
    set$y: [function(_, value) {
      J.set$y$x(this.Arcade$Body$position, value);
    }, null, null, 3, 0, 605, 100, [], "y"],
    render$3: [function(context, color, filled) {
      var t1 = J.getInterceptor$x(context);
      if (filled === true) {
        t1.set$fillStyle(context, color);
        t1.fillRect$4(context, J.$sub$n(J.get$x$x(this.Arcade$Body$position), J.get$x$x(this.Arcade$Body$game.get$camera())), J.$sub$n(J.get$y$x(this.Arcade$Body$position), J.get$y$x(this.Arcade$Body$game.get$camera())), this.Arcade$Body$width, this.Arcade$Body$height);
      } else {
        t1.set$strokeStyle(context, color);
        t1.strokeRect$4(context, J.$sub$n(J.get$x$x(this.Arcade$Body$position), J.get$x$x(this.Arcade$Body$game.get$camera())), J.$sub$n(J.get$y$x(this.Arcade$Body$position), J.get$y$x(this.Arcade$Body$game.get$camera())), this.Arcade$Body$width, this.Arcade$Body$height);
      }
    }, function(context) {
      return this.render$3(context, "rgba(0,255,0,0.4)", true);
    }, "render$1", function(context, color) {
      return this.render$3(context, color, true);
    }, "render$2", "call$3", "call$1", "call$2", "get$render", 2, 4, 606, 607, 39, 104, [], 114, [], 608, [], "render"],
    renderBodyInfo$1: [function(debug) {
      debug.line$1(["x: " + J.toStringAsFixed$1$n(J.get$x$x(this.Arcade$Body$position), 2), "y: " + J.toStringAsFixed$1$n(J.get$y$x(this.Arcade$Body$position), 2), C.JSString_methods.$add("width: ", J.toString$0(this.Arcade$Body$width)), C.JSString_methods.$add("height: ", J.toString$0(this.Arcade$Body$height))]);
      debug.line$1(["velocity x: " + J.toStringAsFixed$1$n(J.get$x$x(this.Arcade$Body$velocity), 2), "y: " + J.toStringAsFixed$1$n(J.get$y$x(this.Arcade$Body$velocity), 2), "deltaX: " + J.toStringAsFixed$1$n(this._dx, 2), "deltaY: " + J.toStringAsFixed$1$n(this._dy, 2)]);
      debug.line$1(["acceleration x: " + J.toStringAsFixed$1$n(J.get$x$x(this.Arcade$Body$acceleration), 2), "y: " + J.toStringAsFixed$1$n(J.get$y$x(this.Arcade$Body$acceleration), 2), "speed: " + J.toStringAsFixed$1$n(this.Arcade$Body$speed, 2), "angle: " + J.toStringAsFixed$1$n(this.Arcade$Body$angle, 2)]);
      debug.line$1([C.JSString_methods.$add("gravity x: ", J.toString$0(J.get$x$x(this.Arcade$Body$gravity))), C.JSString_methods.$add("y: ", J.toString$0(J.get$y$x(this.Arcade$Body$gravity))), "bounce x: " + J.toStringAsFixed$1$n(J.get$x$x(this.Arcade$Body$bounce), 2), "y: " + J.toStringAsFixed$1$n(J.get$y$x(this.Arcade$Body$bounce), 2)]);
      debug.line$1([C.JSString_methods.$add("touching left: ", J.toString$0(J.get$left$x(this.Arcade$Body$touching))), C.JSString_methods.$add("right: ", J.toString$0(J.get$right$x(this.Arcade$Body$touching))), C.JSString_methods.$add("up: ", J.toString$0(this.Arcade$Body$touching.get$up())), C.JSString_methods.$add("down: ", J.toString$0(this.Arcade$Body$touching.get$down()))]);
      debug.line$1([C.JSString_methods.$add("blocked left: ", J.toString$0(J.get$left$x(this.Arcade$Body$blocked))), C.JSString_methods.$add("right: ", J.toString$0(J.get$right$x(this.Arcade$Body$blocked))), C.JSString_methods.$add("up: ", J.toString$0(this.Arcade$Body$blocked.get$up())), C.JSString_methods.$add("down: ", J.toString$0(this.Arcade$Body$blocked.get$down()))]);
    }, "call$1", "get$renderBodyInfo", 2, 0, 609, 610, [], "renderBodyInfo"],
    updateBounds$0: [function() {
      var asx, asy;
      asx = J.abs$0$n(J.get$x$x(J.get$scale$x(this.sprite)));
      asy = J.abs$0$n(J.get$y$x(J.get$scale$x(this.sprite)));
      if (!J.$eq(asx, this._sx) || !J.$eq(asy, this._sy)) {
        this.Arcade$Body$width = J.$mul$ns(this.sourceWidth, asx);
        this.Arcade$Body$height = J.$mul$ns(this.sourceHeight, asy);
        this.halfWidth = J.floor$0$n(J.$div$n(this.Arcade$Body$width, 2));
        this.halfHeight = J.floor$0$n(J.$div$n(this.Arcade$Body$height, 2));
        this._sx = asx;
        this._sy = asy;
        this.center.setTo$2(J.$add$ns(J.get$x$x(this.Arcade$Body$position), this.halfWidth), J.$add$ns(J.get$y$x(this.Arcade$Body$position), this.halfHeight));
        this._Arcade$_reset = true;
      }
    }, "call$0", "get$updateBounds", 0, 0, 13, "updateBounds"],
    preUpdate$0: [function() {
      var t1, t2;
      if (!this.enable)
        return;
      this.Arcade$Body$phase = 1;
      this.wasTouching.none = this.Arcade$Body$touching.get$none();
      this.wasTouching.up = this.Arcade$Body$touching.get$up();
      this.wasTouching.down = this.Arcade$Body$touching.get$down();
      this.wasTouching.left = J.get$left$x(this.Arcade$Body$touching);
      this.wasTouching.right = J.get$right$x(this.Arcade$Body$touching);
      this.Arcade$Body$touching.set$none(true);
      this.Arcade$Body$touching.set$up(false);
      this.Arcade$Body$touching.set$down(false);
      J.set$left$x(this.Arcade$Body$touching, false);
      J.set$right$x(this.Arcade$Body$touching, false);
      this.Arcade$Body$blocked.set$up(false);
      this.Arcade$Body$blocked.set$down(false);
      J.set$left$x(this.Arcade$Body$blocked, false);
      J.set$right$x(this.Arcade$Body$blocked, false);
      this.embedded = false;
      this.updateBounds$0();
      J.set$x$x(this.Arcade$Body$position, J.$add$ns(J.$sub$n(J.get$x$x(this.sprite.get$world()), J.$mul$ns(J.get$x$x(this.sprite.get$anchor()), this.Arcade$Body$width)), J.get$x$x(this.offset)));
      J.set$y$x(this.Arcade$Body$position, J.$add$ns(J.$sub$n(J.get$y$x(this.sprite.get$world()), J.$mul$ns(J.get$y$x(this.sprite.get$anchor()), this.Arcade$Body$height)), J.get$y$x(this.offset)));
      t1 = this.sprite.get$angle();
      this.rotation = t1;
      this.preRotation = t1;
      if (this._Arcade$_reset || this.sprite.get$fresh()) {
        this.prev.x = J.get$x$x(this.Arcade$Body$position);
        this.prev.y = J.get$y$x(this.Arcade$Body$position);
      }
      if (this.Arcade$Body$moves === true) {
        this.Arcade$Body$game.get$physics().get$arcade().updateMotion$1(this);
        this.newVelocity.set$2(J.$mul$ns(J.get$x$x(this.Arcade$Body$velocity), this.Arcade$Body$game.get$time().get$physicsElapsed()), J.$mul$ns(J.get$y$x(this.Arcade$Body$velocity), this.Arcade$Body$game.get$time().get$physicsElapsed()));
        t1 = this.Arcade$Body$position;
        t2 = J.getInterceptor$x(t1);
        t2.set$x(t1, J.$add$ns(t2.get$x(t1), this.newVelocity.x));
        t1 = this.Arcade$Body$position;
        t2 = J.getInterceptor$x(t1);
        t2.set$y(t1, J.$add$ns(t2.get$y(t1), this.newVelocity.y));
        if (!J.$eq(J.get$x$x(this.Arcade$Body$position), this.prev.x) || !J.$eq(J.get$y$x(this.Arcade$Body$position), this.prev.y)) {
          t1 = J.$add$ns(J.$mul$ns(J.get$x$x(this.Arcade$Body$velocity), J.get$x$x(this.Arcade$Body$velocity)), J.$mul$ns(J.get$y$x(this.Arcade$Body$velocity), J.get$y$x(this.Arcade$Body$velocity)));
          if (typeof t1 !== "number")
            H.throwExpression(P.ArgumentError$(t1));
          this.Arcade$Body$speed = Math.sqrt(t1);
          t1 = J.get$y$x(this.Arcade$Body$velocity);
          t2 = J.get$x$x(this.Arcade$Body$velocity);
          if (typeof t1 !== "number")
            H.throwExpression(P.ArgumentError$(t1));
          if (typeof t2 !== "number")
            H.throwExpression(P.ArgumentError$(t2));
          this.Arcade$Body$angle = Math.atan2(t1, t2);
        }
        if (this.Arcade$Body$collideWorldBounds === true) {
          if (J.$lt$n(J.get$x$x(this.Arcade$Body$position), J.get$x$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds())) && J.get$left$x(this.Arcade$Body$game.get$physics().get$arcade().get$checkCollision()) === true) {
            J.set$x$x(this.Arcade$Body$position, J.get$x$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds()));
            t1 = this.Arcade$Body$velocity;
            t2 = J.getInterceptor$x(t1);
            t2.set$x(t1, J.$mul$ns(t2.get$x(t1), J.$negate$n(J.get$x$x(this.Arcade$Body$bounce))));
            J.set$left$x(this.Arcade$Body$blocked, true);
          } else if (J.$gt$n(J.$add$ns(J.get$x$x(this.Arcade$Body$position), this.Arcade$Body$width), J.get$right$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds())) && J.get$right$x(this.Arcade$Body$game.get$physics().get$arcade().get$checkCollision()) === true) {
            J.set$x$x(this.Arcade$Body$position, J.$sub$n(J.get$right$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds()), this.Arcade$Body$width));
            t1 = this.Arcade$Body$velocity;
            t2 = J.getInterceptor$x(t1);
            t2.set$x(t1, J.$mul$ns(t2.get$x(t1), J.$negate$n(J.get$x$x(this.Arcade$Body$bounce))));
            J.set$right$x(this.Arcade$Body$blocked, true);
          }
          if (J.$lt$n(J.get$y$x(this.Arcade$Body$position), J.get$y$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds())) && this.Arcade$Body$game.get$physics().get$arcade().get$checkCollision().get$up() === true) {
            J.set$y$x(this.Arcade$Body$position, J.get$y$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds()));
            t1 = this.Arcade$Body$velocity;
            t2 = J.getInterceptor$x(t1);
            t2.set$y(t1, J.$mul$ns(t2.get$y(t1), J.$negate$n(J.get$y$x(this.Arcade$Body$bounce))));
            this.Arcade$Body$blocked.set$up(true);
          } else if (J.$gt$n(J.$add$ns(J.get$y$x(this.Arcade$Body$position), this.Arcade$Body$height), J.get$bottom$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds())) && this.Arcade$Body$game.get$physics().get$arcade().get$checkCollision().get$down() === true) {
            J.set$y$x(this.Arcade$Body$position, J.$sub$n(J.get$bottom$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds()), this.Arcade$Body$height));
            t1 = this.Arcade$Body$velocity;
            t2 = J.getInterceptor$x(t1);
            t2.set$y(t1, J.$mul$ns(t2.get$y(t1), J.$negate$n(J.get$y$x(this.Arcade$Body$bounce))));
            this.Arcade$Body$blocked.set$down(true);
          }
        }
      }
      this._dx = J.$sub$n(J.get$x$x(this.Arcade$Body$position), this.prev.x);
      this._dy = J.$sub$n(J.get$y$x(this.Arcade$Body$position), this.prev.y);
      this._Arcade$_reset = false;
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    postUpdate$0: [function() {
      var t1, t2;
      if (!this.enable)
        return;
      if (J.$eq(this.Arcade$Body$phase, 2))
        return;
      this.Arcade$Body$phase = 2;
      if (J.$lt$n(J.$sub$n(J.get$x$x(this.Arcade$Body$position), this.prev.x), 0))
        this.facing = 1;
      else if (J.$gt$n(J.$sub$n(J.get$x$x(this.Arcade$Body$position), this.prev.x), 0))
        this.facing = 2;
      if (J.$lt$n(J.$sub$n(J.get$y$x(this.Arcade$Body$position), this.prev.y), 0))
        this.facing = 3;
      else if (J.$gt$n(J.$sub$n(J.get$y$x(this.Arcade$Body$position), this.prev.y), 0))
        this.facing = 4;
      if (this.Arcade$Body$moves === true) {
        this._dx = J.$sub$n(J.get$x$x(this.Arcade$Body$position), this.prev.x);
        this._dy = J.$sub$n(J.get$y$x(this.Arcade$Body$position), this.prev.y);
        if (!J.$eq(this.deltaMax.x, 0) && !J.$eq(this._dx, 0))
          if (J.$lt$n(this._dx, 0) && J.$lt$n(this._dx, J.$negate$n(this.deltaMax.x)))
            this._dx = J.$negate$n(this.deltaMax.x);
          else if (J.$gt$n(this._dx, 0) && J.$gt$n(this._dx, this.deltaMax.x))
            this._dx = this.deltaMax.x;
        if (!J.$eq(this.deltaMax.y, 0) && !J.$eq(this._dy, 0))
          if (J.$lt$n(this._dy, 0) && J.$lt$n(this._dy, J.$negate$n(this.deltaMax.y)))
            this._dy = J.$negate$n(this.deltaMax.y);
          else if (J.$gt$n(this._dy, 0) && J.$gt$n(this._dy, this.deltaMax.y))
            this._dy = this.deltaMax.y;
        t1 = this.sprite;
        t2 = J.getInterceptor$x(t1);
        t2.set$x(t1, J.$add$ns(t2.get$x(t1), this._dx));
        t1 = this.sprite;
        t2 = J.getInterceptor$x(t1);
        t2.set$y(t1, J.$add$ns(t2.get$y(t1), this._dy));
      }
      this.center.setTo$2(J.$add$ns(J.get$x$x(this.Arcade$Body$position), this.halfWidth), J.$add$ns(J.get$y$x(this.Arcade$Body$position), this.halfHeight));
      if (this.allowRotation) {
        t1 = this.sprite;
        t1.set$angle(J.$add$ns(t1.get$angle(), J.$sub$n(this.rotation, this.preRotation)));
      }
      this.prev.x = J.get$x$x(this.Arcade$Body$position);
      this.prev.y = J.get$y$x(this.Arcade$Body$position);
    }, "call$0", "get$postUpdate", 0, 0, 13, "postUpdate"],
    moveLeft$1: [function(speed) {
      var t1, t2;
      t1 = this.Arcade$Body$velocity;
      t2 = J.getInterceptor$x(t1);
      t2.set$x(t1, J.$sub$n(t2.get$x(t1), P.max(speed, J.get$x$x(this.Arcade$Body$maxVelocity))));
    }, "call$1", "get$moveLeft", 2, 0, 605, 611, [], "moveLeft"],
    moveRight$1: [function(speed) {
      var t1, t2;
      t1 = this.Arcade$Body$velocity;
      t2 = J.getInterceptor$x(t1);
      t2.set$x(t1, J.$add$ns(t2.get$x(t1), P.max(speed, J.get$x$x(this.Arcade$Body$maxVelocity))));
    }, "call$1", "get$moveRight", 2, 0, 605, 611, [], "moveRight"],
    moveUp$1: [function(speed) {
      var t1, t2;
      t1 = this.Arcade$Body$velocity;
      t2 = J.getInterceptor$x(t1);
      t2.set$y(t1, J.$sub$n(t2.get$y(t1), P.max(speed, J.get$y$x(this.Arcade$Body$maxVelocity))));
    }, "call$1", "get$moveUp", 2, 0, 605, 611, [], "moveUp"],
    moveDown$1: [function(speed) {
      var t1, t2;
      t1 = this.Arcade$Body$velocity;
      t2 = J.getInterceptor$x(t1);
      t2.set$y(t1, J.$add$ns(t2.get$y(t1), P.max(speed, J.get$y$x(this.Arcade$Body$maxVelocity))));
    }, "call$1", "get$moveDown", 2, 0, 605, 611, [], "moveDown"],
    destroy$0: [function() {
      this.sprite = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    checkWorldBounds$0: [function() {
      var t1, t2;
      if (J.$lt$n(J.get$x$x(this.Arcade$Body$position), J.get$x$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds())) && J.get$left$x(this.Arcade$Body$game.get$physics().get$arcade().get$checkCollision()) === true) {
        J.set$x$x(this.Arcade$Body$position, J.get$x$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds()));
        t1 = this.Arcade$Body$velocity;
        t2 = J.getInterceptor$x(t1);
        t2.set$x(t1, J.$mul$ns(t2.get$x(t1), J.$negate$n(J.get$x$x(this.Arcade$Body$bounce))));
        J.set$left$x(this.Arcade$Body$blocked, true);
      } else if (J.$gt$n(J.$add$ns(J.get$x$x(this.Arcade$Body$position), this.Arcade$Body$width), J.get$right$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds())) && J.get$right$x(this.Arcade$Body$game.get$physics().get$arcade().get$checkCollision()) === true) {
        J.set$x$x(this.Arcade$Body$position, J.$sub$n(J.get$right$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds()), this.Arcade$Body$width));
        t1 = this.Arcade$Body$velocity;
        t2 = J.getInterceptor$x(t1);
        t2.set$x(t1, J.$mul$ns(t2.get$x(t1), J.$negate$n(J.get$x$x(this.Arcade$Body$bounce))));
        J.set$right$x(this.Arcade$Body$blocked, true);
      }
      if (J.$lt$n(J.get$y$x(this.Arcade$Body$position), J.get$y$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds())) && this.Arcade$Body$game.get$physics().get$arcade().get$checkCollision().get$up() === true) {
        J.set$y$x(this.Arcade$Body$position, J.get$y$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds()));
        t1 = this.Arcade$Body$velocity;
        t2 = J.getInterceptor$x(t1);
        t2.set$y(t1, J.$mul$ns(t2.get$y(t1), J.$negate$n(J.get$y$x(this.Arcade$Body$bounce))));
        this.Arcade$Body$blocked.set$up(true);
      } else if (J.$gt$n(J.$add$ns(J.get$y$x(this.Arcade$Body$position), this.Arcade$Body$height), J.get$bottom$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds())) && this.Arcade$Body$game.get$physics().get$arcade().get$checkCollision().get$down() === true) {
        J.set$y$x(this.Arcade$Body$position, J.$sub$n(J.get$bottom$x(this.Arcade$Body$game.get$physics().get$arcade().get$bounds()), this.Arcade$Body$height));
        t1 = this.Arcade$Body$velocity;
        t2 = J.getInterceptor$x(t1);
        t2.set$y(t1, J.$mul$ns(t2.get$y(t1), J.$negate$n(J.get$y$x(this.Arcade$Body$bounce))));
        this.Arcade$Body$blocked.set$down(true);
      }
    }, "call$0", "get$checkWorldBounds", 0, 0, 13],
    setSize$4: [function(width, height, offsetX, offsetY) {
      if (offsetX == null)
        offsetX = J.get$x$x(this.offset);
      if (offsetY == null)
        offsetY = J.get$y$x(this.offset);
      this.sourceWidth = width;
      this.sourceHeight = height;
      this.Arcade$Body$width = J.$mul$ns(width, this._sx);
      this.Arcade$Body$height = J.$mul$ns(this.sourceHeight, this._sy);
      this.halfWidth = J.floor$0$n(J.$div$n(this.Arcade$Body$width, 2));
      this.halfHeight = J.floor$0$n(J.$div$n(this.Arcade$Body$height, 2));
      this.offset.setTo$2(offsetX, offsetY);
      this.center.setTo$2(J.$add$ns(J.get$x$x(this.Arcade$Body$position), this.halfWidth), J.$add$ns(J.get$y$x(this.Arcade$Body$position), this.halfHeight));
    }, function(width, height) {
      return this.setSize$4(width, height, null, null);
    }, "setSize$2", function(width, height, offsetX) {
      return this.setSize$4(width, height, offsetX, null);
    }, "setSize$3", "call$4", "call$2", "call$3", "get$setSize", 4, 4, 612, 32, 32, 10, [], 11, [], 613, [], 614, [], "setSize"],
    reset$4: [function(_, x, y, a1, a2) {
      var t1;
      this.Arcade$Body$velocity.set$1(0);
      this.Arcade$Body$acceleration.set$1(0);
      this.Arcade$Body$angularVelocity = 0;
      this.angularAcceleration = 0;
      J.set$x$x(this.Arcade$Body$position, J.$add$ns(J.$sub$n(x, J.$mul$ns(J.get$x$x(this.sprite.get$anchor()), this.Arcade$Body$width)), J.get$x$x(this.offset)));
      J.set$y$x(this.Arcade$Body$position, J.$add$ns(J.$sub$n(y, J.$mul$ns(J.get$y$x(this.sprite.get$anchor()), this.Arcade$Body$height)), J.get$y$x(this.offset)));
      this.prev.x = J.get$x$x(this.Arcade$Body$position);
      this.prev.y = J.get$y$x(this.Arcade$Body$position);
      t1 = this.sprite.get$angle();
      this.rotation = t1;
      this.preRotation = t1;
      this._sx = J.get$x$x(J.get$scale$x(this.sprite));
      this._sy = J.get$y$x(J.get$scale$x(this.sprite));
      this.center.setTo$2(J.$add$ns(J.get$x$x(this.Arcade$Body$position), this.halfWidth), J.$add$ns(J.get$y$x(this.Arcade$Body$position), this.halfHeight));
    }, function($receiver, x, y, a1) {
      return this.reset$4($receiver, x, y, a1, null);
    }, "reset$3", function($receiver, x, y) {
      return this.reset$4($receiver, x, y, null, null);
    }, "reset$2", "call$4", "call$3", "call$2", "get$reset", 4, 4, 615, 32, 32, 6, [], 7, [], 402, [], 403, [], "reset"],
    hitTest$2: function(x, y) {
      return this.contains$2(0, x, y);
    },
    onFloor$0: [function() {
      return this.Arcade$Body$blocked.get$down();
    }, "call$0", "get$onFloor", 0, 0, 209, "onFloor"],
    deltaAbsX$0: function() {
      var t1, t2;
      t1 = J.$gt$n(J.$sub$n(J.get$x$x(this.Arcade$Body$position), this.prev.x), 0);
      t2 = this.Arcade$Body$position;
      return t1 ? J.$sub$n(J.get$x$x(t2), this.prev.x) : J.$negate$n(J.$sub$n(J.get$x$x(t2), this.prev.x));
    },
    deltaAbsY$0: function() {
      var t1, t2;
      t1 = J.$gt$n(J.$sub$n(J.get$y$x(this.Arcade$Body$position), this.prev.y), 0);
      t2 = this.Arcade$Body$position;
      return t1 ? J.$sub$n(J.get$y$x(t2), this.prev.y) : J.$negate$n(J.$sub$n(J.get$y$x(t2), this.prev.y));
    },
    deltaX$0: [function(_) {
      return J.$sub$n(J.get$x$x(this.Arcade$Body$position), this.prev.x);
    }, "call$0", "get$deltaX", 0, 0, 604],
    deltaY$0: [function(_) {
      return J.$sub$n(J.get$y$x(this.Arcade$Body$position), this.prev.y);
    }, "call$0", "get$deltaY", 0, 0, 604],
    deltaZ$0: [function(_) {
      return J.$sub$n(this.rotation, this.preRotation);
    }, "call$0", "get$deltaZ", 0, 0, 604],
    Body$1: function(sprite) {
      var t1, t2, t3;
      this.Arcade$Body$game = this.sprite.get$game();
      this.Arcade$Body$type = 0;
      this.enable = true;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.offset = t1;
      t1 = J.get$x$x(this.sprite);
      t2 = J.get$y$x(this.sprite);
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      this.Arcade$Body$position = t3;
      t3 = t3.x;
      t2 = J.get$y$x(this.Arcade$Body$position);
      t1 = new R.Point(null, null);
      t1.x = t3;
      t1.y = t2;
      this.prev = t1;
      this.allowRotation = true;
      this.rotation = this.sprite.get$rotation();
      this.preRotation = this.sprite.get$rotation();
      this.sourceWidth = J.get$width$x(this.sprite.get$texture().get$frame());
      this.sourceHeight = J.get$height$x(this.sprite.get$texture().get$frame());
      this.Arcade$Body$width = J.get$width$x(this.sprite);
      this.Arcade$Body$height = J.get$height$x(this.sprite);
      this.halfWidth = J.abs$0$n(J.$div$n(J.get$width$x(this.sprite), 2));
      this.halfHeight = J.abs$0$n(J.$div$n(J.get$height$x(this.sprite), 2));
      t1 = J.$add$ns(J.get$x$x(this.sprite), this.halfWidth);
      t2 = J.$add$ns(J.get$y$x(this.sprite), this.halfHeight);
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      this.center = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.Arcade$Body$velocity = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.newVelocity = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.deltaMax = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.Arcade$Body$acceleration = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.Arcade$Body$drag = t3;
      this.allowGravity = true;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.Arcade$Body$gravity = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.Arcade$Body$bounce = t3;
      t3 = new R.Point(null, null);
      t3.x = 10000;
      t3.y = 10000;
      this.Arcade$Body$maxVelocity = t3;
      this.Arcade$Body$angularVelocity = 0;
      this.angularAcceleration = 0;
      this.Arcade$Body$angularDrag = 0;
      this.maxAngular = 1000;
      this.mass = 1;
      this.Arcade$Body$angle = 0;
      this.Arcade$Body$speed = 0;
      this.facing = 0;
      this.Arcade$Body$immovable = false;
      this.Arcade$Body$moves = true;
      this.customSeparateX = false;
      this.customSeparateY = false;
      this.overlapX = 0;
      this.overlapY = 0;
      this.embedded = false;
      this.Arcade$Body$collideWorldBounds = false;
      t3 = R.CollisionInfo$(false, false, false, false);
      t3.none = false;
      t3.any = true;
      t3.up = true;
      t3.down = true;
      t3.left = true;
      t3.right = true;
      this.checkCollision = t3;
      t3 = R.CollisionInfo$(false, false, false, false);
      t3.none = true;
      t3.up = false;
      t3.down = false;
      t3.left = false;
      t3.right = false;
      this.Arcade$Body$touching = t3;
      t3 = R.CollisionInfo$(false, false, false, false);
      t3.none = true;
      t3.up = false;
      t3.down = false;
      t3.left = false;
      t3.right = false;
      this.wasTouching = t3;
      t3 = R.CollisionInfo$(false, false, false, false);
      t3.up = false;
      t3.down = false;
      t3.left = false;
      t3.right = false;
      this.Arcade$Body$blocked = t3;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      this.Arcade$Body$tilePadding = t3;
      this.Arcade$Body$phase = 0;
      this._Arcade$_reset = true;
      this._sx = J.get$x$x(J.get$scale$x(this.sprite));
      this._sy = J.get$y$x(J.get$scale$x(this.sprite));
      this._dx = 0;
      this._dy = 0;
    },
    static: {Body$: function(sprite) {
        var t1 = new O.Body(sprite, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, 0, 0, 0, 0);
        t1.Body$1(sprite);
        return t1;
      }}
  },
  "+Body": 0
}],
["Ninja", "package:alienzed/physics/ninja/body.dart", , E, {
  "^": "",
  AABB: {
    "^": "Shape0;body:Ninja0$AABB$body*,Ninja0$AABB$system,pos:Ninja0$AABB$pos<,oldpos:Ninja0$AABB$oldpos<,_Ninja0$_width:Ninja0$AABB$_Ninja0$_width<,_Ninja0$_height:Ninja0$AABB$_Ninja0$_height<,Ninja0$AABB$oH,Ninja0$AABB$oV,velocity:Ninja0$AABB$velocity@,Ninja0$AABB$aabbTileProjections,body,system,pos,oldpos,_Ninja0$_width,_Ninja0$_height,oH,oV,velocity,aabbTileProjections",
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.Ninja0$AABB$body.call$3(arg0, arg1, arg2);
    },
    get$xw: function() {
      return J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_width, 2));
    },
    get$yw: function() {
      return J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_height, 2));
    },
    get$width: function(_) {
      return this.Ninja0$AABB$_Ninja0$_width;
    },
    get$height: function(_) {
      return this.Ninja0$AABB$_Ninja0$_height;
    },
    integrate$0: function() {
      var t1, px, py;
      t1 = this.Ninja0$AABB$pos;
      px = t1.x;
      py = t1.y;
      t1.x = J.$add$ns(px, J.$sub$n(J.$mul$ns(this.Ninja0$AABB$body.get$drag(), this.Ninja0$AABB$pos.x), J.$mul$ns(this.Ninja0$AABB$body.get$drag(), this.Ninja0$AABB$oldpos.x)));
      t1 = this.Ninja0$AABB$pos;
      t1.y = J.$add$ns(t1.y, J.$add$ns(J.$sub$n(J.$mul$ns(this.Ninja0$AABB$body.get$drag(), this.Ninja0$AABB$pos.y), J.$mul$ns(this.Ninja0$AABB$body.get$drag(), this.Ninja0$AABB$oldpos.y)), J.$mul$ns(this.Ninja0$AABB$system.gravity, this.Ninja0$AABB$body.get$gravityScale())));
      this.Ninja0$AABB$velocity.set$2(J.$sub$n(this.Ninja0$AABB$pos.x, px), J.$sub$n(this.Ninja0$AABB$pos.y, py));
      this.Ninja0$AABB$oldpos.set$2(px, py);
    },
    reportCollisionVsWorld$4: function(px, py, dx, dy) {
      var p, o, vx, vy, t1, t2, dp, t3, nx, ny, tx, ty, fx, fy, b, bx, by;
      p = this.Ninja0$AABB$pos;
      o = this.Ninja0$AABB$oldpos;
      vx = J.$sub$n(p.x, o.x);
      vy = J.$sub$n(p.y, o.y);
      t1 = J.getInterceptor$ns(vx);
      t2 = J.getInterceptor$ns(vy);
      dp = J.$add$ns(t1.$mul(vx, dx), t2.$mul(vy, dy));
      t3 = J.getInterceptor$ns(dp);
      nx = t3.$mul(dp, dx);
      ny = t3.$mul(dp, dy);
      tx = t1.$sub(vx, nx);
      ty = t2.$sub(vy, ny);
      if (t3.$lt(dp, 0)) {
        fx = J.$mul$ns(tx, this.Ninja0$AABB$body.get$friction());
        fy = J.$mul$ns(ty, this.Ninja0$AABB$body.get$friction());
        t1 = this.Ninja0$AABB$body.get$bounce();
        if (typeof t1 !== "number")
          return H.iae(t1);
        b = 1 + t1;
        bx = J.$mul$ns(nx, b);
        by = J.$mul$ns(ny, b);
        t1 = J.getInterceptor(dx);
        if (t1.$eq(dx, 1))
          J.set$left$x(this.Ninja0$AABB$body.get$touching(), true);
        else if (t1.$eq(dx, -1))
          J.set$right$x(this.Ninja0$AABB$body.get$touching(), true);
        t1 = J.getInterceptor(dy);
        if (t1.$eq(dy, 1))
          this.Ninja0$AABB$body.get$touching().set$up(true);
        else if (t1.$eq(dy, -1))
          this.Ninja0$AABB$body.get$touching().set$down(true);
      } else {
        bx = 0;
        by = 0;
        fx = 0;
        fy = 0;
      }
      p.x = J.$add$ns(p.x, px);
      p.y = J.$add$ns(p.y, py);
      o.x = J.$add$ns(o.x, J.$add$ns(J.$add$ns(px, bx), fx));
      o.y = J.$add$ns(o.y, J.$add$ns(J.$add$ns(py, by), fy));
    },
    reverse$0: [function() {
      var vx, vy;
      vx = J.$sub$n(this.Ninja0$AABB$pos.x, this.Ninja0$AABB$oldpos.x);
      vy = J.$sub$n(this.Ninja0$AABB$pos.y, this.Ninja0$AABB$oldpos.y);
      if (J.$lt$n(this.Ninja0$AABB$oldpos.x, this.Ninja0$AABB$pos.x))
        this.Ninja0$AABB$oldpos.x = J.$add$ns(this.Ninja0$AABB$pos.x, vx);
      else if (J.$gt$n(this.Ninja0$AABB$oldpos.x, this.Ninja0$AABB$pos.x))
        this.Ninja0$AABB$oldpos.x = J.$sub$n(this.Ninja0$AABB$pos.x, vx);
      if (J.$lt$n(this.Ninja0$AABB$oldpos.y, this.Ninja0$AABB$pos.y))
        this.Ninja0$AABB$oldpos.y = J.$add$ns(this.Ninja0$AABB$pos.y, vy);
      else if (J.$gt$n(this.Ninja0$AABB$oldpos.y, this.Ninja0$AABB$pos.y))
        this.Ninja0$AABB$oldpos.y = J.$sub$n(this.Ninja0$AABB$pos.y, vy);
    }, "call$0", "get$reverse", 0, 0, 13],
    reportCollisionVsBody$5: function(px, py, dx, dy, obj) {
      var vx1, vy1, dp1, t1, t2;
      vx1 = J.$sub$n(this.Ninja0$AABB$pos.x, this.Ninja0$AABB$oldpos.x);
      vy1 = J.$sub$n(this.Ninja0$AABB$pos.y, this.Ninja0$AABB$oldpos.y);
      dp1 = J.$add$ns(J.$mul$ns(vx1, dx), J.$mul$ns(vy1, dy));
      if (this.Ninja0$AABB$body.get$immovable() === true && obj.Ninja0$AABB$body.get$immovable() === true) {
        px = J.$mul$ns(px, 0.5);
        py = J.$mul$ns(py, 0.5);
        t1 = this.Ninja0$AABB$pos;
        t1.x = J.$add$ns(t1.x, px);
        t1.y = J.$add$ns(t1.y, py);
        t1 = this.Ninja0$AABB$oldpos;
        t2 = this.Ninja0$AABB$pos;
        t1.set$2(t2.x, t2.y);
        t2 = obj.Ninja0$AABB$pos;
        t2.x = J.$sub$n(t2.x, px);
        t2.y = J.$sub$n(t2.y, py);
        t2 = obj.Ninja0$AABB$oldpos;
        t1 = obj.Ninja0$AABB$pos;
        t2.set$2(t1.x, t1.y);
        return;
      } else if (this.Ninja0$AABB$body.get$immovable() !== true && obj.Ninja0$AABB$body.get$immovable() !== true) {
        px = J.$mul$ns(px, 0.5);
        py = J.$mul$ns(py, 0.5);
        t1 = this.Ninja0$AABB$pos;
        t1.x = J.$add$ns(t1.x, px);
        t1.y = J.$add$ns(t1.y, py);
        t1 = obj.Ninja0$AABB$pos;
        t1.x = J.$sub$n(t1.x, px);
        t1.y = J.$sub$n(t1.y, py);
        if (J.$lt$n(dp1, 0)) {
          this.reverse$0();
          obj.reverse$0();
        }
      } else if (this.Ninja0$AABB$body.get$immovable() !== true) {
        t1 = this.Ninja0$AABB$pos;
        t1.x = J.$sub$n(t1.x, px);
        t1.y = J.$sub$n(t1.y, py);
        if (J.$lt$n(dp1, 0))
          this.reverse$0();
      } else if (obj.Ninja0$AABB$body.get$immovable() !== true) {
        t1 = obj.Ninja0$AABB$pos;
        t1.x = J.$sub$n(t1.x, px);
        t1.y = J.$sub$n(t1.y, py);
        if (J.$lt$n(dp1, 0))
          obj.reverse$0();
      }
    },
    collideWorldBounds$0: [function() {
      var dx, dy;
      dx = J.$sub$n(J.get$x$x(this.Ninja0$AABB$system.bounds), J.$sub$n(this.Ninja0$AABB$pos.x, J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_width, 2))));
      if (typeof dx !== "number")
        return H.iae(dx);
      if (0 < dx)
        this.reportCollisionVsWorld$4(dx, 0, 1, 0);
      else {
        dx = J.$sub$n(J.$add$ns(this.Ninja0$AABB$pos.x, J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_width, 2))), J.get$right$x(this.Ninja0$AABB$system.bounds));
        if (typeof dx !== "number")
          return H.iae(dx);
        if (0 < dx)
          this.reportCollisionVsWorld$4(-dx, 0, -1, 0);
      }
      dy = J.$sub$n(J.get$y$x(this.Ninja0$AABB$system.bounds), J.$sub$n(this.Ninja0$AABB$pos.y, J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_height, 2))));
      if (typeof dy !== "number")
        return H.iae(dy);
      if (0 < dy)
        this.reportCollisionVsWorld$4(0, dy, 0, 1);
      else {
        dy = J.$sub$n(J.$add$ns(this.Ninja0$AABB$pos.y, J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_height, 2))), J.get$bottom$x(this.Ninja0$AABB$system.bounds));
        if (typeof dy !== "number")
          return H.iae(dy);
        if (0 < dy)
          this.reportCollisionVsWorld$4(0, -dy, 0, -1);
      }
    }, "call$0", "get$collideWorldBounds", 0, 0, 13],
    collideAABBVsAABB$1: function(aabb) {
      var pos, t1, tx, ty, txw, tyw, dx, t2, t3, px, dy, t4, py, l;
      pos = this.Ninja0$AABB$pos;
      t1 = aabb.Ninja0$AABB$pos;
      tx = t1.x;
      ty = t1.y;
      txw = J.abs$0$n(J.$div$n(aabb.Ninja0$AABB$_Ninja0$_width, 2));
      tyw = J.abs$0$n(J.$div$n(aabb.Ninja0$AABB$_Ninja0$_height, 2));
      dx = J.$sub$n(pos.x, tx);
      t1 = J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_width, 2));
      t2 = J.getInterceptor$n(dx);
      t3 = t2.abs$0(dx);
      if (typeof t3 !== "number")
        return H.iae(t3);
      px = txw + t1 - t3;
      if (0 < px) {
        dy = J.$sub$n(pos.y, ty);
        t1 = J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_height, 2));
        t3 = J.getInterceptor$n(dy);
        t4 = t3.abs$0(dy);
        if (typeof t4 !== "number")
          return H.iae(t4);
        py = tyw + t1 - t4;
        if (0 < py) {
          if (px < py) {
            if (t2.$lt(dx, 0))
              px *= -1;
            py = 0;
          } else {
            if (t3.$lt(dy, 0))
              py *= -1;
            px = 0;
          }
          l = Math.sqrt(px * px + py * py);
          this.reportCollisionVsBody$5(px, py, px / l, py / l, aabb);
          return 1;
        }
      }
      return false;
    },
    collideAABBVsTile$1: function(tile) {
      var dx, t1, t2, t3, t4, px, dy, t5, py;
      dx = J.$sub$n(this.Ninja0$AABB$pos.x, tile.Ninja0$Tile0$pos.x);
      t1 = J.abs$0$n(J.$div$n(tile.Ninja0$Tile0$_Ninja0$_width, 2));
      t2 = J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_width, 2));
      t3 = J.getInterceptor$n(dx);
      t4 = t3.abs$0(dx);
      if (typeof t4 !== "number")
        return H.iae(t4);
      px = t1 + t2 - t4;
      if (0 < px) {
        dy = J.$sub$n(this.Ninja0$AABB$pos.y, tile.Ninja0$Tile0$pos.y);
        t1 = J.abs$0$n(J.$div$n(tile.Ninja0$Tile0$_Ninja0$_height, 2));
        t2 = J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_height, 2));
        t4 = J.getInterceptor$n(dy);
        t5 = t4.abs$0(dy);
        if (typeof t5 !== "number")
          return H.iae(t5);
        py = t1 + t2 - t5;
        if (0 < py) {
          if (px < py) {
            if (t3.$lt(dx, 0))
              px *= -1;
            py = 0;
          } else {
            if (t4.$lt(dy, 0))
              py *= -1;
            px = 0;
          }
          return this.resolveTile$4(px, py, this, tile);
        }
      }
      return false;
    },
    resolveTile$4: function(x, y, body, tile) {
      var t1 = tile.id;
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (0 < t1)
        return this.Ninja0$AABB$aabbTileProjections.$index(0, tile.type).call$4(x, y, body, tile);
      else
        return false;
    },
    projAABB_Full$3: [function(x, y, obj) {
      var t1, t2, t3, l;
      t1 = J.getInterceptor$ns(x);
      t2 = J.getInterceptor$ns(y);
      t3 = J.$add$ns(t1.$mul(x, x), t2.$mul(y, y));
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      l = Math.sqrt(t3);
      obj.reportCollisionVsWorld$4(x, y, t1.$div(x, l), t2.$div(y, l));
      return 1;
    }, "call$3", "get$projAABB_Full", 6, 0, 616, 6, [], 7, [], 617, []],
    projAABB_Half$4: [function(x, y, obj, t) {
      var sx, sy, t1, t2, ox, oy, dp, lenN, t3, lenP;
      sx = t.get$signx();
      sy = t.get$signy();
      t1 = obj.get$pos().x;
      t2 = obj.get$xw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      ox = J.$sub$n(J.$sub$n(t1, sx * t2), t.get$pos().x);
      t2 = obj.get$pos().y;
      t1 = obj.get$yw();
      if (typeof t1 !== "number")
        return H.iae(t1);
      oy = J.$sub$n(J.$sub$n(t2, sy * t1), t.get$pos().y);
      dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
      t1 = J.getInterceptor$n(dp);
      if (t1.$lt(dp, 0)) {
        t2 = t1.$negate(dp);
        if (typeof t2 !== "number")
          return H.iae(t2);
        sx *= t2;
        t1 = t1.$negate(dp);
        if (typeof t1 !== "number")
          return H.iae(t1);
        sy *= t1;
        lenN = Math.sqrt(sx * sx + sy * sy);
        t1 = J.getInterceptor$ns(x);
        t2 = J.getInterceptor$ns(y);
        t3 = J.$add$ns(t1.$mul(x, x), t2.$mul(y, y));
        if (typeof t3 !== "number")
          H.throwExpression(P.ArgumentError$(t3));
        lenP = Math.sqrt(t3);
        if (lenP < lenN) {
          obj.reportCollisionVsWorld$4(x, y, t1.$div(x, lenP), t2.$div(y, lenP));
          return 1;
        } else {
          obj.reportCollisionVsWorld$4(sx, sy, t.get$signx(), t.get$signy());
          return 2;
        }
      }
      return 0;
    }, "call$4", "get$projAABB_Half", 8, 0, 618, 6, [], 7, [], 617, [], 380, []],
    projAABB_45Deg$4: [function(x, y, obj, t) {
      var signx, signy, t1, t2, ox, oy, sx, sy, dp, lenN, t3, lenP;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = obj.get$pos().x;
      t2 = obj.get$xw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      ox = J.$sub$n(J.$sub$n(t1, signx * t2), t.get$pos().x);
      t2 = obj.get$pos().y;
      t1 = obj.get$yw();
      if (typeof t1 !== "number")
        return H.iae(t1);
      oy = J.$sub$n(J.$sub$n(t2, signy * t1), t.get$pos().y);
      sx = t.get$sx();
      sy = t.get$sy();
      dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
      t1 = J.getInterceptor$n(dp);
      if (t1.$lt(dp, 0)) {
        t2 = t1.$negate(dp);
        if (typeof t2 !== "number")
          return H.iae(t2);
        sx *= t2;
        t1 = t1.$negate(dp);
        if (typeof t1 !== "number")
          return H.iae(t1);
        sy *= t1;
        lenN = Math.sqrt(sx * sx + sy * sy);
        t1 = J.getInterceptor$ns(x);
        t2 = J.getInterceptor$ns(y);
        t3 = J.$add$ns(t1.$mul(x, x), t2.$mul(y, y));
        if (typeof t3 !== "number")
          H.throwExpression(P.ArgumentError$(t3));
        lenP = Math.sqrt(t3);
        if (lenP < lenN) {
          obj.reportCollisionVsWorld$4(x, y, t1.$div(x, lenP), t2.$div(y, lenP));
          return 1;
        } else {
          obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
          return 2;
        }
      }
      return 0;
    }, "call$4", "get$projAABB_45Deg", 8, 0, 618, 6, [], 7, [], 617, [], 380, []],
    projAABB_22DegS$4: [function(x, y, obj, t) {
      var signx, signy, t1, t2, py, penY, t3, t4, ox, oy, sx, sy, dp, lenN, lenP, aY;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = obj.get$pos().y;
      t2 = obj.get$yw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      py = J.$sub$n(t1, signy * t2);
      penY = J.$sub$n(t.get$pos().y, py);
      t1 = J.getInterceptor$ns(penY);
      t2 = t1.$mul(penY, signy);
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (0 < t2) {
        t2 = obj.get$pos().x;
        t3 = obj.get$xw();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t3 = J.$sub$n(t2, signx * t3);
        t2 = t.get$pos().x;
        t4 = t.get$xw();
        if (typeof t4 !== "number")
          return H.iae(t4);
        ox = J.$sub$n(t3, J.$add$ns(t2, signx * t4));
        t4 = obj.get$pos().y;
        t2 = obj.get$yw();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = J.$sub$n(t4, signy * t2);
        t4 = t.get$pos().y;
        t3 = t.get$yw();
        if (typeof t3 !== "number")
          return H.iae(t3);
        oy = J.$sub$n(t2, J.$sub$n(t4, signy * t3));
        sx = t.get$sx();
        sy = t.get$sy();
        dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
        t2 = J.getInterceptor$n(dp);
        if (t2.$lt(dp, 0)) {
          t3 = t2.$negate(dp);
          if (typeof t3 !== "number")
            return H.iae(t3);
          sx *= t3;
          t2 = t2.$negate(dp);
          if (typeof t2 !== "number")
            return H.iae(t2);
          sy *= t2;
          lenN = Math.sqrt(sx * sx + sy * sy);
          t2 = J.getInterceptor$ns(x);
          t3 = J.getInterceptor$ns(y);
          t4 = J.$add$ns(t2.$mul(x, x), t3.$mul(y, y));
          if (typeof t4 !== "number")
            H.throwExpression(P.ArgumentError$(t4));
          lenP = Math.sqrt(t4);
          aY = t1.abs$0(penY);
          if (lenP < lenN)
            if (J.$lt$n(aY, lenP)) {
              obj.reportCollisionVsWorld$4(0, penY, 0, t1.$div(penY, aY));
              return 2;
            } else {
              obj.reportCollisionVsWorld$4(x, y, t2.$div(x, lenP), t3.$div(y, lenP));
              return 1;
            }
          else if (J.$lt$n(aY, lenN)) {
            obj.reportCollisionVsWorld$4(0, penY, 0, t1.$div(penY, aY));
            return 2;
          } else {
            obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
            return 2;
          }
        }
      }
      return 0;
    }, "call$4", "get$projAABB_22DegS", 8, 0, 618, 6, [], 7, [], 617, [], 380, []],
    projAABB_22DegB$4: [function(x, y, obj, t) {
      var signx, signy, t1, t2, t3, ox, oy, sx, sy, dp, lenN, lenP;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = obj.get$pos().x;
      t2 = obj.get$xw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = J.$sub$n(t1, signx * t2);
      t1 = t.get$pos().x;
      t3 = t.get$xw();
      if (typeof t3 !== "number")
        return H.iae(t3);
      ox = J.$sub$n(t2, J.$sub$n(t1, signx * t3));
      t3 = obj.get$pos().y;
      t1 = obj.get$yw();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = J.$sub$n(t3, signy * t1);
      t3 = t.get$pos().y;
      t2 = t.get$yw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      oy = J.$sub$n(t1, J.$add$ns(t3, signy * t2));
      sx = t.get$sx();
      sy = t.get$sy();
      dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
      t1 = J.getInterceptor$n(dp);
      if (t1.$lt(dp, 0)) {
        t2 = t1.$negate(dp);
        if (typeof t2 !== "number")
          return H.iae(t2);
        sx *= t2;
        t1 = t1.$negate(dp);
        if (typeof t1 !== "number")
          return H.iae(t1);
        sy *= t1;
        lenN = Math.sqrt(sx * sx + sy * sy);
        t1 = J.getInterceptor$ns(x);
        t2 = J.getInterceptor$ns(y);
        t3 = J.$add$ns(t1.$mul(x, x), t2.$mul(y, y));
        if (typeof t3 !== "number")
          H.throwExpression(P.ArgumentError$(t3));
        lenP = Math.sqrt(t3);
        if (lenP < lenN) {
          obj.reportCollisionVsWorld$4(x, y, t1.$div(x, lenP), t2.$div(y, lenP));
          return 1;
        } else {
          obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
          return 2;
        }
      }
      return 0;
    }, "call$4", "get$projAABB_22DegB", 8, 0, 618, 6, [], 7, [], 617, [], 380, []],
    projAABB_67DegS$4: [function(x, y, obj, t) {
      var signx, signy, t1, t2, px, penX, t3, t4, ox, oy, sx, sy, dp, lenN, lenP, aX;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = obj.get$pos().x;
      t2 = obj.get$xw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      px = J.$sub$n(t1, signx * t2);
      penX = J.$sub$n(t.get$pos().x, px);
      t1 = J.getInterceptor$ns(penX);
      t2 = t1.$mul(penX, signx);
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (0 < t2) {
        t2 = obj.get$pos().x;
        t3 = obj.get$xw();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t3 = J.$sub$n(t2, signx * t3);
        t2 = t.get$pos().x;
        t4 = t.get$xw();
        if (typeof t4 !== "number")
          return H.iae(t4);
        ox = J.$sub$n(t3, J.$sub$n(t2, signx * t4));
        t4 = obj.get$pos().y;
        t2 = obj.get$yw();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = J.$sub$n(t4, signy * t2);
        t4 = t.get$pos().y;
        t3 = t.get$yw();
        if (typeof t3 !== "number")
          return H.iae(t3);
        oy = J.$sub$n(t2, J.$add$ns(t4, signy * t3));
        sx = t.get$sx();
        sy = t.get$sy();
        dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
        t2 = J.getInterceptor$n(dp);
        if (t2.$lt(dp, 0)) {
          t3 = t2.$negate(dp);
          if (typeof t3 !== "number")
            return H.iae(t3);
          sx *= t3;
          t2 = t2.$negate(dp);
          if (typeof t2 !== "number")
            return H.iae(t2);
          sy *= t2;
          lenN = Math.sqrt(sx * sx + sy * sy);
          t2 = J.getInterceptor$ns(x);
          t3 = J.getInterceptor$ns(y);
          t4 = J.$add$ns(t2.$mul(x, x), t3.$mul(y, y));
          if (typeof t4 !== "number")
            H.throwExpression(P.ArgumentError$(t4));
          lenP = Math.sqrt(t4);
          aX = t1.abs$0(penX);
          if (lenP < lenN)
            if (J.$lt$n(aX, lenP)) {
              obj.reportCollisionVsWorld$4(penX, 0, t1.$div(penX, aX), 0);
              return 2;
            } else {
              obj.reportCollisionVsWorld$4(x, y, t2.$div(x, lenP), t3.$div(y, lenP));
              return 1;
            }
          else if (J.$lt$n(aX, lenN)) {
            obj.reportCollisionVsWorld$4(penX, 0, t1.$div(penX, aX), 0);
            return 2;
          } else {
            obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
            return 2;
          }
        }
      }
      return 0;
    }, "call$4", "get$projAABB_67DegS", 8, 0, 618, 6, [], 7, [], 617, [], 380, []],
    projAABB_67DegB$4: [function(x, y, obj, t) {
      var signx, signy, t1, t2, t3, ox, oy, sx, sy, dp, lenN, lenP;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = obj.get$pos().x;
      t2 = obj.get$xw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = J.$sub$n(t1, signx * t2);
      t1 = t.get$pos().x;
      t3 = t.get$xw();
      if (typeof t3 !== "number")
        return H.iae(t3);
      ox = J.$sub$n(t2, J.$add$ns(t1, signx * t3));
      t3 = obj.get$pos().y;
      t1 = obj.get$yw();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = J.$sub$n(t3, signy * t1);
      t3 = t.get$pos().y;
      t2 = t.get$yw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      oy = J.$sub$n(t1, J.$sub$n(t3, signy * t2));
      sx = t.get$sx();
      sy = t.get$sy();
      dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
      t1 = J.getInterceptor$n(dp);
      if (t1.$lt(dp, 0)) {
        t2 = t1.$negate(dp);
        if (typeof t2 !== "number")
          return H.iae(t2);
        sx *= t2;
        t1 = t1.$negate(dp);
        if (typeof t1 !== "number")
          return H.iae(t1);
        sy *= t1;
        lenN = Math.sqrt(sx * sx + sy * sy);
        t1 = J.getInterceptor$ns(x);
        t2 = J.getInterceptor$ns(y);
        t3 = J.$add$ns(t1.$mul(x, x), t2.$mul(y, y));
        if (typeof t3 !== "number")
          H.throwExpression(P.ArgumentError$(t3));
        lenP = Math.sqrt(t3);
        if (lenP < lenN) {
          obj.reportCollisionVsWorld$4(x, y, t1.$div(x, lenP), t2.$div(y, lenP));
          return 1;
        } else {
          obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
          return 2;
        }
      }
      return 0;
    }, "call$4", "get$projAABB_67DegB", 8, 0, 618, 6, [], 7, [], 617, [], 380, []],
    projAABB_Convex$4: [function(x, y, obj, t) {
      var signx, signy, t1, t2, t3, ox, oy, len, twid, pen, lenP;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = obj.get$pos().x;
      t2 = obj.get$xw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = J.$sub$n(t1, signx * t2);
      t1 = t.get$pos().x;
      t3 = t.get$xw();
      if (typeof t3 !== "number")
        return H.iae(t3);
      ox = J.$sub$n(t2, J.$sub$n(t1, signx * t3));
      t3 = obj.get$pos().y;
      t1 = obj.get$yw();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = J.$sub$n(t3, signy * t1);
      t3 = t.get$pos().y;
      t2 = t.get$yw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      oy = J.$sub$n(t1, J.$sub$n(t3, signy * t2));
      t2 = J.getInterceptor$ns(oy);
      t3 = J.$add$ns(J.$mul$ns(ox, ox), t2.$mul(oy, oy));
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      len = Math.sqrt(t3);
      twid = J.$mul$ns(t.get$xw(), 2);
      t1 = J.$add$ns(J.$mul$ns(twid, twid), 0);
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      pen = Math.sqrt(t1) - len;
      if (typeof ox !== "number")
        return H.iae(ox);
      if (!(signx * ox < 0)) {
        if (typeof oy !== "number")
          return H.iae(oy);
        t1 = signy * oy < 0;
      } else
        t1 = true;
      if (t1) {
        t1 = J.getInterceptor$ns(x);
        t2 = J.getInterceptor$ns(y);
        t3 = J.$add$ns(t1.$mul(x, x), t2.$mul(y, y));
        if (typeof t3 !== "number")
          H.throwExpression(P.ArgumentError$(t3));
        lenP = Math.sqrt(t3);
        obj.reportCollisionVsWorld$4(x, y, t1.$div(x, lenP), t2.$div(y, lenP));
        return 1;
      } else if (0 < pen) {
        ox /= len;
        oy = t2.$div(oy, len);
        obj.reportCollisionVsWorld$4(ox * pen, J.$mul$ns(oy, pen), ox, oy);
        return 2;
      }
      return 0;
    }, "call$4", "get$projAABB_Convex", 8, 0, 618, 6, [], 7, [], 617, [], 380, []],
    projAABB_Concave$4: [function(x, y, obj, t) {
      var signx, signy, t1, t2, t3, ox, oy, twid, rad, len, pen, t4, t5, lenP;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = t.get$pos().x;
      t2 = t.get$xw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = J.$add$ns(t1, signx * t2);
      t1 = obj.get$pos().x;
      t3 = obj.get$xw();
      if (typeof t3 !== "number")
        return H.iae(t3);
      ox = J.$sub$n(t2, J.$sub$n(t1, signx * t3));
      t3 = t.get$pos().y;
      t1 = t.get$yw();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = J.$add$ns(t3, signy * t1);
      t3 = obj.get$pos().y;
      t2 = obj.get$yw();
      if (typeof t2 !== "number")
        return H.iae(t2);
      oy = J.$sub$n(t1, J.$sub$n(t3, signy * t2));
      twid = J.$mul$ns(t.get$xw(), 2);
      t2 = J.$add$ns(J.$mul$ns(twid, twid), 0);
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      rad = Math.sqrt(t2);
      t1 = J.getInterceptor$ns(ox);
      t2 = J.getInterceptor$ns(oy);
      t3 = J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy));
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      len = Math.sqrt(t3);
      pen = len - rad;
      if (0 < pen) {
        t3 = J.getInterceptor$ns(x);
        t4 = J.getInterceptor$ns(y);
        t5 = J.$add$ns(t3.$mul(x, x), t4.$mul(y, y));
        if (typeof t5 !== "number")
          H.throwExpression(P.ArgumentError$(t5));
        lenP = Math.sqrt(t5);
        if (lenP < pen) {
          obj.reportCollisionVsWorld$4(x, y, t3.$div(x, lenP), t4.$div(y, lenP));
          return 1;
        } else {
          ox = t1.$div(ox, len);
          oy = t2.$div(oy, len);
          obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
          return 2;
        }
      }
      return 0;
    }, "call$4", "get$projAABB_Concave", 8, 0, 618, 6, [], 7, [], 617, [], 380, []],
    destroy$0: function() {
      this.Ninja0$AABB$body = null;
      this.Ninja0$AABB$system = null;
    },
    render$5: [function(context, xOffset, yOffset, color, filled) {
      var left, $top, t1;
      left = J.$sub$n(J.$sub$n(this.Ninja0$AABB$pos.x, J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_width, 2))), xOffset);
      $top = J.$sub$n(J.$sub$n(this.Ninja0$AABB$pos.y, J.abs$0$n(J.$div$n(this.Ninja0$AABB$_Ninja0$_height, 2))), yOffset);
      t1 = J.getInterceptor$x(context);
      if (filled === true) {
        t1.set$fillStyle(context, color);
        t1.fillRect$4(context, left, $top, this.Ninja0$AABB$_Ninja0$_width, this.Ninja0$AABB$_Ninja0$_height);
      } else {
        t1.set$strokeStyle(context, color);
        t1.strokeRect$4(context, left, $top, this.Ninja0$AABB$_Ninja0$_width, this.Ninja0$AABB$_Ninja0$_height);
      }
    }, "call$5", "get$render", 10, 0, 619, 104, [], 293, [], 294, [], 114, [], 608, []],
    AABB$5: function(body, x, y, width, height) {
      var t1;
      this.Ninja0$AABB$body = body;
      this.Ninja0$AABB$system = body.system;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.Ninja0$AABB$pos = t1;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.Ninja0$AABB$oldpos = t1;
      this.Ninja0$AABB$_Ninja0$_width = width;
      this.Ninja0$AABB$_Ninja0$_height = height;
      this.Ninja0$AABB$oH = 0;
      this.Ninja0$AABB$oV = 0;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.Ninja0$AABB$velocity = t1;
      t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      this.Ninja0$AABB$aabbTileProjections = t1;
      t1.$indexSet(0, 1, this.get$projAABB_Full());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 2, this.get$projAABB_45Deg());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 6, this.get$projAABB_Concave());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 10, this.get$projAABB_Convex());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 14, this.get$projAABB_22DegS());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 18, this.get$projAABB_22DegB());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 22, this.get$projAABB_67DegS());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 26, this.get$projAABB_67DegB());
      this.Ninja0$AABB$aabbTileProjections.$indexSet(0, 30, this.get$projAABB_Half());
    },
    static: {"^": "AABB_COL_NONE,AABB_COL_AXIS,AABB_COL_OTHER"}
  },
  Body2: {
    "^": "Body0;sprite@,game:Ninja0$Body2$game@-598,type:Ninja0$Body2$type*-599,system,aabb<,tile<,circle@,shape,drag:Ninja0$Body2$drag@-601,friction<,gravityScale@,bounce:Ninja0$Body2$bounce@-601,velocity:Ninja0$Body2$velocity@-600,facing,immovable:Ninja0$Body2$immovable@-602,collideWorldBounds:Ninja0$Body2$collideWorldBounds@-602,checkCollision@,touching:Ninja0$Body2$touching@-603,wasTouching,maxSpeed,game-598,position-600,tilePadding-600,Phaser$Body0$width-601,Phaser$Body0$height-601,velocity-600,acceleration-600,maxVelocity-600,collideWorldBounds-602,bounce-32,type-599,angularVelocity-601,gravity-600,drag-32,angularDrag-601,immovable-602,Phaser$Body0$x-601,Phaser$Body0$y-601,speed-601,blocked-603,angle-601,moves-602,phase-599,_reset-602,safeRemove-602,touching-603,Phaser$Rectangle1$x-601,Phaser$Rectangle1$y-601,Phaser$Rectangle1$width-601,Phaser$Rectangle1$height-601,x-601,y-601,width-601,height-601",
    sprite$3: function(arg0, arg1, arg2) {
      return this.sprite.call$3(arg0, arg1, arg2);
    },
    sprite$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.sprite.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    sprite$4: function(arg0, arg1, arg2, arg3) {
      return this.sprite.call$4(arg0, arg1, arg2, arg3);
    },
    circle$4: function(arg0, arg1, arg2, arg3) {
      return this.circle.call$4(arg0, arg1, arg2, arg3);
    },
    preUpdate$0: [function() {
      this.wasTouching.none = this.Ninja0$Body2$touching.get$none();
      this.wasTouching.up = this.Ninja0$Body2$touching.get$up();
      this.wasTouching.down = this.Ninja0$Body2$touching.get$down();
      this.wasTouching.left = J.get$left$x(this.Ninja0$Body2$touching);
      this.wasTouching.right = J.get$right$x(this.Ninja0$Body2$touching);
      this.Ninja0$Body2$touching.set$none(true);
      this.Ninja0$Body2$touching.set$up(false);
      this.Ninja0$Body2$touching.set$down(false);
      J.set$left$x(this.Ninja0$Body2$touching, false);
      J.set$right$x(this.Ninja0$Body2$touching, false);
      this.shape.integrate$0();
      if (this.Ninja0$Body2$collideWorldBounds === true)
        this.shape.collideWorldBounds$0();
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    setSize$4: [function(width, height, offsetX, offsetY) {
      throw H.wrapException(P.Exception_Exception("Do not use it!"));
    }, function(width, height) {
      return this.setSize$4(width, height, null, null);
    }, "setSize$2", function(width, height, offsetX) {
      return this.setSize$4(width, height, offsetX, null);
    }, "setSize$3", "call$4", "call$2", "call$3", "get$setSize", 4, 4, 612, 32, 32, 10, [], 11, [], 613, [], 614, [], "setSize"],
    onFloor$0: [function() {
      throw H.wrapException(P.Exception_Exception("Do not use it!"));
    }, "call$0", "get$onFloor", 0, 0, 13, "onFloor"],
    removeFromWorld$0: [function() {
      throw H.wrapException(P.Exception_Exception("Do not use it!"));
    }, "call$0", "get$removeFromWorld", 0, 0, 13, "removeFromWorld"],
    addToWorld$0: [function() {
      throw H.wrapException(P.Exception_Exception("Do not use it!"));
    }, "call$0", "get$addToWorld", 0, 0, 13, "addToWorld"],
    updateBounds$0: [function() {
      throw H.wrapException(P.Exception_Exception("Do not use it!"));
    }, "call$0", "get$updateBounds", 0, 0, 13, "updateBounds"],
    postUpdate$0: [function() {
      var t1, t2, t3;
      t1 = this.sprite;
      if (t1 != null) {
        t1 = J.$eq(J.get$type$x(t1), 5);
        t2 = this.sprite;
        t3 = this.shape;
        if (t1) {
          J.set$x$x(t2, J.$sub$n(t3.get$pos().x, this.shape.get$xw()));
          J.set$y$x(this.sprite, J.$sub$n(this.shape.get$pos().y, this.shape.get$yw()));
        } else {
          J.set$x$x(t2, t3.get$pos().x);
          J.set$y$x(this.sprite, this.shape.get$pos().y);
        }
      }
      if (J.$lt$n(J.get$x$x(this.Ninja0$Body2$velocity), 0))
        this.facing = 1;
      else if (J.$gt$n(J.get$x$x(this.Ninja0$Body2$velocity), 0))
        this.facing = 2;
      if (J.$lt$n(J.get$y$x(this.Ninja0$Body2$velocity), 0))
        this.facing = 3;
      else if (J.$gt$n(J.get$y$x(this.Ninja0$Body2$velocity), 0))
        this.facing = 4;
    }, "call$0", "get$postUpdate", 0, 0, 13, "postUpdate"],
    moveTo$2: function(_, speed, angle) {
      var magnitude, t1, t2, t3, t4;
      magnitude = J.$mul$ns(speed, this.Ninja0$Body2$game.get$time().get$physicsElapsed());
      angle = J.$mul$ns(angle, 0.017453292519943295);
      t1 = this.shape.get$pos();
      t2 = this.shape.get$oldpos().x;
      t3 = typeof angle !== "number";
      if (t3)
        H.throwExpression(P.ArgumentError$(angle));
      t4 = J.getInterceptor$ns(magnitude);
      t1.x = J.$add$ns(t2, t4.$mul(magnitude, Math.cos(angle)));
      t2 = this.shape.get$pos();
      t1 = this.shape.get$oldpos().y;
      if (t3)
        H.throwExpression(P.ArgumentError$(angle));
      t2.y = J.$add$ns(t1, t4.$mul(magnitude, Math.sin(angle)));
    },
    moveLeft$1: [function(speed) {
      var fx, t1, t2, t3;
      fx = J.$mul$ns(J.$negate$n(speed), this.Ninja0$Body2$game.get$time().get$physicsElapsed());
      t1 = this.shape.get$pos();
      t2 = this.shape.get$oldpos().x;
      t3 = this.maxSpeed;
      t1.x = J.$add$ns(t2, P.min(t3, P.max(-t3, J.$add$ns(J.$sub$n(this.shape.get$pos().x, this.shape.get$oldpos().x), fx))));
    }, "call$1", "get$moveLeft", 2, 0, 605, 611, [], "moveLeft"],
    moveRight$1: [function(speed) {
      var fx, t1, t2, t3;
      fx = J.$mul$ns(speed, this.Ninja0$Body2$game.get$time().get$physicsElapsed());
      t1 = this.shape.get$pos();
      t2 = this.shape.get$oldpos().x;
      t3 = this.maxSpeed;
      t1.x = J.$add$ns(t2, P.min(t3, P.max(-t3, J.$add$ns(J.$sub$n(this.shape.get$pos().x, this.shape.get$oldpos().x), fx))));
    }, "call$1", "get$moveRight", 2, 0, 605, 611, [], "moveRight"],
    moveUp$1: [function(speed) {
      var fx, t1, t2, t3;
      fx = J.$mul$ns(J.$negate$n(speed), this.Ninja0$Body2$game.get$time().get$physicsElapsed());
      t1 = this.shape.get$pos();
      t2 = this.shape.get$oldpos().y;
      t3 = this.maxSpeed;
      t1.y = J.$add$ns(t2, P.min(t3, P.max(-t3, J.$add$ns(J.$sub$n(this.shape.get$pos().y, this.shape.get$oldpos().y), fx))));
    }, "call$1", "get$moveUp", 2, 0, 605, 611, [], "moveUp"],
    moveDown$1: [function(speed) {
      var fx, t1, t2, t3;
      fx = J.$mul$ns(speed, this.Ninja0$Body2$game.get$time().get$physicsElapsed());
      t1 = this.shape.get$pos();
      t2 = this.shape.get$oldpos().y;
      t3 = this.maxSpeed;
      t1.y = J.$add$ns(t2, P.min(t3, P.max(-t3, J.$add$ns(J.$sub$n(this.shape.get$pos().y, this.shape.get$oldpos().y), fx))));
    }, "call$1", "get$moveDown", 2, 0, 605, 611, [], "moveDown"],
    reset$4: [function(_, x, y, a1, a2) {
      var t1, t2;
      this.Ninja0$Body2$velocity.set$1(0);
      this.shape.get$pos().x = J.get$x$x(this.sprite);
      this.shape.get$pos().y = J.get$y$x(this.sprite);
      t1 = this.shape.get$oldpos();
      t2 = this.shape.get$pos();
      t1.setTo$2(t2.x, t2.y);
    }, function($receiver, x, y, a1) {
      return this.reset$4($receiver, x, y, a1, null);
    }, "reset$3", function($receiver, x, y) {
      return this.reset$4($receiver, x, y, null, null);
    }, "reset$2", "call$4", "call$3", "call$2", "get$reset", 4, 4, 615, 32, 32, 6, [], 7, [], 402, [], 403, [], "reset"],
    renderBodyInfo$1: [function(debug) {
      var t1, t2, t3, t4;
      t1 = "x: " + J.toStringAsFixed$1$n(this.shape.get$pos().x, 2);
      t2 = "y: " + J.toStringAsFixed$1$n(this.shape.get$pos().y, 2);
      t3 = this.shape;
      t3 = C.JSString_methods.$add("width: ", J.toString$0(t3.get$width(t3)));
      t4 = this.shape;
      debug.line$1([t1, t2, t3, C.JSString_methods.$add("height: ", J.toString$0(t4.get$height(t4)))]);
      debug.line$1(["velocity x: " + J.toStringAsFixed$1$n(J.get$x$x(this.Ninja0$Body2$velocity), 2), "y: " + J.toStringAsFixed$1$n(J.get$y$x(this.Ninja0$Body2$velocity), 2), "deltaX: " + J.toStringAsFixed$1$n(this.shape.get$pos().x, 2), "deltaY: " + J.toStringAsFixed$1$n(this.shape.get$pos().y, 2)]);
      t4 = "acceleration x: " + J.toStringAsFixed$1$n(J.get$x$x(this.acceleration), 2);
      t3 = "y: " + J.toStringAsFixed$1$n(J.get$y$x(this.acceleration), 2);
      t2 = J.$add$ns(J.$mul$ns(this.shape.get$velocity().x, this.shape.get$velocity().x), J.$mul$ns(this.shape.get$velocity().y, this.shape.get$velocity().y));
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      debug.line$1([t4, t3, "speed: " + C.JSDouble_methods.toStringAsFixed$1(Math.sqrt(t2), 2), "angle: " + C.JSDouble_methods.toStringAsFixed$1(this.get$angle(), 2)]);
      debug.line$1([C.JSString_methods.$add("gravity x: ", J.toString$0(J.get$x$x(this.gravity))), C.JSString_methods.$add("y: ", J.toString$0(J.get$y$x(this.gravity))), "bounce: " + J.toStringAsFixed$1$n(this.Ninja0$Body2$bounce, 2)]);
      debug.line$1([C.JSString_methods.$add("touching left: ", J.toString$0(J.get$left$x(this.Ninja0$Body2$touching))), C.JSString_methods.$add("right: ", J.toString$0(J.get$right$x(this.Ninja0$Body2$touching))), C.JSString_methods.$add("up: ", J.toString$0(this.Ninja0$Body2$touching.get$up())), C.JSString_methods.$add("down: ", J.toString$0(this.Ninja0$Body2$touching.get$down()))]);
      debug.line$1([C.JSString_methods.$add("blocked left: ", J.toString$0(J.get$left$x(this.blocked))), C.JSString_methods.$add("right: ", J.toString$0(J.get$right$x(this.blocked))), C.JSString_methods.$add("up: ", J.toString$0(this.blocked.get$up())), C.JSString_methods.$add("down: ", J.toString$0(this.blocked.get$down()))]);
    }, "call$1", "get$renderBodyInfo", 2, 0, 609, 610, [], "renderBodyInfo"],
    deltaAbsX$0: function() {
      return J.$gt$n(this.deltaX$0(0), 0) ? this.deltaX$0(0) : J.$negate$n(this.deltaX$0(0));
    },
    deltaAbsY$0: function() {
      return J.$gt$n(this.deltaY$0(0), 0) ? this.deltaY$0(0) : J.$negate$n(this.deltaY$0(0));
    },
    deltaX$0: [function(_) {
      return J.$sub$n(this.shape.get$pos().x, this.shape.get$oldpos().x);
    }, "call$0", "get$deltaX", 0, 0, 13],
    deltaY$0: [function(_) {
      return J.$sub$n(this.shape.get$pos().y, this.shape.get$oldpos().y);
    }, "call$0", "get$deltaY", 0, 0, 13],
    destroy$0: [function() {
      this.sprite = null;
      this.system = null;
      this.aabb = null;
      this.tile = null;
      this.circle = null;
      this.shape.destroy$0();
      this.shape = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    get$x: [function(_) {
      return this.shape.get$pos().x;
    }, null, null, 1, 0, 604, "x"],
    set$x: [function(_, value) {
      this.shape.get$pos().x = value;
    }, null, null, 3, 0, 605, 100, [], "x"],
    get$y: [function(_) {
      return this.shape.get$pos().y;
    }, null, null, 1, 0, 604, "y"],
    set$y: [function(_, value) {
      this.shape.get$pos().y = value;
    }, null, null, 3, 0, 605, 100, [], "y"],
    get$width: [function(_) {
      var t1 = this.shape;
      return t1.get$width(t1);
    }, null, null, 1, 0, 604, "width"],
    get$height: [function(_) {
      var t1 = this.shape;
      return t1.get$height(t1);
    }, null, null, 1, 0, 604, "height"],
    get$bottom: [function(_) {
      return J.$add$ns(this.shape.get$pos().y, this.shape.get$yw());
    }, null, null, 1, 0, 604, "bottom"],
    get$right: [function(_) {
      return J.$add$ns(this.shape.get$pos().x, this.shape.get$xw());
    }, null, null, 1, 0, 604, "right"],
    get$speed: [function() {
      var t1 = J.$add$ns(J.$mul$ns(this.shape.get$velocity().x, this.shape.get$velocity().x), J.$mul$ns(this.shape.get$velocity().y, this.shape.get$velocity().y));
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      return Math.sqrt(t1);
    }, null, null, 1, 0, 604, "speed"],
    get$angle: [function() {
      var t1, t2;
      t1 = this.shape.get$velocity().y;
      t2 = this.shape.get$velocity().x;
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      return Math.atan2(t1, t2);
    }, null, null, 1, 0, 604, "angle"],
    angle$0: function() {
      return this.get$angle().call$0();
    },
    angle$2: function(arg0, arg1) {
      return this.get$angle().call$2(arg0, arg1);
    },
    render$3: [function(context, color, filled) {
      if (filled == null)
        filled = true;
      if (this.aabb != null || this.circle != null)
        this.shape.render$5(context, J.get$x$x(this.Ninja0$Body2$game.get$camera()), J.get$y$x(this.Ninja0$Body2$game.get$camera()), color, filled);
    }, function(context) {
      return this.render$3(context, "rgba(0,255,0,0.4)", true);
    }, "render$1", function(context, color) {
      return this.render$3(context, color, true);
    }, "render$2", "call$3", "call$1", "call$2", "get$render", 2, 4, 620, 607, 39, 104, [], 114, [], 608, [], "render"],
    Body$9: function(system, sprite, type, id, radius, x, y, width, height) {
      var t1;
      this.sprite = sprite;
      this.Ninja0$Body2$game = system.game;
      this.Ninja0$Body2$type = 2;
      this.system = system;
      this.aabb = null;
      this.tile = null;
      this.circle = null;
      this.shape = null;
      this.Ninja0$Body2$drag = 1;
      this.friction = 0.05;
      this.gravityScale = 1;
      this.Ninja0$Body2$bounce = 0.3;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.Ninja0$Body2$velocity = t1;
      this.facing = 0;
      this.Ninja0$Body2$immovable = false;
      this.Ninja0$Body2$collideWorldBounds = true;
      this.checkCollision = R.CollisionInfo$(true, true, true, true);
      this.Ninja0$Body2$touching = R.CollisionInfo$(false, false, false, false);
      this.wasTouching = R.CollisionInfo$(false, false, false, false);
      this.maxSpeed = 8;
      if (sprite != null) {
        t1 = J.getInterceptor$x(sprite);
        x = t1.get$x(sprite);
        y = t1.get$y(sprite);
        width = t1.get$width(sprite);
        height = t1.get$height(sprite);
        if (J.$eq(J.get$x$x(sprite.get$anchor()), 0))
          x = J.$add$ns(x, J.$mul$ns(t1.get$width(sprite), 0.5));
        if (J.$eq(J.get$y$x(sprite.get$anchor()), 0))
          y = J.$add$ns(y, J.$mul$ns(t1.get$height(sprite), 0.5));
      }
      t1 = J.getInterceptor(type);
      if (t1.$eq(type, 1)) {
        t1 = new E.AABB(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.AABB$5(this, x, y, width, height);
        this.aabb = t1;
        this.shape = t1;
      } else if (t1.$eq(type, 2)) {
        t1 = new E.Circle1(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Circle$4(this, x, y, radius);
        this.circle = t1;
        this.shape = t1;
      } else if (t1.$eq(type, 3)) {
        t1 = new E.Tile0(null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Tile$6(this, x, y, width, height, id);
        this.tile = t1;
        this.shape = t1;
      }
    },
    $isBody2: true,
    static: {Body$0: function(system, sprite, type, id, radius, x, y, width, height) {
        var t1 = new E.Body2(null, null, 2, null, null, null, null, null, null, null, null, null, null, 0, null, true, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, 0, 0, 0, 0);
        t1.Body$9(system, sprite, type, id, radius, x, y, width, height);
        return t1;
      }}
  },
  "+Body": 0,
  Circle1: {
    "^": "Shape0;body:Ninja0$Circle1$body*,Ninja0$Circle1$system,pos:Ninja0$Circle1$pos<,oldpos:Ninja0$Circle1$oldpos<,_Ninja0$_width:Ninja0$Circle1$_Ninja0$_width<,_Ninja0$_height:Ninja0$Circle1$_Ninja0$_height<,Ninja0$Circle1$oH,Ninja0$Circle1$oV,velocity:Ninja0$Circle1$velocity@,circleTileProjections,radius@,body,system,pos,oldpos,_Ninja0$_width,_Ninja0$_height,oH,oV,velocity,aabbTileProjections",
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.Ninja0$Circle1$body.call$3(arg0, arg1, arg2);
    },
    get$xw: function() {
      return this.radius;
    },
    get$yw: function() {
      return this.radius;
    },
    get$width: function(_) {
      return this.Ninja0$Circle1$_Ninja0$_width;
    },
    get$height: function(_) {
      return this.Ninja0$Circle1$_Ninja0$_height;
    },
    integrate$0: function() {
      var t1, px, py;
      t1 = this.Ninja0$Circle1$pos;
      px = t1.x;
      py = t1.y;
      t1.x = J.$add$ns(px, J.$sub$n(J.$mul$ns(this.Ninja0$Circle1$body.get$drag(), this.Ninja0$Circle1$pos.x), J.$mul$ns(this.Ninja0$Circle1$body.get$drag(), this.Ninja0$Circle1$oldpos.x)));
      t1 = this.Ninja0$Circle1$pos;
      t1.y = J.$add$ns(t1.y, J.$add$ns(J.$sub$n(J.$mul$ns(this.Ninja0$Circle1$body.get$drag(), this.Ninja0$Circle1$pos.y), J.$mul$ns(this.Ninja0$Circle1$body.get$drag(), this.Ninja0$Circle1$oldpos.y)), J.$mul$ns(this.Ninja0$Circle1$system.gravity, this.Ninja0$Circle1$body.get$gravityScale())));
      this.Ninja0$Circle1$velocity.set$2(J.$sub$n(this.Ninja0$Circle1$pos.x, px), J.$sub$n(this.Ninja0$Circle1$pos.y, py));
      this.Ninja0$Circle1$oldpos.set$2(px, py);
    },
    reportCollisionVsWorld$4: function(px, py, dx, dy) {
      var p, o, vx, vy, t1, t2, dp, t3, nx, ny, tx, ty, fx, fy, b, bx, by;
      p = this.Ninja0$Circle1$pos;
      o = this.Ninja0$Circle1$oldpos;
      vx = J.$sub$n(p.x, o.x);
      vy = J.$sub$n(p.y, o.y);
      t1 = J.getInterceptor$ns(vx);
      t2 = J.getInterceptor$ns(vy);
      dp = J.$add$ns(t1.$mul(vx, dx), t2.$mul(vy, dy));
      t3 = J.getInterceptor$ns(dp);
      nx = t3.$mul(dp, dx);
      ny = t3.$mul(dp, dy);
      tx = t1.$sub(vx, nx);
      ty = t2.$sub(vy, ny);
      if (t3.$lt(dp, 0)) {
        fx = J.$mul$ns(tx, this.Ninja0$Circle1$body.get$friction());
        fy = J.$mul$ns(ty, this.Ninja0$Circle1$body.get$friction());
        t1 = this.Ninja0$Circle1$body.get$bounce();
        if (typeof t1 !== "number")
          return H.iae(t1);
        b = 1 + t1;
        bx = J.$mul$ns(nx, b);
        by = J.$mul$ns(ny, b);
        t1 = J.getInterceptor(dx);
        if (t1.$eq(dx, 1))
          J.set$left$x(this.Ninja0$Circle1$body.get$touching(), true);
        else if (t1.$eq(dx, -1))
          J.set$right$x(this.Ninja0$Circle1$body.get$touching(), true);
        t1 = J.getInterceptor(dy);
        if (t1.$eq(dy, 1))
          this.Ninja0$Circle1$body.get$touching().set$up(true);
        else if (t1.$eq(dy, -1))
          this.Ninja0$Circle1$body.get$touching().set$down(true);
      } else {
        bx = 0;
        by = 0;
        fx = 0;
        fy = 0;
      }
      p.x = J.$add$ns(p.x, px);
      p.y = J.$add$ns(p.y, py);
      o.x = J.$add$ns(o.x, J.$add$ns(J.$add$ns(px, bx), fx));
      o.y = J.$add$ns(o.y, J.$add$ns(J.$add$ns(py, by), fy));
    },
    collideWorldBounds$0: [function() {
      var dx, dy;
      dx = J.$sub$n(J.get$x$x(this.Ninja0$Circle1$system.bounds), J.$sub$n(this.Ninja0$Circle1$pos.x, this.radius));
      if (typeof dx !== "number")
        return H.iae(dx);
      if (0 < dx)
        this.reportCollisionVsWorld$4(dx, 0, 1, 0);
      else {
        dx = J.$sub$n(J.$add$ns(this.Ninja0$Circle1$pos.x, this.radius), J.get$right$x(this.Ninja0$Circle1$system.bounds));
        if (typeof dx !== "number")
          return H.iae(dx);
        if (0 < dx)
          this.reportCollisionVsWorld$4(-dx, 0, -1, 0);
      }
      dy = J.$sub$n(J.get$y$x(this.Ninja0$Circle1$system.bounds), J.$sub$n(this.Ninja0$Circle1$pos.y, this.radius));
      if (typeof dy !== "number")
        return H.iae(dy);
      if (0 < dy)
        this.reportCollisionVsWorld$4(0, dy, 0, 1);
      else {
        dy = J.$sub$n(J.$add$ns(this.Ninja0$Circle1$pos.y, this.radius), J.get$bottom$x(this.Ninja0$Circle1$system.bounds));
        if (typeof dy !== "number")
          return H.iae(dy);
        if (0 < dy)
          this.reportCollisionVsWorld$4(0, -dy, 0, -1);
      }
    }, "call$0", "get$collideWorldBounds", 0, 0, 13],
    collideCircleVsTile$1: function(tile) {
      var pos, r, t1, tx, ty, txw, tyw, dx, t2, px, dy, t3, py;
      pos = this.Ninja0$Circle1$pos;
      r = this.radius;
      t1 = tile.Ninja0$Tile0$pos;
      tx = t1.x;
      ty = t1.y;
      txw = J.abs$0$n(J.$div$n(tile.Ninja0$Tile0$_Ninja0$_width, 2));
      tyw = J.abs$0$n(J.$div$n(tile.Ninja0$Tile0$_Ninja0$_height, 2));
      dx = J.$sub$n(pos.x, tx);
      if (typeof r !== "number")
        return H.iae(r);
      t1 = J.getInterceptor$n(dx);
      t2 = t1.abs$0(dx);
      if (typeof t2 !== "number")
        return H.iae(t2);
      px = txw + r - t2;
      if (0 < px) {
        dy = J.$sub$n(pos.y, ty);
        t2 = J.getInterceptor$n(dy);
        t3 = t2.abs$0(dy);
        if (typeof t3 !== "number")
          return H.iae(t3);
        py = tyw + r - t3;
        if (0 < py) {
          this.Ninja0$Circle1$oH = 0;
          this.Ninja0$Circle1$oV = 0;
          if (t1.$lt(dx, -txw))
            this.Ninja0$Circle1$oH = -1;
          else {
            if (typeof dx !== "number")
              return H.iae(dx);
            if (txw < dx)
              this.Ninja0$Circle1$oH = 1;
          }
          if (t2.$lt(dy, -tyw))
            this.Ninja0$Circle1$oV = -1;
          else {
            if (typeof dy !== "number")
              return H.iae(dy);
            if (tyw < dy)
              this.Ninja0$Circle1$oV = 1;
          }
          return this.resolveCircleTile$6(px, py, this.Ninja0$Circle1$oH, this.Ninja0$Circle1$oV, this, tile);
        }
      }
    },
    resolveCircleTile$6: function(x, y, oH, oV, obj, t) {
      var t1 = t.id;
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (0 < t1)
        return this.circleTileProjections.$index(0, t.type).call$6(x, y, oH, oV, obj, t);
      else
        return false;
    },
    projCircle_Full$6: [function(x, y, oH, oV, obj, t) {
      var t1, t2, vx, vy, dx, dy, t3, t4, t5, len, pen;
      t1 = J.getInterceptor(oH);
      if (t1.$eq(oH, 0))
        if (J.$eq(oV, 0)) {
          t1 = J.getInterceptor$n(x);
          if (t1.$lt(x, y))
            if (J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0)) {
              obj.reportCollisionVsWorld$4(t1.$negate(x), 0, -1, 0);
              return 1;
            } else {
              obj.reportCollisionVsWorld$4(x, 0, 1, 0);
              return 1;
            }
          else if (J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0)) {
            obj.reportCollisionVsWorld$4(0, J.$negate$n(y), 0, -1);
            return 1;
          } else {
            obj.reportCollisionVsWorld$4(0, y, 0, 1);
            return 1;
          }
        } else {
          obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
          return 1;
        }
      else {
        t2 = J.getInterceptor(oV);
        if (t2.$eq(oV, 0)) {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        } else {
          vx = J.$add$ns(t.get$pos().x, t1.$mul(oH, t.get$xw()));
          vy = J.$add$ns(t.get$pos().y, t2.$mul(oV, t.get$yw()));
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t3 = J.getInterceptor$ns(dx);
          t4 = J.getInterceptor$ns(dy);
          t5 = J.$add$ns(t3.$mul(dx, dx), t4.$mul(dy, dy));
          if (typeof t5 !== "number")
            H.throwExpression(P.ArgumentError$(t5));
          len = Math.sqrt(t5);
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = t1.$div(oH, 1.4142135623730951);
              dy = t2.$div(oV, 1.4142135623730951);
            } else {
              dx = t3.$div(dx, len);
              dy = t4.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_Full", 12, 0, 621, 6, [], 7, [], 622, [], 623, [], 617, [], 380, []],
    projCircle_45Deg$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, sx, sy, t1, t2, ox, oy, dp, x0, lenP, y0, t3, len, pen, vx, vy, dx, dy;
      signx = t.get$signx();
      signy = t.get$signy();
      if (J.$eq(oH, 0))
        if (J.$eq(oV, 0)) {
          sx = t.get$sx();
          sy = t.get$sy();
          t1 = obj.get$pos().x;
          t2 = obj.get$radius();
          if (typeof t2 !== "number")
            return H.iae(t2);
          ox = J.$sub$n(J.$sub$n(t1, sx * t2), t.get$pos().x);
          t2 = obj.get$pos().y;
          t1 = obj.get$radius();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(J.$sub$n(t2, sy * t1), t.get$pos().y);
          dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
          t1 = J.getInterceptor$n(dp);
          if (t1.$lt(dp, 0)) {
            t2 = t1.$negate(dp);
            if (typeof t2 !== "number")
              return H.iae(t2);
            sx *= t2;
            t1 = t1.$negate(dp);
            if (typeof t1 !== "number")
              return H.iae(t1);
            sy *= t1;
            t1 = J.getInterceptor$n(x);
            if (t1.$lt(x, y)) {
              x0 = J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0) ? t1.$mul(x, -1) : x;
              lenP = x;
              x = x0;
              y = 0;
            } else {
              y0 = J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0) ? J.$mul$ns(y, -1) : y;
              lenP = y;
              y = y0;
              x = 0;
            }
            if (J.$lt$n(lenP, Math.sqrt(sx * sx + sy * sy))) {
              obj.reportCollisionVsWorld$4(x, y, J.$div$n(x, lenP), J.$div$n(y, lenP));
              return 1;
            } else {
              obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
              return 2;
            }
          }
        } else {
          if (typeof oV !== "number")
            return H.iae(oV);
          if (signy * oV < 0) {
            obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
            return 1;
          } else {
            sx = t.get$sx();
            sy = t.get$sy();
            t1 = obj.get$pos().x;
            t2 = t.get$pos().x;
            t3 = t.get$xw();
            if (typeof t3 !== "number")
              return H.iae(t3);
            ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
            t3 = obj.get$pos().y;
            t2 = t.get$pos().y;
            t1 = t.get$yw();
            if (typeof t1 !== "number")
              return H.iae(t1);
            oy = J.$sub$n(t3, J.$add$ns(t2, oV * t1));
            t1 = J.getInterceptor$ns(ox);
            t2 = J.getInterceptor$ns(oy);
            t3 = J.$mul$ns(J.$mul$ns(J.$add$ns(t1.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (0 < t3) {
              t3 = J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy));
              if (typeof t3 !== "number")
                H.throwExpression(P.ArgumentError$(t3));
              len = Math.sqrt(t3);
              pen = J.$sub$n(obj.get$radius(), len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                ox = t1.$div(ox, len);
                oy = t2.$div(oy, len);
                obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
                return 2;
              }
            } else {
              dp = J.$add$ns(t1.$mul(ox, sx), t2.$mul(oy, sy));
              pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                obj.reportCollisionVsWorld$4(sx * pen, sy * pen, sx, sy);
                return 2;
              }
            }
          }
        }
      else if (J.$eq(oV, 0)) {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (signx * oH < 0) {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        } else {
          sx = t.get$sx();
          sy = t.get$sy();
          t1 = obj.get$pos().x;
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$add$ns(t2, oH * t3));
          t3 = obj.get$pos().y;
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
          t1 = J.getInterceptor$ns(ox);
          t2 = J.getInterceptor$ns(oy);
          if (J.$lt$n(J.$mul$ns(J.$mul$ns(J.$add$ns(t1.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy), 0)) {
            t3 = J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy));
            if (typeof t3 !== "number")
              H.throwExpression(P.ArgumentError$(t3));
            len = Math.sqrt(t3);
            pen = J.$sub$n(obj.get$radius(), len);
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              ox = t1.$div(ox, len);
              oy = t2.$div(oy, len);
              obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
              return 2;
            }
          } else {
            dp = J.$add$ns(t1.$mul(ox, sx), t2.$mul(oy, sy));
            pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              obj.reportCollisionVsWorld$4(sx * pen, sy * pen, sx, sy);
              return 2;
            }
          }
        }
      } else {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (typeof oV !== "number")
          return H.iae(oV);
        if (0 < signx * oH + signy * oV)
          return 0;
        else {
          t1 = t.get$pos().x;
          t2 = t.get$xw();
          if (typeof t2 !== "number")
            return H.iae(t2);
          vx = J.$add$ns(t1, oH * t2);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          vy = J.$add$ns(t2, oV * t1);
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t1 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          t3 = J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy));
          if (typeof t3 !== "number")
            H.throwExpression(P.ArgumentError$(t3));
          len = Math.sqrt(t3);
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = oH / 1.4142135623730951;
              dy = oV / 1.4142135623730951;
            } else {
              dx = t1.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_45Deg", 12, 0, 621, 6, [], 7, [], 622, [], 623, [], 617, [], 380, []],
    projCircle_Concave$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, t1, t2, ox, oy, twid, trad, t3, len, pen, x0, lenP, y0, vx, vy, dx, dy;
      signx = t.get$signx();
      signy = t.get$signy();
      if (J.$eq(oH, 0))
        if (J.$eq(oV, 0)) {
          t1 = t.get$pos().x;
          t2 = t.get$xw();
          if (typeof t2 !== "number")
            return H.iae(t2);
          ox = J.$sub$n(J.$add$ns(t1, signx * t2), obj.get$pos().x);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(J.$add$ns(t2, signy * t1), obj.get$pos().y);
          twid = J.$mul$ns(t.get$xw(), 2);
          t1 = J.$add$ns(J.$mul$ns(twid, twid), 0);
          if (typeof t1 !== "number")
            H.throwExpression(P.ArgumentError$(t1));
          trad = Math.sqrt(t1);
          t1 = J.getInterceptor$ns(ox);
          t2 = J.getInterceptor$ns(oy);
          t3 = J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy));
          if (typeof t3 !== "number")
            H.throwExpression(P.ArgumentError$(t3));
          len = Math.sqrt(t3);
          t3 = obj.get$radius();
          if (typeof t3 !== "number")
            return H.iae(t3);
          pen = len + t3 - trad;
          if (0 < pen) {
            t3 = J.getInterceptor$n(x);
            if (t3.$lt(x, y)) {
              x0 = J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0) ? t3.$mul(x, -1) : x;
              lenP = x;
              x = x0;
              y = 0;
            } else {
              y0 = J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0) ? J.$mul$ns(y, -1) : y;
              lenP = y;
              y = y0;
              x = 0;
            }
            if (J.$lt$n(lenP, pen)) {
              obj.reportCollisionVsWorld$4(x, y, J.$div$n(x, lenP), J.$div$n(y, lenP));
              return 1;
            } else {
              ox = t1.$div(ox, len);
              oy = t2.$div(oy, len);
              obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
              return 2;
            }
          } else
            return 0;
        } else {
          if (typeof oV !== "number")
            return H.iae(oV);
          if (signy * oV < 0) {
            obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
            return 1;
          } else {
            t1 = t.get$pos().x;
            t2 = t.get$xw();
            if (typeof t2 !== "number")
              return H.iae(t2);
            vx = J.$sub$n(t1, signx * t2);
            t2 = t.get$pos().y;
            t1 = t.get$yw();
            if (typeof t1 !== "number")
              return H.iae(t1);
            vy = J.$add$ns(t2, oV * t1);
            dx = J.$sub$n(obj.get$pos().x, vx);
            dy = J.$sub$n(obj.get$pos().y, vy);
            t1 = J.getInterceptor$ns(dx);
            t2 = J.getInterceptor$ns(dy);
            t3 = J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy));
            if (typeof t3 !== "number")
              H.throwExpression(P.ArgumentError$(t3));
            len = Math.sqrt(t3);
            pen = J.$sub$n(obj.get$radius(), len);
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              if (len === 0) {
                dy = oV;
                dx = 0;
              } else {
                dx = t1.$div(dx, len);
                dy = t2.$div(dy, len);
              }
              obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
              return 2;
            }
          }
        }
      else if (J.$eq(oV, 0)) {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (signx * oH < 0) {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        } else {
          t1 = t.get$pos().x;
          t2 = t.get$xw();
          if (typeof t2 !== "number")
            return H.iae(t2);
          vx = J.$add$ns(t1, oH * t2);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          vy = J.$sub$n(t2, signy * t1);
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t1 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          t3 = J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy));
          if (typeof t3 !== "number")
            H.throwExpression(P.ArgumentError$(t3));
          len = Math.sqrt(t3);
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = oH;
              dy = 0;
            } else {
              dx = t1.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      } else {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (typeof oV !== "number")
          return H.iae(oV);
        if (0 < signx * oH + signy * oV)
          return 0;
        else {
          t1 = t.get$pos().x;
          t2 = t.get$xw();
          if (typeof t2 !== "number")
            return H.iae(t2);
          vx = J.$add$ns(t1, oH * t2);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          vy = J.$add$ns(t2, oV * t1);
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t1 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          t3 = J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy));
          if (typeof t3 !== "number")
            H.throwExpression(P.ArgumentError$(t3));
          len = Math.sqrt(t3);
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = oH / 1.4142135623730951;
              dy = oV / 1.4142135623730951;
            } else {
              dx = t1.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_Concave", 12, 0, 621, 6, [], 7, [], 622, [], 623, [], 617, [], 380, []],
    projCircle_Convex$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, t1, t2, t3, ox, oy, twid, trad, len, pen, x0, lenP, y0, vx, vy, dx, dy;
      signx = t.get$signx();
      signy = t.get$signy();
      if (J.$eq(oH, 0))
        if (J.$eq(oV, 0)) {
          t1 = obj.get$pos().x;
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
          t3 = obj.get$pos().y;
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
          twid = J.$mul$ns(t.get$xw(), 2);
          t1 = J.$add$ns(J.$mul$ns(twid, twid), 0);
          if (typeof t1 !== "number")
            H.throwExpression(P.ArgumentError$(t1));
          trad = Math.sqrt(t1);
          t1 = J.getInterceptor$ns(ox);
          t2 = J.getInterceptor$ns(oy);
          t3 = J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy));
          if (typeof t3 !== "number")
            H.throwExpression(P.ArgumentError$(t3));
          len = Math.sqrt(t3);
          t3 = obj.get$radius();
          if (typeof t3 !== "number")
            return H.iae(t3);
          pen = trad + t3 - len;
          if (0 < pen) {
            t3 = J.getInterceptor$n(x);
            if (t3.$lt(x, y)) {
              x0 = J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0) ? t3.$mul(x, -1) : x;
              lenP = x;
              x = x0;
              y = 0;
            } else {
              y0 = J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0) ? J.$mul$ns(y, -1) : y;
              lenP = y;
              y = y0;
              x = 0;
            }
            if (J.$lt$n(lenP, pen)) {
              obj.reportCollisionVsWorld$4(x, y, J.$div$n(x, lenP), J.$div$n(y, lenP));
              return 1;
            } else {
              ox = t1.$div(ox, len);
              oy = t2.$div(oy, len);
              obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
              return 2;
            }
          }
        } else {
          if (typeof oV !== "number")
            return H.iae(oV);
          if (signy * oV < 0) {
            obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
            return 1;
          } else {
            t1 = obj.get$pos().x;
            t2 = t.get$pos().x;
            t3 = t.get$xw();
            if (typeof t3 !== "number")
              return H.iae(t3);
            ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
            t3 = obj.get$pos().y;
            t2 = t.get$pos().y;
            t1 = t.get$yw();
            if (typeof t1 !== "number")
              return H.iae(t1);
            oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
            twid = J.$mul$ns(t.get$xw(), 2);
            t1 = J.$add$ns(J.$mul$ns(twid, twid), 0);
            if (typeof t1 !== "number")
              H.throwExpression(P.ArgumentError$(t1));
            trad = Math.sqrt(t1);
            t1 = J.getInterceptor$ns(ox);
            t2 = J.getInterceptor$ns(oy);
            t3 = J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy));
            if (typeof t3 !== "number")
              H.throwExpression(P.ArgumentError$(t3));
            len = Math.sqrt(t3);
            t3 = obj.get$radius();
            if (typeof t3 !== "number")
              return H.iae(t3);
            pen = trad + t3 - len;
            if (0 < pen) {
              ox = t1.$div(ox, len);
              oy = t2.$div(oy, len);
              obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
              return 2;
            }
          }
        }
      else if (J.$eq(oV, 0)) {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (signx * oH < 0) {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        } else {
          t1 = obj.get$pos().x;
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
          t3 = obj.get$pos().y;
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
          twid = J.$mul$ns(t.get$xw(), 2);
          t1 = J.$add$ns(J.$mul$ns(twid, twid), 0);
          if (typeof t1 !== "number")
            H.throwExpression(P.ArgumentError$(t1));
          trad = Math.sqrt(t1);
          t1 = J.getInterceptor$ns(ox);
          t2 = J.getInterceptor$ns(oy);
          t3 = J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy));
          if (typeof t3 !== "number")
            H.throwExpression(P.ArgumentError$(t3));
          len = Math.sqrt(t3);
          t3 = obj.get$radius();
          if (typeof t3 !== "number")
            return H.iae(t3);
          pen = trad + t3 - len;
          if (0 < pen) {
            ox = t1.$div(ox, len);
            oy = t2.$div(oy, len);
            obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
            return 2;
          }
        }
      } else {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (typeof oV !== "number")
          return H.iae(oV);
        if (0 < signx * oH + signy * oV) {
          t1 = obj.get$pos().x;
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
          t3 = obj.get$pos().y;
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
          twid = J.$mul$ns(t.get$xw(), 2);
          t1 = J.$add$ns(J.$mul$ns(twid, twid), 0);
          if (typeof t1 !== "number")
            H.throwExpression(P.ArgumentError$(t1));
          trad = Math.sqrt(t1);
          t1 = J.getInterceptor$ns(ox);
          t2 = J.getInterceptor$ns(oy);
          t3 = J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy));
          if (typeof t3 !== "number")
            H.throwExpression(P.ArgumentError$(t3));
          len = Math.sqrt(t3);
          t3 = obj.get$radius();
          if (typeof t3 !== "number")
            return H.iae(t3);
          pen = trad + t3 - len;
          if (0 < pen) {
            ox = t1.$div(ox, len);
            oy = t2.$div(oy, len);
            obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
            return 2;
          }
        } else {
          t1 = t.get$pos().x;
          t2 = t.get$xw();
          if (typeof t2 !== "number")
            return H.iae(t2);
          vx = J.$add$ns(t1, oH * t2);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          vy = J.$add$ns(t2, oV * t1);
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t1 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          t3 = J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy));
          if (typeof t3 !== "number")
            H.throwExpression(P.ArgumentError$(t3));
          len = Math.sqrt(t3);
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = oH / 1.4142135623730951;
              dy = oV / 1.4142135623730951;
            } else {
              dx = t1.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_Convex", 12, 0, 621, 6, [], 7, [], 622, [], 623, [], 617, [], 380, []],
    projCircle_Half$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, t1, t2, celldp, r, ox, oy, dp, sx, sy, lenN, t3, lenP, dx, dy, t4, len, pen, vx, vy, t5;
      signx = t.get$signx();
      signy = t.get$signy();
      t1 = J.getInterceptor$ns(oH);
      t2 = J.getInterceptor$ns(oV);
      celldp = J.$add$ns(t1.$mul(oH, signx), t2.$mul(oV, signy));
      if (typeof celldp !== "number")
        return H.iae(celldp);
      if (0 < celldp)
        return 0;
      else if (t1.$eq(oH, 0))
        if (t2.$eq(oV, 0)) {
          r = obj.get$radius();
          t1 = obj.get$pos().x;
          if (typeof r !== "number")
            return H.iae(r);
          ox = J.$sub$n(J.$sub$n(t1, signx * r), t.get$pos().x);
          oy = J.$sub$n(J.$sub$n(obj.get$pos().y, signy * r), t.get$pos().y);
          dp = J.$add$ns(J.$mul$ns(ox, signx), J.$mul$ns(oy, signy));
          t1 = J.getInterceptor$n(dp);
          if (t1.$lt(dp, 0)) {
            t2 = t1.$negate(dp);
            if (typeof t2 !== "number")
              return H.iae(t2);
            sx = signx * t2;
            t1 = t1.$negate(dp);
            if (typeof t1 !== "number")
              return H.iae(t1);
            sy = signy * t1;
            lenN = Math.sqrt(sx * sx + sy * sy);
            t1 = J.getInterceptor$ns(x);
            t2 = J.getInterceptor$ns(y);
            t3 = J.$add$ns(t1.$mul(x, x), t2.$mul(y, y));
            if (typeof t3 !== "number")
              H.throwExpression(P.ArgumentError$(t3));
            lenP = Math.sqrt(t3);
            if (lenP < lenN) {
              obj.reportCollisionVsWorld$4(x, y, t1.$div(x, lenP), t2.$div(y, lenP));
              return 1;
            } else {
              obj.reportCollisionVsWorld$4(sx, sy, t.get$signx(), t.get$signy());
              return 2;
            }
          }
        } else if (celldp === 0) {
          dx = J.$sub$n(obj.get$pos().x, t.get$pos().x);
          t1 = J.getInterceptor$ns(dx);
          if (J.$lt$n(t1.$mul(dx, signx), 0)) {
            obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
            return 1;
          } else {
            dy = J.$sub$n(obj.get$pos().y, J.$add$ns(t.get$pos().y, t2.$mul(oV, t.get$yw())));
            t3 = J.getInterceptor$ns(dy);
            t4 = J.$add$ns(t1.$mul(dx, dx), t3.$mul(dy, dy));
            if (typeof t4 !== "number")
              H.throwExpression(P.ArgumentError$(t4));
            len = Math.sqrt(t4);
            pen = J.$sub$n(obj.get$radius(), len);
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              if (len === 0) {
                dx = signx / 1.4142135623730951;
                dy = t2.$div(oV, 1.4142135623730951);
              } else {
                dx = t1.$div(dx, len);
                dy = t3.$div(dy, len);
              }
              obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
              return 2;
            }
          }
        } else {
          obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
          return 1;
        }
      else if (t2.$eq(oV, 0))
        if (celldp === 0) {
          dy = J.$sub$n(obj.get$pos().y, t.get$pos().y);
          t3 = J.getInterceptor$ns(dy);
          if (J.$lt$n(t3.$mul(dy, signy), 0)) {
            obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
            return 1;
          } else {
            dx = J.$sub$n(obj.get$pos().x, J.$add$ns(t.get$pos().x, t1.$mul(oH, t.get$xw())));
            t1 = J.getInterceptor$ns(dx);
            t4 = J.$add$ns(t1.$mul(dx, dx), t3.$mul(dy, dy));
            if (typeof t4 !== "number")
              H.throwExpression(P.ArgumentError$(t4));
            len = Math.sqrt(t4);
            pen = J.$sub$n(obj.get$radius(), len);
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              if (len === 0) {
                dx = signx / 1.4142135623730951;
                dy = t2.$div(oV, 1.4142135623730951);
              } else {
                dx = t1.$div(dx, len);
                dy = t3.$div(dy, len);
              }
              obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
              return 2;
            }
          }
        } else {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        }
      else {
        vx = J.$add$ns(t.get$pos().x, t1.$mul(oH, t.get$xw()));
        vy = J.$add$ns(t.get$pos().y, t2.$mul(oV, t.get$yw()));
        dx = J.$sub$n(obj.get$pos().x, vx);
        dy = J.$sub$n(obj.get$pos().y, vy);
        t3 = J.getInterceptor$ns(dx);
        t4 = J.getInterceptor$ns(dy);
        t5 = J.$add$ns(t3.$mul(dx, dx), t4.$mul(dy, dy));
        if (typeof t5 !== "number")
          H.throwExpression(P.ArgumentError$(t5));
        len = Math.sqrt(t5);
        pen = J.$sub$n(obj.get$radius(), len);
        if (typeof pen !== "number")
          return H.iae(pen);
        if (0 < pen) {
          if (len === 0) {
            dx = t1.$div(oH, 1.4142135623730951);
            dy = t2.$div(oV, 1.4142135623730951);
          } else {
            dx = t3.$div(dx, len);
            dy = t4.$div(dy, len);
          }
          obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
          return 2;
        }
      }
      return 0;
    }, "call$6", "get$projCircle_Half", 12, 0, 621, 6, [], 7, [], 622, [], 623, [], 617, [], 380, []],
    projCircle_22DegS$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, t1, sx, sy, r, t2, t3, ox, oy, len, pen, dp, lenN, x0, lenP, y0, vx, vy, dx, dy, t4;
      signx = t.get$signx();
      signy = t.get$signy();
      if (typeof oV !== "number")
        return H.iae(oV);
      if (0 < signy * oV)
        return 0;
      else {
        t1 = J.getInterceptor(oH);
        if (t1.$eq(oH, 0))
          if (oV === 0) {
            sx = t.get$sx();
            sy = t.get$sy();
            r = obj.get$radius();
            t1 = obj.get$pos().x;
            t2 = t.get$pos().x;
            t3 = t.get$xw();
            if (typeof t3 !== "number")
              return H.iae(t3);
            ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
            oy = J.$sub$n(obj.get$pos().y, t.get$pos().y);
            t3 = J.getInterceptor$ns(ox);
            t2 = J.getInterceptor$ns(oy);
            t1 = J.$mul$ns(J.$mul$ns(J.$add$ns(t3.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy);
            if (typeof t1 !== "number")
              return H.iae(t1);
            if (0 < t1) {
              t1 = J.$add$ns(t3.$mul(ox, ox), t2.$mul(oy, oy));
              if (typeof t1 !== "number")
                H.throwExpression(P.ArgumentError$(t1));
              len = Math.sqrt(t1);
              pen = J.$sub$n(r, len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                ox = t3.$div(ox, len);
                oy = t2.$div(oy, len);
                obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
                return 2;
              }
            } else {
              t1 = J.getInterceptor$ns(r);
              ox = t3.$sub(ox, t1.$mul(r, sx));
              oy = t2.$sub(oy, t1.$mul(r, sy));
              dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
              t1 = J.getInterceptor$n(dp);
              if (t1.$lt(dp, 0)) {
                t2 = t1.$negate(dp);
                if (typeof t2 !== "number")
                  return H.iae(t2);
                sx *= t2;
                t1 = t1.$negate(dp);
                if (typeof t1 !== "number")
                  return H.iae(t1);
                sy *= t1;
                lenN = Math.sqrt(sx * sx + sy * sy);
                t1 = J.getInterceptor$n(x);
                if (t1.$lt(x, y)) {
                  x0 = J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0) ? t1.$mul(x, -1) : x;
                  lenP = x;
                  x = x0;
                  y = 0;
                } else {
                  y0 = J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0) ? J.$mul$ns(y, -1) : y;
                  lenP = y;
                  y = y0;
                  x = 0;
                }
                if (J.$lt$n(lenP, lenN)) {
                  obj.reportCollisionVsWorld$4(x, y, J.$div$n(x, lenP), J.$div$n(y, lenP));
                  return 1;
                } else {
                  obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
                  return 2;
                }
              }
            }
          } else {
            obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
            return 1;
          }
        else if (oV === 0) {
          if (typeof oH !== "number")
            return H.iae(oH);
          if (signx * oH < 0) {
            t1 = t.get$pos().x;
            t2 = t.get$xw();
            if (typeof t2 !== "number")
              return H.iae(t2);
            vx = J.$sub$n(t1, signx * t2);
            vy = t.get$pos().y;
            dx = J.$sub$n(obj.get$pos().x, vx);
            dy = J.$sub$n(obj.get$pos().y, vy);
            t1 = J.getInterceptor$ns(dy);
            if (J.$lt$n(t1.$mul(dy, signy), 0)) {
              obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
              return 1;
            } else {
              t2 = J.getInterceptor$ns(dx);
              t3 = J.$add$ns(t2.$mul(dx, dx), t1.$mul(dy, dy));
              if (typeof t3 !== "number")
                H.throwExpression(P.ArgumentError$(t3));
              len = Math.sqrt(t3);
              pen = J.$sub$n(obj.get$radius(), len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                if (len === 0) {
                  dx = oH / 1.4142135623730951;
                  dy = oV / 1.4142135623730951;
                } else {
                  dx = t2.$div(dx, len);
                  dy = t1.$div(dy, len);
                }
                obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
                return 2;
              }
            }
          } else {
            sx = t.get$sx();
            sy = t.get$sy();
            t1 = obj.get$pos().x;
            t2 = t.get$pos().x;
            t3 = t.get$xw();
            if (typeof t3 !== "number")
              return H.iae(t3);
            ox = J.$sub$n(t1, J.$add$ns(t2, oH * t3));
            t3 = obj.get$pos().y;
            t2 = t.get$pos().y;
            t1 = t.get$yw();
            if (typeof t1 !== "number")
              return H.iae(t1);
            oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
            t1 = J.getInterceptor$ns(ox);
            t2 = J.getInterceptor$ns(oy);
            if (J.$lt$n(J.$mul$ns(J.$mul$ns(J.$add$ns(t1.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy), 0)) {
              t3 = J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy));
              if (typeof t3 !== "number")
                H.throwExpression(P.ArgumentError$(t3));
              len = Math.sqrt(t3);
              pen = J.$sub$n(obj.get$radius(), len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                ox = t1.$div(ox, len);
                oy = t2.$div(oy, len);
                obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
                return 2;
              }
            } else {
              dp = J.$add$ns(t1.$mul(ox, sx), t2.$mul(oy, sy));
              pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                obj.reportCollisionVsWorld$4(sx * pen, sy * pen, sx, sy);
                return 2;
              }
            }
          }
        } else {
          vx = J.$add$ns(t.get$pos().x, t1.$mul(oH, t.get$xw()));
          t2 = t.get$pos().y;
          t3 = t.get$yw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          vy = J.$add$ns(t2, oV * t3);
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t3 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          t4 = J.$add$ns(t3.$mul(dx, dx), t2.$mul(dy, dy));
          if (typeof t4 !== "number")
            H.throwExpression(P.ArgumentError$(t4));
          len = Math.sqrt(t4);
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = t1.$div(oH, 1.4142135623730951);
              dy = oV / 1.4142135623730951;
            } else {
              dx = t3.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_22DegS", 12, 0, 621, 6, [], 7, [], 622, [], 623, [], 617, [], 380, []],
    projCircle_22DegB$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, sx, sy, r, t1, t2, t3, ox, oy, dp, lenN, x0, lenP, y0, len, pen, slen, vx, vy, dx, dy;
      signx = t.get$signx();
      signy = t.get$signy();
      if (J.$eq(oH, 0))
        if (J.$eq(oV, 0)) {
          sx = t.get$sx();
          sy = t.get$sy();
          r = obj.get$radius();
          t1 = obj.get$pos().x;
          if (typeof r !== "number")
            return H.iae(r);
          t1 = J.$sub$n(t1, sx * r);
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
          t3 = J.$sub$n(obj.get$pos().y, sy * r);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$add$ns(t2, signy * t1));
          dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
          t1 = J.getInterceptor$n(dp);
          if (t1.$lt(dp, 0)) {
            t2 = t1.$negate(dp);
            if (typeof t2 !== "number")
              return H.iae(t2);
            sx *= t2;
            t1 = t1.$negate(dp);
            if (typeof t1 !== "number")
              return H.iae(t1);
            sy *= t1;
            lenN = Math.sqrt(sx * sx + sy * sy);
            t1 = J.getInterceptor$n(x);
            if (t1.$lt(x, y)) {
              x0 = J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0) ? t1.$mul(x, -1) : x;
              lenP = x;
              x = x0;
              y = 0;
            } else {
              y0 = J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0) ? J.$mul$ns(y, -1) : y;
              lenP = y;
              y = y0;
              x = 0;
            }
            if (J.$lt$n(lenP, lenN)) {
              obj.reportCollisionVsWorld$4(x, y, J.$div$n(x, lenP), J.$div$n(y, lenP));
              return 1;
            } else {
              obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
              return 2;
            }
          }
        } else {
          if (typeof oV !== "number")
            return H.iae(oV);
          if (signy * oV < 0) {
            obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
            return 1;
          } else {
            sx = t.get$sx();
            sy = t.get$sy();
            t1 = obj.get$pos().x;
            t2 = t.get$pos().x;
            t3 = t.get$xw();
            if (typeof t3 !== "number")
              return H.iae(t3);
            ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
            t3 = obj.get$pos().y;
            t2 = t.get$pos().y;
            t1 = t.get$yw();
            if (typeof t1 !== "number")
              return H.iae(t1);
            oy = J.$sub$n(t3, J.$add$ns(t2, signy * t1));
            t1 = J.getInterceptor$ns(ox);
            t2 = J.getInterceptor$ns(oy);
            t3 = J.$mul$ns(J.$mul$ns(J.$add$ns(t1.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (0 < t3) {
              t3 = J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy));
              if (typeof t3 !== "number")
                H.throwExpression(P.ArgumentError$(t3));
              len = Math.sqrt(t3);
              pen = J.$sub$n(obj.get$radius(), len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                ox = t1.$div(ox, len);
                oy = t2.$div(oy, len);
                obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
                return 2;
              }
            } else {
              dp = J.$add$ns(t1.$mul(ox, sx), t2.$mul(oy, sy));
              pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                obj.reportCollisionVsWorld$4(sx * pen, sy * pen, sx, sy);
                return 2;
              }
            }
          }
        }
      else if (J.$eq(oV, 0)) {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (signx * oH < 0) {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        } else {
          t1 = obj.get$pos().x;
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$add$ns(t2, signx * t3));
          oy = J.$sub$n(obj.get$pos().y, t.get$pos().y);
          t1 = J.getInterceptor$ns(oy);
          if (J.$lt$n(t1.$mul(oy, signy), 0)) {
            obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
            return 1;
          } else {
            sx = t.get$sx();
            sy = t.get$sy();
            t2 = J.getInterceptor$ns(ox);
            if (J.$lt$n(J.$mul$ns(J.$mul$ns(J.$add$ns(t2.$mul(ox, -sy), t1.$mul(oy, sx)), signx), signy), 0)) {
              t3 = J.$add$ns(t2.$mul(ox, ox), t1.$mul(oy, oy));
              if (typeof t3 !== "number")
                H.throwExpression(P.ArgumentError$(t3));
              len = Math.sqrt(t3);
              pen = J.$sub$n(obj.get$radius(), len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                ox = t2.$div(ox, len);
                oy = t1.$div(oy, len);
                obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
                return 2;
              }
            } else {
              dp = J.$add$ns(t2.$mul(ox, sx), t1.$mul(oy, sy));
              pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                obj.reportCollisionVsWorld$4(sx * pen, sy * pen, t.get$sx(), t.get$sy());
                return 2;
              }
            }
          }
        }
      } else {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (typeof oV !== "number")
          return H.iae(oV);
        if (0 < signx * oH + signy * oV) {
          slen = Math.sqrt(5);
          sx = signx / slen;
          sy = signy * 2 / slen;
          r = obj.get$radius();
          t1 = obj.get$pos().x;
          if (typeof r !== "number")
            return H.iae(r);
          t1 = J.$sub$n(t1, sx * r);
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
          t3 = J.$sub$n(obj.get$pos().y, sy * r);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$add$ns(t2, signy * t1));
          dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
          if (J.$lt$n(dp, 0)) {
            if (typeof dp !== "number")
              return H.iae(dp);
            obj.reportCollisionVsWorld$4(-sx * dp, -sy * dp, t.get$sx(), t.get$sy());
            return 2;
          }
          return 0;
        } else {
          t1 = t.get$pos().x;
          t2 = t.get$xw();
          if (typeof t2 !== "number")
            return H.iae(t2);
          vx = J.$add$ns(t1, oH * t2);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          vy = J.$add$ns(t2, oV * t1);
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t1 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          t3 = J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy));
          if (typeof t3 !== "number")
            H.throwExpression(P.ArgumentError$(t3));
          len = Math.sqrt(t3);
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = oH / 1.4142135623730951;
              dy = oV / 1.4142135623730951;
            } else {
              dx = t1.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_22DegB", 12, 0, 621, 6, [], 7, [], 622, [], 623, [], 617, [], 380, []],
    projCircle_67DegS$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, sx, sy, r, ox, t1, t2, t3, oy, len, pen, dp, lenN, x0, lenP, y0, vx, vy, dx, dy, t4;
      signx = t.get$signx();
      signy = t.get$signy();
      if (typeof oH !== "number")
        return H.iae(oH);
      if (0 < signx * oH)
        return 0;
      else if (oH === 0)
        if (J.$eq(oV, 0)) {
          sx = t.get$sx();
          sy = t.get$sy();
          r = obj.get$radius();
          ox = J.$sub$n(obj.get$pos().x, t.get$pos().x);
          t1 = obj.get$pos().y;
          t2 = t.get$pos().y;
          t3 = t.get$yw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          oy = J.$sub$n(t1, J.$sub$n(t2, signy * t3));
          t3 = J.getInterceptor$ns(ox);
          t2 = J.getInterceptor$ns(oy);
          if (J.$lt$n(J.$mul$ns(J.$mul$ns(J.$add$ns(t3.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy), 0)) {
            t1 = J.$add$ns(t3.$mul(ox, ox), t2.$mul(oy, oy));
            if (typeof t1 !== "number")
              H.throwExpression(P.ArgumentError$(t1));
            len = Math.sqrt(t1);
            pen = J.$sub$n(r, len);
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              ox = t3.$div(ox, len);
              oy = t2.$div(oy, len);
              obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
              return 2;
            }
          } else {
            t1 = J.getInterceptor$ns(r);
            ox = t3.$sub(ox, t1.$mul(r, sx));
            oy = t2.$sub(oy, t1.$mul(r, sy));
            dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
            t1 = J.getInterceptor$n(dp);
            if (t1.$lt(dp, 0)) {
              t2 = t1.$negate(dp);
              if (typeof t2 !== "number")
                return H.iae(t2);
              sx *= t2;
              t1 = t1.$negate(dp);
              if (typeof t1 !== "number")
                return H.iae(t1);
              sy *= t1;
              lenN = Math.sqrt(sx * sx + sy * sy);
              t1 = J.getInterceptor$n(x);
              if (t1.$lt(x, y)) {
                x0 = J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0) ? t1.$mul(x, -1) : x;
                lenP = x;
                x = x0;
                y = 0;
              } else {
                y0 = J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0) ? J.$mul$ns(y, -1) : y;
                lenP = y;
                y = y0;
                x = 0;
              }
              if (J.$lt$n(lenP, lenN)) {
                obj.reportCollisionVsWorld$4(x, y, J.$div$n(x, lenP), J.$div$n(y, lenP));
                return 1;
              } else {
                obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
                return 2;
              }
            }
          }
        } else {
          if (typeof oV !== "number")
            return H.iae(oV);
          if (signy * oV < 0) {
            vx = t.get$pos().x;
            t1 = t.get$pos().y;
            t2 = t.get$yw();
            if (typeof t2 !== "number")
              return H.iae(t2);
            vy = J.$sub$n(t1, signy * t2);
            dx = J.$sub$n(obj.get$pos().x, vx);
            dy = J.$sub$n(obj.get$pos().y, vy);
            t1 = J.getInterceptor$ns(dx);
            if (J.$lt$n(t1.$mul(dx, signx), 0)) {
              obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
              return 1;
            } else {
              t2 = J.getInterceptor$ns(dy);
              t3 = J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy));
              if (typeof t3 !== "number")
                H.throwExpression(P.ArgumentError$(t3));
              len = Math.sqrt(t3);
              pen = J.$sub$n(obj.get$radius(), len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                if (len === 0) {
                  dx = oH / 1.4142135623730951;
                  dy = oV / 1.4142135623730951;
                } else {
                  dx = t1.$div(dx, len);
                  dy = t2.$div(dy, len);
                }
                obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
                return 2;
              }
            }
          } else {
            sx = t.get$sx();
            sy = t.get$sy();
            t1 = obj.get$pos().x;
            t2 = t.get$pos().x;
            t3 = t.get$xw();
            if (typeof t3 !== "number")
              return H.iae(t3);
            ox = J.$sub$n(t1, J.$sub$n(t2, signx * t3));
            t3 = obj.get$pos().y;
            t2 = t.get$pos().y;
            t1 = t.get$yw();
            if (typeof t1 !== "number")
              return H.iae(t1);
            oy = J.$sub$n(t3, J.$add$ns(t2, oV * t1));
            t1 = J.getInterceptor$ns(ox);
            t2 = J.getInterceptor$ns(oy);
            t3 = J.$mul$ns(J.$mul$ns(J.$add$ns(t1.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (0 < t3) {
              t3 = J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy));
              if (typeof t3 !== "number")
                H.throwExpression(P.ArgumentError$(t3));
              len = Math.sqrt(t3);
              pen = J.$sub$n(obj.get$radius(), len);
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                ox = t1.$div(ox, len);
                oy = t2.$div(oy, len);
                obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
                return 2;
              }
            } else {
              dp = J.$add$ns(t1.$mul(ox, sx), t2.$mul(oy, sy));
              pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
              if (typeof pen !== "number")
                return H.iae(pen);
              if (0 < pen) {
                obj.reportCollisionVsWorld$4(sx * pen, sy * pen, t.get$sx(), t.get$sy());
                return 2;
              }
            }
          }
        }
      else {
        t1 = J.getInterceptor(oV);
        if (t1.$eq(oV, 0)) {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        } else {
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          vx = J.$add$ns(t2, oH * t3);
          vy = J.$add$ns(t.get$pos().y, t1.$mul(oV, t.get$yw()));
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t3 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          t4 = J.$add$ns(t3.$mul(dx, dx), t2.$mul(dy, dy));
          if (typeof t4 !== "number")
            H.throwExpression(P.ArgumentError$(t4));
          len = Math.sqrt(t4);
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = oH / 1.4142135623730951;
              dy = t1.$div(oV, 1.4142135623730951);
            } else {
              dx = t3.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_67DegS", 12, 0, 621, 6, [], 7, [], 622, [], 623, [], 617, [], 380, []],
    projCircle_67DegB$6: [function(x, y, oH, oV, obj, t) {
      var signx, signy, sx, sy, r, t1, t2, t3, ox, oy, dp, lenN, x0, lenP, y0, len, pen, slen, vx, vy, dx, dy;
      signx = t.get$signx();
      signy = t.get$signy();
      if (J.$eq(oH, 0))
        if (J.$eq(oV, 0)) {
          sx = t.get$sx();
          sy = t.get$sy();
          r = obj.get$radius();
          t1 = obj.get$pos().x;
          if (typeof r !== "number")
            return H.iae(r);
          t1 = J.$sub$n(t1, sx * r);
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$add$ns(t2, signx * t3));
          t3 = J.$sub$n(obj.get$pos().y, sy * r);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
          dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
          t1 = J.getInterceptor$n(dp);
          if (t1.$lt(dp, 0)) {
            t2 = t1.$negate(dp);
            if (typeof t2 !== "number")
              return H.iae(t2);
            sx *= t2;
            t1 = t1.$negate(dp);
            if (typeof t1 !== "number")
              return H.iae(t1);
            sy *= t1;
            lenN = Math.sqrt(sx * sx + sy * sy);
            t1 = J.getInterceptor$n(x);
            if (t1.$lt(x, y)) {
              x0 = J.$lt$n(J.$sub$n(obj.get$pos().x, t.get$pos().x), 0) ? t1.$mul(x, -1) : x;
              lenP = x;
              x = x0;
              y = 0;
            } else {
              y0 = J.$lt$n(J.$sub$n(obj.get$pos().y, t.get$pos().y), 0) ? J.$mul$ns(y, -1) : y;
              lenP = y;
              y = y0;
              x = 0;
            }
            if (J.$lt$n(lenP, lenN)) {
              obj.reportCollisionVsWorld$4(x, y, J.$div$n(x, lenP), J.$div$n(y, lenP));
              return 1;
            } else {
              obj.reportCollisionVsWorld$4(sx, sy, t.get$sx(), t.get$sy());
              return 2;
            }
          }
        } else {
          if (typeof oV !== "number")
            return H.iae(oV);
          if (signy * oV < 0) {
            obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
            return 1;
          } else {
            ox = J.$sub$n(obj.get$pos().x, t.get$pos().x);
            t1 = obj.get$pos().y;
            t2 = t.get$pos().y;
            t3 = t.get$yw();
            if (typeof t3 !== "number")
              return H.iae(t3);
            oy = J.$sub$n(t1, J.$add$ns(t2, signy * t3));
            t1 = J.getInterceptor$ns(ox);
            if (J.$lt$n(t1.$mul(ox, signx), 0)) {
              obj.reportCollisionVsWorld$4(0, J.$mul$ns(y, oV), 0, oV);
              return 1;
            } else {
              sx = t.get$sx();
              sy = t.get$sy();
              t2 = J.getInterceptor$ns(oy);
              t3 = J.$mul$ns(J.$mul$ns(J.$add$ns(t1.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy);
              if (typeof t3 !== "number")
                return H.iae(t3);
              if (0 < t3) {
                t3 = J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy));
                if (typeof t3 !== "number")
                  H.throwExpression(P.ArgumentError$(t3));
                len = Math.sqrt(t3);
                pen = J.$sub$n(obj.get$radius(), len);
                if (typeof pen !== "number")
                  return H.iae(pen);
                if (0 < pen) {
                  ox = t1.$div(ox, len);
                  oy = t2.$div(oy, len);
                  obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
                  return 2;
                }
              } else {
                dp = J.$add$ns(t1.$mul(ox, sx), t2.$mul(oy, sy));
                pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
                if (typeof pen !== "number")
                  return H.iae(pen);
                if (0 < pen) {
                  obj.reportCollisionVsWorld$4(sx * pen, sy * pen, sx, sy);
                  return 2;
                }
              }
            }
          }
        }
      else if (J.$eq(oV, 0)) {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (signx * oH < 0) {
          obj.reportCollisionVsWorld$4(J.$mul$ns(x, oH), 0, oH, 0);
          return 1;
        } else {
          slen = Math.sqrt(5);
          sx = signx * 2 / slen;
          sy = signy / slen;
          t1 = obj.get$pos().x;
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$add$ns(t2, signx * t3));
          t3 = obj.get$pos().y;
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
          t1 = J.getInterceptor$ns(ox);
          t2 = J.getInterceptor$ns(oy);
          if (J.$lt$n(J.$mul$ns(J.$mul$ns(J.$add$ns(t1.$mul(ox, -sy), t2.$mul(oy, sx)), signx), signy), 0)) {
            t3 = J.$add$ns(t1.$mul(ox, ox), t2.$mul(oy, oy));
            if (typeof t3 !== "number")
              H.throwExpression(P.ArgumentError$(t3));
            len = Math.sqrt(t3);
            pen = J.$sub$n(obj.get$radius(), len);
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              ox = t1.$div(ox, len);
              oy = t2.$div(oy, len);
              obj.reportCollisionVsWorld$4(J.$mul$ns(ox, pen), J.$mul$ns(oy, pen), ox, oy);
              return 2;
            }
          } else {
            dp = J.$add$ns(t1.$mul(ox, sx), t2.$mul(oy, sy));
            pen = J.$sub$n(obj.get$radius(), J.abs$0$n(dp));
            if (typeof pen !== "number")
              return H.iae(pen);
            if (0 < pen) {
              obj.reportCollisionVsWorld$4(sx * pen, sy * pen, t.get$sx(), t.get$sy());
              return 2;
            }
          }
        }
      } else {
        if (typeof oH !== "number")
          return H.iae(oH);
        if (typeof oV !== "number")
          return H.iae(oV);
        if (0 < signx * oH + signy * oV) {
          sx = t.get$sx();
          sy = t.get$sy();
          r = obj.get$radius();
          t1 = obj.get$pos().x;
          if (typeof r !== "number")
            return H.iae(r);
          t1 = J.$sub$n(t1, sx * r);
          t2 = t.get$pos().x;
          t3 = t.get$xw();
          if (typeof t3 !== "number")
            return H.iae(t3);
          ox = J.$sub$n(t1, J.$add$ns(t2, signx * t3));
          t3 = J.$sub$n(obj.get$pos().y, sy * r);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          oy = J.$sub$n(t3, J.$sub$n(t2, signy * t1));
          dp = J.$add$ns(J.$mul$ns(ox, sx), J.$mul$ns(oy, sy));
          if (J.$lt$n(dp, 0)) {
            if (typeof dp !== "number")
              return H.iae(dp);
            obj.reportCollisionVsWorld$4(-sx * dp, -sy * dp, t.get$sx(), t.get$sy());
            return 2;
          }
          return 0;
        } else {
          t1 = t.get$pos().x;
          t2 = t.get$xw();
          if (typeof t2 !== "number")
            return H.iae(t2);
          vx = J.$add$ns(t1, oH * t2);
          t2 = t.get$pos().y;
          t1 = t.get$yw();
          if (typeof t1 !== "number")
            return H.iae(t1);
          vy = J.$add$ns(t2, oV * t1);
          dx = J.$sub$n(obj.get$pos().x, vx);
          dy = J.$sub$n(obj.get$pos().y, vy);
          t1 = J.getInterceptor$ns(dx);
          t2 = J.getInterceptor$ns(dy);
          t3 = J.$add$ns(t1.$mul(dx, dx), t2.$mul(dy, dy));
          if (typeof t3 !== "number")
            H.throwExpression(P.ArgumentError$(t3));
          len = Math.sqrt(t3);
          pen = J.$sub$n(obj.get$radius(), len);
          if (typeof pen !== "number")
            return H.iae(pen);
          if (0 < pen) {
            if (len === 0) {
              dx = oH / 1.4142135623730951;
              dy = oV / 1.4142135623730951;
            } else {
              dx = t1.$div(dx, len);
              dy = t2.$div(dy, len);
            }
            obj.reportCollisionVsWorld$4(J.$mul$ns(dx, pen), J.$mul$ns(dy, pen), dx, dy);
            return 2;
          }
        }
      }
      return 0;
    }, "call$6", "get$projCircle_67DegB", 12, 0, 621, 6, [], 7, [], 622, [], 623, [], 617, [], 380, []],
    destroy$0: function() {
      this.Ninja0$Circle1$body = null;
      this.Ninja0$Circle1$system = null;
    },
    render$5: [function(context, xOffset, yOffset, color, filled) {
      var x, y, t1;
      x = J.$sub$n(this.Ninja0$Circle1$pos.x, xOffset);
      y = J.$sub$n(this.Ninja0$Circle1$pos.y, yOffset);
      t1 = J.getInterceptor$x(context);
      t1.beginPath$0(context);
      t1.arc$6(context, x, y, this.radius, 0, 6.283185307179586, false);
      if (filled === true) {
        t1.set$fillStyle(context, color);
        t1.fill$0(context);
      } else {
        t1.set$strokeStyle(context, color);
        t1.stroke$0(context);
      }
    }, "call$5", "get$render", 10, 0, 619, 104, [], 293, [], 294, [], 114, [], 608, []],
    Circle$4: function(body, x, y, radius) {
      var t1;
      this.Ninja0$Circle1$body = body;
      this.Ninja0$Circle1$system = body.system;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.Ninja0$Circle1$pos = t1;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.Ninja0$Circle1$oldpos = t1;
      this.radius = radius;
      t1 = J.getInterceptor$ns(radius);
      this.Ninja0$Circle1$_Ninja0$_width = t1.$mul(radius, 2);
      this.Ninja0$Circle1$_Ninja0$_height = t1.$mul(radius, 2);
      this.Ninja0$Circle1$oH = 0;
      this.Ninja0$Circle1$oV = 0;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.Ninja0$Circle1$velocity = t1;
      t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      this.circleTileProjections = t1;
      t1.$indexSet(0, 1, this.get$projCircle_Full());
      this.circleTileProjections.$indexSet(0, 2, this.get$projCircle_45Deg());
      this.circleTileProjections.$indexSet(0, 6, this.get$projCircle_Concave());
      this.circleTileProjections.$indexSet(0, 10, this.get$projCircle_Convex());
      this.circleTileProjections.$indexSet(0, 14, this.get$projCircle_22DegS());
      this.circleTileProjections.$indexSet(0, 18, this.get$projCircle_22DegB());
      this.circleTileProjections.$indexSet(0, 22, this.get$projCircle_67DegS());
      this.circleTileProjections.$indexSet(0, 26, this.get$projCircle_67DegB());
      this.circleTileProjections.$indexSet(0, 30, this.get$projCircle_Half());
    },
    static: {"^": "Circle_COL_NONE,Circle_COL_AXIS,Circle_COL_OTHER"}
  },
  "+Circle": 0,
  Shape0: {
    "^": "Object;body*,pos<,_Ninja0$_width<,_Ninja0$_height<,velocity@",
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.body.call$3(arg0, arg1, arg2);
    },
    get$xw: function() {
      return J.abs$0$n(J.$div$n(this.get$width(this), 2));
    },
    get$yw: function() {
      return J.abs$0$n(J.$div$n(this.get$height(this), 2));
    },
    get$width: function(_) {
      return this.get$_Ninja0$_width();
    },
    get$height: function(_) {
      return this.get$_Ninja0$_height();
    }
  },
  "+Shape": 0,
  Tile0: {
    "^": "Shape0;body:Ninja0$Tile0$body*,Ninja0$Tile0$system,pos:Ninja0$Tile0$pos<,oldpos:Ninja0$Tile0$oldpos<,_Ninja0$_width:Ninja0$Tile0$_Ninja0$_width<,_Ninja0$_height:Ninja0$Tile0$_Ninja0$_height<,Ninja0$Tile0$oH,Ninja0$Tile0$oV,velocity:Ninja0$Tile0$velocity@,Ninja0$Tile0$aabbTileProjections,signx<,signy<,sx<,sy<,id*,type*,body,system,pos,oldpos,_Ninja0$_width,_Ninja0$_height,oH,oV,velocity,aabbTileProjections",
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.Ninja0$Tile0$body.call$3(arg0, arg1, arg2);
    },
    get$xw: function() {
      return J.abs$0$n(J.$div$n(this.Ninja0$Tile0$_Ninja0$_width, 2));
    },
    get$yw: function() {
      return J.abs$0$n(J.$div$n(this.Ninja0$Tile0$_Ninja0$_height, 2));
    },
    get$width: function(_) {
      return this.Ninja0$Tile0$_Ninja0$_width;
    },
    get$height: function(_) {
      return this.Ninja0$Tile0$_Ninja0$_height;
    },
    render$5: [function(context, xOffset, yOffset, color, filled) {
      throw H.wrapException(P.Expando$("Never call!", null));
    }, "call$5", "get$render", 10, 0, 619, 104, [], 293, [], 294, [], 114, [], 608, []],
    integrate$0: function() {
      var t1, px, py;
      t1 = this.Ninja0$Tile0$pos;
      px = t1.x;
      py = t1.y;
      t1.x = J.$add$ns(px, J.$sub$n(J.$mul$ns(this.Ninja0$Tile0$body.get$drag(), this.Ninja0$Tile0$pos.x), J.$mul$ns(this.Ninja0$Tile0$body.get$drag(), this.Ninja0$Tile0$oldpos.x)));
      t1 = this.Ninja0$Tile0$pos;
      t1.y = J.$add$ns(t1.y, J.$add$ns(J.$sub$n(J.$mul$ns(this.Ninja0$Tile0$body.get$drag(), this.Ninja0$Tile0$pos.y), J.$mul$ns(this.Ninja0$Tile0$body.get$drag(), this.Ninja0$Tile0$oldpos.y)), J.$mul$ns(this.Ninja0$Tile0$system.gravity, this.Ninja0$Tile0$body.get$gravityScale())));
      this.Ninja0$Tile0$velocity.set$2(J.$sub$n(this.Ninja0$Tile0$pos.x, px), J.$sub$n(this.Ninja0$Tile0$pos.y, py));
      this.Ninja0$Tile0$oldpos.set$2(px, py);
    },
    collideWorldBounds$0: [function() {
      var dx, dy;
      dx = J.$sub$n(J.get$x$x(this.Ninja0$Tile0$system.bounds), J.$sub$n(this.Ninja0$Tile0$pos.x, J.abs$0$n(J.$div$n(this.Ninja0$Tile0$_Ninja0$_width, 2))));
      if (typeof dx !== "number")
        return H.iae(dx);
      if (0 < dx)
        this.reportCollisionVsWorld$4(dx, 0, 1, 0);
      else {
        dx = J.$sub$n(J.$add$ns(this.Ninja0$Tile0$pos.x, J.abs$0$n(J.$div$n(this.Ninja0$Tile0$_Ninja0$_width, 2))), J.get$right$x(this.Ninja0$Tile0$system.bounds));
        if (typeof dx !== "number")
          return H.iae(dx);
        if (0 < dx)
          this.reportCollisionVsWorld$4(-dx, 0, -1, 0);
      }
      dy = J.$sub$n(J.get$y$x(this.Ninja0$Tile0$system.bounds), J.$sub$n(this.Ninja0$Tile0$pos.y, J.abs$0$n(J.$div$n(this.Ninja0$Tile0$_Ninja0$_height, 2))));
      if (typeof dy !== "number")
        return H.iae(dy);
      if (0 < dy)
        this.reportCollisionVsWorld$4(0, dy, 0, 1);
      else {
        dy = J.$sub$n(J.$add$ns(this.Ninja0$Tile0$pos.y, J.abs$0$n(J.$div$n(this.Ninja0$Tile0$_Ninja0$_height, 2))), J.get$bottom$x(this.Ninja0$Tile0$system.bounds));
        if (typeof dy !== "number")
          return H.iae(dy);
        if (0 < dy)
          this.reportCollisionVsWorld$4(0, -dy, 0, -1);
      }
    }, "call$0", "get$collideWorldBounds", 0, 0, 13],
    reportCollisionVsWorld$4: function(px, py, dx, dy) {
      var p, o, vx, vy, t1, t2, dp, t3, nx, ny, tx, ty, fx, fy, b, bx, by;
      p = this.Ninja0$Tile0$pos;
      o = this.Ninja0$Tile0$oldpos;
      vx = J.$sub$n(p.x, o.x);
      vy = J.$sub$n(p.y, o.y);
      t1 = J.getInterceptor$ns(vx);
      t2 = J.getInterceptor$ns(vy);
      dp = J.$add$ns(t1.$mul(vx, dx), t2.$mul(vy, dy));
      t3 = J.getInterceptor$ns(dp);
      nx = t3.$mul(dp, dx);
      ny = t3.$mul(dp, dy);
      tx = t1.$sub(vx, nx);
      ty = t2.$sub(vy, ny);
      if (t3.$lt(dp, 0)) {
        fx = J.$mul$ns(tx, this.Ninja0$Tile0$body.get$friction());
        fy = J.$mul$ns(ty, this.Ninja0$Tile0$body.get$friction());
        t1 = this.Ninja0$Tile0$body.get$bounce();
        if (typeof t1 !== "number")
          return H.iae(t1);
        b = 1 + t1;
        bx = J.$mul$ns(nx, b);
        by = J.$mul$ns(ny, b);
        t1 = J.getInterceptor(dx);
        if (t1.$eq(dx, 1))
          J.set$left$x(this.Ninja0$Tile0$body.get$touching(), true);
        else if (t1.$eq(dx, -1))
          J.set$right$x(this.Ninja0$Tile0$body.get$touching(), true);
        t1 = J.getInterceptor(dy);
        if (t1.$eq(dy, 1))
          this.Ninja0$Tile0$body.get$touching().set$up(true);
        else if (t1.$eq(dy, -1))
          this.Ninja0$Tile0$body.get$touching().set$down(true);
      } else {
        bx = 0;
        by = 0;
        fx = 0;
        fy = 0;
      }
      p.x = J.$add$ns(p.x, px);
      p.y = J.$add$ns(p.y, py);
      o.x = J.$add$ns(o.x, J.$add$ns(J.$add$ns(px, bx), fx));
      o.y = J.$add$ns(o.y, J.$add$ns(J.$add$ns(py, by), fy));
    },
    clear$0: function(_) {
      this.id = 0;
      this.updateType$0();
    },
    destroy$0: function() {
      this.Ninja0$Tile0$body = null;
      this.Ninja0$Tile0$system = null;
    },
    updateType$0: function() {
      if (J.$eq(this.id, 0)) {
        this.type = 0;
        this.signx = 0;
        this.signy = 0;
        this.sx = 0;
        this.sy = 0;
        return true;
      }
      if (J.$lt$n(this.id, 2)) {
        this.type = 1;
        this.signx = 0;
        this.signy = 0;
        this.sx = 0;
        this.sy = 0;
      } else if (J.$lt$n(this.id, 6)) {
        this.type = 2;
        if (J.$eq(this.id, 2)) {
          this.signx = 1;
          this.signy = -1;
          this.sx = 0.7071067811865475;
          this.sy = -0.7071067811865475;
        } else if (J.$eq(this.id, 3)) {
          this.signx = -1;
          this.signy = -1;
          this.sx = -0.7071067811865475;
          this.sy = -0.7071067811865475;
        } else if (J.$eq(this.id, 4)) {
          this.signx = -1;
          this.signy = 1;
          this.sx = -0.7071067811865475;
          this.sy = 0.7071067811865475;
        } else if (J.$eq(this.id, 5)) {
          this.signx = 1;
          this.signy = 1;
          this.sx = 0.7071067811865475;
          this.sy = 0.7071067811865475;
        } else
          return false;
      } else if (J.$lt$n(this.id, 10)) {
        this.type = 6;
        if (J.$eq(this.id, 6)) {
          this.signx = 1;
          this.signy = -1;
          this.sx = 0;
          this.sy = 0;
        } else if (J.$eq(this.id, 7)) {
          this.signx = -1;
          this.signy = -1;
          this.sx = 0;
          this.sy = 0;
        } else if (J.$eq(this.id, 8)) {
          this.signx = -1;
          this.signy = 1;
          this.sx = 0;
          this.sy = 0;
        } else if (J.$eq(this.id, 9)) {
          this.signx = 1;
          this.signy = 1;
          this.sx = 0;
          this.sy = 0;
        } else
          return false;
      } else if (J.$lt$n(this.id, 14)) {
        this.type = 10;
        if (J.$eq(this.id, 10)) {
          this.signx = 1;
          this.signy = -1;
          this.sx = 0;
          this.sy = 0;
        } else if (J.$eq(this.id, 11)) {
          this.signx = -1;
          this.signy = -1;
          this.sx = 0;
          this.sy = 0;
        } else if (J.$eq(this.id, 12)) {
          this.signx = -1;
          this.signy = 1;
          this.sx = 0;
          this.sy = 0;
        } else if (J.$eq(this.id, 13)) {
          this.signx = 1;
          this.signy = 1;
          this.sx = 0;
          this.sy = 0;
        } else
          return false;
      } else if (J.$lt$n(this.id, 18)) {
        this.type = 14;
        if (J.$eq(this.id, 14)) {
          this.signx = 1;
          this.signy = -1;
          var slen = Math.sqrt(5);
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else if (J.$eq(this.id, 15)) {
          this.signx = -1;
          this.signy = -1;
          slen = Math.sqrt(5);
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else if (J.$eq(this.id, 16)) {
          this.signx = -1;
          this.signy = 1;
          slen = Math.sqrt(5);
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else if (J.$eq(this.id, 17)) {
          this.signx = 1;
          this.signy = 1;
          slen = Math.sqrt(5);
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else
          return false;
      } else if (J.$lt$n(this.id, 22)) {
        this.type = 18;
        if (J.$eq(this.id, 18)) {
          this.signx = 1;
          this.signy = -1;
          slen = Math.sqrt(5);
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else if (J.$eq(this.id, 19)) {
          this.signx = -1;
          this.signy = -1;
          slen = Math.sqrt(5);
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else if (J.$eq(this.id, 20)) {
          this.signx = -1;
          this.signy = 1;
          slen = Math.sqrt(5);
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else if (J.$eq(this.id, 21)) {
          this.signx = 1;
          this.signy = 1;
          slen = Math.sqrt(5);
          this.sx = this.signx / slen;
          this.sy = this.signy * 2 / slen;
        } else
          return false;
      } else if (J.$lt$n(this.id, 26)) {
        this.type = 22;
        if (J.$eq(this.id, 22)) {
          this.signx = 1;
          this.signy = -1;
          slen = Math.sqrt(5);
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else if (J.$eq(this.id, 23)) {
          this.signx = -1;
          this.signy = -1;
          slen = Math.sqrt(5);
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else if (J.$eq(this.id, 24)) {
          this.signx = -1;
          this.signy = 1;
          slen = Math.sqrt(5);
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else if (J.$eq(this.id, 25)) {
          this.signx = 1;
          this.signy = 1;
          slen = Math.sqrt(5);
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else
          return false;
      } else if (J.$lt$n(this.id, 30)) {
        this.type = 26;
        if (J.$eq(this.id, 26)) {
          this.signx = 1;
          this.signy = -1;
          slen = Math.sqrt(5);
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else if (J.$eq(this.id, 27)) {
          this.signx = -1;
          this.signy = -1;
          slen = Math.sqrt(5);
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else if (J.$eq(this.id, 28)) {
          this.signx = -1;
          this.signy = 1;
          slen = Math.sqrt(5);
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else if (J.$eq(this.id, 29)) {
          this.signx = 1;
          this.signy = 1;
          slen = Math.sqrt(5);
          this.sx = this.signx * 2 / slen;
          this.sy = this.signy / slen;
        } else
          return false;
      } else {
        this.type = 30;
        if (J.$eq(this.id, 30)) {
          this.signx = 0;
          this.signy = -1;
          this.sx = 0;
          this.sy = -1;
        } else if (J.$eq(this.id, 32)) {
          this.signx = 0;
          this.signy = 1;
          this.sx = 0;
          this.sy = 1;
        } else if (J.$eq(this.id, 33)) {
          this.signx = 1;
          this.signy = 0;
          this.sx = 1;
          this.sy = 0;
        } else if (J.$eq(this.id, 31)) {
          this.signx = -1;
          this.signy = 0;
          this.sx = -1;
          this.sy = 0;
        } else
          return false;
      }
    },
    get$x: function(_) {
      return J.$sub$n(this.Ninja0$Tile0$pos.x, J.abs$0$n(J.$div$n(this.Ninja0$Tile0$_Ninja0$_width, 2)));
    },
    set$x: function(_, value) {
      this.Ninja0$Tile0$pos.x = value;
    },
    get$y: function(_) {
      return J.$sub$n(this.Ninja0$Tile0$pos.y, J.abs$0$n(J.$div$n(this.Ninja0$Tile0$_Ninja0$_height, 2)));
    },
    set$y: function(_, value) {
      this.Ninja0$Tile0$pos.y = value;
    },
    get$bottom: function(_) {
      return J.$add$ns(this.Ninja0$Tile0$pos.y, J.abs$0$n(J.$div$n(this.Ninja0$Tile0$_Ninja0$_height, 2)));
    },
    get$right: function(_) {
      return J.$add$ns(this.Ninja0$Tile0$pos.x, J.abs$0$n(J.$div$n(this.Ninja0$Tile0$_Ninja0$_width, 2)));
    },
    Tile$6: function(body, x, y, width, height, type) {
      var t1;
      this.Ninja0$Tile0$body = body;
      this.Ninja0$Tile0$system = body.system;
      this.id = type;
      this.type = 0;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.Ninja0$Tile0$pos = t1;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.Ninja0$Tile0$oldpos = t1;
      if (J.$gt$n(type, 1) && J.$lt$n(this.id, 30))
        height = width;
      this.Ninja0$Tile0$_Ninja0$_width = width;
      this.Ninja0$Tile0$_Ninja0$_height = height;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.Ninja0$Tile0$velocity = t1;
      this.signx = 0;
      this.signy = 0;
      this.sx = 0;
      this.sy = 0;
      this.Ninja0$Tile0$body.set$gravityScale(0);
      this.Ninja0$Tile0$body.set$collideWorldBounds(false);
      if (J.$gt$n(this.id, 0)) {
        t1 = this.id;
        if (J.$eq(t1, 0)) {
          this.id = 0;
          this.updateType$0();
        } else {
          this.id = t1;
          this.updateType$0();
        }
      }
    },
    static: {"^": "Tile_EMPTY,Tile_FULL,Tile_SLOPE_45DEGpn,Tile_SLOPE_45DEGnn,Tile_SLOPE_45DEGnp,Tile_SLOPE_45DEGpp,Tile_CONCAVEpn,Tile_CONCAVEnn,Tile_CONCAVEnp,Tile_CONCAVEpp,Tile_CONVEXpn,Tile_CONVEXnn,Tile_CONVEXnp,Tile_CONVEXpp,Tile_SLOPE_22DEGpnS,Tile_SLOPE_22DEGnnS,Tile_SLOPE_22DEGnpS,Tile_SLOPE_22DEGppS,Tile_SLOPE_22DEGpnB,Tile_SLOPE_22DEGnnB,Tile_SLOPE_22DEGnpB,Tile_SLOPE_22DEGppB,Tile_SLOPE_67DEGpnS,Tile_SLOPE_67DEGnnS,Tile_SLOPE_67DEGnpS,Tile_SLOPE_67DEGppS,Tile_SLOPE_67DEGpnB,Tile_SLOPE_67DEGnnB,Tile_SLOPE_67DEGnpB,Tile_SLOPE_67DEGppB,Tile_HALFd,Tile_HALFr,Tile_HALFu,Tile_HALFl,Tile_TYPE_EMPTY,Tile_TYPE_FULL,Tile_TYPE_45DEG,Tile_TYPE_CONCAVE,Tile_TYPE_CONVEX,Tile_TYPE_22DEGs,Tile_TYPE_22DEGb,Tile_TYPE_67DEGs,Tile_TYPE_67DEGb,Tile_TYPE_HALF"}
  },
  "+Tile": 0
}],
["PIXI", "package:play_pixi/pixi.dart", , M, {
  "^": "",
  determineMatrixArrayType: [function() {
    return C.Type_Art;
  }, "call$0", "determineMatrixArrayType$closure", 0, 0, 12, "determineMatrixArrayType"],
  binarySearch: [function(values, target, step) {
    var t1, high, current, low, low0;
    t1 = J.getInterceptor$asx(values);
    high = J.floor$0$n(J.$div$n(t1.get$length(values), step)) - 2;
    if (high === 0)
      return step;
    current = C.JSInt_methods._shrOtherPositive$1(high, 1);
    for (low = 0; true;) {
      low0 = current + 1;
      if (typeof step !== "number")
        return H.iae(step);
      if (J.$le$n(t1.$index(values, low0 * step), target))
        low = low0;
      else
        high = current;
      if (low === high)
        return (low + 1) * step;
      current = C.JSInt_methods._shrOtherPositive$1(low + high, 1);
    }
  }, "call$3", "binarySearch$closure", 6, 0, 56, 57, [], 58, [], 59, [], "binarySearch"],
  linearSearch: [function(values, target, step) {
    var t1, last, i;
    t1 = J.getInterceptor$asx(values);
    last = J.$sub$n(t1.get$length(values), step);
    if (typeof last !== "number")
      return H.iae(last);
    i = 0;
    while (i <= last) {
      if (J.$gt$n(t1.$index(values, i), target))
        return i;
      if (typeof step !== "number")
        return H.iae(step);
      i += step;
    }
    return -1;
  }, "call$3", "linearSearch$closure", 6, 0, 56, 57, [], 58, [], 59, [], "linearSearch"],
  CompileVertexShader: [function(gl, shaderSrc) {
    return M._CompileShader(gl, shaderSrc, 35633);
  }, "call$2", "CompileVertexShader$closure", 4, 0, 142, 122, [], 143, [], "CompileVertexShader"],
  CompileFragmentShader: [function(gl, shaderSrc) {
    return M._CompileShader(gl, shaderSrc, 35632);
  }, "call$2", "CompileFragmentShader$closure", 4, 0, 142, 122, [], 143, [], "CompileFragmentShader"],
  _CompileShader: [function(gl, shaderSrc, shaderType) {
    var src, t1, shader;
    src = J.join$1$ax(shaderSrc, "\n");
    t1 = J.getInterceptor$x(gl);
    shader = t1.createShader$1(gl, shaderType);
    t1.shaderSource$2(gl, shader, src);
    t1.compileShader$1(gl, shader);
    if (t1.getShaderParameter$2(gl, shader, 35713) == null) {
      window;
      t1 = t1.getShaderInfoLog$1(gl, shader);
      if (typeof console != "undefined")
        console.log(t1);
      return;
    }
    return shader;
  }, "call$3", "_CompileShader$closure", 6, 0, 144, 122, [], 143, [], 145, [], "_CompileShader"],
  compileProgram: [function(gl, vertexSrc, fragmentSrc) {
    var fragmentShader, vertexShader, t1, shaderProgram;
    fragmentShader = M._CompileShader(gl, fragmentSrc, 35632);
    vertexShader = M._CompileShader(gl, vertexSrc, 35633);
    t1 = J.getInterceptor$x(gl);
    shaderProgram = t1.createProgram$0(gl);
    t1.attachShader$2(gl, shaderProgram, vertexShader);
    t1.attachShader$2(gl, shaderProgram, fragmentShader);
    t1.linkProgram$1(gl, shaderProgram);
    if (t1.getProgramParameter$2(gl, shaderProgram, 35714) == null) {
      window;
      if (typeof console != "undefined")
        console.log("Could not initialise shaders");
    }
    return shaderProgram;
  }, "call$3", "compileProgram$closure", 6, 0, 146, 122, [], 147, [], 148, [], "compileProgram"],
  createWebGLTexture: [function(texture, gl) {
    var t1;
    if (texture.get$hasLoaded() === true) {
      t1 = J.getInterceptor$x(gl);
      J.$indexSet$ax(texture.get$_glTextures(), gl, t1.createTexture$0(gl));
      t1.bindTexture$2(gl, 3553, J.$index$asx(texture.get$_glTextures(), gl));
      t1.pixelStorei$2(gl, 37441, texture.get$premultipliedAlpha() === true ? 1 : 0);
      t1.texImage2D$6(gl, 3553, 0, 6408, 6408, 5121, J.get$source$x(texture));
      t1.texParameteri$3(gl, 3553, 10240, J.$eq(texture.get$scaleMode(), C.scaleModes_1) ? 9729 : 9728);
      t1.texParameteri$3(gl, 3553, 10241, J.$eq(texture.get$scaleMode(), C.scaleModes_1) ? 9729 : 9728);
      if (texture.get$_powerOf2() !== true) {
        t1.texParameteri$3(gl, 3553, 10242, 33071);
        t1.texParameteri$3(gl, 3553, 10243, 33071);
      } else {
        t1.texParameteri$3(gl, 3553, 10242, 10497);
        t1.texParameteri$3(gl, 3553, 10243, 10497);
      }
      t1.bindTexture$2(gl, 3553, null);
      J.$indexSet$ax(texture.get$_dirty(), gl, false);
    }
    return J.$index$asx(texture.get$_glTextures(), gl);
  }, "call$2", "createWebGLTexture$closure", 4, 0, 152, 28, [], 122, [], "createWebGLTexture"],
  updateWebGLTexture: [function(texture, gl) {
    var t1;
    if (J.$index$asx(texture.get$_glTextures(), gl) != null) {
      t1 = J.getInterceptor$x(gl);
      t1.bindTexture$2(gl, 3553, J.$index$asx(texture.get$_glTextures(), gl));
      t1.pixelStorei$2(gl, 37441, texture.get$premultipliedAlpha() === true ? 1 : 0);
      t1.texImage2D$6(gl, 3553, 0, 6408, 6408, 5121, J.get$source$x(texture));
      t1.texParameteri$3(gl, 3553, 10240, J.$eq(texture.get$scaleMode(), C.scaleModes_1) ? 9729 : 9728);
      t1.texParameteri$3(gl, 3553, 10241, J.$eq(texture.get$scaleMode(), C.scaleModes_1) ? 9729 : 9728);
      if (texture.get$_powerOf2() !== true) {
        t1.texParameteri$3(gl, 3553, 10242, 33071);
        t1.texParameteri$3(gl, 3553, 10243, 33071);
      } else {
        t1.texParameteri$3(gl, 3553, 10242, 10497);
        t1.texParameteri$3(gl, 3553, 10243, 10497);
      }
      J.$indexSet$ax(texture.get$_dirty(), gl, false);
    }
  }, "call$2", "updateWebGLTexture$closure", 4, 0, 152, 28, [], 122, [], "updateWebGLTexture"],
  autoDetectRenderer: [function(width, height, view, transparent, antialias) {
    if (J.getContext3d$0$x(W.CanvasElement_CanvasElement(null, null)) != null)
      return M.WebGLRenderer$(width, height, view, transparent, antialias, false);
    else
      return M.CanvasRenderer$(width, height, view, transparent, false);
  }, function() {
    return M.autoDetectRenderer(800, 600, null, false, false);
  }, null, function(width) {
    return M.autoDetectRenderer(width, 600, null, false, false);
  }, null, function(width, height) {
    return M.autoDetectRenderer(width, height, null, false, false);
  }, null, function(width, height, view) {
    return M.autoDetectRenderer(width, height, view, false, false);
  }, null, function(width, height, view, transparent) {
    return M.autoDetectRenderer(width, height, view, transparent, false);
  }, null, "call$5", "call$0", "call$1", "call$2", "call$3", "call$4", "autoDetectRenderer$closure", 0, 10, 186, 106, 107, 32, 95, 95, 10, [], 11, [], 108, [], 109, [], 110, [], "autoDetectRenderer"],
  hex2rgb: [function(hex) {
    var t1 = J.getInterceptor$n(hex);
    return [(t1.$shr(hex, 16) & 255) / 255, (t1.$shr(hex, 8) & 255) / 255, t1.$and(hex, 255) / 255];
  }, "call$1", "hex2rgb$closure", 2, 0, 204, 205, [], "hex2rgb"],
  rgb2hex: [function(rgb) {
    var t1, t2, t3;
    t1 = J.getInterceptor$asx(rgb);
    t2 = J.floor$0$n(J.$mul$ns(t1.$index(rgb, 0), 255));
    if (typeof t2 !== "number")
      return t2.$shl();
    t3 = J.floor$0$n(J.$mul$ns(t1.$index(rgb, 1), 255));
    if (typeof t3 !== "number")
      return t3.$shl();
    t1 = J.$mul$ns(t1.$index(rgb, 2), 255);
    if (typeof t1 !== "number")
      return H.iae(t1);
    return (t2 << 16 >>> 0) + (t3 << 8 >>> 0) + t1;
  }, "call$1", "rgb2hex$closure", 2, 0, 206, 207, [], "rgb2hex"],
  AjaxRequest: [function() {
    return new XMLHttpRequest();
  }, "call$0", "AjaxRequest$closure", 0, 0, 208, "AjaxRequest"],
  canUseNewCanvasBlendModes: [function() {
    var canvas, context, t1;
    canvas = H.interceptedTypeCast(document.createElement("canvas", null), "$isCanvasElement");
    canvas.width = 1;
    canvas.height = 1;
    context = J.getContext$1$x(canvas, "2d");
    t1 = J.getInterceptor$x(context);
    t1.set$fillStyle(context, "#000");
    t1.fillRect$4(context, 0, 0, 1, 1);
    t1.set$globalCompositeOperation(context, "multiply");
    t1.set$fillStyle(context, "#fff");
    t1.fillRect$4(context, 0, 0, 1, 1);
    t1 = J.get$data$x(t1.getImageData$4(context, 0, 0, 1, 1));
    if (0 >= t1.length)
      return H.ioore(t1, 0);
    return t1[0] === 0;
  }, "call$0", "canUseNewCanvasBlendModes$closure", 0, 0, 209, "canUseNewCanvasBlendModes"],
  getNextPowerOfTwo: [function(number) {
    var t1, result;
    t1 = J.getInterceptor$n(number);
    if (t1.$gt(number, 0) && t1.$and(number, t1.$sub(number, 1)) === 0)
      return number;
    else {
      if (typeof number !== "number")
        return H.iae(number);
      result = 1;
      for (; result < number;)
        result = result << 1 >>> 0;
      return result;
    }
  }, "call$1", "getNextPowerOfTwo$closure", 2, 0, 210, 211, [], "getNextPowerOfTwo"],
  Circle: {
    "^": "Shape;x*-601,y*-601,radius@-601",
    clone$0: [function(_) {
      return new M.Circle(this.get$x(this), this.get$y(this), this.get$radius());
    }, "call$0", "get$clone", 0, 0, 624, "clone"],
    contains$2: [function(_, x, y) {
      var dx, dy, r2;
      if (J.$le$n(this.get$radius(), 0))
        return false;
      dx = J.$sub$n(this.get$x(this), x);
      dy = J.$sub$n(this.get$y(this), y);
      r2 = J.$mul$ns(this.get$radius(), this.get$radius());
      return J.$le$n(J.$add$ns(J.$mul$ns(dx, dx), J.$mul$ns(dy, dy)), r2);
    }, "call$2", "get$contains", 4, 0, 625, 6, [], 7, [], "contains"],
    getBounds$0: [function() {
      var t1, t2, t3, t4;
      t1 = J.$sub$n(this.get$x(this), this.get$radius());
      t2 = J.$sub$n(this.get$y(this), this.get$radius());
      t3 = this.get$radius();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = this.get$radius();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return new M.Rectangle0(t1, t2, 2 * t3, 2 * t4);
    }, "call$0", "get$getBounds", 0, 0, 626, "getBounds"],
    static: {Circle$0: [function(x, y, radius) {
        return new M.Circle(x, y, radius);
      }, null, null, 0, 6, 4, 5, 5, 5, 6, [], 7, [], 8, [], "new Circle"]}
  },
  "+Circle": [627],
  Ellipse: {
    "^": "Shape;x*-601,y*-601,width*-601,height*-601",
    clone$0: [function(_) {
      return new M.Ellipse(this.get$x(this), this.get$y(this), this.get$width(this), this.get$height(this));
    }, "call$0", "get$clone", 0, 0, 628, "clone"],
    contains$2: [function(_, x, y) {
      var normx, normy;
      if (J.$le$n(this.get$width(this), 0) || J.$le$n(this.get$height(this), 0))
        return false;
      normx = J.$div$n(J.$sub$n(x, this.get$x(this)), this.get$width(this));
      normy = J.$div$n(J.$sub$n(y, this.get$y(this)), this.get$height(this));
      return J.$le$n(J.$add$ns(J.$mul$ns(normx, normx), J.$mul$ns(normy, normy)), 1);
    }, "call$2", "get$contains", 4, 0, 625, 6, [], 7, [], "contains"],
    getBounds$0: [function() {
      return new M.Rectangle0(J.$sub$n(this.get$x(this), this.get$width(this)), J.$sub$n(this.get$y(this), this.get$height(this)), this.get$width(this), this.get$height(this));
    }, "call$0", "get$getBounds", 0, 0, 626, "getBounds"],
    static: {Ellipse$: [function(x, y, width, height) {
        return new M.Ellipse(x, y, width, height);
      }, null, null, 0, 8, 9, 5, 5, 5, 5, 6, [], 7, [], 10, [], 11, [], "new Ellipse"]}
  },
  "+Ellipse": [627],
  Matrix: {
    "^": "Object;a*-629,b@-629,c@-629,d@-629,tx@-629,ty@-629,array@-630",
    $index: [function(_, i) {
      return J.$index$asx(this.array, i);
    }, "call$1", "get$[]", 2, 0, 534, 381, [], "[]"],
    toArray$1: [function(transpose) {
      var array, t1, t2;
      array = this.array;
      t1 = J.getInterceptor$ax(array);
      t2 = this.a;
      if (transpose === true) {
        t1.$indexSet(array, 0, t2);
        t1.$indexSet(array, 1, this.c);
        t1.$indexSet(array, 2, 0);
        t1.$indexSet(array, 3, this.b);
        t1.$indexSet(array, 4, this.d);
        t1.$indexSet(array, 5, 0);
        t1.$indexSet(array, 6, this.tx);
        t1.$indexSet(array, 7, this.ty);
        t1.$indexSet(array, 8, 1);
      } else {
        t1.$indexSet(array, 0, t2);
        t1.$indexSet(array, 1, this.b);
        t1.$indexSet(array, 2, this.tx);
        t1.$indexSet(array, 3, this.c);
        t1.$indexSet(array, 4, this.d);
        t1.$indexSet(array, 5, this.ty);
        t1.$indexSet(array, 6, 0);
        t1.$indexSet(array, 7, 0);
        t1.$indexSet(array, 8, 1);
      }
      return array;
    }, "call$1", "get$toArray", 2, 0, 631, 597, [], "toArray"],
    Matrix$fromArray$1: function(array) {
      var t1 = J.getInterceptor$asx(array);
      this.a = t1.$index(array, 0);
      this.b = t1.$index(array, 1);
      this.c = t1.$index(array, 3);
      this.d = t1.$index(array, 4);
      this.tx = t1.$index(array, 2);
      this.ty = t1.$index(array, 5);
    },
    static: {Matrix$: [function() {
        return new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9));
      }, null, null, 0, 0, 13, "new Matrix"], Matrix$fromArray: [function(array) {
        var t1 = new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9));
        t1.Matrix$fromArray$1(array);
        return t1;
      }, null, null, 2, 0, 14, 15, [], "new Matrix$fromArray"]}
  },
  "+Matrix": [632],
  Point0: {
    "^": "Object;x*-601,y*-601",
    clone$0: [function(_) {
      var t1, t2, t3;
      t1 = this.x;
      t2 = this.y;
      t3 = new M.Point0(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, "call$0", "get$clone", 0, 0, 13, "clone"],
    set$2: [function(x, y) {
      this.x = x;
      this.y = y == null ? x : y;
    }, function(x) {
      return this.set$2(x, null);
    }, "set$1", function() {
      return this.set$2(0, null);
    }, "set$0", "call$2", "call$1", "call$0", "get$set", 0, 4, 16, 5, 32, 6, [], 7, [], "set"],
    static: {Point$: [function(x, y) {
        var t1 = new M.Point0(null, null);
        t1.x = x;
        t1.y = y;
        return t1;
      }, null, null, 0, 4, 16, 5, 5, 6, [], 7, [], "new Point"]}
  },
  "+Point": [632],
  Polygon: {
    "^": "Shape;points*-633",
    clone$0: [function(_) {
      var points, i, t1;
      points = [];
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.points);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        points.push(J.clone$0$x(J.$index$asx(this.points, i)));
        ++i;
      }
      return M.Polygon$(points);
    }, "call$0", "get$clone", 0, 0, 13, "clone"],
    contains$2: [function(_, x, y) {
      var j, t1, t2, inside, i, t3, xi, yi, xj, yj, i0;
      j = J.$sub$n(J.get$length$asx(this.points), 1);
      t1 = J.getInterceptor$n(y);
      t2 = J.getInterceptor$n(x);
      inside = false;
      i = 0;
      while (true) {
        t3 = J.get$length$asx(this.points);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        xi = J.get$x$x(J.$index$asx(this.points, i));
        yi = J.get$y$x(J.$index$asx(this.points, i));
        xj = J.get$x$x(J.$index$asx(this.points, j));
        yj = J.get$y$x(J.$index$asx(this.points, j));
        t3 = J.getInterceptor$n(yj);
        if (J.$gt$n(yi, y) !== t3.$gt(yj, y) && t2.$lt(x, J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(xj, xi), t1.$sub(y, yi)), t3.$sub(yj, yi)), xi)))
          inside = !inside;
        i0 = i + 1;
        j = i;
        i = i0;
      }
      return inside;
    }, "call$2", "get$contains", 4, 0, 111, 6, [], 7, [], "contains"],
    Polygon$1: function(points) {
      var t1, t2, p, il, i, t3, t4;
      t1 = J.getInterceptor$asx(points);
      t2 = t1.$index(points, 0);
      if (typeof t2 === "number") {
        p = [];
        il = t1.get$length(points);
        if (typeof il !== "number")
          return H.iae(il);
        i = 0;
        for (; i < il; i += 2) {
          t2 = t1.$index(points, i);
          t3 = t1.$index(points, i + 1);
          t4 = new M.Point0(null, null);
          t4.x = t2;
          t4.y = t3;
          p.push(t4);
        }
        points = p;
      }
      this.points = points;
    },
    static: {Polygon$: [function(points) {
        var t1 = new M.Polygon(null);
        t1.Polygon$1(points);
        return t1;
      }, null, null, 2, 0, 14, 17, [], "new Polygon"]}
  },
  "+Polygon": [627],
  Rectangle0: {
    "^": "Shape;x*-601,y*-601,width*-601,height*-601",
    clone$0: [function(_) {
      return new M.Rectangle0(this.get$x(this), this.get$y(this), this.get$width(this), this.get$height(this));
    }, "call$0", "get$clone", 0, 0, 626, "clone"],
    contains$2: [function(_, x, y) {
      var x1, t1, y1;
      if (J.$le$n(this.get$width(this), 0) || J.$le$n(this.get$height(this), 0))
        return false;
      x1 = this.get$x(this);
      t1 = J.getInterceptor$n(x);
      if (t1.$ge(x, x1) && t1.$le(x, J.$add$ns(x1, this.get$width(this)))) {
        y1 = this.get$y(this);
        t1 = J.getInterceptor$n(y);
        if (t1.$ge(y, y1) && t1.$le(y, J.$add$ns(y1, this.get$height(this))))
          return true;
      }
      return false;
    }, "call$2", "get$contains", 4, 0, 625, 6, [], 7, [], "contains"],
    static: {Rectangle$0: [function(x, y, width, height) {
        return new M.Rectangle0(x, y, width, height);
      }, null, null, 0, 8, 9, 5, 5, 5, 5, 6, [], 7, [], 10, [], 11, [], "new Rectangle"]}
  },
  "+Rectangle": [627],
  Shape: {
    "^": "Object;",
    static: {Shape$: [function() {
        return new M.Shape();
      }, null, null, 0, 0, 18, "new Shape"]}
  },
  "+Shape": [632],
  DisplayInterface: {
    "^": "Object;hitArea@-627",
    static: {DisplayInterface$: [function() {
        return new M.DisplayInterface(null);
      }, null, null, 0, 0, 19, "new DisplayInterface"]}
  },
  "+DisplayInterface": [632],
  DisplayObject: {
    "^": "Object;position*-634,scale*-634,pivot@-634,rotation@-601,alpha*-601,visible@-602,hitArea@-627,buttonMode@-602,renderable@-602,_parent@-635,__hit@-602,__isOver@-602,__mouseIsDown@-602,__isDown@-602,_dirty@-602,click*-636,mousemove@-636,mousedown@-636,mouseout@-636,mouseover@-636,mouseup@-636,mouseupoutside@-636,touchmove@-636,touchstart@-636,touchend@-636,tap@-636,touchendoutside@-636,__touchData@-637,_stage@-638,_worldAlpha@-601,_interactive@-602,defaultCursor@-639,_worldTransform@-640,_sr@-601,_cr@-601,filterArea@-641,_bounds@-641,_currentBounds@-641,_mask@-642,_cacheAsBitmap@-602,_cachedSprite@-643,_cacheIsDirty@-602,_filterBlock@-644,_filters@-645,_rotationCache@-601",
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    get$parent: [function(_) {
      return this._parent;
    }, null, null, 1, 0, 19, "parent"],
    click$1: function($receiver, arg0) {
      return this.click.call$1(arg0);
    },
    mousemove$1: function(arg0) {
      return this.mousemove.call$1(arg0);
    },
    mousedown$1: function(arg0) {
      return this.mousedown.call$1(arg0);
    },
    mouseout$1: function(arg0) {
      return this.mouseout.call$1(arg0);
    },
    mouseover$1: function(arg0) {
      return this.mouseover.call$1(arg0);
    },
    mouseup$1: function(arg0) {
      return this.mouseup.call$1(arg0);
    },
    mouseupoutside$1: function(arg0) {
      return this.mouseupoutside.call$1(arg0);
    },
    touchmove$1: function(arg0) {
      return this.touchmove.call$1(arg0);
    },
    touchstart$1: function(arg0) {
      return this.touchstart.call$1(arg0);
    },
    touchend$1: function(arg0) {
      return this.touchend.call$1(arg0);
    },
    tap$1: function(arg0) {
      return this.tap.call$1(arg0);
    },
    touchendoutside$1: function(arg0) {
      return this.touchendoutside.call$1(arg0);
    },
    get$stage: [function() {
      return this._stage;
    }, null, null, 1, 0, 646, "stage"],
    get$worldAlpha: [function() {
      return this._worldAlpha;
    }, null, null, 1, 0, 604, "worldAlpha"],
    get$interactive: [function() {
      return this._interactive;
    }, null, null, 1, 0, 209, "interactive"],
    set$interactive: [function(value) {
      var t1;
      this._interactive = value;
      t1 = this._stage;
      if (t1 != null)
        t1.set$_dirty(true);
    }, null, null, 3, 0, 63, 100, [], "interactive"],
    get$worldTransform: [function() {
      return this.get$_worldTransform();
    }, null, null, 1, 0, 647, "worldTransform"],
    get$mask: [function(_) {
      return this._mask;
    }, null, null, 1, 0, 648, "mask"],
    set$mask: [function(_, value) {
      var t1 = this._mask;
      if (t1 != null)
        t1.set$_isMask(false);
      this._mask = value;
      if (value != null)
        value.set$_isMask(true);
    }, null, null, 3, 0, 649, 100, [], "mask"],
    get$cacheAsBitmap: [function() {
      return this._cacheAsBitmap;
    }, null, null, 1, 0, 209, "cacheAsBitmap"],
    set$cacheAsBitmap: [function(value) {
      if (J.$eq(this._cacheAsBitmap, value))
        return;
      if (value === true)
        this._generateCachedSprite$0();
      else
        this._destroyCachedSprite$0();
      this._cacheAsBitmap = value;
    }, null, null, 3, 0, 650, 100, [], "cacheAsBitmap"],
    get$worldVisible: [function() {
      var item = this;
      do {
        if (item.get$visible() !== true)
          return false;
        item = item.get$_parent();
      } while (item != null);
      return true;
    }, null, null, 1, 0, 209, "worldVisible"],
    get$filters: [function() {
      return this._filters;
    }, null, null, 1, 0, 651, "filters"],
    set$filters: [function(value) {
      var passes, t1, i, t2, filterPasses, j, t3;
      if (value != null) {
        passes = [];
        t1 = J.getInterceptor$asx(value);
        i = 0;
        while (true) {
          t2 = t1.get$length(value);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          filterPasses = t1.$index(value, i).get$passes();
          t2 = J.getInterceptor$asx(filterPasses);
          j = 0;
          while (true) {
            t3 = t2.get$length(filterPasses);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(j < t3))
              break;
            passes.push(t2.$index(filterPasses, j));
            ++j;
          }
          ++i;
        }
        J.set$target$x(this._filterBlock, this);
        this._filterBlock.set$filterPasses(passes);
      }
      this._filters = value;
    }, null, null, 3, 0, 652, 100, [], "filters"],
    updateTransform$0: [function() {
      var t1, $parent, parentTransform, worldTransform, px, py, a00, a01, a10, a11, a02, a12, b00, b01, b10, b11, t2;
      if (!J.$eq(this.rotation, this._rotationCache)) {
        t1 = this.rotation;
        this._rotationCache = t1;
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        this._sr = Math.sin(t1);
        t1 = this.rotation;
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        this._cr = Math.cos(t1);
      }
      $parent = this._parent;
      parentTransform = $parent.get$_worldTransform();
      worldTransform = this.get$_worldTransform();
      px = J.get$x$x(this.pivot);
      py = J.get$y$x(this.pivot);
      a00 = J.$mul$ns(this._cr, J.get$x$x(this.scale));
      a01 = J.$mul$ns(J.$negate$n(this._sr), J.get$y$x(this.scale));
      a10 = J.$mul$ns(this._sr, J.get$x$x(this.scale));
      a11 = J.$mul$ns(this._cr, J.get$y$x(this.scale));
      a02 = J.$sub$n(J.$sub$n(J.get$x$x(this.get$position(this)), J.$mul$ns(a00, px)), J.$mul$ns(py, a01));
      a12 = J.$sub$n(J.$sub$n(J.get$y$x(this.get$position(this)), J.$mul$ns(a11, py)), J.$mul$ns(px, a10));
      b00 = J.get$a$x(parentTransform);
      b01 = parentTransform.get$b();
      b10 = parentTransform.get$c();
      b11 = parentTransform.get$d();
      t1 = J.getInterceptor$ns(b00);
      t2 = J.getInterceptor$ns(b01);
      J.set$a$x(worldTransform, J.$add$ns(t1.$mul(b00, a00), t2.$mul(b01, a10)));
      worldTransform.set$b(J.$add$ns(t1.$mul(b00, a01), t2.$mul(b01, a11)));
      worldTransform.set$tx(J.$add$ns(J.$add$ns(t1.$mul(b00, a02), t2.$mul(b01, a12)), parentTransform.get$tx()));
      t2 = J.getInterceptor$ns(b10);
      t1 = J.getInterceptor$ns(b11);
      worldTransform.set$c(J.$add$ns(t2.$mul(b10, a00), t1.$mul(b11, a10)));
      worldTransform.set$d(J.$add$ns(t2.$mul(b10, a01), t1.$mul(b11, a11)));
      worldTransform.set$ty(J.$add$ns(J.$add$ns(t2.$mul(b10, a02), t1.$mul(b11, a12)), parentTransform.get$ty()));
      this._worldAlpha = J.$mul$ns(this.alpha, $parent.get$_worldAlpha());
    }, "call$0", "get$updateTransform", 0, 0, 550, "updateTransform"],
    getBounds$1: [function(matrix) {
      return $.get$EmptyRectangle();
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 653, 32, 537, [], "getBounds"],
    getLocalBounds$0: [function() {
      return this.getBounds$1($.get$IdentityMatrix());
    }, "call$0", "get$getLocalBounds", 0, 0, 626, "getLocalBounds"],
    _setStageReference$1: [function(stage) {
      this._stage = stage;
      if (this._interactive === true)
        stage.set$_dirty(true);
    }, "call$1", "get$_setStageReference", 2, 0, 92, 93, [], "_setStageReference"],
    generateTexture$1: [function(renderer) {
      var bounds, t1, renderTexture, t2, t3;
      bounds = this.getLocalBounds$0();
      t1 = J.getInterceptor$x(bounds);
      renderTexture = M.RenderTexture$0(J.floor$0$n(t1.get$width(bounds)), J.floor$0$n(t1.get$height(bounds)), renderer, C.scaleModes_0);
      t2 = J.$negate$n(t1.get$x(bounds));
      t1 = J.$negate$n(t1.get$y(bounds));
      t3 = new M.Point0(null, null);
      t3.x = t2;
      t3.y = t1;
      renderTexture.render$2(this, t3);
      return renderTexture;
    }, "call$1", "get$generateTexture", 2, 0, 654, 175, [], "generateTexture"],
    updateCache$0: [function() {
      this._generateCachedSprite$0();
    }, "call$0", "get$updateCache", 0, 0, 13, "updateCache"],
    _renderCachedSprite$1: [function(renderSession) {
      var t1, t2;
      this._cachedSprite.set$_worldAlpha(this._worldAlpha);
      t1 = renderSession.get$gl();
      t2 = this._cachedSprite;
      if (t1 != null)
        t2._renderWebGL$1(renderSession);
      else
        t2._renderCanvas$1(renderSession);
    }, "call$1", "get$_renderCachedSprite", 2, 0, 655, 128, [], "_renderCachedSprite"],
    _generateCachedSprite$0: [function() {
      var bounds, t1, t2, renderTexture, t3, t4, t5, tempFilters, texture;
      this._cacheAsBitmap = false;
      bounds = this.getLocalBounds$0();
      t1 = this._cachedSprite;
      t2 = J.getInterceptor$x(bounds);
      if (t1 == null) {
        renderTexture = M.RenderTexture$0(J.floor$0$n(t2.get$width(bounds)), J.floor$0$n(t2.get$height(bounds)), null, C.scaleModes_0);
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new M.Sprite(t1, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t5, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.texture = renderTexture;
        t1._setupTexture$0();
        this._cachedSprite = t1;
        t1._worldTransform = this.get$_worldTransform();
      } else
        H.interceptedTypeCast(t1.get$texture(), "$isRenderTexture0").resize$2(0, J.floor$0$n(t2.get$width(bounds)), J.floor$0$n(t2.get$height(bounds)));
      tempFilters = this._filters;
      this._filters = null;
      this._cachedSprite.set$filters(tempFilters);
      texture = H.interceptedTypeCast(this._cachedSprite.get$texture(), "$isRenderTexture0");
      t1 = J.getInterceptor$x(bounds);
      t2 = J.$negate$n(t1.get$x(bounds));
      t3 = J.$negate$n(t1.get$y(bounds));
      t4 = new M.Point0(null, null);
      t4.x = t2;
      t4.y = t3;
      texture.render$3(this, t4, false);
      J.set$x$x(this._cachedSprite.get$anchor(), J.$negate$n(J.$div$n(t1.get$x(bounds), t1.get$width(bounds))));
      J.set$y$x(this._cachedSprite.get$anchor(), J.$negate$n(J.$div$n(t1.get$y(bounds), t1.get$height(bounds))));
      this._filters = tempFilters;
      this._cacheAsBitmap = true;
    }, "call$0", "get$_generateCachedSprite", 0, 0, 550, "_generateCachedSprite"],
    _destroyCachedSprite$0: [function() {
      var t1 = this._cachedSprite;
      if (t1 == null)
        return;
      t1.get$texture().destroy$1(true);
      this._cachedSprite = null;
    }, "call$0", "get$_destroyCachedSprite", 0, 0, 550, "_destroyCachedSprite"],
    _renderWebGL$1: [function(renderSession) {
    }, "call$1", "get$_renderWebGL", 2, 0, 656, 128, [], "_renderWebGL"],
    _renderCanvas$1: [function(renderSession) {
    }, "call$1", "get$_renderCanvas", 2, 0, 554, 128, [], "_renderCanvas"],
    get$x: [function(_) {
      return J.get$x$x(this.get$position(this));
    }, null, null, 1, 0, 604, "x"],
    set$x: [function(_, value) {
      J.set$x$x(this.get$position(this), value);
    }, null, null, 3, 0, 569, 100, [], "x"],
    get$y: [function(_) {
      return J.get$y$x(this.get$position(this));
    }, null, null, 1, 0, 604, "y"],
    set$y: [function(_, value) {
      J.set$y$x(this.get$position(this), value);
    }, null, null, 3, 0, 569, 100, [], "y"],
    $isDisplayObject: true,
    static: {DisplayObject$: [function() {
        var t1, t2, t3, t4;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 1;
        t2.y = 1;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        return new M.DisplayObject(t1, t2, t3, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t4, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
      }, null, null, 0, 0, 20, "new DisplayObject"]}
  },
  "+DisplayObject": [632, 635],
  DisplayObjectContainer: {
    "^": "DisplayObject;children>-657,interactiveChildren@-602,_width@-601,_height@-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    get$width: [function(_) {
      return J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.getLocalBounds$0()));
    }, null, null, 1, 0, 604, "width"],
    set$width: [function(_, value) {
      var width, t1, t2;
      width = J.get$width$x(this.getLocalBounds$0());
      t1 = J.$eq(width, 0);
      t2 = this.scale;
      if (!t1)
        J.set$x$x(t2, J.$div$n(value, width));
      else
        J.set$x$x(t2, 1);
      this.set$_width(value);
    }, null, null, 3, 0, 605, 100, [], "width"],
    get$height: [function(_) {
      return J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.getLocalBounds$0()));
    }, null, null, 1, 0, 604, "height"],
    set$height: [function(_, value) {
      var height, t1, t2;
      height = J.get$height$x(this.getLocalBounds$0());
      t1 = J.$eq(height, 0);
      t2 = this.scale;
      if (!t1)
        J.set$y$x(t2, J.$div$n(value, height));
      else
        J.set$y$x(t2, 1);
      this.set$_height(value);
    }, null, null, 3, 0, 605, 100, [], "height"],
    addChild$1: [function(child) {
      return this.addChildAt$2(child, J.get$length$asx(this.get$children(this)));
    }, "call$1", "get$addChild", 2, 0, 658, 659, [], "addChild"],
    addChildAt$2: [function(child, index) {
      var t1;
      H.interceptedTypeCast(child, "$isDisplayObject");
      t1 = J.getInterceptor$n(index);
      if (t1.$ge(index, 0) && t1.$le(index, J.get$length$asx(this.get$children(this)))) {
        t1 = child._parent;
        if (t1 != null) {
          H.interceptedTypeCast(t1, "$isDisplayObjectContainer");
          t1.removeChildAt$1(J.indexOf$1$asx(t1.get$children(t1), child));
        }
        child._parent = this;
        J.insert$2$ax(this.get$children(this), index, child);
        t1 = this._stage;
        if (t1 != null)
          child._setStageReference$1(t1);
        return child;
      } else
        throw H.wrapException(P.Exception_Exception(H.S(child) + "  The index " + H.S(index) + " supplied is out of bounds " + H.S(J.get$length$asx(this.get$children(this)))));
    }, "call$2", "get$addChildAt", 4, 0, 660, 659, [], 243, [], "addChildAt"],
    swapChildren$2: [function(child, child2) {
      var index1, index2;
      if (J.$eq(child, child2))
        return false;
      index1 = J.indexOf$1$asx(this.get$children(this), child);
      index2 = J.indexOf$1$asx(this.get$children(this), child2);
      if (J.$lt$n(index1, 0) || J.$lt$n(index2, 0))
        throw H.wrapException(P.Exception_Exception("swapChildren: Both the supplied DisplayObjects must be a child of the caller."));
      J.$indexSet$ax(this.get$children(this), index1, child2);
      J.$indexSet$ax(this.get$children(this), index2, child);
      return true;
    }, "call$2", "get$swapChildren", 4, 0, 661, 659, [], 662, [], "swapChildren"],
    getChildAt$1: [function(index) {
      var t1 = J.getInterceptor$n(index);
      if (t1.$ge(index, 0) && t1.$lt(index, J.get$length$asx(this.get$children(this))))
        return J.$index$asx(this.get$children(this), index);
      else
        throw H.wrapException(P.Exception_Exception("Supplied index does not exist in the child list, or the supplied DisplayObject must be a child of the caller"));
    }, "call$1", "get$getChildAt", 2, 0, 663, 243, [], "getChildAt"],
    removeChild$1: [function(child) {
      return this.removeChildAt$1(J.indexOf$1$asx(this.get$children(this), child));
    }, "call$1", "get$removeChild", 2, 0, 658, 659, [], "removeChild"],
    removeChildAt$1: [function(index) {
      var child = this.getChildAt$1(index);
      if (this._stage != null && !!J.getInterceptor(child).$isDisplayObjectContainer)
        child._removeStageReference$0();
      child.set$_parent(null);
      J.removeAt$1$ax(this.get$children(this), index);
      return child;
    }, "call$1", "get$removeChildAt", 2, 0, 663, 243, [], "removeChildAt"],
    removeChildren$2: [function(begin, end) {
      var range, t1, removed, child;
      if (end == null)
        end = J.get$length$asx(this.get$children(this));
      range = J.$sub$n(end, begin);
      t1 = J.getInterceptor$n(range);
      if (t1.$gt(range, 0) && t1.$le(range, end)) {
        removed = J.getRange$2$ax(this.get$children(this), begin, range);
        J.removeRange$2$ax(this.get$children(this), begin, range);
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(removed, removed.get$length(removed), 0, null), [H.getRuntimeTypeArgument(removed, "ListIterable", 0)]); t1.moveNext$0();) {
          child = t1._current;
          child.set$_stage(null);
          child.set$_parent(null);
        }
        return removed;
      } else
        throw H.wrapException(P.Exception_Exception("Range Error, numeric values are outside the acceptable range"));
    }, function() {
      return this.removeChildren$2(0, null);
    }, "removeChildren$0", function(begin) {
      return this.removeChildren$2(begin, null);
    }, "removeChildren$1", "call$2", "call$0", "call$1", "get$removeChildren", 0, 4, 664, 5, 32, 665, [], 666, [], "removeChildren"],
    updateTransform$0: [function() {
      var j, i;
      if (this.visible !== true)
        return;
      M.DisplayObject.prototype.updateTransform$0.call(this);
      if (this._cacheAsBitmap === true)
        return;
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i).updateTransform$0();
    }, "call$0", "get$updateTransform", 0, 0, 13, "updateTransform"],
    getBounds$1: [function(matrix) {
      var matrixCache, j, minX, minY, maxX, maxY, childBounds, childMaxX, childMaxY, childVisible, i, child, t1, bounds;
      if (J.$eq(J.get$length$asx(this.get$children(this)), 0))
        return $.get$EmptyRectangle();
      if (matrix != null) {
        matrixCache = this.get$_worldTransform();
        this.set$_worldTransform(matrix);
        this.updateTransform$0();
        this.set$_worldTransform(matrixCache);
      }
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      minX = 1 / 0;
      minY = 1 / 0;
      maxX = -1 / 0;
      maxY = -1 / 0;
      childBounds = null;
      childMaxX = null;
      childMaxY = null;
      childVisible = false;
      i = 0;
      for (; i < j; ++i) {
        child = J.$index$asx(this.get$children(this), i);
        if (child.get$visible() !== true)
          continue;
        childBounds = child.getBounds$1(matrix);
        t1 = J.getInterceptor$x(childBounds);
        minX = J.$lt$n(minX, t1.get$x(childBounds)) ? minX : t1.get$x(childBounds);
        minY = J.$lt$n(minY, t1.get$y(childBounds)) ? minY : t1.get$y(childBounds);
        childMaxX = J.$add$ns(t1.get$width(childBounds), t1.get$x(childBounds));
        childMaxY = J.$add$ns(t1.get$height(childBounds), t1.get$y(childBounds));
        maxX = J.$gt$n(maxX, childMaxX) ? maxX : childMaxX;
        maxY = J.$gt$n(maxY, childMaxY) ? maxY : childMaxY;
        childVisible = true;
      }
      if (!childVisible)
        return $.get$EmptyRectangle();
      bounds = this._bounds;
      t1 = J.getInterceptor$x(bounds);
      t1.set$x(bounds, minX);
      t1.set$y(bounds, minY);
      t1.set$width(bounds, J.$sub$n(maxX, minX));
      t1.set$height(bounds, J.$sub$n(maxY, minY));
      return bounds;
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 653, 32, 537, [], "getBounds"],
    getLocalBounds$0: [function() {
      var matrixCache, j, i, bounds;
      matrixCache = this.get$_worldTransform();
      this.set$_worldTransform($.get$IdentityMatrix());
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i).updateTransform$0();
      bounds = this.getBounds$0();
      this.set$_worldTransform(matrixCache);
      return bounds;
    }, "call$0", "get$getLocalBounds", 0, 0, 626, "getLocalBounds"],
    _setStageReference$1: [function(stage) {
      var j, i;
      this._stage = stage;
      if (this._interactive === true)
        stage.set$_dirty(true);
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i)._setStageReference$1(stage);
    }, "call$1", "get$_setStageReference", 2, 0, 667, 93, [], "_setStageReference"],
    _removeStageReference$0: [function() {
      var j, i;
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i)._removeStageReference$0();
      if (this._interactive === true)
        this._stage.set$_dirty(true);
      this._stage = null;
    }, "call$0", "get$_removeStageReference", 0, 0, 550, "_removeStageReference"],
    _renderWebGL$1: [function(renderSession) {
      var j, i;
      if (this.visible !== true || J.$le$n(this.alpha, 0))
        return;
      if (this._cacheAsBitmap === true) {
        this._renderCachedSprite$1(renderSession);
        return;
      }
      if (this._mask != null || this._filters != null) {
        if (this._filters != null) {
          J.flush$0$x(renderSession.get$spriteBatch());
          renderSession.get$filterManager().pushFilter$1(this._filterBlock);
        }
        if (this._mask != null) {
          J.stop$0$x(renderSession.get$spriteBatch());
          renderSession.get$maskManager().pushMask$2(this._mask, renderSession);
          J.start$0$x(renderSession.get$spriteBatch());
        }
        j = J.get$length$asx(this.get$children(this));
        if (typeof j !== "number")
          return H.iae(j);
        i = 0;
        for (; i < j; ++i)
          J.$index$asx(this.get$children(this), i)._renderWebGL$1(renderSession);
        J.stop$0$x(renderSession.get$spriteBatch());
        if (this._mask != null)
          renderSession.get$maskManager().popMask$2(this._mask, renderSession);
        if (this._filters != null)
          renderSession.get$filterManager().popFilter$0();
        J.start$0$x(renderSession.get$spriteBatch());
      } else {
        j = J.get$length$asx(this.get$children(this));
        if (typeof j !== "number")
          return H.iae(j);
        i = 0;
        for (; i < j; ++i)
          J.$index$asx(this.get$children(this), i)._renderWebGL$1(renderSession);
      }
    }, "call$1", "get$_renderWebGL", 2, 0, 656, 128, [], "_renderWebGL"],
    _renderCanvas$1: [function(renderSession) {
      var j, i;
      if (J.$eq(this.visible, false) || J.$eq(this.alpha, 0))
        return;
      if (this._cacheAsBitmap === true) {
        this._renderCachedSprite$1(renderSession);
        return;
      }
      if (this._mask != null)
        renderSession.get$maskManager().pushMask$2(this._mask, J.get$context$x(renderSession));
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i)._renderCanvas$1(renderSession);
      if (this._mask != null)
        renderSession.get$maskManager().popMask$1(J.get$context$x(renderSession));
    }, "call$1", "get$_renderCanvas", 2, 0, 656, 128, [], "_renderCanvas"],
    $isDisplayObjectContainer: true,
    static: {DisplayObjectContainer$: [function() {
        var t1, t2, t3, t4;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 1;
        t2.y = 1;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        return new M.DisplayObjectContainer([], false, 0, 0, t1, t2, t3, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t4, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
      }, null, null, 0, 0, 21, "new DisplayObjectContainer"]}
  },
  "+DisplayObjectContainer": [668],
  MovieClip: {
    "^": "Sprite;textures@-669,animationSpeed@-601,loop*-602,onComplete*-0,_currentFrame@-601,_playing@-602,anchor-634,texture-670,updateFrame-602,PIXI$Sprite$_width-601,PIXI$Sprite$_height-601,_uvs-671,tintedTexture-672,buffer-673,tint-599,cachedTint-599,blendMode-674,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    loop$0: function($receiver) {
      return this.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return this.loop.call$3(arg0, arg1, arg2);
    },
    onComplete$0: function($receiver) {
      return this.onComplete.call$0();
    },
    get$currentFrame: [function() {
      return this._currentFrame;
    }, null, null, 1, 0, 604, "currentFrame"],
    get$playing: [function() {
      return this._playing;
    }, null, null, 1, 0, 209, "playing"],
    get$totalFrames: [function() {
      return J.get$length$asx(this.textures);
    }, null, null, 1, 0, 367, "totalFrames"],
    stop$0: [function(_) {
      this._playing = false;
    }, "call$0", "get$stop", 0, 0, 13, "stop"],
    play$0: [function(_) {
      this._playing = true;
    }, "call$0", "get$play", 0, 0, 13, "play"],
    gotoAndStop$1: [function(frameNumber) {
      var round, t1, t2, t3;
      this._playing = false;
      this._currentFrame = frameNumber;
      round = J.ceil$0$n(frameNumber);
      t1 = this.textures;
      t2 = J.getInterceptor$asx(t1);
      t3 = t2.get$length(t1);
      if (typeof t3 !== "number")
        return H.iae(t3);
      this.texture = t2.$index(t1, C.JSInt_methods.$mod(round, t3));
      this.cachedTint = 16777215;
    }, "call$1", "get$gotoAndStop", 2, 0, 60, 675, [], "gotoAndStop"],
    gotoAndPlay$1: [function(frameNumber) {
      this._currentFrame = frameNumber;
      this._playing = true;
    }, "call$1", "get$gotoAndPlay", 2, 0, 60, 675, [], "gotoAndPlay"],
    updateTransform$0: [function() {
      var t1, round, t2, t3;
      M.DisplayObjectContainer.prototype.updateTransform$0.call(this);
      if (this._playing !== true)
        return;
      t1 = J.$add$ns(this._currentFrame, this.animationSpeed);
      this._currentFrame = t1;
      round = J.ceil$0$n(t1);
      this._currentFrame = J.$mod$n(this._currentFrame, J.get$length$asx(this.textures));
      if (this.loop !== true) {
        t1 = J.get$length$asx(this.textures);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = round < t1;
      } else
        t1 = true;
      if (t1) {
        t1 = this.textures;
        t2 = J.getInterceptor$asx(t1);
        t3 = t2.get$length(t1);
        if (typeof t3 !== "number")
          return H.iae(t3);
        this.texture = t2.$index(t1, C.JSInt_methods.$mod(round, t3));
        this.cachedTint = 16777215;
      } else {
        t1 = J.get$length$asx(this.textures);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (round >= t1) {
          t1 = J.$sub$n(J.get$length$asx(this.textures), 1);
          this._playing = false;
          this._currentFrame = t1;
          round = J.ceil$0$n(t1);
          t1 = this.textures;
          t2 = J.getInterceptor$asx(t1);
          t3 = t2.get$length(t1);
          if (typeof t3 !== "number")
            return H.iae(t3);
          this.texture = t2.$index(t1, C.JSInt_methods.$mod(round, t3));
          this.cachedTint = 16777215;
          if (this.onComplete != null)
            this.onComplete$0(0);
        }
      }
    }, "call$0", "get$updateTransform", 0, 0, 13, "updateTransform"],
    static: {MovieClip$: [function(textures) {
        var t1, t2, t3, t4, t5, t6;
        t1 = J.$index$asx(textures, 0);
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t2 = new M.MovieClip(null, 1, true, null, 0, false, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t2.texture = t1;
        t2._setupTexture$0();
        t2.textures = textures;
        return t2;
      }, null, null, 2, 0, 22, 23, [], "new MovieClip"], MovieClip_fromFrames: [function($frames) {
        var textures, t1, i, t2, texture, t3, t4, t5, t6;
        textures = [];
        t1 = J.getInterceptor$asx($frames);
        i = 0;
        while (true) {
          t2 = t1.get$length($frames);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          t2 = t1.$index($frames, i);
          texture = J.$index$asx($.get$TextureCache(), t2);
          if (texture == null)
            H.throwExpression(P.Exception_Exception("The frameId \"" + H.S(t2) + "\" does not exist in the texture cache"));
          textures.push(texture);
          ++i;
        }
        if (0 >= textures.length)
          return H.ioore(textures, 0);
        t1 = textures[0];
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t2 = new M.MovieClip(null, 1, true, null, 0, false, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t2.texture = t1;
        t2._setupTexture$0();
        t2.textures = textures;
        return t2;
      }, "call$1", "MovieClip_fromFrames$closure", 2, 0, 24, 25, [], "fromFrames"], MovieClip_fromImages: [function(images) {
        var textures, t1, i, t2, t3, t4, t5, t6;
        textures = [];
        t1 = J.getInterceptor$asx(images);
        i = 0;
        while (true) {
          t2 = t1.get$length(images);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          textures.push(M.Texture_fromImage(t1.$index(images, i), null, null));
          ++i;
        }
        if (0 >= textures.length)
          return H.ioore(textures, 0);
        t1 = textures[0];
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t2 = new M.MovieClip(null, 1, true, null, 0, false, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t2.texture = t1;
        t2._setupTexture$0();
        t2.textures = textures;
        return t2;
      }, "call$1", "MovieClip_fromImages$closure", 2, 0, 24, 26, [], "fromImages"]}
  },
  "+MovieClip": [643],
  Sprite: {
    "^": "DisplayObjectContainer;anchor@-634,texture@-670,updateFrame@-602,_width:PIXI$Sprite$_width@-601,_height:PIXI$Sprite$_height@-601,_uvs@-671,tintedTexture@-672,buffer*-673,tint@-599,cachedTint@-599,blendMode@-674,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    get$width: [function(_) {
      return J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.get$texture().get$frame()));
    }, null, null, 1, 0, 604, "width"],
    set$width: [function(_, value) {
      J.set$x$x(this.scale, J.$div$n(value, J.get$width$x(this.get$texture().get$frame())));
      this.set$_width(value);
    }, null, null, 3, 0, 605, 100, [], "width"],
    get$height: [function(_) {
      return J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.get$texture().get$frame()));
    }, null, null, 1, 0, 604, "height"],
    set$height: [function(_, value) {
      J.set$y$x(this.scale, J.$div$n(value, J.get$height$x(this.get$texture().get$frame())));
      this.set$_height(value);
    }, null, null, 3, 0, 605, 100, [], "height"],
    _setupTexture$0: [function() {
      if (this.get$texture().get$baseTexture().get$hasLoaded() === true)
        this._onTextureUpdate$1(null);
      else
        J.addEventListener$2$x(this.get$texture(), "update", this.get$_onTextureUpdate());
    }, "call$0", "get$_setupTexture", 0, 0, 550, "_setupTexture"],
    setTexture$1: [function(texture) {
      this.set$texture(texture);
      this.cachedTint = 16777215;
    }, "call$1", "get$setTexture", 2, 0, 676, 28, [], "setTexture"],
    _onTextureUpdate$1: [function(e) {
      if (!J.$eq(this.get$_width(), 0))
        J.set$x$x(this.scale, J.$div$n(this.get$_width(), J.get$width$x(this.get$texture().get$frame())));
      if (!J.$eq(this.get$_height(), 0))
        J.set$y$x(this.scale, J.$div$n(this.get$_height(), J.get$height$x(this.get$texture().get$frame())));
    }, "call$1", "get$_onTextureUpdate", 2, 0, 677, 312, [], "_onTextureUpdate"],
    getBounds$1: [function(matrix) {
      var width, height, t1, t2, w0, w1, h0, h1, worldTransform, a, b, c, d, tx, ty, x1, t3, t4, y1, x2, y2, x3, y3, x4, y4, minX, t5, minY, t6, t7, t8, maxX, maxY, bounds;
      width = J.get$width$x(this.get$texture().get$frame());
      height = J.get$height$x(this.get$texture().get$frame());
      t1 = J.get$x$x(this.get$anchor());
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = J.getInterceptor$ns(width);
      w0 = t2.$mul(width, 1 - t1);
      w1 = t2.$mul(width, J.$negate$n(J.get$x$x(this.get$anchor())));
      t2 = J.get$y$x(this.get$anchor());
      if (typeof t2 !== "number")
        return H.iae(t2);
      t1 = J.getInterceptor$ns(height);
      h0 = t1.$mul(height, 1 - t2);
      h1 = t1.$mul(height, J.$negate$n(J.get$y$x(this.get$anchor())));
      worldTransform = matrix == null ? this._worldTransform : matrix;
      a = J.get$a$x(worldTransform);
      b = worldTransform.get$c();
      c = worldTransform.get$b();
      d = worldTransform.get$d();
      tx = worldTransform.get$tx();
      ty = worldTransform.get$ty();
      t1 = J.getInterceptor$ns(a);
      t2 = J.getInterceptor$ns(c);
      x1 = J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h1)), tx);
      t3 = J.getInterceptor$ns(d);
      t4 = J.getInterceptor$ns(b);
      y1 = J.$add$ns(J.$add$ns(t3.$mul(d, h1), t4.$mul(b, w1)), ty);
      x2 = J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h1)), tx);
      y2 = J.$add$ns(J.$add$ns(t3.$mul(d, h1), t4.$mul(b, w0)), ty);
      x3 = J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h0)), tx);
      y3 = J.$add$ns(J.$add$ns(t3.$mul(d, h0), t4.$mul(b, w0)), ty);
      x4 = J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h0)), tx);
      y4 = J.$add$ns(J.$add$ns(t3.$mul(d, h0), t4.$mul(b, w1)), ty);
      t1 = J.getInterceptor$n(x1);
      minX = t1.$lt(x1, 1 / 0) ? x1 : 1 / 0;
      t2 = J.getInterceptor$n(x2);
      if (t2.$lt(x2, minX))
        minX = x2;
      t3 = J.getInterceptor$n(x3);
      if (t3.$lt(x3, minX))
        minX = x3;
      t4 = J.getInterceptor$n(x4);
      if (t4.$lt(x4, minX))
        minX = x4;
      t5 = J.getInterceptor$n(y1);
      minY = t5.$lt(y1, 1 / 0) ? y1 : 1 / 0;
      t6 = J.getInterceptor$n(y2);
      if (t6.$lt(y2, minY))
        minY = y2;
      t7 = J.getInterceptor$n(y3);
      if (t7.$lt(y3, minY))
        minY = y3;
      t8 = J.getInterceptor$n(y4);
      if (t8.$lt(y4, minY))
        minY = y4;
      maxX = t1.$gt(x1, -1 / 0) ? x1 : -1 / 0;
      if (t2.$gt(x2, maxX))
        maxX = x2;
      if (t3.$gt(x3, maxX))
        maxX = x3;
      if (t4.$gt(x4, maxX))
        maxX = x4;
      maxY = t5.$gt(y1, -1 / 0) ? y1 : -1 / 0;
      if (t6.$gt(y2, maxY))
        maxY = y2;
      if (t7.$gt(y3, maxY))
        maxY = y3;
      if (t8.$gt(y4, maxY))
        maxY = y4;
      bounds = this._bounds;
      t1 = J.getInterceptor$x(bounds);
      t1.set$x(bounds, minX);
      t1.set$width(bounds, J.$sub$n(maxX, minX));
      t1.set$y(bounds, minY);
      t1.set$height(bounds, J.$sub$n(maxY, minY));
      this._currentBounds = bounds;
      return bounds;
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 653, 32, 537, [], "getBounds"],
    _renderWebGL$1: [function(renderSession) {
      var spriteBatch, t1, j, i;
      if (this.visible !== true || J.$le$n(this.alpha, 0))
        return;
      if (this._mask != null || this._filters != null) {
        spriteBatch = renderSession.get$spriteBatch();
        if (this._filters != null) {
          J.flush$0$x(spriteBatch);
          renderSession.get$filterManager().pushFilter$1(this._filterBlock);
        }
        if (this._mask != null) {
          t1 = J.getInterceptor$x(spriteBatch);
          t1.stop$0(spriteBatch);
          renderSession.get$maskManager().pushMask$2(this._mask, renderSession);
          t1.start$0(spriteBatch);
        }
        spriteBatch.render$1(this);
        j = J.get$length$asx(this.get$children(this));
        if (typeof j !== "number")
          return H.iae(j);
        i = 0;
        for (; i < j; ++i)
          J.$index$asx(this.get$children(this), i)._renderWebGL$1(renderSession);
        t1 = J.getInterceptor$x(spriteBatch);
        t1.stop$0(spriteBatch);
        if (this._mask != null)
          renderSession.get$maskManager().popMask$2(this._mask, renderSession);
        if (this._filters != null)
          renderSession.get$filterManager().popFilter$0();
        t1.start$0(spriteBatch);
      } else {
        renderSession.get$spriteBatch().render$1(this);
        j = J.get$length$asx(this.get$children(this));
        if (typeof j !== "number")
          return H.iae(j);
        i = 0;
        for (; i < j; ++i)
          J.$index$asx(this.get$children(this), i)._renderWebGL$1(renderSession);
      }
    }, "call$1", "get$_renderWebGL", 2, 0, 656, 128, [], "_renderWebGL"],
    _renderCanvas$1: [function(renderSession) {
      var t1, t2, t3, t4, t5, t6, t7, dx, dy, j, i;
      if (J.$eq(this.visible, false) || J.$eq(this.alpha, 0))
        return;
      if (!J.$eq(this.blendMode, renderSession.get$currentBlendMode())) {
        renderSession.set$currentBlendMode(this.blendMode);
        J.set$globalCompositeOperation$x(J.get$context$x(renderSession), J.$index$asx($.blendModesCanvas, renderSession.get$currentBlendMode()));
      }
      if (this._mask != null)
        renderSession.get$maskManager().pushMask$2(this._mask, J.get$context$x(renderSession));
      if (this.get$texture().get$valid() === true) {
        t1 = J.getInterceptor$x(renderSession);
        J.set$globalAlpha$x(t1.get$context(renderSession), this._worldAlpha);
        if (renderSession.get$roundPixels() != null)
          J.setTransform$6$x(t1.get$context(renderSession), J.get$a$x(this._worldTransform), this._worldTransform.get$c(), this._worldTransform.get$b(), this._worldTransform.get$d(), J.floor$0$n(this._worldTransform.get$tx()), J.floor$0$n(this._worldTransform.get$ty()));
        else {
          t2 = t1.get$context(renderSession);
          t3 = J.get$a$x(this._worldTransform);
          t4 = this._worldTransform.get$c();
          t5 = this._worldTransform.get$b();
          t6 = this._worldTransform.get$d();
          t7 = this._worldTransform.get$tx() == null ? 0 : this._worldTransform.get$tx();
          J.setTransform$6$x(t2, t3, t4, t5, t6, t7, this._worldTransform.get$ty() == null ? 0 : this._worldTransform.get$ty());
        }
        if (!J.$eq(renderSession.get$scaleMode(), this.get$texture().get$baseTexture().get$scaleMode())) {
          renderSession.set$scaleMode(this.get$texture().get$baseTexture().get$scaleMode());
          J.set$imageSmoothingEnabled$x(t1.get$context(renderSession), J.$eq(renderSession.get$scaleMode(), C.scaleModes_1));
        }
        dx = J.get$trim$s(this.get$texture()) != null ? J.$sub$n(J.get$x$x(J.get$trim$s(this.get$texture())), J.$mul$ns(J.get$x$x(this.get$anchor()), J.get$width$x(J.get$trim$s(this.get$texture())))) : J.$mul$ns(J.get$x$x(this.get$anchor()), J.$negate$n(J.get$width$x(this.get$texture().get$frame())));
        dy = J.get$trim$s(this.get$texture()) != null ? J.$sub$n(J.get$y$x(J.get$trim$s(this.get$texture())), J.$mul$ns(J.get$y$x(this.get$anchor()), J.get$height$x(J.get$trim$s(this.get$texture())))) : J.$mul$ns(J.get$y$x(this.get$anchor()), J.$negate$n(J.get$height$x(this.get$texture().get$frame())));
        if (!J.$eq(this.tint, 16777215)) {
          if (!J.$eq(this.cachedTint, this.tint)) {
            t2 = this.tint;
            this.cachedTint = t2;
            this.tintedTexture = M.CanvasTinter_getTintedTexture(this, t2);
          }
          J.drawImageScaledFromSource$9$x(t1.get$context(renderSession), this.tintedTexture, 0, 0, J.get$width$x(this.get$texture().get$crop()), J.get$height$x(this.get$texture().get$crop()), dx, dy, J.get$width$x(this.get$texture().get$crop()), J.get$height$x(this.get$texture().get$crop()));
        } else
          J.drawImageScaledFromSource$9$x(t1.get$context(renderSession), J.get$source$x(this.get$texture().get$baseTexture()), J.get$x$x(this.get$texture().get$crop()), J.get$y$x(this.get$texture().get$crop()), J.get$width$x(this.get$texture().get$crop()), J.get$height$x(this.get$texture().get$crop()), dx, dy, J.get$width$x(this.get$texture().get$crop()), J.get$height$x(this.get$texture().get$crop()));
      }
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i)._renderCanvas$1(renderSession);
      if (this._mask != null)
        renderSession.get$maskManager().popMask$1(J.get$context$x(renderSession));
    }, "call$1", "get$_renderCanvas", 2, 0, 656, 128, [], "_renderCanvas"],
    $isSprite: true,
    static: {Sprite$_: [function() {
        var t1, t2, t3, t4, t5;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new M.Sprite(t1, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t5, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.renderable = true;
        return t1;
      }, null, null, 0, 0, 13, "new Sprite$_"], Sprite$0: [function(texture) {
        var t1, t2, t3, t4, t5;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new M.Sprite(t1, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t5, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.texture = texture;
        t1._setupTexture$0();
        return t1;
      }, null, null, 2, 0, 27, 28, [], "new Sprite"], Sprite_fromFrame: [function(frameId) {
        var texture, t1, t2, t3, t4, t5;
        texture = J.$index$asx($.get$TextureCache(), frameId);
        if (texture == null)
          throw H.wrapException(P.Exception_Exception("The frameId \"" + H.S(frameId) + "\" does not exist in the texture cache."));
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new M.Sprite(t1, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t5, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.texture = texture;
        t1._setupTexture$0();
        return t1;
      }, "call$1", "Sprite_fromFrame$closure", 2, 0, 29, 30, [], "fromFrame"], Sprite_fromImage: [function(imageId, crossorigin, scaleMode) {
        var texture, t1, t2, t3, t4, t5;
        texture = M.Texture_fromImage(imageId, crossorigin, scaleMode);
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new M.Sprite(t1, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t5, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.texture = texture;
        t1._setupTexture$0();
        return t1;
      }, function(imageId) {
        return M.Sprite_fromImage(imageId, null, null);
      }, null, function(imageId, crossorigin) {
        return M.Sprite_fromImage(imageId, crossorigin, null);
      }, null, "call$3", "call$1", "call$2", "Sprite_fromImage$closure", 2, 4, 31, 32, 32, 33, [], 34, [], 35, [], "fromImage"]}
  },
  "+Sprite": [678],
  SpriteBatch0: {
    "^": "DisplayObjectContainer;textureThing@-679,_ready@-602,fastSpriteBatch@-680,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    _initWebGL$1: [function(gl) {
      this.fastSpriteBatch = M.WebGLFastSpriteBatch$(gl);
      this._ready = true;
    }, "call$1", "get$_initWebGL", 2, 0, 63, 122, [], "_initWebGL"],
    updateTransform$0: [function() {
      M.DisplayObjectContainer.prototype.updateTransform$0.call(this);
    }, "call$0", "get$updateTransform", 0, 0, 13, "updateTransform"],
    _renderWebGL$1: [function(renderSession) {
      if (this.visible !== true || J.$le$n(this.alpha, 0) || J.$eq(J.get$length$asx(this.children), 0))
        return;
      if (this._ready !== true) {
        this.fastSpriteBatch = M.WebGLFastSpriteBatch$(renderSession.get$gl());
        this._ready = true;
      }
      J.stop$0$x(renderSession.get$spriteBatch());
      renderSession.get$shaderManager().setShader$1(renderSession.get$shaderManager().get$fastShader());
      this.fastSpriteBatch.begin$2(this, renderSession);
      this.fastSpriteBatch.render$1(this);
      J.start$0$x(renderSession.get$spriteBatch());
    }, "call$1", "get$_renderWebGL", 2, 0, 656, 128, [], "_renderWebGL"],
    _renderCanvas$1: [function(renderSession) {
      var context, t1, transform, t2, t3, t4, isRotated, i, t5, child, texture, frame, t6, childTransform;
      context = renderSession.get$_context();
      t1 = J.getInterceptor$x(context);
      t1.set$globalAlpha(context, this._worldAlpha);
      M.DisplayObjectContainer.prototype.updateTransform$0.call(this);
      transform = this._worldTransform;
      t2 = this.children;
      t3 = J.getInterceptor$asx(t2);
      t4 = J.getInterceptor$x(transform);
      isRotated = true;
      i = 0;
      while (true) {
        t5 = t3.get$length(t2);
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (!(i < t5))
          break;
        c$0: {
          child = t3.$index(t2, i);
          if (child.get$visible() !== true)
            break c$0;
          texture = child.get$texture();
          frame = texture.get$frame();
          t5 = J.getInterceptor$x(child);
          t1.set$globalAlpha(context, J.$mul$ns(this._worldAlpha, t5.get$alpha(child)));
          if (J.$mod$n(child.get$rotation(), 6.283185307179586) === 0) {
            if (isRotated) {
              t1.setTransform$6(context, t4.get$a(transform), transform.get$c(), transform.get$b(), transform.get$d(), transform.get$tx(), transform.get$ty());
              isRotated = false;
            }
            t6 = J.getInterceptor$x(frame);
            t1.drawImageScaledFromSource$9(context, J.get$source$x(texture.get$baseTexture()), t6.get$x(frame), t6.get$y(frame), t6.get$width(frame), t6.get$height(frame), J.floor$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(J.get$x$x(child.get$anchor()), J.$mul$ns(J.$negate$n(t6.get$width(frame)), J.get$x$x(t5.get$scale(child)))), J.get$x$x(t5.get$position(child))), 0.5)), J.floor$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(J.get$y$x(child.get$anchor()), J.$mul$ns(J.$negate$n(t6.get$height(frame)), J.get$y$x(t5.get$scale(child)))), J.get$y$x(t5.get$position(child))), 0.5)), J.$mul$ns(t6.get$width(frame), J.get$x$x(t5.get$scale(child))), J.$mul$ns(t6.get$height(frame), J.get$y$x(t5.get$scale(child))));
          } else {
            if (!isRotated)
              isRotated = true;
            child.updateTransform$0();
            childTransform = child.get$_worldTransform();
            t5 = J.getInterceptor$x(childTransform);
            if (renderSession.get$roundPixels() === true)
              t1.setTransform$6(context, t5.get$a(childTransform), childTransform.get$c(), childTransform.get$b(), childTransform.get$d(), J.floor$0$n(childTransform.get$tx()), J.floor$0$n(childTransform.get$ty()));
            else
              t1.setTransform$6(context, t5.get$a(childTransform), childTransform.get$c(), childTransform.get$b(), childTransform.get$d(), childTransform.get$tx(), childTransform.get$ty());
            t5 = J.getInterceptor$x(frame);
            t1.drawImageScaledFromSource$9(context, J.get$source$x(texture.get$baseTexture()), t5.get$x(frame), t5.get$y(frame), t5.get$width(frame), t5.get$height(frame), J.$add$ns(J.$mul$ns(J.get$x$x(child.get$anchor()), J.$negate$n(t5.get$width(frame))), 0.5), J.$add$ns(J.$mul$ns(J.get$y$x(child.get$anchor()), J.$negate$n(t5.get$height(frame))), 0.5), t5.get$width(frame), t5.get$height(frame));
          }
        }
        ++i;
      }
    }, "call$1", "get$_renderCanvas", 2, 0, 554, 128, [], "_renderCanvas"],
    static: {SpriteBatch$0: [function(textureThing) {
        var t1, t2, t3, t4;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 1;
        t2.y = 1;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        return new M.SpriteBatch0(textureThing, false, null, [], false, 0, 0, t1, t2, t3, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t4, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
      }, null, null, 0, 2, 36, 32, 37, [], "new SpriteBatch"]}
  },
  "+SpriteBatch": [678],
  Stage0: {
    "^": "DisplayObjectContainer;_dirty:PIXI$Stage0$_dirty@-602,_interactiveEventsAdded@-602,hitArea:PIXI$Stage0$hitArea@-641,backgroundColor*-599,backgroundColorSplit@-681,backgroundColorString@-639,_worldTransform:PIXI$Stage0$_worldTransform@-640,interactionManager@-682,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    get$worldTransform: [function() {
      return this.PIXI$Stage0$_worldTransform;
    }, null, null, 1, 0, 647, "worldTransform"],
    setInteractionDelegate$1: [function(domElement) {
      this.interactionManager.setTargetDomElement$1(domElement);
    }, "call$1", "get$setInteractionDelegate", 2, 0, 554, 683, [], "setInteractionDelegate"],
    updateTransform$0: [function() {
      var j, i;
      this._worldAlpha = 1;
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i).updateTransform$0();
      if (this.PIXI$Stage0$_dirty === true) {
        this.PIXI$Stage0$_dirty = false;
        this.interactionManager.set$dirty(true);
      }
      if (this._interactive === true)
        this.interactionManager.update$0();
    }, "call$0", "get$updateTransform", 0, 0, 550, "updateTransform"],
    setBackgroundColor$1: [function(backgroundColor) {
      var hex;
      this.set$backgroundColor(0, backgroundColor);
      this.backgroundColorSplit = M.hex2rgb(this.get$backgroundColor(this));
      hex = J.toRadixString$1$n(this.get$backgroundColor(this), 16);
      this.backgroundColorString = "#" + (C.JSString_methods.substring$2("000000", 0, 6 - hex.length) + hex);
    }, "call$1", "get$setBackgroundColor", 2, 0, 583, 40, [], "setBackgroundColor"],
    getMousePosition$0: [function() {
      return this.interactionManager.get$mouse().get$global();
    }, "call$0", "get$getMousePosition", 0, 0, 684, "getMousePosition"],
    Stage$2: function(backgroundColor, interactive) {
      var t1, t2, t3, t4;
      this.PIXI$Stage0$_dirty = true;
      this._stage = this;
      if (backgroundColor != null)
        this.set$backgroundColor(0, backgroundColor);
      this.set$interactive(interactive);
      t1 = new M.Point0(null, null);
      t1.x = 0;
      t1.y = 0;
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      t3 = new M.Point0(null, null);
      t3.x = 0;
      t3.y = 0;
      t4 = new P.DateTime(Date.now(), false);
      t4.DateTime$_now$0();
      t4 = new M.InteractionManager(this, new M.InteractionData(t1, null, null), t2, t3, true, [], [], null, null, t4, null, "inherit", false, null);
      t4.isCocoonJS = J.contains$1$asx(window.navigator.appVersion, "CocoonJS");
      this.interactionManager = t4;
      this.setBackgroundColor$1(backgroundColor);
    },
    static: {Stage$: [function(backgroundColor, interactive) {
        var t1, t2, t3, t4, t5;
        t1 = new Float32Array(9);
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new M.Stage0(null, false, new M.Rectangle0(0, 0, 100000, 100000), 0, [], null, new M.Matrix(1, 0, 0, 1, 0, 0, t1), null, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t5, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.Stage$2(backgroundColor, interactive);
        return t1;
      }, null, null, 0, 4, 38, 5, 39, 40, [], 41, [], "new Stage"]}
  },
  "+Stage": [678],
  Rope: {
    "^": "Strip;points*-633,count:PIXI$Rope$count@-601,texture-670,blendMode-674,uvs-630,verticies-630,colors-630,indices-685,updateFrame-602,_vertexBuffer-686,_indexBuffer-686,_uvBuffer-686,_colorBuffer-686,count-599,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    refresh$0: [function() {
      var points, t1, uvs, indices, colors, t2, t3, t4, total, t5, i, index, amount, t6, t7, t8;
      points = this.points;
      t1 = J.getInterceptor$asx(points);
      if (J.$lt$n(t1.get$length(points), 1))
        return;
      uvs = this.uvs;
      t1.$index(points, 0);
      indices = this.indices;
      colors = this.colors;
      this.PIXI$Rope$count = J.$sub$n(this.PIXI$Rope$count, 0.2);
      t2 = J.getInterceptor$ax(uvs);
      t2.$indexSet(uvs, 0, 0);
      t2.$indexSet(uvs, 1, 0);
      t2.$indexSet(uvs, 2, 0);
      t2.$indexSet(uvs, 3, 1);
      t3 = J.getInterceptor$ax(colors);
      t3.$indexSet(colors, 0, 1);
      t3.$indexSet(colors, 1, 1);
      t4 = J.getInterceptor$ax(indices);
      t4.$indexSet(indices, 0, 0);
      t4.$indexSet(indices, 1, 1);
      total = t1.get$length(points);
      if (typeof total !== "number")
        return H.iae(total);
      t5 = total - 1;
      i = 1;
      for (; i < total; ++i) {
        t1.$index(points, i);
        index = i * 4;
        amount = i / t5;
        t6 = index + 2;
        t7 = index + 1;
        t8 = index + 3;
        if (C.JSInt_methods.$mod(i, 2) !== 0) {
          t2.$indexSet(uvs, index, amount);
          t2.$indexSet(uvs, t7, 0);
          t2.$indexSet(uvs, t6, amount);
          t2.$indexSet(uvs, t8, 1);
        } else {
          t2.$indexSet(uvs, index, amount);
          t2.$indexSet(uvs, t7, 0);
          t2.$indexSet(uvs, t6, amount);
          t2.$indexSet(uvs, t8, 1);
        }
        index = i * 2;
        t3.$indexSet(colors, index, 1);
        t6 = index + 1;
        t3.$indexSet(colors, t6, 1);
        t4.$indexSet(indices, index, index);
        t4.$indexSet(indices, t6, t6);
      }
    }, "call$0", "get$refresh", 0, 0, 13, "refresh"],
    updateTransform$0: [function() {
      var points, t1, lastPoint, perp, verticies, total, t2, t3, i, point, index, t4, nextPoint, t5, perpLength, n;
      points = this.points;
      t1 = J.getInterceptor$asx(points);
      if (J.$lt$n(t1.get$length(points), 1))
        return;
      lastPoint = t1.$index(points, 0);
      perp = new M.Point0(null, null);
      perp.x = 0;
      perp.y = 0;
      this.PIXI$Rope$count = J.$sub$n(this.PIXI$Rope$count, 0.2);
      verticies = this.verticies;
      total = t1.get$length(points);
      if (typeof total !== "number")
        return H.iae(total);
      t2 = J.getInterceptor$ax(verticies);
      t3 = total - 1;
      i = 0;
      for (; i < total; ++i, lastPoint = point) {
        point = t1.$index(points, i);
        index = i * 4;
        t4 = J.$sub$n(t1.get$length(points), 1);
        if (typeof t4 !== "number")
          return H.iae(t4);
        nextPoint = i < t4 ? t1.$index(points, i + 1) : point;
        t4 = J.getInterceptor$x(nextPoint);
        t5 = J.getInterceptor$x(lastPoint);
        perp.y = J.$negate$n(J.$sub$n(t4.get$x(nextPoint), t5.get$x(lastPoint)));
        t5 = J.$sub$n(t4.get$y(nextPoint), t5.get$y(lastPoint));
        perp.x = t5;
        if ((1 - i / t3) * 10 > 1)
          ;
        t4 = J.$mul$ns(t5, t5);
        t5 = perp.y;
        t5 = J.$add$ns(t4, J.$mul$ns(t5, t5));
        if (typeof t5 !== "number")
          H.throwExpression(P.ArgumentError$(t5));
        perpLength = Math.sqrt(t5);
        n = J.$div$n(J.get$height$x(this.texture), 2);
        perp.x = J.$div$n(perp.x, perpLength);
        perp.y = J.$div$n(perp.y, perpLength);
        perp.x = J.$mul$ns(perp.x, n);
        perp.y = J.$mul$ns(perp.y, n);
        t4 = J.getInterceptor$x(point);
        t2.$indexSet(verticies, index, J.$add$ns(t4.get$x(point), J.toDouble$0$n(perp.x)));
        t2.$indexSet(verticies, index + 1, J.$add$ns(t4.get$y(point), J.toDouble$0$n(perp.y)));
        t2.$indexSet(verticies, index + 2, J.$sub$n(t4.get$x(point), J.toDouble$0$n(perp.x)));
        t2.$indexSet(verticies, index + 3, J.$sub$n(t4.get$y(point), J.toDouble$0$n(perp.y)));
      }
      M.DisplayObjectContainer.prototype.updateTransform$0.call(this);
    }, "call$0", "get$updateTransform", 0, 0, 13, "updateTransform"],
    setTexture$1: [function(texture) {
      this.texture = texture;
    }, "call$1", "get$setTexture", 2, 0, 27, 28, [], "setTexture"],
    Rope$2: function(texture, points) {
      var t1 = J.$mul$ns(J.get$length$asx(this.points), 4);
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.verticies = new Float32Array(t1);
      t1 = J.$mul$ns(J.get$length$asx(this.points), 4);
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.uvs = new Float32Array(t1);
      t1 = J.$mul$ns(J.get$length$asx(this.points), 2);
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.colors = new Float32Array(t1);
      t1 = J.$mul$ns(J.get$length$asx(this.points), 2);
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.indices = new Uint16Array(t1);
      this.refresh$0();
    },
    static: {Rope$: [function(texture, points) {
        var t1, t2, t3, t4;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 1;
        t2.y = 1;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new M.Rope(points, 0, null, C.BlendModes_0, null, null, null, null, false, null, null, null, null, 0, [], false, 0, 0, t1, t2, t3, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t4, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.Strip$1(texture);
        t1.Rope$2(texture, points);
        return t1;
      }, null, null, 4, 0, 42, 28, [], 17, [], "new Rope"]}
  },
  "+Rope": [687],
  BoneData: {
    "^": "Object;name*-639,parent*-688,length*-601,x*-601,y*-601,rotation@-601,scaleX@-601,scaleY@-601",
    static: {BoneData$: [function($name, $parent) {
        return new M.BoneData($name, $parent, 0, 0, 0, 0, 1, 1);
      }, null, null, 4, 0, 43, 44, [], 45, [], "new BoneData"]}
  },
  "+BoneData": [632],
  SlotData: {
    "^": "Object;name*-639,boneData@-688,r*-601,g@-601,b@-601,a*-601,attachmentName@-639",
    static: {SlotData$: [function($name, boneData) {
        return new M.SlotData($name, boneData, 1, 1, 1, 1, null);
      }, null, null, 4, 0, 43, 44, [], 46, [], "new SlotData"]}
  },
  "+SlotData": [632],
  Bone: {
    "^": "Object;parent*-689,data*-688,x*-601,y*-601,rotation@-601,scaleX@-601,scaleY@-601,m00@-601,m01@-601,worldX@-601,m10@-601,m11@-601,worldY@-601,worldRotation@-601,worldScaleX@-601,worldScaleY@-601",
    updateWorldTransform$2: [function(flipX, flipY) {
      var $parent, t1, radians, _cos, _sin, t2;
      $parent = this.parent;
      t1 = this.x;
      if ($parent != null) {
        this.worldX = J.$add$ns(J.$add$ns(J.$mul$ns(t1, $parent.get$m00()), J.$mul$ns(this.y, $parent.get$m01())), $parent.get$worldX());
        this.worldY = J.$add$ns(J.$add$ns(J.$mul$ns(this.x, $parent.get$m10()), J.$mul$ns(this.y, $parent.get$m11())), $parent.get$worldY());
        this.worldScaleX = J.$mul$ns($parent.get$worldScaleX(), this.scaleX);
        this.worldScaleY = J.$mul$ns($parent.get$worldScaleY(), this.scaleY);
        t1 = J.$add$ns($parent.get$worldRotation(), this.rotation);
        this.worldRotation = t1;
      } else {
        this.worldX = t1;
        this.worldY = this.y;
        this.worldScaleX = this.scaleX;
        this.worldScaleY = this.scaleY;
        t1 = this.rotation;
        this.worldRotation = t1;
      }
      radians = J.$div$n(J.$mul$ns(t1, 3.141592653589793), 180);
      t1 = typeof radians !== "number";
      if (t1)
        H.throwExpression(P.ArgumentError$(radians));
      _cos = Math.cos(radians);
      if (t1)
        H.throwExpression(P.ArgumentError$(radians));
      _sin = Math.sin(radians);
      t1 = this.worldScaleX;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = _cos * t1;
      this.m00 = t2;
      this.m10 = _sin * t1;
      t1 = this.worldScaleY;
      if (typeof t1 !== "number")
        return H.iae(t1);
      this.m01 = -_sin * t1;
      this.m11 = _cos * t1;
      if (flipX === true) {
        this.m00 = -t2;
        this.m01 = J.$negate$n(this.m01);
      }
      if (flipY === true) {
        this.m10 = J.$negate$n(this.m10);
        this.m11 = J.$negate$n(this.m11);
      }
      if ($.Bone_yDown === true) {
        this.m10 = J.$negate$n(this.m10);
        this.m11 = J.$negate$n(this.m11);
      }
    }, "call$2", "get$updateWorldTransform", 4, 0, 690, 691, [], 692, [], "updateWorldTransform"],
    setToSetupPose$0: [function() {
      var data, t1;
      data = this.data;
      t1 = J.getInterceptor$x(data);
      this.x = t1.get$x(data);
      this.y = t1.get$y(data);
      this.rotation = data.get$rotation();
      this.scaleX = data.get$scaleX();
      this.scaleY = data.get$scaleY();
    }, "call$0", "get$setToSetupPose", 0, 0, 13, "setToSetupPose"],
    static: {"^": "Bone_yDown@-602", Bone$: [function(data, $parent) {
        var t1 = new M.Bone($parent, data, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1);
        t1.setToSetupPose$0();
        return t1;
      }, null, null, 4, 0, 47, 48, [], 45, [], "new Bone"]}
  },
  "+Bone": [632],
  Slot: {
    "^": "Object;data*-693,skeleton@-694,bone@-689,sprites@-695,currentSprite@-643,currentSpriteName@-639,r*-601,g@-601,b@-601,a*-601,_attachmentTime@-601,attachment@-696",
    setAttachment$1: [function(attachment) {
      this.attachment = attachment;
      this._attachmentTime = this.skeleton.get$time();
    }, "call$1", "get$setAttachment", 2, 0, 63, 697, [], "setAttachment"],
    setAttachmentTime$1: [function(time) {
      this._attachmentTime = J.$sub$n(this.skeleton.get$time(), time);
    }, "call$1", "get$setAttachmentTime", 2, 0, 63, 568, [], "setAttachmentTime"],
    getAttachmentTime$0: [function() {
      return J.$sub$n(this.skeleton.get$time(), this._attachmentTime);
    }, "call$0", "get$getAttachmentTime", 0, 0, 13, "getAttachmentTime"],
    setToSetupPose$0: [function() {
      var slotDatas, t1, n, i;
      this.r = J.get$r$x(this.data);
      this.g = this.data.get$g();
      this.b = this.data.get$b();
      this.a = J.get$a$x(this.data);
      slotDatas = J.get$data$x(this.skeleton).get$slots();
      t1 = J.getInterceptor$asx(slotDatas);
      n = t1.get$length(slotDatas);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(t1.$index(slotDatas, i), this.data)) {
          this.attachment = this.data.get$attachmentName() == null ? null : this.skeleton.getAttachmentBySlotIndex$2(i, this.data.get$attachmentName());
          this._attachmentTime = this.skeleton.get$time();
          break;
        }
    }, "call$0", "get$setToSetupPose", 0, 0, 13, "setToSetupPose"],
    static: {Slot$: [function(data, skeleton, bone) {
        var t1 = new M.Slot(data, skeleton, bone, null, null, null, 1, 1, 1, 1, 0, null);
        t1.setToSetupPose$0();
        return t1;
      }, null, null, 6, 0, 49, 48, [], 50, [], 51, [], "new Slot"]}
  },
  "+Slot": [632],
  Skin: {
    "^": "Object;name*-639,attachments@-698",
    addAttachment$3: [function(slotIndex, $name, attachment) {
      J.$indexSet$ax(this.attachments, H.S(slotIndex) + ":" + H.S($name), attachment);
    }, "call$3", "get$addAttachment", 6, 0, 699, 700, [], 44, [], 697, [], "addAttachment"],
    getAttachment$2: [function(slotIndex, $name) {
      return J.$index$asx(this.attachments, H.S(slotIndex) + ":" + H.S($name));
    }, "call$2", "get$getAttachment", 4, 0, 701, 700, [], 44, [], "getAttachment"],
    _attachAll$2: [function(skeleton, oldSkin) {
      var t1, key, t2, colon, slotIndex, $name, slot, attachment;
      for (t1 = J.get$iterator$ax(J.get$keys$x(oldSkin.get$attachments())); t1.moveNext$0();) {
        key = t1.get$current();
        t2 = J.getInterceptor$asx(key);
        colon = t2.indexOf$1(key, ":");
        slotIndex = H.Primitives_parseInt(t2.substring$2(key, 0, colon), null, null);
        $name = t2.substring$1(key, J.$add$ns(colon, 1));
        slot = J.$index$asx(skeleton.get$slots(), slotIndex);
        if (slot.get$attachment() != null && J.$eq(J.get$name$x(slot.get$attachment()), $name)) {
          attachment = J.$index$asx(this.attachments, H.S(slotIndex) + ":" + $name);
          if (attachment != null)
            slot.setAttachment$1(attachment);
        }
      }
    }, "call$2", "get$_attachAll", 4, 0, 702, 50, [], 703, [], "_attachAll"],
    static: {Skin$: [function($name) {
        return new M.Skin($name, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      }, null, null, 2, 0, 52, 44, [], "new Skin"]}
  },
  "+Skin": [632],
  Animation0: {
    "^": "Object;name*-639,timelines@-704,duration*-601",
    apply$3: [function(skeleton, time, loop) {
      var timelines, t1, n, i;
      if (loop === true && !J.$eq(this.duration, 0))
        time = J.$mod$n(time, this.duration);
      timelines = this.timelines;
      t1 = J.getInterceptor$asx(timelines);
      n = t1.get$length(timelines);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        t1.$index(timelines, i).apply$3(skeleton, time, 1);
    }, "call$3", "get$apply", 6, 0, 705, 50, [], 568, [], 219, [], "apply"],
    mix$4: [function(skeleton, time, loop, alpha) {
      var timelines, t1, n, i;
      if (loop === true && !J.$eq(this.duration, 0))
        time = J.$mod$n(time, this.duration);
      timelines = this.timelines;
      t1 = J.getInterceptor$asx(timelines);
      n = t1.get$length(timelines);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        t1.$index(timelines, i).apply$3(skeleton, time, alpha);
    }, "call$4", "get$mix", 8, 0, 706, 50, [], 568, [], 219, [], 524, [], "mix"],
    static: {Animation$: [function($name, timelines, duration) {
        return new M.Animation0($name, timelines, duration);
      }, null, null, 6, 0, 53, 44, [], 54, [], 55, [], "new Animation"]}
  },
  "+Animation": [632],
  Curves: {
    "^": "Object;curves@-681",
    setLinear$1: [function(frameIndex) {
      J.$indexSet$ax(this.curves, J.$mul$ns(frameIndex, 6), 0);
    }, "call$1", "get$setLinear", 2, 0, 60, 75, [], "setLinear"],
    setStepped$1: [function(frameIndex) {
      J.$indexSet$ax(this.curves, J.$mul$ns(frameIndex, 6), -1);
    }, "call$1", "get$setStepped", 2, 0, 60, 75, [], "setStepped"],
    setCurve$5: [function(frameIndex, cx1, cy1, cx2, cy2) {
      var t1, tmp1x, t2, tmp1y, tmp2x, tmp2y, i, curves, t3, t4, t5, t6, t7;
      t1 = J.getInterceptor$n(cx1);
      tmp1x = J.$add$ns(J.$mul$ns(t1.$negate(cx1), 2), cx2);
      t2 = J.getInterceptor$n(cy1);
      tmp1y = J.$add$ns(J.$mul$ns(t2.$negate(cy1), 2), cy2);
      tmp2x = J.$add$ns(J.$mul$ns(t1.$sub(cx1, cx2), 3), 1);
      tmp2y = J.$add$ns(J.$mul$ns(t2.$sub(cy1, cy2), 3), 1);
      i = J.$mul$ns(frameIndex, 6);
      curves = this.curves;
      t3 = J.getInterceptor$ns(tmp1x);
      t4 = J.getInterceptor$ns(tmp2x);
      t5 = J.getInterceptor$ax(curves);
      t5.$indexSet(curves, i, J.$add$ns(J.$add$ns(t1.$mul(cx1, 0.30000000000000004), t3.$mul(tmp1x, 0.030000000000000006)), t4.$mul(tmp2x, 0.0010000000000000002)));
      t1 = J.getInterceptor$ns(i);
      t6 = J.getInterceptor$ns(tmp1y);
      t7 = J.getInterceptor$ns(tmp2y);
      t5.$indexSet(curves, t1.$add(i, 1), J.$add$ns(J.$add$ns(t2.$mul(cy1, 0.30000000000000004), t6.$mul(tmp1y, 0.030000000000000006)), t7.$mul(tmp2y, 0.0010000000000000002)));
      t5.$indexSet(curves, t1.$add(i, 2), J.$add$ns(t3.$mul(tmp1x, 0.06000000000000001), t4.$mul(tmp2x, 0.006000000000000002)));
      t5.$indexSet(curves, t1.$add(i, 3), J.$add$ns(t6.$mul(tmp1y, 0.06000000000000001), t7.$mul(tmp2y, 0.006000000000000002)));
      t5.$indexSet(curves, t1.$add(i, 4), t4.$mul(tmp2x, 0.006000000000000002));
      t5.$indexSet(curves, t1.$add(i, 5), t7.$mul(tmp2y, 0.006000000000000002));
    }, "call$5", "get$setCurve", 10, 0, 707, 75, [], 708, [], 709, [], 710, [], 711, [], "setCurve"],
    getCurvePercent$2: [function(frameIndex, percent) {
      var t1, curveIndex, dfx, dfy, ddfx, ddfy, dddfx, dddfy, y, x, i, lastX, t2, lastY;
      t1 = J.getInterceptor$n(percent);
      if (t1.$lt(percent, 0))
        percent = 0;
      else if (t1.$gt(percent, 1))
        percent = 1;
      curveIndex = J.$mul$ns(frameIndex, 6);
      dfx = J.$index$asx(this.curves, curveIndex);
      t1 = J.getInterceptor(dfx);
      if (t1.$eq(dfx, 0) || dfx == null)
        return percent;
      if (t1.$eq(dfx, -1))
        return 0;
      t1 = J.getInterceptor$ns(curveIndex);
      dfy = J.$index$asx(this.curves, t1.$add(curveIndex, 1));
      ddfx = J.$index$asx(this.curves, t1.$add(curveIndex, 2));
      ddfy = J.$index$asx(this.curves, t1.$add(curveIndex, 3));
      dddfx = J.$index$asx(this.curves, t1.$add(curveIndex, 4));
      dddfy = J.$index$asx(this.curves, t1.$add(curveIndex, 5));
      for (y = dfy, x = dfx, i = 8; true;) {
        t1 = J.getInterceptor$n(x);
        if (t1.$ge(x, percent)) {
          lastX = t1.$sub(x, dfx);
          t2 = J.getInterceptor$n(y);
          lastY = t2.$sub(y, dfy);
          return J.$add$ns(lastY, J.$div$n(J.$mul$ns(t2.$sub(y, lastY), J.$sub$n(percent, lastX)), t1.$sub(x, lastX)));
        }
        if (i === 0)
          break;
        --i;
        dfx = J.$add$ns(dfx, ddfx);
        dfy = J.$add$ns(dfy, ddfy);
        ddfx = J.$add$ns(ddfx, dddfx);
        ddfy = J.$add$ns(ddfy, dddfy);
        x = t1.$add(x, dfx);
        y = J.$add$ns(y, dfy);
      }
      if (typeof y !== "number")
        return H.iae(y);
      t1 = J.$sub$n(percent, x);
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (typeof x !== "number")
        return H.iae(x);
      return y + (1 - y) * t1 / (1 - x);
    }, "call$2", "get$getCurvePercent", 4, 0, 712, 75, [], 713, [], "getCurvePercent"],
    Curves$1: function(frameCount) {
      var t1 = J.$mul$ns(J.$sub$n(frameCount, 1), 6);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = Array(t1);
      t1.fixed$length = init;
      this.curves = H.setRuntimeTypeInfo(t1, [P.num]);
    },
    static: {Curves$: [function(frameCount) {
        var t1 = new M.Curves(null);
        t1.Curves$1(frameCount);
        return t1;
      }, null, null, 2, 0, 60, 61, [], "new Curves"]}
  },
  "+Curves": [632],
  Timeline: {
    "^": "Object;curves@-714,frames@-715,boneIndex@-599",
    static: {Timeline$: [function() {
        return new M.Timeline(null, null, 0);
      }, null, null, 0, 0, 62, "new Timeline"]}
  },
  "+Timeline": [632],
  RotateTimeline: {
    "^": "Timeline;curves-714,frames-715,boneIndex-599",
    getFrameCount$0: [function() {
      return J.$tdiv$n(J.get$length$asx(this.frames), 2);
    }, "call$0", "get$getFrameCount", 0, 0, 367, "getFrameCount"],
    setFrame$6: [function(frameIndex, time, angle, a, b, c) {
      frameIndex = J.$mul$ns(frameIndex, 2);
      J.$indexSet$ax(this.frames, frameIndex, time);
      J.$indexSet$ax(this.frames, J.$add$ns(frameIndex, 1), angle);
    }, function(frameIndex, time, angle) {
      return this.setFrame$6(frameIndex, time, angle, null, null, null);
    }, "setFrame$3", function(frameIndex, time, angle, a) {
      return this.setFrame$6(frameIndex, time, angle, a, null, null);
    }, "setFrame$4", function(frameIndex, time, angle, a, b) {
      return this.setFrame$6(frameIndex, time, angle, a, b, null);
    }, "setFrame$5", "call$6", "call$3", "call$4", "call$5", "get$setFrame", 6, 6, 716, 32, 32, 32, 75, [], 568, [], 373, [], 304, [], 305, [], 301, [], "setFrame"],
    apply$3: [function(skeleton, time, alpha) {
      var t1, bone, t2, t3, amount, frameIndex, lastFrameValue, frameTime, percent;
      t1 = J.getInterceptor$n(time);
      if (t1.$lt(time, J.$index$asx(this.frames, 0)))
        return;
      bone = J.$index$asx(skeleton.get$bones(), this.boneIndex);
      t2 = this.frames;
      t3 = J.getInterceptor$asx(t2);
      if (t1.$ge(time, t3.$index(t2, J.$sub$n(t3.get$length(t2), 2)))) {
        t1 = J.get$data$x(bone).get$rotation();
        t2 = this.frames;
        t3 = J.getInterceptor$asx(t2);
        amount = J.$sub$n(J.$add$ns(t1, t3.$index(t2, J.$sub$n(t3.get$length(t2), 1))), bone.get$rotation());
        for (; t1 = J.getInterceptor$n(amount), t1.$gt(amount, 180);)
          amount = t1.$sub(amount, 360);
        for (; t1 = J.getInterceptor$n(amount), t1.$lt(amount, -180);)
          amount = t1.$add(amount, 360);
        bone.set$rotation(J.$add$ns(bone.get$rotation(), t1.$mul(amount, alpha)));
        return;
      }
      frameIndex = M.binarySearch(this.frames, time, 2);
      t2 = J.getInterceptor$n(frameIndex);
      lastFrameValue = J.$index$asx(this.frames, t2.$sub(frameIndex, 1));
      frameTime = J.$index$asx(this.frames, frameIndex);
      t1 = J.$div$n(t1.$sub(time, frameTime), J.$sub$n(J.$index$asx(this.frames, t2.$sub(frameIndex, 2)), frameTime));
      if (typeof t1 !== "number")
        return H.iae(t1);
      percent = this.curves.getCurvePercent$2(J.$sub$n(t2.$tdiv(frameIndex, 2), 1), 1 - t1);
      amount = J.$sub$n(J.$index$asx(this.frames, t2.$add(frameIndex, 1)), lastFrameValue);
      for (; t1 = J.getInterceptor$n(amount), t1.$gt(amount, 180);)
        amount = t1.$sub(amount, 360);
      for (; t1 = J.getInterceptor$n(amount), t1.$lt(amount, -180);)
        amount = t1.$add(amount, 360);
      amount = J.$sub$n(J.$add$ns(J.get$data$x(bone).get$rotation(), J.$add$ns(lastFrameValue, t1.$mul(amount, percent))), bone.get$rotation());
      for (; t1 = J.getInterceptor$n(amount), t1.$gt(amount, 180);)
        amount = t1.$sub(amount, 360);
      for (; t1 = J.getInterceptor$n(amount), t1.$lt(amount, -180);)
        amount = t1.$add(amount, 360);
      bone.set$rotation(J.$add$ns(bone.get$rotation(), t1.$mul(amount, alpha)));
    }, "call$3", "get$apply", 6, 0, 717, 50, [], 568, [], 524, [], "apply"],
    RotateTimeline$1: function(frameCount) {
      var t1;
      this.curves = M.Curves$(frameCount);
      t1 = J.$mul$ns(frameCount, 2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = Array(t1);
      t1.fixed$length = init;
      this.frames = t1;
    },
    static: {RotateTimeline$: [function(frameCount) {
        var t1 = new M.RotateTimeline(null, null, 0);
        t1.RotateTimeline$1(frameCount);
        return t1;
      }, null, null, 2, 0, 60, 61, [], "new RotateTimeline"]}
  },
  "+RotateTimeline": [718],
  TranslateTimeline: {
    "^": "Timeline;curves-714,frames-715,boneIndex-599",
    getFrameCount$0: [function() {
      return J.$div$n(J.get$length$asx(this.frames), 3);
    }, "call$0", "get$getFrameCount", 0, 0, 13, "getFrameCount"],
    setFrame$6: [function(frameIndex, time, x, y, a, b) {
      var t1;
      frameIndex = J.$mul$ns(frameIndex, 3);
      J.$indexSet$ax(this.frames, frameIndex, time);
      t1 = J.getInterceptor$ns(frameIndex);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 1), x);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 2), y);
    }, function(frameIndex, time, x, y) {
      return this.setFrame$6(frameIndex, time, x, y, null, null);
    }, "setFrame$4", function(frameIndex, time, x) {
      return this.setFrame$6(frameIndex, time, x, null, null, null);
    }, "setFrame$3", function(frameIndex, time, x, y, a) {
      return this.setFrame$6(frameIndex, time, x, y, a, null);
    }, "setFrame$5", "call$6", "call$4", "call$3", "call$5", "get$setFrame", 6, 6, 719, 32, 32, 32, 75, [], 568, [], 6, [], 7, [], 304, [], 305, [], "setFrame"],
    apply$3: [function(skeleton, time, alpha) {
      var $frames, t1, t2, bone, frameIndex, t3, lastFrameX, lastFrameY, frameTime, percent;
      $frames = this.frames;
      t1 = J.getInterceptor$asx($frames);
      t2 = J.getInterceptor$n(time);
      if (t2.$lt(time, t1.$index($frames, 0)))
        return;
      bone = J.$index$asx(skeleton.get$bones(), this.boneIndex);
      if (t2.$ge(time, t1.$index($frames, J.$sub$n(t1.get$length($frames), 3)))) {
        t2 = J.getInterceptor$x(bone);
        t2.set$x(bone, J.$add$ns(t2.get$x(bone), J.$mul$ns(J.$sub$n(J.$add$ns(J.get$x$x(t2.get$data(bone)), t1.$index($frames, J.$sub$n(t1.get$length($frames), 2))), t2.get$x(bone)), alpha)));
        t2.set$y(bone, J.$add$ns(t2.get$y(bone), J.$mul$ns(J.$sub$n(J.$add$ns(J.get$y$x(t2.get$data(bone)), t1.$index($frames, J.$sub$n(t1.get$length($frames), 1))), t2.get$y(bone)), alpha)));
        return;
      }
      frameIndex = M.binarySearch($frames, time, 3);
      t3 = J.getInterceptor$n(frameIndex);
      lastFrameX = t1.$index($frames, t3.$sub(frameIndex, 2));
      lastFrameY = t1.$index($frames, t3.$sub(frameIndex, 1));
      frameTime = t1.$index($frames, frameIndex);
      t2 = J.$div$n(t2.$sub(time, frameTime), J.$sub$n(t1.$index($frames, t3.$add(frameIndex, -3)), frameTime));
      if (typeof t2 !== "number")
        return H.iae(t2);
      percent = this.curves.getCurvePercent$2(J.$sub$n(t3.$tdiv(frameIndex, 3), 1), 1 - t2);
      t2 = J.getInterceptor$x(bone);
      t2.set$x(bone, J.$add$ns(t2.get$x(bone), J.$mul$ns(J.$sub$n(J.$add$ns(J.$add$ns(J.get$x$x(t2.get$data(bone)), lastFrameX), J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 1)), lastFrameX), percent)), t2.get$x(bone)), alpha)));
      t2.set$y(bone, J.$add$ns(t2.get$y(bone), J.$mul$ns(J.$sub$n(J.$add$ns(J.$add$ns(J.get$y$x(t2.get$data(bone)), lastFrameY), J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 2)), lastFrameY), percent)), t2.get$y(bone)), alpha)));
    }, "call$3", "get$apply", 6, 0, 117, 50, [], 568, [], 524, [], "apply"],
    TranslateTimeline$1: function(frameCount) {
      var t1;
      this.curves = M.Curves$(frameCount);
      t1 = J.$mul$ns(frameCount, 3);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = Array(t1);
      t1.fixed$length = init;
      this.frames = t1;
    },
    static: {TranslateTimeline$: [function(frameCount) {
        var t1 = new M.TranslateTimeline(null, null, 0);
        t1.TranslateTimeline$1(frameCount);
        return t1;
      }, null, null, 2, 0, 60, 61, [], "new TranslateTimeline"]}
  },
  "+TranslateTimeline": [718],
  ScaleTimeline: {
    "^": "Timeline;curves-714,frames-715,boneIndex-599",
    getFrameCount$0: [function() {
      return J.$div$n(J.get$length$asx(this.frames), 3);
    }, "call$0", "get$getFrameCount", 0, 0, 13, "getFrameCount"],
    setFrame$6: [function(frameIndex, time, x, y, a, b) {
      var t1;
      frameIndex = J.$mul$ns(frameIndex, 3);
      J.$indexSet$ax(this.frames, frameIndex, time);
      t1 = J.getInterceptor$ns(frameIndex);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 1), x);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 2), y);
    }, function(frameIndex, time, x, y) {
      return this.setFrame$6(frameIndex, time, x, y, null, null);
    }, "setFrame$4", function(frameIndex, time, x) {
      return this.setFrame$6(frameIndex, time, x, null, null, null);
    }, "setFrame$3", function(frameIndex, time, x, y, a) {
      return this.setFrame$6(frameIndex, time, x, y, a, null);
    }, "setFrame$5", "call$6", "call$4", "call$3", "call$5", "get$setFrame", 6, 6, 719, 32, 32, 32, 75, [], 568, [], 6, [], 7, [], 304, [], 305, [], "setFrame"],
    apply$3: [function(skeleton, time, alpha) {
      var $frames, t1, t2, bone, frameIndex, t3, lastFrameX, lastFrameY, frameTime, percent;
      $frames = this.frames;
      t1 = J.getInterceptor$asx($frames);
      t2 = J.getInterceptor$n(time);
      if (t2.$lt(time, t1.$index($frames, 0)))
        return;
      bone = J.$index$asx(skeleton.get$bones(), this.boneIndex);
      if (t2.$ge(time, t1.$index($frames, J.$sub$n(t1.get$length($frames), 3)))) {
        t2 = J.getInterceptor$x(bone);
        bone.set$scaleX(J.$add$ns(bone.get$scaleX(), J.$mul$ns(J.$sub$n(J.$add$ns(J.$sub$n(t2.get$data(bone).get$scaleX(), 1), t1.$index($frames, J.$sub$n(t1.get$length($frames), 2))), bone.get$scaleX()), alpha)));
        bone.set$scaleY(J.$add$ns(bone.get$scaleY(), J.$mul$ns(J.$sub$n(J.$add$ns(J.$sub$n(t2.get$data(bone).get$scaleY(), 1), t1.$index($frames, J.$sub$n(t1.get$length($frames), 1))), bone.get$scaleY()), alpha)));
        return;
      }
      frameIndex = M.binarySearch($frames, time, 3);
      t3 = J.getInterceptor$n(frameIndex);
      lastFrameX = t1.$index($frames, t3.$sub(frameIndex, 2));
      lastFrameY = t1.$index($frames, t3.$sub(frameIndex, 1));
      frameTime = t1.$index($frames, frameIndex);
      t2 = J.$div$n(t2.$sub(time, frameTime), J.$sub$n(t1.$index($frames, t3.$add(frameIndex, -3)), frameTime));
      if (typeof t2 !== "number")
        return H.iae(t2);
      percent = this.curves.getCurvePercent$2(J.$sub$n(t3.$tdiv(frameIndex, 3), 1), 1 - t2);
      t2 = J.getInterceptor$x(bone);
      bone.set$scaleX(J.$add$ns(bone.get$scaleX(), J.$mul$ns(J.$sub$n(J.$add$ns(J.$add$ns(J.$sub$n(t2.get$data(bone).get$scaleX(), 1), lastFrameX), J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 1)), lastFrameX), percent)), bone.get$scaleX()), alpha)));
      bone.set$scaleY(J.$add$ns(bone.get$scaleY(), J.$mul$ns(J.$sub$n(J.$add$ns(J.$add$ns(J.$sub$n(t2.get$data(bone).get$scaleY(), 1), lastFrameY), J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 2)), lastFrameY), percent)), bone.get$scaleY()), alpha)));
    }, "call$3", "get$apply", 6, 0, 117, 50, [], 568, [], 524, [], "apply"],
    ScaleTimeline$1: function(frameCount) {
      var t1;
      this.curves = M.Curves$(frameCount);
      t1 = J.$mul$ns(frameCount, 3);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = Array(t1);
      t1.fixed$length = init;
      this.frames = t1;
    },
    static: {ScaleTimeline$: [function(frameCount) {
        var t1 = new M.ScaleTimeline(null, null, 0);
        t1.ScaleTimeline$1(frameCount);
        return t1;
      }, null, null, 2, 0, 60, 61, [], "new ScaleTimeline"]}
  },
  "+ScaleTimeline": [718],
  ColorTimeline: {
    "^": "Timeline;slotIndex@-599,curves-714,frames-715,boneIndex-599",
    getFrameCount$0: [function() {
      return J.$div$n(J.get$length$asx(this.frames), 5);
    }, "call$0", "get$getFrameCount", 0, 0, 13, "getFrameCount"],
    setFrame$6: [function(frameIndex, time, r, g, b, a) {
      var t1;
      frameIndex = J.$mul$ns(frameIndex, 5);
      J.$indexSet$ax(this.frames, frameIndex, time);
      t1 = J.getInterceptor$ns(frameIndex);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 1), r);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 2), g);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 3), b);
      J.$indexSet$ax(this.frames, t1.$add(frameIndex, 4), a);
    }, function(frameIndex, time, r) {
      return this.setFrame$6(frameIndex, time, r, null, null, null);
    }, "setFrame$3", function(frameIndex, time, r, g) {
      return this.setFrame$6(frameIndex, time, r, g, null, null);
    }, "setFrame$4", function(frameIndex, time, r, g, b) {
      return this.setFrame$6(frameIndex, time, r, g, b, null);
    }, "setFrame$5", "call$6", "call$3", "call$4", "call$5", "get$setFrame", 6, 6, 719, 32, 32, 32, 75, [], 568, [], 302, [], 493, [], 305, [], 304, [], "setFrame"],
    apply$3: [function(skeleton, time, alpha) {
      var $frames, t1, t2, slot, i, t3, frameIndex, lastFrameR, lastFrameG, lastFrameB, lastFrameA, frameTime, percent, r, g, b, a;
      $frames = this.frames;
      t1 = J.getInterceptor$asx($frames);
      t2 = J.getInterceptor$n(time);
      if (t2.$lt(time, t1.$index($frames, 0)))
        return;
      slot = J.$index$asx(skeleton.get$slots(), this.slotIndex);
      if (t2.$ge(time, t1.$index($frames, J.$sub$n(t1.get$length($frames), 5)))) {
        i = J.$sub$n(t1.get$length($frames), 1);
        t2 = J.getInterceptor$n(i);
        t3 = J.getInterceptor$x(slot);
        t3.set$r(slot, t1.$index($frames, t2.$sub(i, 3)));
        slot.set$g(t1.$index($frames, t2.$sub(i, 2)));
        slot.set$b(t1.$index($frames, t2.$sub(i, 1)));
        t3.set$a(slot, t1.$index($frames, i));
        return;
      }
      frameIndex = M.binarySearch($frames, time, 5);
      t3 = J.getInterceptor$n(frameIndex);
      lastFrameR = t1.$index($frames, t3.$sub(frameIndex, 4));
      lastFrameG = t1.$index($frames, t3.$sub(frameIndex, 3));
      lastFrameB = t1.$index($frames, t3.$sub(frameIndex, 2));
      lastFrameA = t1.$index($frames, t3.$sub(frameIndex, 1));
      frameTime = t1.$index($frames, frameIndex);
      t2 = J.$div$n(t2.$sub(time, frameTime), J.$sub$n(t1.$index($frames, t3.$sub(frameIndex, 5)), frameTime));
      if (typeof t2 !== "number")
        return H.iae(t2);
      percent = this.curves.getCurvePercent$2(J.$sub$n(t3.$tdiv(frameIndex, 5), 1), 1 - t2);
      r = J.$add$ns(lastFrameR, J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 1)), lastFrameR), percent));
      g = J.$add$ns(lastFrameG, J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 2)), lastFrameG), percent));
      b = J.$add$ns(lastFrameB, J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 3)), lastFrameB), percent));
      a = J.$add$ns(lastFrameA, J.$mul$ns(J.$sub$n(t1.$index($frames, t3.$add(frameIndex, 4)), lastFrameA), percent));
      t1 = J.getInterceptor$x(slot);
      if (J.$lt$n(alpha, 1)) {
        t1.set$r(slot, J.$add$ns(t1.get$r(slot), J.$mul$ns(J.$sub$n(r, t1.get$r(slot)), alpha)));
        slot.set$g(J.$add$ns(slot.get$g(), J.$mul$ns(J.$sub$n(g, slot.get$g()), alpha)));
        slot.set$b(J.$add$ns(slot.get$b(), J.$mul$ns(J.$sub$n(b, slot.get$b()), alpha)));
        t1.set$a(slot, J.$add$ns(t1.get$a(slot), J.$mul$ns(J.$sub$n(a, t1.get$a(slot)), alpha)));
      } else {
        t1.set$r(slot, r);
        slot.set$g(g);
        slot.set$b(b);
        t1.set$a(slot, a);
      }
    }, "call$3", "get$apply", 6, 0, 117, 50, [], 568, [], 524, [], "apply"],
    ColorTimeline$1: function(frameCount) {
      var t1;
      this.curves = M.Curves$(frameCount);
      t1 = J.$mul$ns(frameCount, 5);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = Array(t1);
      t1.fixed$length = init;
      this.frames = t1;
    },
    static: {ColorTimeline$: [function(frameCount) {
        var t1 = new M.ColorTimeline(0, null, null, 0);
        t1.ColorTimeline$1(frameCount);
        return t1;
      }, null, null, 2, 0, 63, 61, [], "new ColorTimeline"]}
  },
  "+ColorTimeline": [718],
  AttachmentTimeline: {
    "^": "Timeline;slotIndex@-599,attachmentNames@-720,curves-714,frames-715,boneIndex-599",
    getFrameCount$0: [function() {
      return J.get$length$asx(this.frames);
    }, "call$0", "get$getFrameCount", 0, 0, 13, "getFrameCount"],
    setFrame$6: [function(frameIndex, time, attachmentName, a, b, c) {
      J.$indexSet$ax(this.frames, frameIndex, time);
      J.$indexSet$ax(this.attachmentNames, frameIndex, attachmentName);
    }, function(frameIndex, time, attachmentName) {
      return this.setFrame$6(frameIndex, time, attachmentName, null, null, null);
    }, "setFrame$3", function(frameIndex, time, attachmentName, a) {
      return this.setFrame$6(frameIndex, time, attachmentName, a, null, null);
    }, "setFrame$4", function(frameIndex, time, attachmentName, a, b) {
      return this.setFrame$6(frameIndex, time, attachmentName, a, b, null);
    }, "setFrame$5", "call$6", "call$3", "call$4", "call$5", "get$setFrame", 6, 6, 721, 32, 32, 32, 75, [], 568, [], 722, [], 304, [], 305, [], 301, [], "setFrame"],
    apply$3: [function(skeleton, time, alpha) {
      var $frames, t1, t2, frameIndex, attachmentName;
      $frames = this.frames;
      t1 = J.getInterceptor$asx($frames);
      t2 = J.getInterceptor$n(time);
      if (t2.$lt(time, t1.$index($frames, 0)))
        return;
      frameIndex = t2.$ge(time, t1.$index($frames, J.$sub$n(t1.get$length($frames), 1))) ? J.$sub$n(t1.get$length($frames), 1) : J.$sub$n(M.binarySearch($frames, time, 1), 1);
      attachmentName = J.$index$asx(this.attachmentNames, frameIndex);
      t1 = J.$index$asx(skeleton.get$slots(), this.slotIndex);
      t1.setAttachment$1(attachmentName == null ? null : skeleton.getAttachmentBySlotIndex$2(this.slotIndex, attachmentName));
    }, "call$3", "get$apply", 6, 0, 117, 50, [], 568, [], 524, [], "apply"],
    AttachmentTimeline$1: function(frameCount) {
      var t1;
      this.curves = M.Curves$(frameCount);
      if (typeof frameCount !== "number")
        return H.iae(frameCount);
      t1 = Array(frameCount);
      t1.fixed$length = init;
      this.frames = t1;
      t1 = Array(frameCount);
      t1.fixed$length = init;
      this.attachmentNames = t1;
    },
    static: {AttachmentTimeline$: [function(frameCount) {
        var t1 = new M.AttachmentTimeline(0, null, null, null, 0);
        t1.AttachmentTimeline$1(frameCount);
        return t1;
      }, null, null, 2, 0, 60, 61, [], "new AttachmentTimeline"]}
  },
  "+AttachmentTimeline": [718],
  SkeletonData: {
    "^": "Object;bones@-723,slots@-724,skins@-720,animations@-725,defaultSkin@-726",
    findBone$1: [function(boneName) {
      var n, i;
      n = J.get$length$asx(this.bones);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.$index$asx(this.bones, i)), boneName))
          return J.$index$asx(this.bones, i);
      return;
    }, "call$1", "get$findBone", 2, 0, 727, 728, [], "findBone"],
    findBoneIndex$1: [function(boneName) {
      var n, i;
      n = J.get$length$asx(this.bones);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.$index$asx(this.bones, i)), boneName))
          return i;
      return -1;
    }, "call$1", "get$findBoneIndex", 2, 0, 514, 728, [], "findBoneIndex"],
    findSlot$1: [function(slotName) {
      var n, i;
      n = J.get$length$asx(this.slots);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.$index$asx(this.slots, i)), slotName))
          return J.$index$asx(this.slots, i);
      return;
    }, "call$1", "get$findSlot", 2, 0, 729, 730, [], "findSlot"],
    findSlotIndex$1: [function(slotName) {
      var n, i;
      n = J.get$length$asx(this.slots);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.$index$asx(this.slots, i)), slotName))
          return i;
      return -1;
    }, "call$1", "get$findSlotIndex", 2, 0, 514, 730, [], "findSlotIndex"],
    findSkin$1: [function(skinName) {
      var n, i;
      n = J.get$length$asx(this.skins);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.$index$asx(this.skins, i)), skinName))
          return J.$index$asx(this.skins, i);
      return;
    }, "call$1", "get$findSkin", 2, 0, 731, 732, [], "findSkin"],
    findAnimation$1: [function(animationName) {
      var n, i;
      n = J.get$length$asx(this.animations);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.$index$asx(this.animations, i)), animationName))
          return J.$index$asx(this.animations, i);
      return;
    }, "call$1", "get$findAnimation", 2, 0, 733, 734, [], "findAnimation"],
    static: {SkeletonData$: [function() {
        return new M.SkeletonData([], [], [], [], null);
      }, null, null, 0, 0, 13, "new SkeletonData"]}
  },
  "+SkeletonData": [632],
  Skeleton: {
    "^": "Object;data*-735,bones@-736,slots@-737,drawOrder@-737,x*-601,y*-601,skin@-726,r*-601,g@-601,b@-601,a*-601,flipX@-602,flipY@-602,time@-601",
    updateWorldTransform$0: [function() {
      var n, i;
      n = J.get$length$asx(this.bones);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        J.$index$asx(this.bones, i).updateWorldTransform$2(this.flipX, this.flipY);
    }, "call$0", "get$updateWorldTransform", 0, 0, 13, "updateWorldTransform"],
    setToSetupPose$0: [function() {
      this.setBonesToSetupPose$0();
      this.setSlotsToSetupPose$0();
    }, "call$0", "get$setToSetupPose", 0, 0, 13, "setToSetupPose"],
    setBonesToSetupPose$0: [function() {
      var n, i;
      n = J.get$length$asx(this.bones);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        J.$index$asx(this.bones, i).setToSetupPose$0();
    }, "call$0", "get$setBonesToSetupPose", 0, 0, 13, "setBonesToSetupPose"],
    setSlotsToSetupPose$0: [function() {
      var n, i;
      n = J.get$length$asx(this.slots);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        J.$index$asx(this.slots, i).setToSetupPose$0();
    }, "call$0", "get$setSlotsToSetupPose", 0, 0, 13, "setSlotsToSetupPose"],
    getRootBone$0: [function() {
      return !J.$eq(J.get$length$asx(this.bones), 0) ? J.$index$asx(this.bones, 0) : null;
    }, "call$0", "get$getRootBone", 0, 0, 738, "getRootBone"],
    findBone$1: [function(boneName) {
      var n, i;
      n = J.get$length$asx(this.bones);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.get$data$x(J.$index$asx(this.bones, i))), boneName))
          return J.$index$asx(this.bones, i);
      return;
    }, "call$1", "get$findBone", 2, 0, 739, 728, [], "findBone"],
    findBoneIndex$1: [function(boneName) {
      var n, i;
      n = J.get$length$asx(this.bones);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.get$data$x(J.$index$asx(this.bones, i))), boneName))
          return i;
      return -1;
    }, "call$1", "get$findBoneIndex", 2, 0, 514, 728, [], "findBoneIndex"],
    findSlot$1: [function(slotName) {
      var n, i;
      n = J.get$length$asx(this.slots);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.get$data$x(J.$index$asx(this.slots, i))), slotName))
          return J.$index$asx(this.slots, i);
      return;
    }, "call$1", "get$findSlot", 2, 0, 740, 730, [], "findSlot"],
    findSlotIndex$1: [function(slotName) {
      var n, i;
      n = J.get$length$asx(this.slots);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.get$data$x(J.$index$asx(this.slots, i))), slotName))
          return i;
      return -1;
    }, "call$1", "get$findSlotIndex", 2, 0, 514, 730, [], "findSlotIndex"],
    setSkinByName$1: [function(skinName) {
      var skin, t1;
      skin = this.data.findSkin$1(skinName);
      if (skin == null)
        throw H.wrapException(P.Exception_Exception("Skin not found: " + H.S(skinName)));
      t1 = this.skin;
      if (t1 != null && true)
        skin._attachAll$2(this, t1);
      this.skin = skin;
    }, "call$1", "get$setSkinByName", 2, 0, 52, 732, [], "setSkinByName"],
    setSkin$1: [function(newSkin) {
      var t1 = this.skin;
      if (t1 != null && newSkin != null)
        newSkin._attachAll$2(this, t1);
      this.skin = newSkin;
    }, "call$1", "get$setSkin", 2, 0, 741, 742, [], "setSkin"],
    getAttachmentBySlotName$2: [function(slotName, attachmentName) {
      return this.getAttachmentBySlotIndex$2(this.data.findSlotIndex$1(slotName), attachmentName);
    }, "call$2", "get$getAttachmentBySlotName", 4, 0, 743, 730, [], 722, [], "getAttachmentBySlotName"],
    getAttachmentBySlotIndex$2: [function(slotIndex, attachmentName) {
      var t1, attachment;
      t1 = this.skin;
      if (t1 != null) {
        attachment = t1.getAttachment$2(slotIndex, attachmentName);
        if (attachment != null)
          return attachment;
      }
      if (this.data.get$defaultSkin() != null)
        return this.data.get$defaultSkin().getAttachment$2(slotIndex, attachmentName);
      return;
    }, "call$2", "get$getAttachmentBySlotIndex", 4, 0, 701, 700, [], 722, [], "getAttachmentBySlotIndex"],
    setAttachment$2: [function(slotName, attachmentName) {
      var slots, t1, n, i, slot;
      slots = this.slots;
      t1 = J.getInterceptor$asx(slots);
      n = t1.get$length(slots);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i) {
        slot = t1.$index(slots, i);
        if (J.$eq(J.get$name$x(J.get$data$x(slot)), slotName)) {
          slot.setAttachment$1(attachmentName != null ? this.getAttachment$2(i, attachmentName) : null);
          return;
        }
      }
      throw H.wrapException(P.Exception_Exception("Slot not found: " + H.S(slotName)));
    }, "call$2", "get$setAttachment", 4, 0, 743, 730, [], 722, [], "setAttachment"],
    getAttachment$2: [function(i, attachmentName) {
      throw H.wrapException(P.Exception_Exception("error"));
    }, "call$2", "get$getAttachment", 4, 0, 744, 381, [], 722, [], "getAttachment"],
    update$1: [function(delta) {
      this.time = J.$add$ns(this.time, delta);
    }, "call$1", "get$update", 2, 0, 605, 745, [], "update"],
    Skeleton$1: function(skeletonData) {
      var n, i, boneData, t1, $parent, t2, slotData, slot;
      this.data = skeletonData;
      n = J.get$length$asx(skeletonData.get$bones());
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i) {
        boneData = J.$index$asx(skeletonData.get$bones(), i);
        t1 = J.getInterceptor$x(boneData);
        $parent = t1.get$parent(boneData) == null ? null : J.$index$asx(this.bones, J.indexOf$1$asx(skeletonData.get$bones(), t1.get$parent(boneData)));
        t1 = this.bones;
        t2 = new M.Bone($parent, boneData, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1);
        t2.setToSetupPose$0();
        J.add$1$ax(t1, t2);
      }
      this.slots = [];
      this.drawOrder = [];
      n = J.get$length$asx(skeletonData.get$slots());
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i) {
        slotData = J.$index$asx(skeletonData.get$slots(), i);
        slot = new M.Slot(slotData, this, J.$index$asx(this.bones, J.indexOf$1$asx(skeletonData.get$bones(), slotData.get$boneData())), null, null, null, 1, 1, 1, 1, 0, null);
        slot.setToSetupPose$0();
        J.add$1$ax(this.slots, slot);
        J.add$1$ax(this.drawOrder, slot);
      }
    },
    static: {Skeleton$: [function(skeletonData) {
        var t1 = new M.Skeleton(null, [], [], [], 0, 0, null, 1, 1, 1, 1, false, false, null);
        t1.Skeleton$1(skeletonData);
        return t1;
      }, null, null, 2, 0, 64, 65, [], "new Skeleton"]}
  },
  "+Skeleton": [632],
  Attachment: {
    "^": "Object;name*-639,offset*-720,uvs@-720,x*-601,y*-601,rotation@-601,scaleX@-601,scaleY@-601,width*-601,height*-601,regionOffsetX@-601,regionOffsetY@-601,regionWidth@-601,regionHeight@-601,regionOriginalWidth@-601,regionOriginalHeight@-601,rendererObject@-746",
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    static: {Attachment$: [function() {
        return new M.Attachment(null, null, null, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, null);
      }, null, null, 0, 0, 66, "new Attachment"]}
  },
  "+Attachment": [632],
  RegionAttachment: {
    "^": "Attachment;name-639,offset-720,uvs-720,x-601,y-601,rotation-601,scaleX-601,scaleY-601,width-601,height-601,regionOffsetX-601,regionOffsetY-601,regionWidth-601,regionHeight-601,regionOriginalWidth-601,regionOriginalHeight-601,rendererObject-746",
    setUVs$5: [function(u, v, u2, v2, rotate) {
      var uvs, t1;
      uvs = this.uvs;
      t1 = J.getInterceptor$ax(uvs);
      if (rotate === true) {
        t1.$indexSet(uvs, 2, u);
        t1.$indexSet(uvs, 3, v2);
        t1.$indexSet(uvs, 4, u);
        t1.$indexSet(uvs, 5, v);
        t1.$indexSet(uvs, 6, u2);
        t1.$indexSet(uvs, 7, v);
        t1.$indexSet(uvs, 0, u2);
        t1.$indexSet(uvs, 1, v2);
      } else {
        t1.$indexSet(uvs, 0, u);
        t1.$indexSet(uvs, 1, v2);
        t1.$indexSet(uvs, 2, u);
        t1.$indexSet(uvs, 3, v);
        t1.$indexSet(uvs, 4, u2);
        t1.$indexSet(uvs, 5, v);
        t1.$indexSet(uvs, 6, u2);
        t1.$indexSet(uvs, 7, v2);
      }
    }, "call$5", "get$setUVs", 10, 0, 747, 748, [], 376, [], 749, [], 750, [], 751, [], "setUVs"],
    updateOffset$0: [function() {
      var regionScaleX, regionScaleY, t1, t2, t3, localX, localY, localX2, localY2, radians, _cos, _sin, localXCos, localXSin, localYCos, localYSin, localX2Cos, localX2Sin, localY2Cos, localY2Sin, offset;
      regionScaleX = J.$mul$ns(J.$div$n(this.width, this.regionOriginalWidth), this.scaleX);
      regionScaleY = J.$mul$ns(J.$div$n(this.height, this.regionOriginalHeight), this.scaleY);
      t1 = J.$div$n(J.$negate$n(this.width), 2);
      t2 = this.scaleX;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = J.$mul$ns(this.regionOffsetX, regionScaleX);
      if (typeof t3 !== "number")
        return H.iae(t3);
      localX = t1 * t2 + t3;
      t3 = J.$div$n(J.$negate$n(this.height), 2);
      t2 = this.scaleY;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t1 = J.$mul$ns(this.regionOffsetY, regionScaleY);
      if (typeof t1 !== "number")
        return H.iae(t1);
      localY = t3 * t2 + t1;
      t1 = J.$mul$ns(this.regionWidth, regionScaleX);
      if (typeof t1 !== "number")
        return H.iae(t1);
      localX2 = localX + t1;
      t1 = J.$mul$ns(this.regionHeight, regionScaleY);
      if (typeof t1 !== "number")
        return H.iae(t1);
      localY2 = localY + t1;
      radians = J.$div$n(J.$mul$ns(this.rotation, 3.141592653589793), 180);
      t1 = typeof radians !== "number";
      if (t1)
        H.throwExpression(P.ArgumentError$(radians));
      _cos = Math.cos(radians);
      if (t1)
        H.throwExpression(P.ArgumentError$(radians));
      _sin = Math.sin(radians);
      t1 = this.x;
      if (typeof t1 !== "number")
        return H.iae(t1);
      localXCos = localX * _cos + t1;
      localXSin = localX * _sin;
      t2 = this.y;
      if (typeof t2 !== "number")
        return H.iae(t2);
      localYCos = localY * _cos + t2;
      localYSin = localY * _sin;
      localX2Cos = localX2 * _cos + t1;
      localX2Sin = localX2 * _sin;
      localY2Cos = localY2 * _cos + t2;
      localY2Sin = localY2 * _sin;
      offset = this.offset;
      t2 = J.getInterceptor$ax(offset);
      t2.$indexSet(offset, 0, localXCos - localYSin);
      t2.$indexSet(offset, 1, localYCos + localXSin);
      t2.$indexSet(offset, 2, localXCos - localY2Sin);
      t2.$indexSet(offset, 3, localY2Cos + localXSin);
      t2.$indexSet(offset, 4, localX2Cos - localY2Sin);
      t2.$indexSet(offset, 5, localY2Cos + localX2Sin);
      t2.$indexSet(offset, 6, localX2Cos - localYSin);
      t2.$indexSet(offset, 7, localYCos + localX2Sin);
    }, "call$0", "get$updateOffset", 0, 0, 13, "updateOffset"],
    computeVertices$4: [function(x, y, bone, vertices) {
      var m00, m01, m10, m11, offset, t1, t2;
      x = J.$add$ns(x, bone.get$worldX());
      y = J.$add$ns(y, bone.get$worldY());
      m00 = bone.get$m00();
      m01 = bone.get$m01();
      m10 = bone.get$m10();
      m11 = bone.get$m11();
      offset = this.offset;
      t1 = J.getInterceptor$asx(offset);
      t2 = J.getInterceptor$ax(vertices);
      t2.$indexSet(vertices, 0, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 0), m00), J.$mul$ns(t1.$index(offset, 1), m01)), x));
      t2.$indexSet(vertices, 1, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 0), m10), J.$mul$ns(t1.$index(offset, 1), m11)), y));
      t2.$indexSet(vertices, 2, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 2), m00), J.$mul$ns(t1.$index(offset, 3), m01)), x));
      t2.$indexSet(vertices, 3, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 2), m10), J.$mul$ns(t1.$index(offset, 3), m11)), y));
      t2.$indexSet(vertices, 4, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 4), m00), J.$mul$ns(t1.$index(offset, 5), m01)), x));
      t2.$indexSet(vertices, 5, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 4), m10), J.$mul$ns(t1.$index(offset, 5), m11)), y));
      t2.$indexSet(vertices, 6, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 6), m00), J.$mul$ns(t1.$index(offset, 7), m01)), x));
      t2.$indexSet(vertices, 7, J.$add$ns(J.$add$ns(J.$mul$ns(t1.$index(offset, 6), m10), J.$mul$ns(t1.$index(offset, 7), m11)), y));
    }, "call$4", "get$computeVertices", 8, 0, 752, 6, [], 7, [], 51, [], 753, [], "computeVertices"],
    RegionAttachment$1: function($name) {
      var t1;
      this.name = $name;
      t1 = Array(8);
      t1.fixed$length = init;
      this.offset = t1;
      t1 = Array(8);
      t1.fixed$length = init;
      this.uvs = t1;
    },
    $isRegionAttachment: true,
    static: {RegionAttachment$: [function($name) {
        var t1 = new M.RegionAttachment(null, null, null, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, null);
        t1.RegionAttachment$1($name);
        return t1;
      }, null, null, 0, 2, 67, 32, 44, [], "new RegionAttachment"]}
  },
  "+RegionAttachment": [696],
  AnimationStateData: {
    "^": "Object;skeletonData@-735,animationToMixTime@-754,defaultMix@-599",
    setMixByName$3: [function(fromName, toName, duration) {
      var from, to;
      from = this.skeletonData.findAnimation$1(fromName);
      if (from == null)
        throw H.wrapException(P.Exception_Exception("Animation not found: " + H.S(fromName)));
      to = this.skeletonData.findAnimation$1(toName);
      if (to == null)
        throw H.wrapException(P.Exception_Exception("Animation not found: " + H.S(toName)));
      J.$indexSet$ax(this.animationToMixTime, H.S(J.get$name$x(from)) + ":" + H.S(J.get$name$x(to)), duration);
    }, "call$3", "get$setMixByName", 6, 0, 755, 756, [], 757, [], 55, [], "setMixByName"],
    setMix$3: [function(from, to, duration) {
      J.$indexSet$ax(this.animationToMixTime, H.S(J.get$name$x(from)) + ":" + H.S(J.get$name$x(to)), duration);
    }, "call$3", "get$setMix", 6, 0, 758, 759, [], 760, [], 55, [], "setMix"],
    getMix$2: [function(from, to) {
      var time = J.$index$asx(this.animationToMixTime, H.S(J.get$name$x(from)) + ":" + H.S(J.get$name$x(to)));
      return time != null ? time : this.defaultMix;
    }, "call$2", "get$getMix", 4, 0, 761, 759, [], 760, [], "getMix"],
    static: {AnimationStateData$: [function(skeletonData) {
        return new M.AnimationStateData(skeletonData, P.LinkedHashMap_LinkedHashMap$_empty(null, null), 0);
      }, null, null, 2, 0, 64, 65, [], "new AnimationStateData"]}
  },
  "+AnimationStateData": [632],
  Entry: {
    "^": "Object;animation*-762,loop*-602,delay@-601",
    loop$0: function($receiver) {
      return this.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return this.loop.call$3(arg0, arg1, arg2);
    },
    delay$1: function(arg0) {
      return this.delay.call$1(arg0);
    },
    static: {Entry$: [function() {
        return new M.Entry(null, true, 0);
      }, null, null, 0, 0, 68, "new Entry"]}
  },
  "+Entry": [632],
  AnimationState: {
    "^": "Object;stateData@-763,queue@-764,current@-762,previous@-762,currentTime*-601,previousTime@-601,currentLoop@-602,previousLoop@-602,mixTime@-601,mixDuration@-601,animationSpeed@-601",
    previous$0: function() {
      return this.previous.call$0();
    },
    previous$1: function(arg0) {
      return this.previous.call$1(arg0);
    },
    update$1: [function(delta) {
      var entry, t1;
      this.currentTime = J.$add$ns(this.currentTime, J.$mul$ns(delta, this.animationSpeed));
      this.previousTime = J.$add$ns(this.previousTime, delta);
      this.mixTime = J.$add$ns(this.mixTime, delta);
      if (J.$gt$n(J.get$length$asx(this.queue), 0)) {
        entry = J.$index$asx(this.queue, 0);
        if (J.$ge$n(this.currentTime, entry.get$delay())) {
          t1 = J.getInterceptor$x(entry);
          this._setAnimation$2(t1.get$animation(entry), t1.get$loop(entry));
          J.removeAt$1$ax(this.queue, 0);
        }
      }
    }, "call$1", "get$update", 2, 0, 63, 745, [], "update"],
    apply$1: [function(skeleton) {
      var t1, t2, alpha;
      t1 = this.current;
      if (t1 == null)
        return;
      t2 = this.previous;
      if (t2 != null) {
        t2.apply$3(skeleton, this.previousTime, this.previousLoop);
        alpha = J.$div$n(this.mixTime, this.mixDuration);
        if (J.$ge$n(alpha, 1)) {
          this.previous = null;
          alpha = 1;
        }
        this.current.mix$4(skeleton, this.currentTime, this.currentLoop, alpha);
      } else
        t1.apply$3(skeleton, this.currentTime, this.currentLoop);
    }, "call$1", "get$apply", 2, 0, 765, 50, [], "apply"],
    clearAnimation$0: [function() {
      this.previous = null;
      this.current = null;
      J.clear$0$ax(this.queue);
    }, "call$0", "get$clearAnimation", 0, 0, 13, "clearAnimation"],
    _setAnimation$2: [function(animation, loop) {
      var t1;
      this.previous = null;
      if (animation != null && this.current != null) {
        t1 = this.stateData.getMix$2(this.current, animation);
        this.mixDuration = t1;
        if (J.$gt$n(t1, 0)) {
          this.mixTime = 0;
          this.previous = this.current;
          this.previousTime = this.currentTime;
          this.previousLoop = this.currentLoop;
        }
      }
      this.current = animation;
      this.currentLoop = loop;
      this.currentTime = 0;
    }, function(animation) {
      return this._setAnimation$2(animation, true);
    }, "_setAnimation$1", "call$2", "call$1", "get$_setAnimation", 2, 2, 766, 39, 767, [], 219, [], "_setAnimation"],
    setAnimationByName$2: [function(animationName, loop) {
      var animation = this.stateData.get$skeletonData().findAnimation$1(animationName);
      if (animation == null)
        throw H.wrapException(P.Exception_Exception("Animation not found: " + H.S(animationName)));
      J.clear$0$ax(this.queue);
      this._setAnimation$2(animation, loop);
    }, "call$2", "get$setAnimationByName", 4, 0, 80, 734, [], 219, [], "setAnimationByName"],
    setAnimation$2: [function(animation, loop) {
      J.clear$0$ax(this.queue);
      this._setAnimation$2(animation, loop);
    }, function(animation) {
      return this.setAnimation$2(animation, true);
    }, "setAnimation$1", "call$2", "call$1", "get$setAnimation", 2, 2, 766, 39, 767, [], 219, [], "setAnimation"],
    addAnimationByName$3: [function(animationName, loop, delay) {
      var animation, entry, t1, t2, previousAnimation;
      animation = this.stateData.get$skeletonData().findAnimation$1(animationName);
      if (animation == null)
        throw H.wrapException(P.Exception_Exception("Animation not found: " + H.S(animationName)));
      entry = new M.Entry(null, true, 0);
      entry.animation = animation;
      entry.loop = loop;
      if (J.$le$n(delay, 0)) {
        if (!J.$eq(J.get$length$asx(this.queue), 0)) {
          t1 = this.queue;
          t2 = J.getInterceptor$asx(t1);
          previousAnimation = J.get$animation$x(t2.$index(t1, J.$sub$n(t2.get$length(t1), 1)));
        } else
          previousAnimation = this.current;
        delay = previousAnimation != null ? J.$add$ns(J.$sub$n(J.get$duration$x(previousAnimation), this.stateData.getMix$2(previousAnimation, animation)), delay) : 0;
      }
      entry.delay = delay;
      J.add$1$ax(this.queue, entry);
    }, function(animationName) {
      return this.addAnimationByName$3(animationName, true, 0);
    }, "addAnimationByName$1", function(animationName, loop) {
      return this.addAnimationByName$3(animationName, loop, 0);
    }, "addAnimationByName$2", "call$3", "call$1", "call$2", "get$addAnimationByName", 2, 4, 768, 39, 5, 734, [], 219, [], 473, [], "addAnimationByName"],
    addAnimation$3: [function(animation, loop, delay) {
      var entry, t1, t2, previousAnimation;
      entry = new M.Entry(null, true, 0);
      entry.animation = animation;
      entry.loop = loop;
      if (J.$le$n(delay, 0)) {
        if (!J.$eq(J.get$length$asx(this.queue), 0)) {
          t1 = this.queue;
          t2 = J.getInterceptor$asx(t1);
          previousAnimation = J.get$animation$x(t2.$index(t1, J.$sub$n(t2.get$length(t1), 1)));
        } else
          previousAnimation = this.current;
        delay = previousAnimation != null ? J.$add$ns(J.$sub$n(J.get$duration$x(previousAnimation), this.stateData.getMix$2(previousAnimation, animation)), delay) : 0;
      }
      entry.delay = delay;
      J.add$1$ax(this.queue, entry);
    }, function(animation) {
      return this.addAnimation$3(animation, true, 0);
    }, "addAnimation$1", function(animation, loop) {
      return this.addAnimation$3(animation, loop, 0);
    }, "addAnimation$2", "call$3", "call$1", "call$2", "get$addAnimation", 2, 4, 769, 39, 5, 767, [], 219, [], 473, [], "addAnimation"],
    isComplete$0: [function() {
      var t1 = this.current;
      return t1 == null || J.$ge$n(this.currentTime, J.get$duration$x(t1));
    }, "call$0", "get$isComplete", 0, 0, 209, "isComplete"],
    static: {AnimationState$: [function(stateData) {
        return new M.AnimationState(stateData, [], null, null, 0, 0, false, false, 0, 0, 1);
      }, null, null, 2, 0, 69, 70, [], "new AnimationState"]}
  },
  "+AnimationState": [632],
  SkeletonJson: {
    "^": "Object;attachmentLoader@-770,scale*-599",
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    readSkeletonData$1: [function(root) {
      var skeletonData, t1, bones, t2, n, i, boneMap, t3, $parent, boneData, t4, slots, slotMap, slotData, color, skins, skinName, skinMap, skin, t5, slotName, slotIndex, slotEntry, t6, t7, attachmentName, attachment, animations, animationName;
      skeletonData = new M.SkeletonData([], [], [], [], null);
      t1 = J.getInterceptor$asx(root);
      bones = t1.$index(root, "bones");
      t2 = J.getInterceptor$asx(bones);
      n = t2.get$length(bones);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i) {
        boneMap = t2.$index(bones, i);
        t3 = J.getInterceptor$asx(boneMap);
        if (t3.$index(boneMap, "parent") != null) {
          $parent = skeletonData.findBone$1(t3.$index(boneMap, "parent"));
          if ($parent == null)
            throw H.wrapException(C.JSString_methods.$add("Parent bone not found: ", t3.$index(boneMap, "parent")));
        } else
          $parent = null;
        boneData = new M.BoneData(t3.$index(boneMap, "name"), $parent, 0, 0, 0, 0, 1, 1);
        t4 = t3.$index(boneMap, "length") == null ? 0 : t3.$index(boneMap, "length");
        boneData.length = J.$mul$ns(t4, this.scale);
        t4 = t3.$index(boneMap, "x") == null ? 0 : t3.$index(boneMap, "x");
        boneData.x = J.$mul$ns(t4, this.scale);
        t4 = t3.$index(boneMap, "y") == null ? 0 : t3.$index(boneMap, "y");
        boneData.y = J.$mul$ns(t4, this.scale);
        boneData.rotation = t3.$index(boneMap, "rotation") == null ? 0 : t3.$index(boneMap, "rotation");
        boneData.scaleX = t3.$index(boneMap, "scaleX") == null ? 1 : t3.$index(boneMap, "scaleX");
        boneData.scaleY = t3.$index(boneMap, "scaleY") == null ? 1 : t3.$index(boneMap, "scaleY");
        J.add$1$ax(skeletonData.bones, boneData);
      }
      slots = t1.$index(root, "slots");
      t2 = J.getInterceptor$asx(slots);
      n = t2.get$length(slots);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i) {
        slotMap = t2.$index(slots, i);
        t3 = J.getInterceptor$asx(slotMap);
        boneData = skeletonData.findBone$1(t3.$index(slotMap, "bone"));
        if (boneData == null)
          throw H.wrapException(P.Exception_Exception("Slot bone not found: " + H.S(t3.$index(slotMap, "bone"))));
        slotData = new M.SlotData(t3.$index(slotMap, "name"), boneData, 1, 1, 1, 1, null);
        color = t3.$index(slotMap, "color");
        if (color != null) {
          t4 = J.getInterceptor$asx(color);
          if (!J.$eq(t4.get$length(color), 8))
            H.throwExpression(C.JSString_methods.$add("Color hexidecimal length must be 8, recieved: ", color));
          slotData.r = J.$div$n(H.Primitives_parseInt(J.toRadixString$1$n(H.Primitives_parseInt(t4.substring$2(color, 0, 2), null, null), 16), null, null), 255);
          if (!J.$eq(t4.get$length(color), 8))
            H.throwExpression(C.JSString_methods.$add("Color hexidecimal length must be 8, recieved: ", color));
          slotData.g = J.$div$n(H.Primitives_parseInt(J.toRadixString$1$n(H.Primitives_parseInt(t4.substring$2(color, 2, 2), null, null), 16), null, null), 255);
          if (!J.$eq(t4.get$length(color), 8))
            H.throwExpression(C.JSString_methods.$add("Color hexidecimal length must be 8, recieved: ", color));
          slotData.b = J.$div$n(H.Primitives_parseInt(J.toRadixString$1$n(H.Primitives_parseInt(t4.substring$2(color, 4, 2), null, null), 16), null, null), 255);
          if (!J.$eq(t4.get$length(color), 8))
            H.throwExpression(C.JSString_methods.$add("Color hexidecimal length must be 8, recieved: ", color));
          slotData.a = J.$div$n(H.Primitives_parseInt(J.toRadixString$1$n(H.Primitives_parseInt(t4.substring$2(color, 6, 2), null, null), 16), null, null), 255);
        }
        slotData.attachmentName = t3.$index(slotMap, "attachment");
        J.add$1$ax(skeletonData.slots, slotData);
      }
      skins = t1.$index(root, "skins");
      for (t2 = J.getInterceptor$x(skins), t3 = J.get$iterator$ax(t2.get$keys(skins)); t3.moveNext$0();) {
        skinName = t3.get$current();
        skinMap = t2.$index(skins, skinName);
        skin = new M.Skin(skinName, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        for (t4 = J.getInterceptor$x(skinMap), t5 = J.get$iterator$ax(t4.get$keys(skinMap)); t5.moveNext$0();) {
          slotName = t5.get$current();
          slotIndex = skeletonData.findSlotIndex$1(slotName);
          slotEntry = t4.$index(skinMap, slotName);
          for (t6 = J.getInterceptor$x(slotEntry), t7 = J.get$iterator$ax(t6.get$keys(slotEntry)); t7.moveNext$0();) {
            attachmentName = t7.get$current();
            attachment = this.readAttachment$3(skin, attachmentName, t6.$index(slotEntry, attachmentName));
            J.$indexSet$ax(skin.attachments, "" + slotIndex + ":" + H.S(attachmentName), attachment);
          }
        }
        J.add$1$ax(skeletonData.skins, skin);
        if (J.$eq(skin.name, "default"))
          skeletonData.defaultSkin = skin;
      }
      animations = t1.$index(root, "animations");
      for (t1 = J.getInterceptor$x(animations), t2 = J.get$iterator$ax(t1.get$keys(animations)); t2.moveNext$0();) {
        animationName = t2.get$current();
        this.readAnimation$3(animationName, t1.$index(animations, animationName), skeletonData);
      }
      return skeletonData;
    }, "call$1", "get$readSkeletonData", 2, 0, 771, 772, [], "readSkeletonData"],
    readAttachment$3: [function(skin, $name, map) {
      var t1, t2, type, attachment, t3, t4, t5, t6, t7, t8, regionScaleX, regionScaleY, localX, localY, localX2, localY2, radians, _cos, _sin, localXCos, localXSin, localYCos, localYSin, localX2Cos, localX2Sin, localY2Cos, localY2Sin;
      t1 = J.getInterceptor$asx(map);
      if (t1.$index(map, "name") != null)
        $name = t1.$index(map, "name");
      t2 = $.get$AttachmentType();
      type = J.$index$asx(t2, t1.$index(map, "type") == null ? "region" : t1.$index(map, "type"));
      if (J.$eq(type, J.$index$asx($.get$AttachmentType(), "region"))) {
        attachment = new M.RegionAttachment(null, null, null, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, null);
        attachment.name = null;
        t2 = Array(8);
        t2.fixed$length = init;
        attachment.offset = t2;
        t3 = Array(8);
        t3.fixed$length = init;
        attachment.uvs = t3;
        t3 = t1.$index(map, "x") == null ? 0 : t1.$index(map, "x");
        t3 = J.$mul$ns(t3, this.scale);
        attachment.x = t3;
        t4 = t1.$index(map, "y") == null ? 0 : t1.$index(map, "y");
        t4 = J.$mul$ns(t4, this.scale);
        attachment.y = t4;
        t5 = t1.$index(map, "scaleX") == null ? 1 : t1.$index(map, "scaleX");
        attachment.scaleX = t5;
        t6 = t1.$index(map, "scaleY") == null ? 1 : t1.$index(map, "scaleY");
        attachment.scaleY = t6;
        t7 = t1.$index(map, "rotation") == null ? 0 : t1.$index(map, "rotation");
        attachment.rotation = t7;
        t8 = t1.$index(map, "width") == null ? 32 : t1.$index(map, "width");
        t8 = J.$mul$ns(t8, this.scale);
        attachment.width = t8;
        t1 = t1.$index(map, "height") == null ? 32 : t1.$index(map, "height");
        t1 = J.$mul$ns(t1, this.scale);
        attachment.height = t1;
        regionScaleX = J.$mul$ns(J.$div$n(t8, 0), t5);
        regionScaleY = J.$mul$ns(J.$div$n(t1, 0), t6);
        t8 = J.$div$n(J.$negate$n(t8), 2);
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (typeof regionScaleX !== "number")
          return H.iae(regionScaleX);
        localX = t8 * t5 + 0 * regionScaleX;
        t1 = J.$div$n(J.$negate$n(t1), 2);
        if (typeof t6 !== "number")
          return H.iae(t6);
        if (typeof regionScaleY !== "number")
          return H.iae(regionScaleY);
        localY = t1 * t6 + 0 * regionScaleY;
        localX2 = localX + 0 * regionScaleX;
        localY2 = localY + 0 * regionScaleY;
        radians = J.$div$n(J.$mul$ns(t7, 3.141592653589793), 180);
        t1 = typeof radians !== "number";
        if (t1)
          H.throwExpression(P.ArgumentError$(radians));
        _cos = Math.cos(radians);
        if (t1)
          H.throwExpression(P.ArgumentError$(radians));
        _sin = Math.sin(radians);
        if (typeof t3 !== "number")
          return H.iae(t3);
        localXCos = localX * _cos + t3;
        localXSin = localX * _sin;
        if (typeof t4 !== "number")
          return H.iae(t4);
        localYCos = localY * _cos + t4;
        localYSin = localY * _sin;
        localX2Cos = localX2 * _cos + t3;
        localX2Sin = localX2 * _sin;
        localY2Cos = localY2 * _cos + t4;
        localY2Sin = localY2 * _sin;
        if (0 < 0 || 0 >= 8)
          return H.ioore(t2, 0);
        t2[0] = localXCos - localYSin;
        if (1 < 0 || 1 >= 8)
          return H.ioore(t2, 1);
        t2[1] = localYCos + localXSin;
        if (2 < 0 || 2 >= 8)
          return H.ioore(t2, 2);
        t2[2] = localXCos - localY2Sin;
        if (3 < 0 || 3 >= 8)
          return H.ioore(t2, 3);
        t2[3] = localY2Cos + localXSin;
        if (4 < 0 || 4 >= 8)
          return H.ioore(t2, 4);
        t2[4] = localX2Cos - localY2Sin;
        if (5 < 0 || 5 >= 8)
          return H.ioore(t2, 5);
        t2[5] = localY2Cos + localX2Sin;
        if (6 < 0 || 6 >= 8)
          return H.ioore(t2, 6);
        t2[6] = localX2Cos - localYSin;
        if (7 < 0 || 7 >= 8)
          return H.ioore(t2, 7);
        t2[7] = localYCos + localX2Sin;
        t1 = new M.AtlasRegion(null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false, null, null, null, null);
        attachment.rendererObject = t1;
        t1.name = $name;
        t1.scale = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        J.$indexSet$ax(t1.scale, "x", t5);
        J.$indexSet$ax(t1.scale, "y", t6);
        t1.rotation = J.$div$n(J.$mul$ns(J.$negate$n(t7), 3.141592653589793), 180);
        return attachment;
      }
      throw H.wrapException(P.Exception_Exception("Unknown attachment type: " + H.S(type)));
    }, "call$3", "get$readAttachment", 6, 0, 773, 774, [], 44, [], 775, [], "readAttachment"],
    readAnimation$3: [function($name, map, skeletonData) {
      var timelines, t1, bones, t2, t3, duration, frameIndex, valueMap, boneName, boneIndex, boneMap, t4, t5, timelineName, values, t6, t7, timeline, t8, t9, t10, n, i, frameIndex0, timelineScale, x, y, slots, slotName, slotMap, slotIndex, color, r, g, b, a;
      timelines = [];
      t1 = J.getInterceptor$asx(map);
      bones = t1.$index(map, "bones");
      for (t2 = J.getInterceptor$x(bones), t3 = J.get$iterator$ax(t2.get$keys(bones)), duration = 0, frameIndex = null, valueMap = null; t3.moveNext$0();) {
        boneName = t3.get$current();
        boneIndex = skeletonData.findBoneIndex$1(boneName);
        if (boneIndex === -1)
          throw H.wrapException(C.JSString_methods.$add("Bone not found: ", boneName));
        boneMap = t2.$index(bones, boneName);
        for (t4 = J.getInterceptor$x(boneMap), t5 = J.get$iterator$ax(t4.get$keys(boneMap)); t5.moveNext$0();) {
          timelineName = t5.get$current();
          values = t4.$index(boneMap, timelineName);
          t6 = J.getInterceptor(timelineName);
          if (t6.$eq(timelineName, "rotate")) {
            t6 = J.getInterceptor$asx(values);
            t7 = t6.get$length(values);
            timeline = new M.RotateTimeline(null, null, 0);
            t8 = new M.Curves(null);
            t9 = J.getInterceptor$n(t7);
            t10 = J.$mul$ns(t9.$sub(t7, 1), 6);
            if (typeof t10 !== "number")
              return H.iae(t10);
            t10 = Array(t10);
            t10.fixed$length = init;
            t10.$builtinTypeInfo = [P.num];
            t8.curves = t10;
            timeline.curves = t8;
            t7 = t9.$mul(t7, 2);
            if (typeof t7 !== "number")
              return H.iae(t7);
            t7 = Array(t7);
            t7.fixed$length = init;
            timeline.frames = t7;
            timeline.boneIndex = boneIndex;
            n = t6.get$length(values);
            if (typeof n !== "number")
              return H.iae(n);
            frameIndex = 0;
            i = 0;
            for (; i < n; ++i) {
              valueMap = t6.$index(values, i);
              t7 = J.getInterceptor$asx(valueMap);
              t8 = t7.$index(valueMap, "time");
              t7 = t7.$index(valueMap, "angle");
              frameIndex0 = frameIndex * 2;
              J.$indexSet$ax(timeline.frames, frameIndex0, t8);
              J.$indexSet$ax(timeline.frames, frameIndex0 + 1, t7);
              M.SkeletonJson_readCurve(timeline, frameIndex, valueMap);
              ++frameIndex;
            }
            timelines.push(timeline);
            t6 = timeline.frames;
            t7 = J.getInterceptor$asx(t6);
            duration = P.max(duration, t7.$index(t6, J.floor$0$n(J.$sub$n(J.$mul$ns(J.$tdiv$n(t7.get$length(t6), 2), 2), 2))));
          } else if (t6.$eq(timelineName, "translate") || t6.$eq(timelineName, "scale")) {
            t7 = J.getInterceptor$asx(values);
            if (t6.$eq(timelineName, "scale")) {
              t6 = t7.get$length(values);
              timeline = new M.ScaleTimeline(null, null, 0);
              t7 = new M.Curves(null);
              t8 = J.getInterceptor$n(t6);
              t9 = J.$mul$ns(t8.$sub(t6, 1), 6);
              if (typeof t9 !== "number")
                return H.iae(t9);
              t9 = Array(t9);
              t9.fixed$length = init;
              t9.$builtinTypeInfo = [P.num];
              t7.curves = t9;
              timeline.curves = t7;
              t6 = t8.$mul(t6, 3);
              if (typeof t6 !== "number")
                return H.iae(t6);
              t6 = Array(t6);
              t6.fixed$length = init;
              timeline.frames = t6;
              timelineScale = 1;
            } else {
              t6 = t7.get$length(values);
              timeline = new M.TranslateTimeline(null, null, 0);
              t7 = new M.Curves(null);
              t8 = J.getInterceptor$n(t6);
              t9 = J.$mul$ns(t8.$sub(t6, 1), 6);
              if (typeof t9 !== "number")
                return H.iae(t9);
              t9 = Array(t9);
              t9.fixed$length = init;
              t9.$builtinTypeInfo = [P.num];
              t7.curves = t9;
              timeline.curves = t7;
              t6 = t8.$mul(t6, 3);
              if (typeof t6 !== "number")
                return H.iae(t6);
              t6 = Array(t6);
              t6.fixed$length = init;
              timeline.frames = t6;
              timelineScale = this.scale;
            }
            timeline.boneIndex = boneIndex;
            t6 = J.getInterceptor$asx(values);
            n = t6.get$length(values);
            if (typeof n !== "number")
              return H.iae(n);
            frameIndex = 0;
            i = 0;
            for (; i < n; ++i) {
              valueMap = t6.$index(values, i);
              t7 = J.getInterceptor$asx(valueMap);
              x = J.$mul$ns(t7.$index(valueMap, "x") == null ? 0 : t7.$index(valueMap, "x"), timelineScale);
              y = J.$mul$ns(t7.$index(valueMap, "y") == null ? 0 : t7.$index(valueMap, "y"), timelineScale);
              timeline.setFrame$4(frameIndex, t7.$index(valueMap, "time"), x, y);
              M.SkeletonJson_readCurve(timeline, frameIndex, valueMap);
              ++frameIndex;
            }
            timelines.push(timeline);
            duration = P.max(duration, J.$index$asx(timeline.frames, J.floor$0$n(J.$sub$n(J.$mul$ns(timeline.getFrameCount$0(), 3), 3))));
          } else
            throw H.wrapException(P.Exception_Exception("Invalid timeline type for a bone: " + H.S(timelineName) + "(" + H.S(boneName) + ")"));
        }
      }
      slots = t1.$index(map, "slots");
      if (slots != null)
        for (t1 = J.getInterceptor$x(slots), t2 = J.get$iterator$ax(t1.get$keys(slots)), values = null; t2.moveNext$0();) {
          slotName = t2.get$current();
          if (t1.containsKey$1(slots, slotName) !== true)
            continue;
          slotMap = t1.$index(slots, slotName);
          slotIndex = skeletonData.findSlotIndex$1(slotName);
          for (t3 = J.getInterceptor$x(slotMap), t4 = J.get$iterator$ax(t3.get$keys(slotMap)); t4.moveNext$0();) {
            timelineName = t4.get$current();
            if (t3.containsKey$1(slotMap, timelineName) !== true)
              continue;
            values = t3.$index(slotMap, timelineName);
            t5 = J.getInterceptor(timelineName);
            if (t5.$eq(timelineName, "color")) {
              t5 = J.getInterceptor$asx(values);
              t6 = t5.get$length(values);
              timeline = new M.ColorTimeline(0, null, null, 0);
              t7 = new M.Curves(null);
              t8 = J.getInterceptor$n(t6);
              t9 = J.$mul$ns(t8.$sub(t6, 1), 6);
              if (typeof t9 !== "number")
                return H.iae(t9);
              t9 = Array(t9);
              t9.fixed$length = init;
              t9.$builtinTypeInfo = [P.num];
              t7.curves = t9;
              timeline.curves = t7;
              t6 = t8.$mul(t6, 5);
              if (typeof t6 !== "number")
                return H.iae(t6);
              t6 = Array(t6);
              t6.fixed$length = init;
              timeline.frames = t6;
              timeline.slotIndex = slotIndex;
              n = t5.get$length(values);
              if (typeof n !== "number")
                return H.iae(n);
              frameIndex = 0;
              i = 0;
              for (; i < n; ++i) {
                valueMap = t5.$index(values, i);
                t6 = J.getInterceptor$asx(valueMap);
                color = t6.$index(valueMap, "color");
                t7 = J.getInterceptor$asx(color);
                if (!J.$eq(t7.get$length(color), 8))
                  H.throwExpression(C.JSString_methods.$add("Color hexidecimal length must be 8, recieved: ", color));
                r = J.$div$n(H.Primitives_parseInt(J.toRadixString$1$n(H.Primitives_parseInt(t7.substring$2(color, 0, 2), null, null), 16), null, null), 255);
                if (!J.$eq(t7.get$length(color), 8))
                  H.throwExpression(C.JSString_methods.$add("Color hexidecimal length must be 8, recieved: ", color));
                g = J.$div$n(H.Primitives_parseInt(J.toRadixString$1$n(H.Primitives_parseInt(t7.substring$2(color, 2, 2), null, null), 16), null, null), 255);
                if (!J.$eq(t7.get$length(color), 8))
                  H.throwExpression(C.JSString_methods.$add("Color hexidecimal length must be 8, recieved: ", color));
                b = J.$div$n(H.Primitives_parseInt(J.toRadixString$1$n(H.Primitives_parseInt(t7.substring$2(color, 4, 2), null, null), 16), null, null), 255);
                if (!J.$eq(t7.get$length(color), 8))
                  H.throwExpression(C.JSString_methods.$add("Color hexidecimal length must be 8, recieved: ", color));
                a = J.$div$n(H.Primitives_parseInt(J.toRadixString$1$n(H.Primitives_parseInt(t7.substring$2(color, 6, 2), null, null), 16), null, null), 255);
                t6 = t6.$index(valueMap, "time");
                frameIndex0 = frameIndex * 5;
                J.$indexSet$ax(timeline.frames, frameIndex0, t6);
                J.$indexSet$ax(timeline.frames, frameIndex0 + 1, r);
                J.$indexSet$ax(timeline.frames, frameIndex0 + 2, g);
                J.$indexSet$ax(timeline.frames, frameIndex0 + 3, b);
                J.$indexSet$ax(timeline.frames, frameIndex0 + 4, a);
                M.SkeletonJson_readCurve(timeline, frameIndex, valueMap);
                ++frameIndex;
              }
              timelines.push(timeline);
              t5 = timeline.frames;
              t6 = J.getInterceptor$asx(t5);
              duration = P.max(duration, t6.$index(t5, J.$sub$n(J.$mul$ns(J.$div$n(t6.get$length(t5), 5), 5), 5)));
            } else if (t5.$eq(timelineName, "attachment")) {
              t5 = J.getInterceptor$asx(values);
              t6 = t5.get$length(values);
              timeline = new M.AttachmentTimeline(0, null, null, null, 0);
              t7 = new M.Curves(null);
              t8 = J.$mul$ns(J.$sub$n(t6, 1), 6);
              if (typeof t8 !== "number")
                return H.iae(t8);
              t8 = Array(t8);
              t8.fixed$length = init;
              t8.$builtinTypeInfo = [P.num];
              t7.curves = t8;
              timeline.curves = t7;
              if (typeof t6 !== "number")
                return H.iae(t6);
              t7 = Array(t6);
              t7.fixed$length = init;
              timeline.frames = t7;
              t6 = Array(t6);
              t6.fixed$length = init;
              timeline.attachmentNames = t6;
              timeline.slotIndex = slotIndex;
              n = t5.get$length(values);
              if (typeof n !== "number")
                return H.iae(n);
              frameIndex = 0;
              i = 0;
              for (; i < n; ++i, frameIndex = frameIndex0) {
                valueMap = t5.$index(values, i);
                frameIndex0 = frameIndex + 1;
                t6 = J.getInterceptor$asx(valueMap);
                t7 = t6.$index(valueMap, "time");
                t6 = t6.$index(valueMap, "name");
                J.$indexSet$ax(timeline.frames, frameIndex, t7);
                J.$indexSet$ax(timeline.attachmentNames, frameIndex, t6);
              }
              timelines.push(timeline);
              t5 = timeline.frames;
              t6 = J.getInterceptor$asx(t5);
              duration = P.max(duration, t6.$index(t5, J.$sub$n(t6.get$length(t5), 1)));
            } else
              throw H.wrapException(C.JSString_methods.$add(C.JSString_methods.$add("Invalid timeline type for a slot: ", timelineName) + " (", slotName) + ")");
          }
        }
      J.add$1$ax(skeletonData.get$animations(), new M.Animation0($name, timelines, duration));
    }, "call$3", "get$readAnimation", 6, 0, 776, 44, [], 775, [], 65, [], "readAnimation"],
    static: {SkeletonJson$: [function(attachmentLoader) {
        return new M.SkeletonJson(attachmentLoader, 1);
      }, null, null, 0, 2, 71, 32, 72, [], "new SkeletonJson"], SkeletonJson_readCurve: [function(timeline, frameIndex, valueMap) {
        var t1, curve;
        t1 = J.getInterceptor$asx(valueMap);
        if (t1.$index(valueMap, "curve") == null)
          return;
        if (J.$eq(t1.$index(valueMap, "curve"), "stepped"))
          timeline.get$curves().setStepped$1(frameIndex);
        else if (!!J.getInterceptor(t1.$index(valueMap, "curve")).$isList) {
          curve = t1.$index(valueMap, "curve");
          t1 = J.getInterceptor$asx(curve);
          timeline.get$curves().setCurve$5(frameIndex, t1.$index(curve, 0), t1.$index(curve, 1), t1.$index(curve, 2), t1.$index(curve, 3));
        }
      }, "call$3", "SkeletonJson_readCurve$closure", 6, 0, 73, 74, [], 75, [], 76, [], "readCurve"], SkeletonJson_toColor: [function(hexString, colorIndex) {
        var t1 = J.getInterceptor$asx(hexString);
        if (!J.$eq(t1.get$length(hexString), 8))
          throw H.wrapException(C.JSString_methods.$add("Color hexidecimal length must be 8, recieved: ", hexString));
        return J.$div$n(H.Primitives_parseInt(J.toRadixString$1$n(H.Primitives_parseInt(t1.substring$2(hexString, J.$mul$ns(colorIndex, 2), 2), null, null), 16), null, null), 255);
      }, "call$2", "SkeletonJson_toColor$closure", 4, 0, 77, 78, [], 79, [], "toColor"]}
  },
  "+SkeletonJson": [632],
  Atlas: {
    "^": "Object;textureLoader@-32,pages@-777,regions@-778",
    findRegion$1: [function($name) {
      var n, i;
      n = J.get$length$asx(this.regions);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        if (J.$eq(J.get$name$x(J.$index$asx(this.regions, i)), $name))
          return J.$index$asx(this.regions, i);
      return;
    }, "call$1", "get$findRegion", 2, 0, 63, 44, [], "findRegion"],
    dispose$0: [function() {
      var pages, t1, n, i;
      pages = this.pages;
      t1 = J.getInterceptor$asx(pages);
      n = t1.get$length(pages);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i)
        this.textureLoader.unload$1(t1.$index(pages, i).get$rendererObject());
    }, "call$0", "get$dispose", 0, 0, 13, "dispose"],
    updateUVs$1: [function(page) {
      var regions, t1, n, t2, i, region, t3;
      regions = this.regions;
      t1 = J.getInterceptor$asx(regions);
      n = t1.get$length(regions);
      if (typeof n !== "number")
        return H.iae(n);
      t2 = J.getInterceptor$x(page);
      i = 0;
      for (; i < n; ++i) {
        region = t1.$index(regions, i);
        t3 = J.getInterceptor$x(region);
        if (!J.$eq(t3.get$page(region), page))
          continue;
        region.set$u(J.$div$n(t3.get$x(region), t2.get$width(page)));
        region.set$v(J.$div$n(t3.get$y(region), t2.get$height(page)));
        if (t3.get$rotate(region) === true) {
          region.set$u2(J.$div$n(J.$add$ns(t3.get$x(region), t3.get$height(region)), t2.get$width(page)));
          region.set$v2(J.$div$n(J.$add$ns(t3.get$y(region), t3.get$width(region)), t2.get$height(page)));
        } else {
          region.set$u2(J.$div$n(J.$add$ns(t3.get$x(region), t3.get$width(region)), t2.get$width(page)));
          region.set$v2(J.$div$n(J.$add$ns(t3.get$y(region), t3.get$height(region)), t2.get$height(page)));
        }
      }
    }, "call$1", "get$updateUVs", 2, 0, 779, 780, [], "updateUVs"],
    Atlas$2: function(atlasText, textureLoader) {
      var reader, tuple, page, line, t1, direction, region, x, y, width, height, t2, t3;
      reader = new M.AtlasReader(null, 0);
      reader.lines = J.split$1$s(atlasText, $.get$AtlasReader_splitReg());
      tuple = [];
      C.JSArray_methods.set$length(tuple, 4);
      for (page = null; true;) {
        line = reader.readLine$0();
        if (line == null)
          break;
        line = J.replace$2$x(line, $.get$AtlasReader_replaceReg(), "");
        if (J.$eq(J.get$length$asx(line), 0))
          page = null;
        else if (page == null) {
          page = new M.AtlasPage(null, null, null, null, null, null, null, 0, 0);
          page.name = line;
          page.format = J.$index$asx($.get$Atlas_Format(), reader.readValue$0());
          reader.readTuple$1(tuple);
          t1 = $.get$Atlas_TextureFilter();
          if (0 >= tuple.length)
            return H.ioore(tuple, 0);
          page.minFilter = J.$index$asx(t1, tuple[0]);
          t1 = $.get$Atlas_TextureFilter();
          if (1 >= tuple.length)
            return H.ioore(tuple, 1);
          page.magFilter = J.$index$asx(t1, tuple[1]);
          direction = reader.readValue$0();
          page.uWrap = J.$index$asx($.get$Atlas_TextureWrap(), "clampToEdge");
          page.vWrap = J.$index$asx($.get$Atlas_TextureWrap(), "clampToEdge");
          t1 = J.getInterceptor(direction);
          if (t1.$eq(direction, "x"))
            page.uWrap = J.$index$asx($.get$Atlas_TextureWrap(), "repeat");
          else if (t1.$eq(direction, "y"))
            page.vWrap = J.$index$asx($.get$Atlas_TextureWrap(), "repeat");
          else if (t1.$eq(direction, "xy")) {
            t1 = J.$index$asx($.get$Atlas_TextureWrap(), "repeat");
            page.vWrap = t1;
            page.uWrap = t1;
          }
          J.load$2$x(this.textureLoader, page, line);
          J.add$1$ax(this.pages, page);
        } else {
          region = new M.AtlasRegion(null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false, null, null, null, null);
          region.name = line;
          region.page = page;
          t1 = J.$eq(reader.readValue$0(), "true");
          region.rotate = t1;
          reader.readTuple$1(tuple);
          if (0 >= tuple.length)
            return H.ioore(tuple, 0);
          x = H.Primitives_parseInt(tuple[0], null, null);
          if (1 >= tuple.length)
            return H.ioore(tuple, 1);
          y = H.Primitives_parseInt(tuple[1], null, null);
          reader.readTuple$1(tuple);
          if (0 >= tuple.length)
            return H.ioore(tuple, 0);
          width = H.Primitives_parseInt(tuple[0], null, null);
          if (1 >= tuple.length)
            return H.ioore(tuple, 1);
          height = H.Primitives_parseInt(tuple[1], null, null);
          t2 = J.getInterceptor$n(x);
          region.u = t2.$div(x, page.width);
          t3 = J.getInterceptor$n(y);
          region.v = t3.$div(y, page.height);
          if (t1) {
            region.u2 = J.$div$n(t2.$add(x, height), page.width);
            region.v2 = J.$div$n(t3.$add(y, width), page.height);
          } else {
            region.u2 = J.$div$n(t2.$add(x, width), page.width);
            region.v2 = J.$div$n(t3.$add(y, height), page.height);
          }
          region.x = x;
          region.y = y;
          region.width = J.abs$0$n(width);
          region.height = J.abs$0$n(height);
          if (reader.readTuple$1(tuple) === 4) {
            if (0 >= tuple.length)
              return H.ioore(tuple, 0);
            t1 = H.Primitives_parseInt(tuple[0], null, null);
            if (1 >= tuple.length)
              return H.ioore(tuple, 1);
            t2 = H.Primitives_parseInt(tuple[1], null, null);
            if (2 >= tuple.length)
              return H.ioore(tuple, 2);
            t3 = H.Primitives_parseInt(tuple[2], null, null);
            if (3 >= tuple.length)
              return H.ioore(tuple, 3);
            region.splits = [t1, t2, t3, H.Primitives_parseInt(tuple[3], null, null)];
            if (reader.readTuple$1(tuple) === 4) {
              if (0 >= tuple.length)
                return H.ioore(tuple, 0);
              t1 = H.Primitives_parseInt(tuple[0], null, null);
              if (1 >= tuple.length)
                return H.ioore(tuple, 1);
              t2 = H.Primitives_parseInt(tuple[1], null, null);
              if (2 >= tuple.length)
                return H.ioore(tuple, 2);
              t3 = H.Primitives_parseInt(tuple[2], null, null);
              if (3 >= tuple.length)
                return H.ioore(tuple, 3);
              region.pads = [t1, t2, t3, H.Primitives_parseInt(tuple[3], null, null)];
              reader.readTuple$1(tuple);
            }
          }
          if (0 >= tuple.length)
            return H.ioore(tuple, 0);
          region.originalWidth = H.Primitives_parseInt(tuple[0], null, null);
          if (1 >= tuple.length)
            return H.ioore(tuple, 1);
          region.originalHeight = H.Primitives_parseInt(tuple[1], null, null);
          reader.readTuple$1(tuple);
          if (0 >= tuple.length)
            return H.ioore(tuple, 0);
          region.offsetX = H.Primitives_parseInt(tuple[0], null, null);
          if (1 >= tuple.length)
            return H.ioore(tuple, 1);
          region.offsetY = H.Primitives_parseInt(tuple[1], null, null);
          region.index = H.Primitives_parseInt(reader.readValue$0(), null, null);
          J.add$1$ax(this.regions, region);
        }
      }
    },
    static: {"^": "Atlas_Format@-754,Atlas_TextureFilter@-754,Atlas_TextureWrap@-754", Atlas$: [function(atlasText, textureLoader) {
        var t1 = new M.Atlas(textureLoader, [], []);
        t1.Atlas$2(atlasText, textureLoader);
        return t1;
      }, null, null, 4, 0, 80, 81, [], 82, [], "new Atlas"]}
  },
  "+Atlas": [632],
  AtlasPage: {
    "^": "Object;name*-639,format*-599,minFilter@-599,magFilter@-599,uWrap@-599,vWrap@-599,rendererObject@-746,width*-601,height*-601",
    static: {AtlasPage$: [function() {
        return new M.AtlasPage(null, null, null, null, null, null, null, 0, 0);
      }, null, null, 0, 0, 83, "new AtlasPage"]}
  },
  "+AtlasPage": [632],
  AtlasRegion: {
    "^": "Object;page*-781,name*-639,x*-601,y*-601,width*-601,height*-601,u@-601,v@-601,u2@-601,v2@-601,offsetX@-601,offsetY@-601,originalWidth@-601,originalHeight@-601,index*-599,rotate*-602,splits@-715,pads@-715,scale*-754,rotation@-601",
    rotate$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.rotate.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    static: {AtlasRegion$: [function() {
        return new M.AtlasRegion(null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false, null, null, null, null);
      }, null, null, 0, 0, 84, "new AtlasRegion"]}
  },
  "+AtlasRegion": [632],
  AtlasReader: {
    "^": "Object;lines@-720,index*-599",
    trim$1: [function(_, value) {
      return J.replace$2$x(value, $.get$AtlasReader_replaceReg(), "");
    }, "call$1", "get$trim", 2, 0, 533, 100, [], "trim"],
    readLine$0: [function() {
      var t1, t2;
      if (J.$ge$n(this.index, J.get$length$asx(this.lines)))
        return;
      t1 = this.lines;
      t2 = this.index;
      this.index = J.$add$ns(t2, 1);
      return J.$index$asx(t1, t2);
    }, "call$0", "get$readLine", 0, 0, 782, "readLine"],
    readValue$0: [function() {
      var line, t1, colon, t2;
      line = this.readLine$0();
      t1 = J.getInterceptor$asx(line);
      colon = t1.indexOf$1(line, ":");
      t2 = J.getInterceptor(colon);
      if (t2.$eq(colon, -1))
        throw H.wrapException(P.Exception_Exception("Invalid line: " + H.S(line)));
      return C.JSString_methods.replace$2(t1.substring$1(line, t2.$add(colon, 1)), $.get$AtlasReader_replaceReg(), "");
    }, "call$0", "get$readValue", 0, 0, 782, "readValue"],
    readTuple$1: [function(tuple) {
      var line, t1, colon, t2, lastMatch, i, comma, t3;
      line = this.readLine$0();
      t1 = J.getInterceptor$asx(line);
      colon = t1.indexOf$1(line, ":");
      t2 = J.getInterceptor(colon);
      if (t2.$eq(colon, -1))
        throw H.wrapException(P.Exception_Exception("Invalid line: " + H.S(line)));
      lastMatch = t2.$add(colon, 1);
      for (t2 = J.getInterceptor$ax(tuple), i = 0; i < 3; ++i) {
        comma = t1.indexOf$2(line, ",", lastMatch);
        t3 = J.getInterceptor(comma);
        if (t3.$eq(comma, -1)) {
          if (i === 0)
            throw H.wrapException(P.Exception_Exception("Invalid line: " + H.S(line)));
          break;
        }
        t2.$indexSet(tuple, i, C.JSString_methods.replace$2(t1.substring$2(line, lastMatch, t3.$sub(comma, lastMatch)), $.get$AtlasReader_replaceReg(), ""));
        lastMatch = t3.$add(comma, 1);
      }
      t2.$indexSet(tuple, i, C.JSString_methods.replace$2(t1.substring$1(line, lastMatch), $.get$AtlasReader_replaceReg(), ""));
      return i + 1;
    }, "call$1", "get$readTuple", 2, 0, 783, 784, [], "readTuple"],
    static: {"^": "AtlasReader_splitReg@-785,AtlasReader_replaceReg@-785", AtlasReader$: [function(text) {
        var t1 = new M.AtlasReader(null, 0);
        t1.lines = J.split$1$s(text, $.get$AtlasReader_splitReg());
        return t1;
      }, null, null, 2, 0, 52, 85, [], "new AtlasReader"]}
  },
  "+AtlasReader": [632],
  AtlasAttachmentLoader: {
    "^": "Object;atlas@-786",
    atlas$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.atlas.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    newAttachment$3: [function(skin, type, $name) {
      var region, attachment, t1, t2, t3, t4, t5, t6, uvs, t7;
      if (J.$eq(type, J.$index$asx($.get$AttachmentType(), "region"))) {
        region = this.atlas.findRegion$1($name);
        if (region == null)
          throw H.wrapException(P.Exception_Exception("Region not found in atlas: " + H.S($name) + " (" + H.S(type) + ")"));
        attachment = M.RegionAttachment$($name);
        attachment.rendererObject = region;
        t1 = region.get$u();
        t2 = region.get$v();
        t3 = region.get$u2();
        t4 = region.get$v2();
        t5 = J.getInterceptor$x(region);
        t6 = t5.get$rotate(region);
        uvs = attachment.uvs;
        t7 = J.getInterceptor$ax(uvs);
        if (t6 === true) {
          t7.$indexSet(uvs, 2, t1);
          t7.$indexSet(uvs, 3, t4);
          t7.$indexSet(uvs, 4, t1);
          t7.$indexSet(uvs, 5, t2);
          t7.$indexSet(uvs, 6, t3);
          t7.$indexSet(uvs, 7, t2);
          t7.$indexSet(uvs, 0, t3);
          t7.$indexSet(uvs, 1, t4);
        } else {
          t7.$indexSet(uvs, 0, t1);
          t7.$indexSet(uvs, 1, t4);
          t7.$indexSet(uvs, 2, t1);
          t7.$indexSet(uvs, 3, t2);
          t7.$indexSet(uvs, 4, t3);
          t7.$indexSet(uvs, 5, t2);
          t7.$indexSet(uvs, 6, t3);
          t7.$indexSet(uvs, 7, t4);
        }
        attachment.regionOffsetX = region.get$offsetX();
        attachment.regionOffsetY = region.get$offsetY();
        attachment.regionWidth = t5.get$width(region);
        attachment.regionHeight = t5.get$height(region);
        attachment.regionOriginalWidth = region.get$originalWidth();
        attachment.regionOriginalHeight = region.get$originalHeight();
        return attachment;
      }
      throw H.wrapException(P.Exception_Exception("Unknown attachment type: " + H.S(type)));
    }, "call$3", "get$newAttachment", 6, 0, 787, 774, [], 99, [], 44, [], "newAttachment"],
    static: {AtlasAttachmentLoader$: [function(atlas) {
        return new M.AtlasAttachmentLoader(atlas);
      }, null, null, 2, 0, 86, 87, [], "new AtlasAttachmentLoader"]}
  },
  "+AtlasAttachmentLoader": [632],
  Spine: {
    "^": "DisplayObjectContainer;skeleton@-694,skeletonData@-735,stateData@-763,state*-788,slotContainers@-789,lastTime@-790,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    updateTransform$0: [function() {
      var now, t1, drawOrder, n, i, slot, attachment, slotContainer, spriteName, bone, t2, t3;
      now = new P.DateTime(Date.now(), false);
      now.DateTime$_now$0();
      t1 = this.lastTime;
      if (t1 == null) {
        this.lastTime = now;
        t1 = now;
      }
      t1 = C.JSNumber_methods._tdivFast$1(now.difference$1(t1)._duration, 1000);
      this.lastTime = now;
      this.state.update$1(t1 * 0.001);
      this.state.apply$1(this.skeleton);
      this.skeleton.updateWorldTransform$0();
      drawOrder = this.skeleton.get$drawOrder();
      t1 = J.getInterceptor$asx(drawOrder);
      n = t1.get$length(drawOrder);
      if (typeof n !== "number")
        return H.iae(n);
      i = 0;
      for (; i < n; ++i) {
        slot = t1.$index(drawOrder, i);
        attachment = slot.get$attachment();
        slotContainer = J.$index$asx(this.slotContainers, i);
        if (!J.getInterceptor(attachment).$isRegionAttachment) {
          slotContainer.set$visible(false);
          continue;
        }
        if (attachment.rendererObject != null)
          if (slot.get$currentSpriteName() == null || !J.$eq(slot.get$currentSpriteName(), attachment.name)) {
            spriteName = J.get$name$x(attachment.rendererObject);
            if (slot.get$currentSprite() != null)
              slot.get$currentSprite().set$visible(false);
            if (slot.get$sprites() == null)
              slot.set$sprites(P.LinkedHashMap_LinkedHashMap$_empty(null, null));
            if (J.$index$asx(slot.get$sprites(), spriteName) != null)
              J.$index$asx(slot.get$sprites(), spriteName).set$visible(true);
            else
              slotContainer.addChild$1(this.createSprite$2(slot, attachment.rendererObject));
            slot.set$currentSprite(J.$index$asx(slot.get$sprites(), spriteName));
            slot.set$currentSpriteName(spriteName);
          }
        slotContainer.set$visible(true);
        bone = slot.get$bone();
        t2 = J.getInterceptor$x(slotContainer);
        J.set$x$x(t2.get$position(slotContainer), J.$add$ns(J.$add$ns(bone.get$worldX(), J.$mul$ns(attachment.x, bone.get$m00())), J.$mul$ns(attachment.y, bone.get$m01())));
        J.set$y$x(t2.get$position(slotContainer), J.$add$ns(J.$add$ns(bone.get$worldY(), J.$mul$ns(attachment.x, bone.get$m10())), J.$mul$ns(attachment.y, bone.get$m11())));
        J.set$x$x(t2.get$scale(slotContainer), bone.get$worldScaleX());
        J.set$y$x(t2.get$scale(slotContainer), bone.get$worldScaleY());
        slotContainer.set$rotation(J.$negate$n(J.$div$n(J.$mul$ns(slot.get$bone().get$worldRotation(), 3.141592653589793), 180)));
        t3 = J.getInterceptor$x(slot);
        t2.set$alpha(slotContainer, t3.get$a(slot));
        slot.get$currentSprite().set$tint(M.rgb2hex([t3.get$r(slot), slot.get$g(), slot.get$b()]));
      }
      M.DisplayObjectContainer.prototype.updateTransform$0.call(this);
    }, "call$0", "get$updateTransform", 0, 0, 13, "updateTransform"],
    createSprite$2: [function(slot, descriptor) {
      var t1, $name, texture, t2, t3, t4, t5, t6, sprite;
      t1 = J.getInterceptor$x(descriptor);
      $name = J.$index$asx($.get$TextureCache(), t1.get$name(descriptor)) != null ? t1.get$name(descriptor) : H.S(t1.get$name(descriptor)) + ".png";
      texture = J.$index$asx($.get$TextureCache(), $name);
      if (texture == null)
        H.throwExpression(P.Exception_Exception("The frameId \"" + H.S($name) + "\" does not exist in the texture cache"));
      t2 = new M.Point0(null, null);
      t2.x = 0;
      t2.y = 0;
      t3 = new M.Point0(null, null);
      t3.x = 0;
      t3.y = 0;
      t4 = new M.Point0(null, null);
      t4.x = 1;
      t4.y = 1;
      t5 = new M.Point0(null, null);
      t5.x = 0;
      t5.y = 0;
      t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      sprite = new M.Sprite(t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
      sprite.texture = texture;
      if (texture.get$baseTexture().get$hasLoaded() === true)
        sprite._onTextureUpdate$1(null);
      else
        J.addEventListener$2$x(texture, "update", sprite.get$_onTextureUpdate());
      t2 = J.$index$asx(t1.get$scale(descriptor), "x");
      t3 = J.$index$asx(t1.get$scale(descriptor), "y");
      t4 = new M.Point0(null, null);
      t4.x = t2;
      t4.y = t3;
      sprite.scale = t4;
      sprite.rotation = descriptor.get$rotation();
      t4 = sprite.anchor;
      t3 = J.getInterceptor$x(t4);
      t3.set$y(t4, 0.5);
      t3.set$x(t4, 0.5);
      if (slot.get$sprites() == null)
        slot.set$sprites(P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      J.$indexSet$ax(slot.get$sprites(), t1.get$name(descriptor), sprite);
      return sprite;
    }, "call$2", "get$createSprite", 4, 0, 791, 792, [], 793, [], "createSprite"],
    Spine$1: function(url) {
      var t1, n, t2, i, slot, attachment, t3, t4, t5, t6, t7, slotContainer, spriteName, sprite;
      t1 = J.$index$asx($.get$AnimCache(), url);
      this.skeletonData = t1;
      if (t1 == null)
        throw H.wrapException(P.Exception_Exception("Spine data must be preloaded using PIXI.SpineLoader or PIXI.AssetLoader: " + H.S(url)));
      t1 = M.Skeleton$(t1);
      this.skeleton = t1;
      t1.updateWorldTransform$0();
      t1 = new M.AnimationStateData(this.skeletonData, P.LinkedHashMap_LinkedHashMap$_empty(null, null), 0);
      this.stateData = t1;
      this.state = new M.AnimationState(t1, [], null, null, 0, 0, false, false, 0, 0, 1);
      this.slotContainers = [];
      n = J.get$length$asx(this.skeleton.get$drawOrder());
      if (typeof n !== "number")
        return H.iae(n);
      t1 = this.children;
      t2 = J.getInterceptor$asx(t1);
      i = 0;
      for (; i < n; ++i) {
        slot = J.$index$asx(this.skeleton.get$drawOrder(), i);
        attachment = slot.get$attachment();
        t3 = [];
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = new M.Point0(null, null);
        t5.x = 1;
        t5.y = 1;
        t6 = new M.Point0(null, null);
        t6.x = 0;
        t6.y = 0;
        t7 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        slotContainer = new M.DisplayObjectContainer(t3, false, 0, 0, t4, t5, t6, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t7, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        J.add$1$ax(this.slotContainers, slotContainer);
        this.addChildAt$2(slotContainer, t2.get$length(t1));
        if (!J.getInterceptor(attachment).$isRegionAttachment)
          continue;
        spriteName = J.get$name$x(attachment.rendererObject);
        sprite = this.createSprite$2(slot, attachment.rendererObject);
        slot.set$currentSprite(sprite);
        slot.set$currentSpriteName(spriteName);
        slotContainer.addChildAt$2(sprite, t3.length);
      }
    },
    static: {Spine$: [function(url) {
        var t1, t2, t3, t4;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 1;
        t2.y = 1;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new M.Spine(null, null, null, null, [], null, [], false, 0, 0, t1, t2, t3, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t4, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.Spine$1(url);
        return t1;
      }, null, null, 2, 0, 52, 88, [], "new Spine"]}
  },
  "+Spine": [678],
  Strip: {
    "^": "DisplayObjectContainer;texture@-670,blendMode@-674,uvs@-630,verticies@-630,colors@-630,indices@-685,updateFrame@-602,_vertexBuffer@-686,_indexBuffer@-686,_uvBuffer@-686,_colorBuffer@-686,count@-599,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    onTextureUpdate$1: [function(e) {
      this.updateFrame = true;
    }, "call$1", "get$onTextureUpdate", 2, 0, 63, 312, [], "onTextureUpdate"],
    _renderWebGL$1: [function(renderSession) {
      var gl, t1, projection, offset, shader, t2, t3;
      if (this.visible !== true || J.$le$n(this.alpha, 0))
        return;
      J.stop$0$x(renderSession.get$spriteBatch());
      if (this._vertexBuffer == null) {
        gl = renderSession.get$gl();
        t1 = J.getInterceptor$x(gl);
        this._vertexBuffer = t1.createBuffer$0(gl);
        this._indexBuffer = t1.createBuffer$0(gl);
        this._uvBuffer = t1.createBuffer$0(gl);
        this._colorBuffer = t1.createBuffer$0(gl);
        t1.bindBuffer$2(gl, 34962, this._vertexBuffer);
        t1.bufferData$3(gl, 34962, this.verticies, 35048);
        t1.bindBuffer$2(gl, 34962, this._uvBuffer);
        t1.bufferData$3(gl, 34962, this.uvs, 35044);
        t1.bindBuffer$2(gl, 34962, this._colorBuffer);
        t1.bufferData$3(gl, 34962, this.colors, 35044);
        t1.bindBuffer$2(gl, 34963, this._indexBuffer);
        t1.bufferData$3(gl, 34963, this.indices, 35044);
      }
      renderSession.get$shaderManager().setShader$1(renderSession.get$shaderManager().get$stripShader());
      gl = renderSession.get$gl();
      projection = renderSession.get$projection();
      offset = J.get$offset$x(renderSession);
      shader = renderSession.get$shaderManager().get$stripShader();
      t1 = J.getInterceptor$x(gl);
      t1.blendFunc$2(gl, 1, 771);
      t1.uniformMatrix3fv$3(gl, shader.get$translationMatrix(), false, this._worldTransform.toArray$1(true));
      t2 = J.getInterceptor$x(projection);
      t1.uniform2f$3(gl, shader.get$projectionVector(), t2.get$x(projection), J.$negate$n(t2.get$y(projection)));
      t2 = J.getInterceptor$x(offset);
      t1.uniform2f$3(gl, shader.get$offsetVector(), J.$negate$n(t2.get$x(offset)), J.$negate$n(t2.get$y(offset)));
      t1.uniform1f$2(gl, J.get$alpha$x(shader), 1);
      if (this._dirty !== true) {
        t1.bindBuffer$2(gl, 34962, this._vertexBuffer);
        t1.bufferSubData$3(gl, 34962, 0, this.verticies);
        t1.vertexAttribPointer$6(gl, shader.get$aVertexPosition(), 2, 5126, false, 0, 0);
        t1.bindBuffer$2(gl, 34962, this._uvBuffer);
        t1.vertexAttribPointer$6(gl, shader.get$aTextureCoord(), 2, 5126, false, 0, 0);
        t1.activeTexture$1(gl, 33984);
        t2 = J.$index$asx(this.texture.get$baseTexture().get$_glTextures(), gl);
        t3 = this.texture;
        t1.bindTexture$2(gl, 3553, t2 == null ? M.createWebGLTexture(t3.get$baseTexture(), gl) : J.$index$asx(t3.get$baseTexture().get$_glTextures(), gl));
        t1.bindBuffer$2(gl, 34963, this._indexBuffer);
      } else {
        this._dirty = false;
        t1.bindBuffer$2(gl, 34962, this._vertexBuffer);
        t1.bufferData$3(gl, 34962, this.verticies, 35044);
        t1.vertexAttribPointer$6(gl, shader.get$aVertexPosition(), 2, 5126, false, 0, 0);
        t1.bindBuffer$2(gl, 34962, this._uvBuffer);
        t1.bufferData$3(gl, 34962, this.uvs, 35044);
        t1.vertexAttribPointer$6(gl, shader.get$aTextureCoord(), 2, 5126, false, 0, 0);
        t1.activeTexture$1(gl, 33984);
        t2 = J.$index$asx(this.texture.get$baseTexture().get$_glTextures(), gl);
        t3 = this.texture;
        t1.bindTexture$2(gl, 3553, t2 == null ? M.createWebGLTexture(t3.get$baseTexture(), gl) : J.$index$asx(t3.get$baseTexture().get$_glTextures(), gl));
        t1.bindBuffer$2(gl, 34963, this._indexBuffer);
        t1.bufferData$3(gl, 34963, this.indices, 35044);
      }
      t1.drawElements$4(gl, 5, J.get$length$asx(this.indices), 5123, 0);
      J.start$0$x(renderSession.get$spriteBatch());
    }, "call$1", "get$_renderWebGL", 2, 0, 655, 128, [], "_renderWebGL"],
    _initWebGL$1: [function(renderSession) {
      var gl, t1;
      gl = renderSession.get$gl();
      t1 = J.getInterceptor$x(gl);
      this._vertexBuffer = t1.createBuffer$0(gl);
      this._indexBuffer = t1.createBuffer$0(gl);
      this._uvBuffer = t1.createBuffer$0(gl);
      this._colorBuffer = t1.createBuffer$0(gl);
      t1.bindBuffer$2(gl, 34962, this._vertexBuffer);
      t1.bufferData$3(gl, 34962, this.verticies, 35048);
      t1.bindBuffer$2(gl, 34962, this._uvBuffer);
      t1.bufferData$3(gl, 34962, this.uvs, 35044);
      t1.bindBuffer$2(gl, 34962, this._colorBuffer);
      t1.bufferData$3(gl, 34962, this.colors, 35044);
      t1.bindBuffer$2(gl, 34963, this._indexBuffer);
      t1.bufferData$3(gl, 34963, this.indices, 35044);
    }, "call$1", "get$_initWebGL", 2, 0, 655, 128, [], "_initWebGL"],
    _renderStrip$1: [function(renderSession) {
      var gl, projection, offset, shader, t1, t2, t3;
      gl = renderSession.get$gl();
      projection = renderSession.get$projection();
      offset = J.get$offset$x(renderSession);
      shader = renderSession.get$shaderManager().get$stripShader();
      t1 = J.getInterceptor$x(gl);
      t1.blendFunc$2(gl, 1, 771);
      t1.uniformMatrix3fv$3(gl, shader.get$translationMatrix(), false, this._worldTransform.toArray$1(true));
      t2 = J.getInterceptor$x(projection);
      t1.uniform2f$3(gl, shader.get$projectionVector(), t2.get$x(projection), J.$negate$n(t2.get$y(projection)));
      t2 = J.getInterceptor$x(offset);
      t1.uniform2f$3(gl, shader.get$offsetVector(), J.$negate$n(t2.get$x(offset)), J.$negate$n(t2.get$y(offset)));
      t1.uniform1f$2(gl, J.get$alpha$x(shader), 1);
      if (this._dirty !== true) {
        t1.bindBuffer$2(gl, 34962, this._vertexBuffer);
        t1.bufferSubData$3(gl, 34962, 0, this.verticies);
        t1.vertexAttribPointer$6(gl, shader.get$aVertexPosition(), 2, 5126, false, 0, 0);
        t1.bindBuffer$2(gl, 34962, this._uvBuffer);
        t1.vertexAttribPointer$6(gl, shader.get$aTextureCoord(), 2, 5126, false, 0, 0);
        t1.activeTexture$1(gl, 33984);
        t2 = J.$index$asx(this.texture.get$baseTexture().get$_glTextures(), gl);
        t3 = this.texture;
        t1.bindTexture$2(gl, 3553, t2 == null ? M.createWebGLTexture(t3.get$baseTexture(), gl) : J.$index$asx(t3.get$baseTexture().get$_glTextures(), gl));
        t1.bindBuffer$2(gl, 34963, this._indexBuffer);
      } else {
        this._dirty = false;
        t1.bindBuffer$2(gl, 34962, this._vertexBuffer);
        t1.bufferData$3(gl, 34962, this.verticies, 35044);
        t1.vertexAttribPointer$6(gl, shader.get$aVertexPosition(), 2, 5126, false, 0, 0);
        t1.bindBuffer$2(gl, 34962, this._uvBuffer);
        t1.bufferData$3(gl, 34962, this.uvs, 35044);
        t1.vertexAttribPointer$6(gl, shader.get$aTextureCoord(), 2, 5126, false, 0, 0);
        t1.activeTexture$1(gl, 33984);
        t2 = J.$index$asx(this.texture.get$baseTexture().get$_glTextures(), gl);
        t3 = this.texture;
        t1.bindTexture$2(gl, 3553, t2 == null ? M.createWebGLTexture(t3.get$baseTexture(), gl) : J.$index$asx(t3.get$baseTexture().get$_glTextures(), gl));
        t1.bindBuffer$2(gl, 34963, this._indexBuffer);
        t1.bufferData$3(gl, 34963, this.indices, 35044);
      }
      t1.drawElements$4(gl, 5, J.get$length$asx(this.indices), 5123, 0);
    }, "call$1", "get$_renderStrip", 2, 0, 655, 128, [], "_renderStrip"],
    _renderCanvas$1: [function(renderSession) {
      var context, transform, t1, t2, verticies, uvs, $length, t3, t4, i, t5, index, x0, x1, t6, x2, t7, y0, t8, y1, t9, y2, t10, centerX, t11, centerY, normX, normY, t12, dist, t13, t14, u0, u1, u2, v0, v1, v2, delta, deltaA, deltaB, deltaC, deltaD, deltaE, deltaF;
      context = J.get$context$x(renderSession);
      transform = this._worldTransform;
      t1 = J.getInterceptor$x(context);
      t2 = J.getInterceptor$x(transform);
      if (renderSession.get$roundPixels() === true)
        t1.setTransform$6(context, t2.get$a(transform), transform.get$c(), transform.get$b(), transform.get$d(), J.floor$0$n(transform.get$tx()), J.floor$0$n(transform.get$ty()));
      else
        t1.setTransform$6(context, t2.get$a(transform), transform.get$c(), transform.get$b(), transform.get$d(), transform.get$tx(), transform.get$ty());
      verticies = this.verticies;
      uvs = this.uvs;
      t1 = J.getInterceptor$asx(verticies);
      $length = J.$div$n(t1.get$length(verticies), 2);
      this.set$count(J.$add$ns(this.get$count(), 1));
      t2 = J.getInterceptor$n($length);
      t3 = J.getInterceptor$asx(uvs);
      t4 = J.getInterceptor$x(context);
      i = 0;
      while (true) {
        t5 = t2.$sub($length, 2);
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (!(i < t5))
          break;
        index = i * 2;
        x0 = t1.$index(verticies, index);
        t5 = index + 2;
        x1 = t1.$index(verticies, t5);
        t6 = index + 4;
        x2 = t1.$index(verticies, t6);
        t7 = index + 1;
        y0 = t1.$index(verticies, t7);
        t8 = index + 3;
        y1 = t1.$index(verticies, t8);
        t9 = index + 5;
        y2 = t1.$index(verticies, t9);
        t10 = J.getInterceptor$ns(x0);
        centerX = J.$div$n(J.$add$ns(t10.$add(x0, x1), x2), 3);
        t11 = J.getInterceptor$ns(y0);
        centerY = J.$div$n(J.$add$ns(t11.$add(y0, y1), y2), 3);
        normX = t10.$sub(x0, centerX);
        normY = t11.$sub(y0, centerY);
        t11 = J.getInterceptor$ns(normX);
        t10 = J.getInterceptor$ns(normY);
        t12 = J.$add$ns(t11.$mul(normX, normX), t10.$mul(normY, normY));
        if (typeof t12 !== "number")
          H.throwExpression(P.ArgumentError$(t12));
        dist = Math.sqrt(t12);
        t12 = dist + 3;
        t13 = J.getInterceptor$ns(centerX);
        x0 = t13.$add(centerX, J.$mul$ns(t11.$div(normX, dist), t12));
        t11 = J.getInterceptor$ns(centerY);
        y0 = t11.$add(centerY, J.$mul$ns(t10.$div(normY, dist), t12));
        normX = J.$sub$n(x1, centerX);
        normY = J.$sub$n(y1, centerY);
        t12 = J.getInterceptor$ns(normX);
        t10 = J.getInterceptor$ns(normY);
        t14 = J.$add$ns(t12.$mul(normX, normX), t10.$mul(normY, normY));
        if (typeof t14 !== "number")
          H.throwExpression(P.ArgumentError$(t14));
        dist = Math.sqrt(t14);
        t14 = dist + 3;
        x1 = t13.$add(centerX, J.$mul$ns(t12.$div(normX, dist), t14));
        y1 = t11.$add(centerY, J.$mul$ns(t10.$div(normY, dist), t14));
        normX = J.$sub$n(x2, centerX);
        normY = J.$sub$n(y2, centerY);
        t14 = J.getInterceptor$ns(normX);
        t10 = J.getInterceptor$ns(normY);
        t12 = J.$add$ns(t14.$mul(normX, normX), t10.$mul(normY, normY));
        if (typeof t12 !== "number")
          H.throwExpression(P.ArgumentError$(t12));
        dist = Math.sqrt(t12);
        t12 = dist + 3;
        x2 = t13.$add(centerX, J.$mul$ns(t14.$div(normX, dist), t12));
        y2 = t11.$add(centerY, J.$mul$ns(t10.$div(normY, dist), t12));
        u0 = J.$mul$ns(t3.$index(uvs, index), J.get$width$x(this.texture));
        u1 = J.$mul$ns(t3.$index(uvs, t5), J.get$width$x(this.texture));
        u2 = J.$mul$ns(t3.$index(uvs, t6), J.get$width$x(this.texture));
        v0 = J.$mul$ns(t3.$index(uvs, t7), J.get$height$x(this.texture));
        v1 = J.$mul$ns(t3.$index(uvs, t8), J.get$height$x(this.texture));
        v2 = J.$mul$ns(t3.$index(uvs, t9), J.get$height$x(this.texture));
        t4.save$0(context);
        t4.beginPath$0(context);
        t4.moveTo$2(context, x0, y0);
        t4.lineTo$2(context, x1, y1);
        t4.lineTo$2(context, x2, y2);
        t4.closePath$0(context);
        t4.clip$0(context);
        t5 = J.getInterceptor$ns(u0);
        t6 = J.getInterceptor$ns(v0);
        t7 = J.getInterceptor$ns(u1);
        t8 = J.getInterceptor$ns(v1);
        delta = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t5.$mul(u0, v1), t6.$mul(v0, u2)), t7.$mul(u1, v2)), t8.$mul(v1, u2)), t6.$mul(v0, u1)), t5.$mul(u0, v2));
        t9 = J.getInterceptor$ns(x0);
        t10 = J.getInterceptor$ns(x1);
        deltaA = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t9.$mul(x0, v1), t6.$mul(v0, x2)), t10.$mul(x1, v2)), t8.$mul(v1, x2)), t6.$mul(v0, x1)), t9.$mul(x0, v2));
        deltaB = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t5.$mul(u0, x1), t9.$mul(x0, u2)), t7.$mul(u1, x2)), t10.$mul(x1, u2)), t9.$mul(x0, u1)), t5.$mul(u0, x2));
        deltaC = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(J.$mul$ns(t5.$mul(u0, v1), x2), J.$mul$ns(t6.$mul(v0, x1), u2)), J.$mul$ns(t9.$mul(x0, u1), v2)), J.$mul$ns(t9.$mul(x0, v1), u2)), J.$mul$ns(t6.$mul(v0, u1), x2)), J.$mul$ns(t5.$mul(u0, x1), v2));
        t9 = J.getInterceptor$ns(y0);
        t10 = J.getInterceptor$ns(y1);
        deltaD = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t9.$mul(y0, v1), t6.$mul(v0, y2)), t10.$mul(y1, v2)), t8.$mul(v1, y2)), t6.$mul(v0, y1)), t9.$mul(y0, v2));
        deltaE = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t5.$mul(u0, y1), t9.$mul(y0, u2)), t7.$mul(u1, y2)), t10.$mul(y1, u2)), t9.$mul(y0, u1)), t5.$mul(u0, y2));
        deltaF = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(J.$mul$ns(t5.$mul(u0, v1), y2), J.$mul$ns(t6.$mul(v0, y1), u2)), J.$mul$ns(t9.$mul(y0, u1), v2)), J.$mul$ns(t9.$mul(y0, v1), u2)), J.$mul$ns(t6.$mul(v0, u1), y2)), J.$mul$ns(t5.$mul(u0, y1), v2));
        t4.transform$6(context, J.$div$n(deltaA, delta), J.$div$n(deltaD, delta), J.$div$n(deltaB, delta), J.$div$n(deltaE, delta), J.$div$n(deltaC, delta), J.$div$n(deltaF, delta));
        t4.drawImage$3(context, J.get$source$x(this.texture.get$baseTexture()), 0, 0);
        t4.restore$0(context);
        ++i;
      }
    }, "call$1", "get$_renderCanvas", 2, 0, 655, 128, [], "_renderCanvas"],
    Strip$1: function(texture) {
      this.texture = texture;
      this.uvs = new Float32Array(H._ensureNativeList([0, 1, 1, 1, 1, 0, 0, 1]));
      this.verticies = new Float32Array(H._ensureNativeList([0, 0, 100, 0, 100, 100, 0, 100]));
      this.colors = new Float32Array(H._ensureNativeList([1, 1, 1, 1]));
      this.indices = new Uint16Array(H._ensureNativeList([0, 1, 2, 3]));
      this._dirty = true;
    },
    static: {Strip$: [function(texture) {
        var t1, t2, t3, t4;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 1;
        t2.y = 1;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new M.Strip(null, C.BlendModes_0, null, null, null, null, false, null, null, null, null, 0, [], false, 0, 0, t1, t2, t3, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t4, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.Strip$1(texture);
        return t1;
      }, null, null, 2, 0, 27, 28, [], "new Strip"]}
  },
  "+Strip": [678],
  TilingSprite: {
    "^": "Sprite;_width:PIXI$TilingSprite$_width@-601,_height:PIXI$TilingSprite$_height@-601,tileScale@-634,tilePosition@-634,_PIXI$__tilePattern@-794,tilingTexture@-670,refreshTexture@-602,tileScaleOffset@-634,anchor-634,texture-670,updateFrame-602,PIXI$Sprite$_width-601,PIXI$Sprite$_height-601,_uvs-671,tintedTexture-672,buffer-673,tint-599,cachedTint-599,blendMode-674,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    get$width: [function(_) {
      return this.PIXI$TilingSprite$_width;
    }, null, null, 1, 0, 604, "width"],
    set$width: [function(_, value) {
      this.PIXI$TilingSprite$_width = value;
    }, null, null, 3, 0, 63, 100, [], "width"],
    get$height: [function(_) {
      return this.PIXI$TilingSprite$_height;
    }, null, null, 1, 0, 604, "height"],
    set$height: [function(_, value) {
      this.PIXI$TilingSprite$_height = value;
    }, null, null, 3, 0, 63, 100, [], "height"],
    setTexture$1: [function(texture) {
      if (J.$eq(this.texture, texture))
        return;
      this.texture = texture;
      this.refreshTexture = true;
      this.cachedTint = 16777215;
    }, "call$1", "get$setTexture", 2, 0, 27, 28, [], "setTexture"],
    _renderWebGL$1: [function(renderSession) {
      var t1, j, i;
      if (J.$eq(this.visible, false) || J.$eq(this.alpha, 0))
        return;
      if (this._mask != null) {
        J.stop$0$x(renderSession.get$spriteBatch());
        renderSession.get$maskManager().pushMask$2(this._mask, renderSession);
        J.start$0$x(renderSession.get$spriteBatch());
      }
      if (this._filters != null) {
        J.flush$0$x(renderSession.get$spriteBatch());
        renderSession.get$filterManager().pushFilter$1(this._filterBlock);
      }
      if (this.tilingTexture == null || this.refreshTexture === true) {
        this.generateTilingTexture$1(true);
        t1 = this.tilingTexture;
        if (t1 != null && t1.get$needsUpdate() === true) {
          M.updateWebGLTexture(this.tilingTexture.get$baseTexture(), renderSession.get$gl());
          this.tilingTexture.set$needsUpdate(false);
        }
      } else
        renderSession.get$spriteBatch().renderTilingSprite$1(this);
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i)._renderWebGL$1(renderSession);
      J.stop$0$x(renderSession.get$spriteBatch());
      if (this._filters != null)
        renderSession.get$filterManager().popFilter$0();
      if (this._mask != null)
        renderSession.get$maskManager().popMask$2(this._mask, renderSession);
      J.start$0$x(renderSession.get$spriteBatch());
    }, "call$1", "get$_renderWebGL", 2, 0, 655, 128, [], "_renderWebGL"],
    _renderCanvas$1: [function(renderSession) {
      var t1, context, t2, transform, t3, tilePosition, tileScale, t4, t5, j, i;
      if (J.$eq(this.visible, false) || J.$eq(this.alpha, 0))
        return;
      t1 = J.getInterceptor$x(renderSession);
      context = t1.get$context(renderSession);
      if (this._mask != null)
        renderSession.get$maskManager().pushMask$2(this._mask, context);
      t2 = J.getInterceptor$x(context);
      t2.set$globalAlpha(context, this._worldAlpha);
      transform = this._worldTransform;
      t2.setTransform$6(context, J.get$a$x(transform), transform.get$c(), transform.get$b(), transform.get$d(), transform.get$tx(), transform.get$ty());
      if (this._PIXI$__tilePattern == null || this.refreshTexture === true) {
        this.generateTilingTexture$1(false);
        t3 = this.tilingTexture;
        if (t3 != null) {
          t3 = J.getInterceptor(J.get$source$x(t3.get$baseTexture()));
          if (!!t3.$isCanvasElement)
            this._PIXI$__tilePattern = t2.createPattern$2(context, H.interceptedTypeCast(J.get$source$x(this.tilingTexture.get$baseTexture()), "$isCanvasElement"), "repeat");
          else if (!!t3.$isImageElement)
            this._PIXI$__tilePattern = t2.createPatternFromImage$2(context, J.get$source$x(this.tilingTexture.get$baseTexture()), "repeat");
          else
            throw H.wrapException(P.Exception_Exception("null source"));
        } else
          return;
      }
      if (!J.$eq(this.blendMode, renderSession.get$currentBlendMode())) {
        renderSession.set$currentBlendMode(this.blendMode);
        t2.set$globalCompositeOperation(context, J.$index$asx($.blendModesCanvas, renderSession.get$currentBlendMode()));
      }
      t2.beginPath$0(context);
      tilePosition = this.tilePosition;
      tileScale = this.tileScale;
      t3 = J.getInterceptor$x(tilePosition);
      t3.set$x(tilePosition, J.$mod$n(t3.get$x(tilePosition), J.get$width$x(this.tilingTexture.get$baseTexture())));
      t3.set$y(tilePosition, J.$mod$n(t3.get$y(tilePosition), J.get$height$x(this.tilingTexture.get$baseTexture())));
      t4 = J.getInterceptor$x(tileScale);
      t2.scale$2(context, t4.get$x(tileScale), t4.get$y(tileScale));
      t2.translate$2(context, t3.get$x(tilePosition), t3.get$y(tilePosition));
      t2.set$fillStyle(context, this._PIXI$__tilePattern);
      t2.fillRect$4(context, J.$add$ns(J.$negate$n(t3.get$x(tilePosition)), J.$mul$ns(J.get$x$x(this.anchor), J.$negate$n(this.PIXI$TilingSprite$_width))), J.$add$ns(J.$negate$n(t3.get$y(tilePosition)), J.$mul$ns(J.get$y$x(this.anchor), J.$negate$n(this.PIXI$TilingSprite$_height))), J.$div$n(this.PIXI$TilingSprite$_width, t4.get$x(tileScale)), J.$div$n(this.PIXI$TilingSprite$_height, t4.get$y(tileScale)));
      t5 = t4.get$x(tileScale);
      if (typeof t5 !== "number")
        return H.iae(t5);
      t4 = t4.get$y(tileScale);
      if (typeof t4 !== "number")
        return H.iae(t4);
      t2.scale$2(context, 1 / t5, 1 / t4);
      t2.translate$2(context, J.$negate$n(t3.get$x(tilePosition)), J.$negate$n(t3.get$y(tilePosition)));
      t2.closePath$0(context);
      if (this._mask != null)
        renderSession.get$maskManager().popMask$1(t1.get$context(renderSession));
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i)._renderCanvas$1(renderSession);
    }, "call$1", "get$_renderCanvas", 2, 0, 655, 128, [], "_renderCanvas"],
    getBounds$1: [function(matrix) {
      var width, height, t1, t2, w0, w1, h0, h1, worldTransform, a, b, c, d, tx, ty, x1, t3, t4, y1, x2, y2, x3, y3, x4, y4, minX, t5, minY, t6, t7, t8, maxX, maxY, bounds;
      width = this.PIXI$TilingSprite$_width;
      height = this.PIXI$TilingSprite$_height;
      t1 = J.get$x$x(this.anchor);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = J.getInterceptor$ns(width);
      w0 = t2.$mul(width, 1 - t1);
      w1 = t2.$mul(width, J.$negate$n(J.get$x$x(this.anchor)));
      t2 = J.get$y$x(this.anchor);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t1 = J.getInterceptor$ns(height);
      h0 = t1.$mul(height, 1 - t2);
      h1 = t1.$mul(height, J.$negate$n(J.get$y$x(this.anchor)));
      worldTransform = this._worldTransform;
      t1 = J.getInterceptor$asx(worldTransform);
      a = t1.$index(worldTransform, 0);
      b = t1.$index(worldTransform, 3);
      c = t1.$index(worldTransform, 1);
      d = t1.$index(worldTransform, 4);
      tx = t1.$index(worldTransform, 2);
      ty = t1.$index(worldTransform, 5);
      t1 = J.getInterceptor$ns(a);
      t2 = J.getInterceptor$ns(c);
      x1 = J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h1)), tx);
      t3 = J.getInterceptor$ns(d);
      t4 = J.getInterceptor$ns(b);
      y1 = J.$add$ns(J.$add$ns(t3.$mul(d, h1), t4.$mul(b, w1)), ty);
      x2 = J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h1)), tx);
      y2 = J.$add$ns(J.$add$ns(t3.$mul(d, h1), t4.$mul(b, w0)), ty);
      x3 = J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h0)), tx);
      y3 = J.$add$ns(J.$add$ns(t3.$mul(d, h0), t4.$mul(b, w0)), ty);
      x4 = J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h0)), tx);
      y4 = J.$add$ns(J.$add$ns(t3.$mul(d, h0), t4.$mul(b, w1)), ty);
      t1 = J.getInterceptor$n(x1);
      minX = t1.$lt(x1, 1 / 0) ? x1 : 1 / 0;
      t2 = J.getInterceptor$n(x2);
      if (t2.$lt(x2, minX))
        minX = x2;
      t3 = J.getInterceptor$n(x3);
      if (t3.$lt(x3, minX))
        minX = x3;
      t4 = J.getInterceptor$n(x4);
      if (t4.$lt(x4, minX))
        minX = x4;
      t5 = J.getInterceptor$n(y1);
      minY = t5.$lt(y1, 1 / 0) ? y1 : 1 / 0;
      t6 = J.getInterceptor$n(y2);
      if (t6.$lt(y2, minY))
        minY = y2;
      t7 = J.getInterceptor$n(y3);
      if (t7.$lt(y3, minY))
        minY = y3;
      t8 = J.getInterceptor$n(y4);
      if (t8.$lt(y4, minY))
        minY = y4;
      maxX = t1.$gt(x1, -1 / 0) ? x1 : -1 / 0;
      if (t2.$gt(x2, maxX))
        maxX = x2;
      if (t3.$gt(x3, maxX))
        maxX = x3;
      if (t4.$gt(x4, maxX))
        maxX = x4;
      maxY = t5.$gt(y1, -1 / 0) ? y1 : -1 / 0;
      if (t6.$gt(y2, maxY))
        maxY = y2;
      if (t7.$gt(y3, maxY))
        maxY = y3;
      if (t8.$gt(y4, maxY))
        maxY = y4;
      bounds = this._bounds;
      t1 = J.getInterceptor$x(bounds);
      t1.set$x(bounds, minX);
      t1.set$width(bounds, J.$sub$n(maxX, minX));
      t1.set$y(bounds, minY);
      t1.set$height(bounds, J.$sub$n(maxY, minY));
      this._currentBounds = bounds;
      return bounds;
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 653, 32, 537, [], "getBounds"],
    generateTilingTexture$1: [function(forcePowerOfTwo) {
      var texture, frame, t1, isFrame, t2, targetWidth, targetHeight, canvasBuffer;
      texture = this.texture;
      if (texture.get$baseTexture().get$hasLoaded() !== true)
        return;
      frame = texture.get$frame();
      t1 = J.getInterceptor$x(frame);
      isFrame = !J.$eq(t1.get$width(frame), J.get$width$x(texture.get$baseTexture())) || !J.$eq(t1.get$height(frame), J.get$height$x(texture.get$baseTexture()));
      t2 = forcePowerOfTwo !== true;
      if (t2)
        if (isFrame) {
          targetWidth = t1.get$width(frame);
          targetHeight = t1.get$height(frame);
        } else {
          targetWidth = null;
          targetHeight = null;
        }
      else {
        targetWidth = M.getNextPowerOfTwo(t1.get$width(frame));
        targetHeight = M.getNextPowerOfTwo(t1.get$height(frame));
        if (!J.$eq(t1.get$width(frame), targetWidth) || !J.$eq(t1.get$height(frame), targetHeight))
          ;
      }
      if (!t2 || isFrame) {
        t2 = this.tilingTexture;
        if (t2 != null && t2.get$isTiling() === true) {
          canvasBuffer = this.tilingTexture.get$canvasBuffer();
          J.resize$2$x(canvasBuffer, targetWidth, targetHeight);
          J.set$width$x(this.tilingTexture.get$baseTexture(), targetWidth);
          J.set$height$x(this.tilingTexture.get$baseTexture(), targetHeight);
          this.tilingTexture.set$needsUpdate(true);
        } else {
          canvasBuffer = M.CanvasBuffer$(targetWidth, targetHeight);
          t2 = M.Texture$(M.BaseTexture_fromCanvas(canvasBuffer.canvas, null), null);
          this.tilingTexture = t2;
          t2.canvasBuffer = canvasBuffer;
          this.tilingTexture.set$isTiling(true);
        }
        J.drawImageScaledFromSource$9$x(J.get$context$x(canvasBuffer), J.get$source$x(texture.get$baseTexture()), J.get$x$x(texture.get$crop()), J.get$y$x(texture.get$crop()), J.get$width$x(texture.get$crop()), J.get$height$x(texture.get$crop()), 0, 0, targetWidth, targetHeight);
        J.set$x$x(this.tileScaleOffset, J.$div$n(t1.get$width(frame), targetWidth));
        J.set$y$x(this.tileScaleOffset, J.$div$n(t1.get$height(frame), targetHeight));
      } else {
        t1 = this.tilingTexture;
        if (t1 != null && t1.get$isTiling() === true)
          this.tilingTexture.destroy$1(true);
        J.set$x$x(this.tileScaleOffset, 1);
        J.set$y$x(this.tileScaleOffset, 1);
        this.tilingTexture = texture;
      }
      this.refreshTexture = false;
      this.tilingTexture.get$baseTexture().set$_powerOf2(true);
    }, "call$1", "get$generateTilingTexture", 2, 0, 650, 795, [], "generateTilingTexture"],
    _onTextureUpdate$1: [function(e) {
    }, "call$1", "get$_onTextureUpdate", 2, 0, 677, 312, [], "_onTextureUpdate"],
    TilingSprite$3: function(texture, width, height) {
      var t1;
      this.PIXI$TilingSprite$_width = width;
      this.PIXI$TilingSprite$_height = height;
      texture.get$baseTexture().set$_powerOf2(true);
      t1 = new M.Point0(null, null);
      t1.x = 1;
      t1.y = 1;
      this.tileScale = t1;
      t1 = new M.Point0(null, null);
      t1.x = 0;
      t1.y = 0;
      this.tilePosition = t1;
      this.renderable = true;
      this.tint = 16777215;
      this.blendMode = C.BlendModes_0;
    },
    static: {TilingSprite$: [function(texture, width, height) {
        var t1, t2, t3, t4, t5, t6;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new M.TilingSprite(null, null, null, null, null, null, false, t1, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.texture = texture;
        t1._setupTexture$0();
        t1.TilingSprite$3(texture, width, height);
        return t1;
      }, null, null, 2, 4, 89, 90, 90, 28, [], 10, [], 11, [], "new TilingSprite"]}
  },
  "+TilingSprite": [643],
  AbstractFilter: {
    "^": "Object;passes@-645,shaders@-754,dirty@-602,padding*-599,uniforms@-754,fragmentSrc@-720",
    static: {AbstractFilter$: [function() {
        var t1 = new M.AbstractFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        return t1;
      }, null, null, 0, 0, 13, "new AbstractFilter"]}
  },
  "+AbstractFilter": [632],
  AlphaMaskFilter: {
    "^": "AbstractFilter;texture@-670,passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    onTextureLoaded$1: [function(e) {
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "x", J.get$width$x(J.$index$asx(J.$index$asx(this.uniforms, "mask"), "value")));
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "y", J.get$height$x(J.$index$asx(J.$index$asx(this.uniforms, "mask"), "value")));
      H.interceptedTypeCast(J.$index$asx(J.$index$asx(this.uniforms, "mask"), "value").get$baseTexture(), "$isBaseTexture").removeEventListener$2(0, "loaded", this.get$onTextureLoaded());
    }, "call$1", "get$onTextureLoaded", 2, 0, 63, 312, [], "onTextureLoaded"],
    get$map: [function(_) {
      return J.$index$asx(J.$index$asx(this.uniforms, "mask"), "value");
    }, null, null, 1, 0, 796, "map"],
    map$1: function($receiver, arg0) {
      return this.get$map(this).call$1(arg0);
    },
    set$map: [function(_, value) {
      J.$indexSet$ax(J.$index$asx(this.uniforms, "mask"), "value", value);
    }, null, null, 3, 0, 27, 100, [], "map"],
    AlphaMaskFilter$1: function(texture) {
      this.texture.get$baseTexture().set$_powerOf2(true);
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["mask", P.LinkedHashMap_LinkedHashMap$_literal(["type", "sampler2D", "value", this.texture], null, null), "mapDimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 1, "y", 5112], null, null)], null, null), "dimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "4fv", "value", [0, 0, 0, 0]], null, null)], null, null);
      if (this.texture.get$baseTexture().get$hasLoaded() === true) {
        J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mask"), "value"), "x", J.get$width$x(this.texture));
        J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mask"), "value"), "y", J.get$height$x(this.texture));
      } else
        J.addEventListener$2$x(this.texture.get$baseTexture(), "loaded", this.get$onTextureLoaded());
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D mask;", "uniform sampler2D uSampler;", "uniform vec2 offset;", "uniform vec4 dimensions;", "uniform vec2 mapDimensions;", "void main(void) {", "   vec2 mapCords = vTextureCoord.xy;", "   mapCords += (dimensions.zw + offset)/ dimensions.xy ;", "   mapCords.y *= -1.0;", "   mapCords.y += 1.0;", "   mapCords *= dimensions.xy / mapDimensions;", "   vec4 original =  texture2D(uSampler, vTextureCoord);", "   float maskAlpha =  texture2D(mask, mapCords).r;", "   original *= maskAlpha;", "   gl_FragColor =  original;", "}"];
    },
    static: {AlphaMaskFilter$: [function(texture) {
        var t1 = new M.AlphaMaskFilter(texture, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.AlphaMaskFilter$1(texture);
        return t1;
      }, null, null, 2, 0, 27, 28, [], "new AlphaMaskFilter"]}
  },
  "+AlphaMaskFilter": [797],
  BlurFilter: {
    "^": "AbstractFilter;blurXFilter@-798,blurYFilter@-799,passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    get$blur: [function(_) {
      return J.get$blur$x(this.blurXFilter);
    }, null, null, 1, 0, 604, "blur"],
    set$blur: [function(_, value) {
      var t1 = this.blurXFilter;
      J.set$blur$x(this.blurYFilter, value);
      J.set$blur$x(t1, value);
    }, null, null, 3, 0, 605, 100, [], "blur"],
    get$blurX: [function() {
      return J.get$blur$x(this.blurXFilter);
    }, null, null, 1, 0, 604, "blurX"],
    set$blurX: [function(value) {
      J.set$blur$x(this.blurXFilter, value);
    }, null, null, 3, 0, 605, 100, [], "blurX"],
    get$blurY: [function() {
      return J.get$blur$x(this.blurYFilter);
    }, null, null, 1, 0, 604, "blurY"],
    set$blurY: [function(value) {
      J.set$blur$x(this.blurYFilter, value);
    }, null, null, 3, 0, 605, 100, [], "blurY"],
    BlurFilter$0: function() {
      var t1 = new M.BlurXFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
      t1.passes = [t1];
      t1.BlurXFilter$0();
      this.blurXFilter = t1;
      t1 = new M.BlurYFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
      t1.passes = [t1];
      t1.BlurYFilter$0();
      this.blurYFilter = t1;
      this.passes = [this.blurXFilter, t1];
    },
    static: {BlurFilter$: [function() {
        var t1 = new M.BlurFilter(null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.BlurFilter$0();
        return t1;
      }, null, null, 0, 0, 13, "new BlurFilter"]}
  },
  "+BlurFilter": [797],
  BlurXFilter: {
    "^": "AbstractFilter;passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    get$blur: [function(_) {
      return J.$div$n(J.$index$asx(J.$index$asx(this.uniforms, "blur"), "value"), 0.00014285714285714287);
    }, null, null, 1, 0, 604, "blur"],
    set$blur: [function(_, value) {
      var t1;
      this.dirty = true;
      t1 = J.$index$asx(this.uniforms, "blur");
      if (typeof value !== "number")
        return H.iae(value);
      J.$indexSet$ax(t1, "value", 0.00014285714285714287 * value);
    }, null, null, 3, 0, 63, 100, [], "blur"],
    BlurXFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["blur", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 0.001953125], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float blur;", "uniform sampler2D uSampler;", "void main(void) {", "   vec4 sum = vec4(0.0);", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - 4.0*blur, vTextureCoord.y)) * 0.05;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - 3.0*blur, vTextureCoord.y)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - 2.0*blur, vTextureCoord.y)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - blur, vTextureCoord.y)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + blur, vTextureCoord.y)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + 2.0*blur, vTextureCoord.y)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + 3.0*blur, vTextureCoord.y)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + 4.0*blur, vTextureCoord.y)) * 0.05;", "   gl_FragColor = sum;", "}"];
    },
    static: {BlurXFilter$: [function() {
        var t1 = new M.BlurXFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.BlurXFilter$0();
        return t1;
      }, null, null, 0, 0, 13, "new BlurXFilter"]}
  },
  "+BlurXFilter": [797],
  BlurYFilter: {
    "^": "AbstractFilter;passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    get$blur: [function(_) {
      return J.$div$n(J.$index$asx(J.$index$asx(this.uniforms, "blur"), "value"), 0.00014285714285714287);
    }, null, null, 1, 0, 604, "blur"],
    set$blur: [function(_, value) {
      var t1;
      this.dirty = true;
      t1 = J.$index$asx(this.uniforms, "blur");
      if (typeof value !== "number")
        return H.iae(value);
      J.$indexSet$ax(t1, "value", 0.00014285714285714287 * value);
    }, null, null, 3, 0, 63, 100, [], "blur"],
    BlurYFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["blur", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 0.001953125], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float blur;", "uniform sampler2D uSampler;", "void main(void) {", "   vec4 sum = vec4(0.0);", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 4.0*blur)) * 0.05;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 3.0*blur)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 2.0*blur)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - blur)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + blur)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 2.0*blur)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 3.0*blur)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 4.0*blur)) * 0.05;", "   gl_FragColor = sum;", "}"];
    },
    static: {BlurYFilter$: [function() {
        var t1 = new M.BlurYFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.BlurYFilter$0();
        return t1;
      }, null, null, 0, 0, 13, "new BlurYFilter"]}
  },
  "+BlurYFilter": [797],
  ColorMatrixFilter: {
    "^": "AbstractFilter;passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    get$matrix: [function() {
      return J.$index$asx(J.$index$asx(this.uniforms, "matrix"), "value");
    }, null, null, 1, 0, 800, "matrix"],
    set$matrix: [function(value) {
      J.$indexSet$ax(J.$index$asx(this.uniforms, "matrix"), "value", value);
    }, null, null, 3, 0, 63, 100, [], "matrix"],
    ColorMatrixFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["matrix", P.LinkedHashMap_LinkedHashMap$_literal(["type", "mat4", "value", [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float invert;", "uniform mat4 matrix;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * matrix;", "}"];
    },
    static: {ColorMatrixFilter$: [function() {
        var t1 = new M.ColorMatrixFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.ColorMatrixFilter$0();
        return t1;
      }, null, null, 0, 0, 13, "new ColorMatrixFilter"]}
  },
  "+ColorMatrixFilter": [797],
  ColorStepFilter: {
    "^": "AbstractFilter;passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    get$step: [function(_) {
      return J.$index$asx(J.$index$asx(this.uniforms, "step"), "value");
    }, null, null, 1, 0, 604, "step"],
    step$0: function($receiver) {
      return this.get$step(this).call$0();
    },
    set$step: [function(_, value) {
      J.$indexSet$ax(J.$index$asx(this.uniforms, "step"), "value", value);
    }, null, null, 3, 0, 605, 100, [], "step"],
    ColorStepFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["step", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 5], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "uniform float step;", "void main(void) {", "   vec4 color = texture2D(uSampler, vTextureCoord);", "   color = floor(color * step) / step;", "   gl_FragColor = color;", "}"];
    },
    static: {ColorStepFilter$: [function() {
        var t1 = new M.ColorStepFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.ColorStepFilter$0();
        return t1;
      }, null, null, 0, 0, 13, "new ColorStepFilter"]}
  },
  "+ColorStepFilter": [797],
  CrossHatchFilter: {
    "^": "AbstractFilter;passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    get$blur: [function(_) {
      return J.$div$n(J.$index$asx(J.$index$asx(this.uniforms, "blur"), "value"), 0.00014285714285714287);
    }, null, null, 1, 0, 604, "blur"],
    set$blur: [function(_, value) {
      var t1 = J.$index$asx(this.uniforms, "blur");
      if (typeof value !== "number")
        return H.iae(value);
      J.$indexSet$ax(t1, "value", 0.00014285714285714287 * value);
    }, null, null, 3, 0, 605, 100, [], "blur"],
    CrossHatchFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["blur", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 0.001953125], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float blur;", "uniform sampler2D uSampler;", "void main(void) {", "    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);", "    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);", "    if (lum < 1.00) {", "        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "    if (lum < 0.75) {", "        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "    if (lum < 0.50) {", "        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "    if (lum < 0.3) {", "        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "}"];
    },
    static: {CrossHatchFilter$: [function() {
        var t1 = new M.CrossHatchFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.CrossHatchFilter$0();
        return t1;
      }, null, null, 0, 0, 13, "new CrossHatchFilter"]}
  },
  "+CrossHatchFilter": [797],
  DisplacementFilter: {
    "^": "AbstractFilter;texture@-670,passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    onTextureLoaded$1: [function(e) {
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "x", J.get$width$x(J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value")));
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "y", J.get$height$x(J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value")));
      J.removeEventListener$2$x(J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value").get$baseTexture(), "loaded", this.get$onTextureLoaded());
    }, "call$1", "get$onTextureLoaded", 2, 0, 63, 312, [], "onTextureLoaded"],
    get$map: [function(_) {
      return J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value");
    }, null, null, 1, 0, 796, "map"],
    map$1: function($receiver, arg0) {
      return this.get$map(this).call$1(arg0);
    },
    set$map: [function(_, value) {
      J.$indexSet$ax(J.$index$asx(this.uniforms, "displacementMap"), "value", value);
    }, null, null, 3, 0, 27, 100, [], "map"],
    get$scale: [function(_) {
      var p, t1, t2, t3;
      p = J.$index$asx(J.$index$asx(this.uniforms, "scale"), "value");
      t1 = J.getInterceptor$asx(p);
      t2 = t1.$index(p, "x");
      t1 = t1.$index(p, "y");
      t3 = new M.Point0(null, null);
      t3.x = t2;
      t3.y = t1;
      return t3;
    }, null, null, 1, 0, 684, "scale"],
    scale$2: function($receiver, arg0, arg1) {
      return this.get$scale(this).call$2(arg0, arg1);
    },
    set$scale: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      J.$indexSet$ax(J.$index$asx(this.uniforms, "scale"), "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", t1.get$x(value), "y", t1.get$y(value)], null, null));
    }, null, null, 3, 0, 801, 100, [], "scale"],
    get$offset: [function(_) {
      var p, t1, t2, t3;
      p = J.$index$asx(J.$index$asx(this.uniforms, "offset"), "value");
      t1 = J.getInterceptor$asx(p);
      t2 = t1.$index(p, "x");
      t1 = t1.$index(p, "y");
      t3 = new M.Point0(null, null);
      t3.x = t2;
      t3.y = t1;
      return t3;
    }, null, null, 1, 0, 684, "offset"],
    offset$2: function($receiver, arg0, arg1) {
      return this.get$offset(this).call$2(arg0, arg1);
    },
    set$offset: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      J.$indexSet$ax(J.$index$asx(this.uniforms, "offset"), "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", t1.get$x(value), "y", t1.get$y(value)], null, null));
    }, null, null, 3, 0, 801, 100, [], "offset"],
    DisplacementFilter$1: function(texture) {
      this.passes = [this];
      this.texture.get$baseTexture().set$_powerOf2(true);
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["displacementMap", P.LinkedHashMap_LinkedHashMap$_literal(["type", "sampler2D", "value", this.texture], null, null), "scale", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 30, "y", 30], null, null)], null, null), "offset", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 0, "y", 0], null, null)], null, null), "mapDimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 1, "y", 5112], null, null)], null, null), "dimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "4fv", "value", [0, 0, 0, 0]], null, null)], null, null);
      if (this.texture.get$baseTexture().get$hasLoaded() === true) {
        J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "x", J.get$width$x(this.texture));
        J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "y", J.get$height$x(this.texture));
      } else
        J.addEventListener$2$x(this.texture.get$baseTexture(), "loaded", this.get$onTextureLoaded());
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D displacementMap;", "uniform sampler2D uSampler;", "uniform vec2 scale;", "uniform vec2 offset;", "uniform vec4 dimensions;", "uniform vec2 mapDimensions;", "void main(void) {", "   vec2 mapCords = vTextureCoord.xy;", "   mapCords += (dimensions.zw + offset)/ dimensions.xy ;", "   mapCords.y *= -1.0;", "   mapCords.y += 1.0;", "   vec2 matSample = texture2D(displacementMap, mapCords).xy;", "   matSample -= 0.5;", "   matSample *= scale;", "   matSample /= mapDimensions;", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + matSample.x, vTextureCoord.y + matSample.y));", "   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb, 1.0);", "   vec2 cord = vTextureCoord;", "}"];
    },
    static: {DisplacementFilter$: [function(texture) {
        var t1 = new M.DisplacementFilter(texture, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.DisplacementFilter$1(texture);
        return t1;
      }, null, null, 2, 0, 27, 28, [], "new DisplacementFilter"]}
  },
  "+DisplacementFilter": [797],
  DotScreenFilter: {
    "^": "AbstractFilter;passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    get$scale: [function(_) {
      return J.$index$asx(J.$index$asx(this.uniforms, "scale"), "value");
    }, null, null, 1, 0, 604, "scale"],
    scale$2: function($receiver, arg0, arg1) {
      return this.get$scale(this).call$2(arg0, arg1);
    },
    set$scale: [function(_, value) {
      this.dirty = true;
      J.$indexSet$ax(J.$index$asx(this.uniforms, "scale"), "value", value);
    }, null, null, 3, 0, 605, 100, [], "scale"],
    get$angle: [function() {
      return J.$index$asx(J.$index$asx(this.uniforms, "angle"), "value");
    }, null, null, 1, 0, 604, "angle"],
    angle$0: function() {
      return this.get$angle().call$0();
    },
    angle$2: function(arg0, arg1) {
      return this.get$angle().call$2(arg0, arg1);
    },
    set$angle: [function(value) {
      this.dirty = true;
      J.$indexSet$ax(J.$index$asx(this.uniforms, "angle"), "value", value);
    }, null, null, 3, 0, 605, 100, [], "angle"],
    DotScreenFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["scale", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 1], null, null), "angle", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 5], null, null), "dimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "4fv", "value", [0, 0, 0, 0]], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform vec4 dimensions;", "uniform sampler2D uSampler;", "uniform float angle;", "uniform float scale;", "float pattern() {", "   float s = sin(angle), c = cos(angle);", "   vec2 tex = vTextureCoord * dimensions.xy;", "   vec2 point = vec2(", "       c * tex.x - s * tex.y,", "       s * tex.x + c * tex.y", "   ) * scale;", "   return (sin(point.x) * sin(point.y)) * 4.0;", "}", "void main() {", "   vec4 color = texture2D(uSampler, vTextureCoord);", "   float average = (color.r + color.g + color.b) / 3.0;", "   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);", "}"];
    },
    static: {DotScreenFilter$: [function() {
        var t1 = new M.DotScreenFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.DotScreenFilter$0();
        return t1;
      }, null, null, 0, 0, 13, "new DotScreenFilter"]}
  },
  "+DotScreenFilter": [797],
  FilterBlock: {
    "^": "Object;visible@-602,renderable@-602,target*-668,_filterArea@-641,filterArea@-641,filterPasses@-645,_glFilterTexture@-802",
    static: {FilterBlock$: [function() {
        return new M.FilterBlock(true, true, null, null, null, [], null);
      }, null, null, 0, 0, 13, "new FilterBlock"]}
  },
  "+FilterBlock": [632],
  GrayFilter: {
    "^": "AbstractFilter;passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    get$gray: [function() {
      return J.$index$asx(J.$index$asx(this.uniforms, "gray"), "value");
    }, null, null, 1, 0, 604, "gray"],
    set$gray: [function(value) {
      J.$indexSet$ax(J.$index$asx(this.uniforms, "gray"), "value", value);
    }, null, null, 3, 0, 605, 100, [], "gray"],
    GrayFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["gray", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 1], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "uniform float gray;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);", "}"];
    },
    static: {GrayFilter$: [function() {
        var t1 = new M.GrayFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.GrayFilter$0();
        return t1;
      }, null, null, 0, 0, 13, "new GrayFilter"]}
  },
  "+GrayFilter": [797],
  InvertFilter: {
    "^": "AbstractFilter;passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    get$invert: [function() {
      return J.$index$asx(J.$index$asx(this.uniforms, "invert"), "value");
    }, null, null, 1, 0, 604, "invert"],
    invert$0: function() {
      return this.get$invert().call$0();
    },
    set$invert: [function(value) {
      J.$indexSet$ax(J.$index$asx(this.uniforms, "invert"), "value", value);
    }, null, null, 3, 0, 605, 100, [], "invert"],
    InvertFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["invert", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 1], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float invert;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "   gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);", "}"];
    },
    static: {InvertFilter$: [function() {
        var t1 = new M.InvertFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.InvertFilter$0();
        return t1;
      }, null, null, 0, 0, 13, "new InvertFilter"]}
  },
  "+InvertFilter": [797],
  NormalMapFilter: {
    "^": "AbstractFilter;texture@-670,passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    onTextureLoaded$1: [function(e) {
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "x", J.get$width$x(J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value")));
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "y", J.get$height$x(J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value")));
      J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value").get$baseTexture().off$2("loaded", this.get$onTextureLoaded());
    }, "call$1", "get$onTextureLoaded", 2, 0, 63, 312, [], "onTextureLoaded"],
    get$map: [function(_) {
      return J.$index$asx(J.$index$asx(this.uniforms, "displacementMap"), "value");
    }, null, null, 1, 0, 796, "map"],
    map$1: function($receiver, arg0) {
      return this.get$map(this).call$1(arg0);
    },
    set$map: [function(_, value) {
      J.$indexSet$ax(J.$index$asx(this.uniforms, "displacementMap"), "value", value);
    }, null, null, 3, 0, 27, 100, [], "map"],
    get$scale: [function(_) {
      var p, t1, t2, t3;
      p = J.$index$asx(J.$index$asx(this.uniforms, "scale"), "value");
      t1 = J.getInterceptor$asx(p);
      t2 = t1.$index(p, "x");
      t1 = t1.$index(p, "y");
      t3 = new M.Point0(null, null);
      t3.x = t2;
      t3.y = t1;
      return t3;
    }, null, null, 1, 0, 684, "scale"],
    scale$2: function($receiver, arg0, arg1) {
      return this.get$scale(this).call$2(arg0, arg1);
    },
    set$scale: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      J.$indexSet$ax(J.$index$asx(this.uniforms, "scale"), "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", t1.get$x(value), "y", t1.get$y(value)], null, null));
    }, null, null, 3, 0, 801, 100, [], "scale"],
    get$offset: [function(_) {
      var p, t1, t2, t3;
      p = J.$index$asx(J.$index$asx(this.uniforms, "offset"), "value");
      t1 = J.getInterceptor$asx(p);
      t2 = t1.$index(p, "x");
      t1 = t1.$index(p, "y");
      t3 = new M.Point0(null, null);
      t3.x = t2;
      t3.y = t1;
      return t3;
    }, null, null, 1, 0, 684, "offset"],
    offset$2: function($receiver, arg0, arg1) {
      return this.get$offset(this).call$2(arg0, arg1);
    },
    set$offset: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      J.$indexSet$ax(J.$index$asx(this.uniforms, "offset"), "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", t1.get$x(value), "y", t1.get$y(value)], null, null));
    }, null, null, 3, 0, 801, 100, [], "offset"],
    NormalMapFilter$0: function() {
      this.passes = [this];
      this.texture.get$baseTexture().set$_powerOf2(true);
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["displacementMap", P.LinkedHashMap_LinkedHashMap$_literal(["type", "sampler2D", "value", this.texture], null, null), "scale", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 15, "y", 15], null, null)], null, null), "offset", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 0, "y", 0], null, null)], null, null), "mapDimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 1, "y", 1], null, null)], null, null), "dimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "4f", "value", [0, 0, 0, 0]], null, null), "LightPos", P.LinkedHashMap_LinkedHashMap$_literal(["type", "3f", "value", [0, 1, 0]], null, null)], null, null);
      if (this.texture.get$baseTexture().get$hasLoaded() === true) {
        J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "x", J.get$width$x(this.texture));
        J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "mapDimensions"), "value"), "y", J.get$height$x(this.texture));
      } else
        J.addEventListener$2$x(this.texture.get$baseTexture(), "loaded", this.get$onTextureLoaded());
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D displacementMap;", "uniform sampler2D uSampler;", "uniform vec4 dimensions;", "const vec2 Resolution = vec2(1.0,1.0);", "uniform vec3 LightPos;", "const vec4 LightColor = vec4(1.0, 1.0, 1.0, 1.0);", "const vec4 AmbientColor = vec4(1.0, 1.0, 1.0, 0.5);", "const vec3 Falloff = vec3(0.0, 1.0, 0.2);", "uniform vec3 LightDir;", "uniform vec2 mapDimensions;", "void main(void) {", "vec2 mapCords = vTextureCoord.xy;", "vec4 color = texture2D(uSampler, vTextureCoord.st);", "vec3 nColor = texture2D(displacementMap, vTextureCoord.st).rgb;", "mapCords *= vec2(dimensions.x/512.0, dimensions.y/512.0);", "mapCords.y *= -1.0;", "mapCords.y += 1.0;", "vec4 DiffuseColor = texture2D(uSampler, vTextureCoord);", "vec3 NormalMap = texture2D(displacementMap, mapCords).rgb;", "vec3 LightDir = vec3(LightPos.xy - (mapCords.xy), LightPos.z);", "float D = length(LightDir);", "vec3 N = normalize(NormalMap * 2.0 - 1.0);", "vec3 L = normalize(LightDir);", "vec3 Diffuse = (LightColor.rgb * LightColor.a) * max(dot(N, L), 0.0);", "vec3 Ambient = AmbientColor.rgb * AmbientColor.a;", "float Attenuation = 1.0 / ( Falloff.x + (Falloff.y*D) + (Falloff.z*D*D) );", "vec3 Intensity = Ambient + Diffuse * Attenuation;", "vec3 FinalColor = DiffuseColor.rgb * Intensity;", "gl_FragColor = vColor * vec4(FinalColor, DiffuseColor.a);", "}"];
    },
    static: {NormalMapFilter$: [function() {
        var t1 = new M.NormalMapFilter(null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.NormalMapFilter$0();
        return t1;
      }, null, null, 0, 0, 13, "new NormalMapFilter"]}
  },
  "+NormalMapFilter": [797],
  PixelateFilter: {
    "^": "AbstractFilter;passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    get$size: [function(_) {
      var p, t1, t2, t3;
      p = J.$index$asx(J.$index$asx(this.uniforms, "pixelSize"), "value");
      t1 = J.getInterceptor$asx(p);
      t2 = t1.$index(p, "x");
      t1 = t1.$index(p, "y");
      t3 = new M.Point0(null, null);
      t3.x = t2;
      t3.y = t1;
      return t3;
    }, null, null, 1, 0, 684, "size"],
    size$1: function($receiver, arg0) {
      return this.get$size(this).call$1(arg0);
    },
    set$size: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      J.$indexSet$ax(J.$index$asx(this.uniforms, "pixelSize"), "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", t1.get$x(value), "y", t1.get$y(value)], null, null));
    }, null, null, 3, 0, 801, 100, [], "size"],
    PixelateFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["invert", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 0], null, null), "dimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "4fv", "value", new Float32Array(H._ensureNativeList([10000, 100, 10, 10]))], null, null), "pixelSize", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 10, "y", 10], null, null)], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform vec2 testDim;", "uniform vec4 dimensions;", "uniform vec2 pixelSize;", "uniform sampler2D uSampler;", "void main(void) {", "   vec2 coord = vTextureCoord;", "   vec2 size = dimensions.xy/pixelSize;", "   vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;", "   gl_FragColor = texture2D(uSampler, color);", "}"];
    },
    static: {PixelateFilter$: [function() {
        var t1 = new M.PixelateFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.PixelateFilter$0();
        return t1;
      }, null, null, 0, 0, 13, "new PixelateFilter"]}
  },
  "+PixelateFilter": [797],
  RGBSplitFilter: {
    "^": "AbstractFilter;passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    get$angle: [function() {
      return J.$div$n(J.$index$asx(J.$index$asx(this.uniforms, "blur"), "value"), 0.00014285714285714287);
    }, null, null, 1, 0, 604, "angle"],
    angle$0: function() {
      return this.get$angle().call$0();
    },
    angle$2: function(arg0, arg1) {
      return this.get$angle().call$2(arg0, arg1);
    },
    set$blur: [function(_, value) {
      var t1 = J.$index$asx(this.uniforms, "blur");
      if (typeof value !== "number")
        return H.iae(value);
      J.$indexSet$ax(t1, "value", 0.00014285714285714287 * value);
    }, null, null, 3, 0, 605, 100, [], "blur"],
    RGBSplitFilter$0: function() {
      this.passes = [this];
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["red", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 20, "y", 20], null, null)], null, null), "green", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", -20, "y", 20], null, null)], null, null), "blue", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 20, "y", -20], null, null)], null, null), "dimensions", P.LinkedHashMap_LinkedHashMap$_literal(["type", "4fv", "value", [0, 0, 0, 0]], null, null)], null, null);
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform vec2 red;", "uniform vec2 green;", "uniform vec2 blue;", "uniform vec4 dimensions;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;", "   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;", "   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;", "   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;", "}"];
    },
    static: {RGBSplitFilter$: [function() {
        var t1 = new M.RGBSplitFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        t1.RGBSplitFilter$0();
        return t1;
      }, null, null, 0, 0, 13, "new RGBSplitFilter"]}
  },
  "+RGBSplitFilter": [797],
  SepiaFilter: {
    "^": "AbstractFilter;passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    static: {SepiaFilter$: [function() {
        var t1 = new M.SepiaFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        return t1;
      }, null, null, 0, 0, 13, "new SepiaFilter"]}
  },
  "+SepiaFilter": [797],
  SmartBlurFilter: {
    "^": "AbstractFilter;passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    static: {SmartBlurFilter$: [function() {
        var t1 = new M.SmartBlurFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        return t1;
      }, null, null, 0, 0, 13, "new SmartBlurFilter"]}
  },
  "+SmartBlurFilter": [797],
  TwistFilter: {
    "^": "AbstractFilter;passes-645,shaders-754,dirty-602,padding-599,uniforms-754,fragmentSrc-720",
    static: {TwistFilter$: [function() {
        var t1 = new M.TwistFilter(null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), true, 0, P.LinkedHashMap_LinkedHashMap$_empty(null, null), []);
        t1.passes = [t1];
        return t1;
      }, null, null, 0, 0, 13, "new TwistFilter"]}
  },
  "+TwistFilter": [797],
  InteractionData: {
    "^": "Object;global@-634,target*-678,originalEvent@-803",
    getLocalPosition$1: [function(displayObject) {
      var worldTransform, a00, a01, a02, a10, a11, a12, t1, t2, t3, t4, id, t5;
      worldTransform = displayObject.get$_worldTransform();
      a00 = J.get$a$x(worldTransform);
      a01 = worldTransform.get$b();
      a02 = worldTransform.get$tx();
      a10 = worldTransform.get$c();
      a11 = worldTransform.get$d();
      a12 = worldTransform.get$ty();
      t1 = J.getInterceptor$ns(a00);
      t2 = J.getInterceptor$n(a10);
      t3 = J.getInterceptor$ns(a01);
      t4 = J.$add$ns(t1.$mul(a00, a11), t3.$mul(a01, t2.$negate(a10)));
      if (typeof t4 !== "number")
        return H.iae(t4);
      id = 1 / t4;
      t4 = J.getInterceptor$ns(a12);
      t5 = J.getInterceptor$ns(a02);
      t3 = J.$add$ns(J.$add$ns(J.$mul$ns(J.$mul$ns(a11, id), J.get$x$x(this.global)), J.$mul$ns(J.$mul$ns(t3.$negate(a01), id), J.get$y$x(this.global))), J.$mul$ns(J.$sub$n(t4.$mul(a12, a01), t5.$mul(a02, a11)), id));
      t5 = J.$add$ns(J.$add$ns(J.$mul$ns(t1.$mul(a00, id), J.get$y$x(this.global)), J.$mul$ns(J.$mul$ns(t2.$negate(a10), id), J.get$x$x(this.global))), J.$mul$ns(J.$add$ns(J.$mul$ns(t4.$negate(a12), a00), t5.$mul(a02, a10)), id));
      t4 = new M.Point0(null, null);
      t4.x = t3;
      t4.y = t5;
      return t4;
    }, "call$1", "get$getLocalPosition", 2, 0, 804, 805, [], "getLocalPosition"],
    static: {InteractionData$: [function() {
        var t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        return new M.InteractionData(t1, null, null);
      }, null, null, 0, 0, 91, "new InteractionData"]}
  },
  "+InteractionData": [632],
  InteractionManager: {
    "^": "Object;stage@-638,mouse@-806,touchs@-637,tempPoint@-634,mouseoverEnabled@-602,pool<-807,interactiveItems@-657,interactionDOMElement@-808,target*-809,last*-790,dirty@-602,currentCursorStyle@-639,mouseOut@-602,isCocoonJS@-602",
    collectInteractiveSprite$2: [function(displayObject, iParent) {
      var children, t1, i, t2, child;
      children = J.get$children$x(displayObject);
      t1 = J.getInterceptor$asx(children);
      for (i = J.$sub$n(t1.get$length(children), 1); t2 = J.getInterceptor$n(i), t2.$ge(i, 0); i = t2.$sub(i, 1)) {
        child = t1.$index(children, i);
        if (child.get$_interactive() === true) {
          iParent.set$interactiveChildren(true);
          J.add$1$ax(this.interactiveItems, child);
          if (J.$gt$n(J.get$length$asx(J.get$children$x(child)), 0))
            this.collectInteractiveSprite$2(child, child);
        } else if (J.$gt$n(J.get$length$asx(J.get$children$x(child)), 0))
          this.collectInteractiveSprite$2(child, iParent);
      }
    }, "call$2", "get$collectInteractiveSprite", 4, 0, 810, 805, [], 811, [], "collectInteractiveSprite"],
    setTarget$1: [function(target) {
      this.target = target;
      if (this.interactionDOMElement == null)
        this.setTargetDomElement$1(J.get$view$x(target));
    }, "call$1", "get$setTarget", 2, 0, 812, 58, [], "setTarget"],
    setTargetDomElement$1: [function(domElement) {
      var t1;
      this.removeEvents$0();
      this.interactionDOMElement = domElement;
      t1 = J.getInterceptor$x(domElement);
      t1.addEventListener$3(domElement, "mousemove", this.get$onMouseMove(this), true);
      t1.addEventListener$3(domElement, "mousedown", this.get$onMouseDown(this), true);
      t1.addEventListener$3(domElement, "mouseout", this.get$onMouseOut(this), true);
      t1.addEventListener$3(domElement, "touchstart", this.get$onTouchStart(this), true);
      t1.addEventListener$3(domElement, "touchend", this.get$onTouchEnd(this), true);
      t1.addEventListener$3(domElement, "touchmove", this.get$onTouchMove(this), true);
      C.Window_methods.addEventListener$3(window, "mouseup", this.get$onMouseUp(this), true);
    }, "call$1", "get$setTargetDomElement", 2, 0, 813, 683, [], "setTargetDomElement"],
    removeEvents$0: [function() {
      var t1 = this.interactionDOMElement;
      if (t1 == null)
        return;
      J.removeEventListener$3$x(t1, "mousemove", this.get$onMouseMove(this), true);
      J.removeEventListener$3$x(this.interactionDOMElement, "mousedown", this.get$onMouseDown(this), true);
      J.removeEventListener$3$x(this.interactionDOMElement, "mouseout", this.get$onMouseOut(this), true);
      J.removeEventListener$3$x(this.interactionDOMElement, "touchstart", this.get$onTouchStart(this), true);
      J.removeEventListener$3$x(this.interactionDOMElement, "touchend", this.get$onTouchEnd(this), true);
      J.removeEventListener$3$x(this.interactionDOMElement, "touchmove", this.get$onTouchMove(this), true);
      this.interactionDOMElement = null;
      C.Window_methods.removeEventListener$3(window, "mouseup", this.get$onMouseUp(this), true);
    }, "call$0", "get$removeEvents", 0, 0, 550, "removeEvents"],
    update$0: [function() {
      var now, $length, i, cursor, over, item;
      if (this.target == null)
        return;
      now = new P.DateTime(Date.now(), false);
      now.DateTime$_now$0();
      if (C.JSNumber_methods._tdivFast$1(now.difference$1(this.last)._duration, 1000) * 30 / 1000 < 1)
        return;
      this.last = now;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      $length = J.get$length$asx(this.interactiveItems);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      cursor = "inherit";
      over = false;
      for (; i < $length; ++i) {
        item = J.$index$asx(this.interactiveItems, i);
        item.set$__hit(this.hitTest$2(item, this.mouse));
        J.set$target$x(this.mouse, item);
        if (item.get$__hit() === true && !over) {
          if (item.get$buttonMode() === true)
            cursor = item.get$defaultCursor();
          if (!!J.getInterceptor(item).$isDisplayObjectContainer && item.interactiveChildren !== true)
            over = true;
          if (item.get$__isOver() !== true) {
            if (item.get$mouseover() != null)
              item.mouseover$1(this.mouse);
            item.set$__isOver(true);
          }
        } else if (item.get$__isOver() === true) {
          if (item.get$mouseout() != null)
            item.mouseout$1(this.mouse);
          item.set$__isOver(false);
        }
      }
      if (!J.$eq(this.currentCursorStyle, cursor)) {
        this.currentCursorStyle = cursor;
        J.set$cursor$x(J.get$style$x(this.interactionDOMElement), cursor);
      }
    }, "call$0", "get$update", 0, 0, 550, "update"],
    rebuildInteractiveGraph$0: [function() {
      var len, i, item, t1;
      this.dirty = false;
      len = J.get$length$asx(this.interactiveItems);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i) {
        item = J.$index$asx(this.interactiveItems, i);
        if (!!J.getInterceptor(item).$isDisplayObjectContainer)
          item.interactiveChildren = false;
      }
      this.interactiveItems = [];
      if (this.stage.get$interactive() === true)
        J.add$1$ax(this.interactiveItems, this.stage);
      t1 = this.stage;
      this.collectInteractiveSprite$2(t1, t1);
    }, "call$0", "get$rebuildInteractiveGraph", 0, 0, 13, "rebuildInteractiveGraph"],
    onMouseMove$1: [function(_, $event) {
      var rect, t1, t2, t3, t4, t5, t6, $length, i, item;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      this.mouse.set$originalEvent($event);
      rect = J.getBoundingClientRect$0$x(this.interactionDOMElement);
      t1 = this.mouse.get$global();
      t2 = J.getInterceptor$x($event);
      t3 = t2.get$client($event);
      t3 = t3.get$x(t3);
      t4 = J.getInterceptor$x(rect);
      t5 = t4.get$left(rect);
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof t5 !== "number")
        return H.iae(t5);
      t6 = J.$div$n(J.get$width$x(this.target), t4.get$width(rect));
      if (typeof t6 !== "number")
        return H.iae(t6);
      J.set$x$x(t1, (t3 - t5) * t6);
      t6 = this.mouse.get$global();
      t2 = t2.get$client($event);
      t2 = t2.get$y(t2);
      t5 = t4.get$top(rect);
      if (typeof t2 !== "number")
        return t2.$sub();
      if (typeof t5 !== "number")
        return H.iae(t5);
      t4 = J.$div$n(J.get$height$x(this.target), t4.get$height(rect));
      if (typeof t4 !== "number")
        return H.iae(t4);
      J.set$y$x(t6, (t2 - t5) * t4);
      $length = J.get$length$asx(this.interactiveItems);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        item = J.$index$asx(this.interactiveItems, i);
        if (item.get$mousemove() != null)
          item.mousemove$1(this.mouse);
      }
    }, "call$1", "get$onMouseMove", 2, 0, 814, 815, [], "onMouseMove"],
    onMouseDown$1: [function(_, $event) {
      var $length, i, item;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      this.mouse.set$originalEvent($event);
      J.preventDefault$0$x(this.mouse.get$originalEvent());
      $length = J.get$length$asx(this.interactiveItems);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        item = J.$index$asx(this.interactiveItems, i);
        if (item.get$mousedown() != null || J.get$click$x(item) != null) {
          item.set$__mouseIsDown(true);
          item.set$__hit(this.hitTest$2(item, this.mouse));
          if (item.get$__hit() === true) {
            if (item.get$mousedown() != null)
              item.mousedown$1(this.mouse);
            item.set$__isDown(true);
            if (!!J.getInterceptor(item).$isDisplayObjectContainer && item.interactiveChildren !== true)
              break;
          }
        }
      }
    }, "call$1", "get$onMouseDown", 2, 0, 816, 815, [], "onMouseDown"],
    onMouseOut$1: [function(_, $event) {
      var $length, i, item;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      $length = J.get$length$asx(this.interactiveItems);
      J.set$cursor$x(J.get$style$x(this.interactionDOMElement), "inherit");
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        item = J.$index$asx(this.interactiveItems, i);
        if (item.get$__isOver() === true) {
          J.set$target$x(this.mouse, item);
          if (item.get$mouseout() != null)
            item.mouseout$1(this.mouse);
          item.set$__isOver(false);
        }
      }
      this.mouseOut = true;
      J.set$x$x(this.mouse.get$global(), -10000);
      J.set$y$x(this.mouse.get$global(), -10000);
    }, "call$1", "get$onMouseOut", 2, 0, 816, 815, [], "onMouseOut"],
    onMouseUp$1: [function(_, $event) {
      var $length, up, i, item, t1;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      this.mouse.set$originalEvent($event);
      $length = J.get$length$asx(this.interactiveItems);
      if (typeof $length !== "number")
        return H.iae($length);
      up = false;
      i = 0;
      for (; i < $length; ++i) {
        item = J.$index$asx(this.interactiveItems, i);
        item.set$__hit(this.hitTest$2(item, this.mouse));
        if (item.get$__hit() === true && !up) {
          if (item.get$mouseup() != null)
            item.mouseup$1(this.mouse);
          if (item.get$__isDown() === true) {
            t1 = J.getInterceptor$x(item);
            if (t1.get$click(item) != null)
              t1.click$1(item, this.mouse);
          }
          if (!!J.getInterceptor(item).$isDisplayObjectContainer && item.interactiveChildren !== true)
            up = true;
        } else if (item.get$__isDown() === true)
          if (item.get$mouseupoutside() != null)
            item.mouseupoutside$1(this.mouse);
        item.set$__isDown(false);
      }
    }, "call$1", "get$onMouseUp", 2, 0, 814, 815, [], "onMouseUp"],
    hitTest$2: [function(item, interactionData) {
      var global, t1, worldTransform, a00, a01, a02, a10, a11, a12, t2, t3, t4, t5, id, t6, t7, x, y, width, height, x1, y1, $length, i;
      global = interactionData.get$global();
      if (!item.get$worldVisible())
        return false;
      t1 = J.getInterceptor(item);
      worldTransform = item.get$_worldTransform();
      a00 = J.get$a$x(worldTransform);
      a01 = worldTransform.get$b();
      a02 = worldTransform.get$tx();
      a10 = worldTransform.get$c();
      a11 = worldTransform.get$d();
      a12 = worldTransform.get$ty();
      t2 = J.getInterceptor$ns(a00);
      t3 = J.getInterceptor$n(a10);
      t4 = J.getInterceptor$ns(a01);
      t5 = J.$add$ns(t2.$mul(a00, a11), t4.$mul(a01, t3.$negate(a10)));
      if (typeof t5 !== "number")
        return H.iae(t5);
      id = 1 / t5;
      t5 = J.getInterceptor$x(global);
      t6 = J.getInterceptor$ns(a12);
      t7 = J.getInterceptor$ns(a02);
      x = J.$add$ns(J.$add$ns(J.$mul$ns(J.$mul$ns(a11, id), t5.get$x(global)), J.$mul$ns(J.$mul$ns(t4.$negate(a01), id), t5.get$y(global))), J.$mul$ns(J.$sub$n(t6.$mul(a12, a01), t7.$mul(a02, a11)), id));
      y = J.$add$ns(J.$add$ns(J.$mul$ns(t2.$mul(a00, id), t5.get$y(global)), J.$mul$ns(J.$mul$ns(t3.$negate(a10), id), t5.get$x(global))), J.$mul$ns(J.$add$ns(J.$mul$ns(t6.$negate(a12), a00), t7.$mul(a02, a10)), id));
      t7 = J.getInterceptor$x(interactionData);
      t7.set$target(interactionData, item);
      if (item.get$hitArea() != null) {
        J.get$contains$asx(item.get$hitArea());
        t2 = true;
      } else
        t2 = false;
      if (t2) {
        if (J.contains$2$asx(item.get$hitArea(), x, y)) {
          t7.set$target(interactionData, item);
          return true;
        }
        return false;
      } else if (!!t1.$isSprite) {
        width = J.get$width$x(item.get$texture().get$frame());
        height = J.get$height$x(item.get$texture().get$frame());
        x1 = J.$mul$ns(J.$negate$n(width), J.get$x$x(item.get$anchor()));
        t2 = J.getInterceptor$n(x);
        if (t2.$gt(x, x1) && t2.$lt(x, J.$add$ns(x1, width))) {
          y1 = J.$mul$ns(J.$negate$n(height), J.get$y$x(item.get$anchor()));
          t2 = J.getInterceptor$n(y);
          if (t2.$gt(y, y1) && t2.$lt(y, J.$add$ns(y1, height))) {
            t7.set$target(interactionData, item);
            return true;
          }
        }
      }
      $length = J.get$length$asx(t1.get$children(item));
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i)
        if (this.hitTest$2(J.$index$asx(t1.get$children(item), i), interactionData)) {
          t7.set$target(interactionData, item);
          return true;
        }
      return false;
    }, "call$2", "get$hitTest", 4, 0, 817, 818, [], 819, [], "hitTest"],
    onTouchMove$1: [function(_, $event) {
      var t1, changedTouches, i, touchEvent, t2, identifier, touchData, rect, t3, t4, t5, t6, t7, j, item;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      if (this.isCocoonJS === true) {
        t1 = [];
        C.JSArray_methods.addAll$1(t1, J.map$1$ax(J.$index$asx(P.JsObject_JsObject$fromBrowserObject($event), "changedTouches"), P._convertToJS$closure()));
        changedTouches = H.setRuntimeTypeInfo(new P.JsArray(t1), [null]);
      } else
        changedTouches = J.get$changedTouches$x($event);
      for (t1 = J.getInterceptor$asx(changedTouches), i = 0; i < t1.get$length(changedTouches); ++i) {
        if (this.isCocoonJS === true) {
          touchEvent = P.JsObject_JsObject$fromBrowserObject(t1.$index(changedTouches, i));
          t2 = J.getInterceptor$asx(touchEvent);
          identifier = t2.$index(touchEvent, "identifier");
          touchData = J.$index$asx(this.touchs, identifier);
          touchData.set$originalEvent($event);
          J.set$x$x(touchData.get$global(), t2.$index(touchEvent, "clientX"));
          J.set$y$x(touchData.get$global(), t2.$index(touchEvent, "clientY"));
        } else {
          rect = J.getBoundingClientRect$0$x(this.interactionDOMElement);
          touchEvent = t1.$index(changedTouches, i);
          t2 = J.getInterceptor$x(touchEvent);
          identifier = t2.get$identifier(touchEvent);
          touchData = J.$index$asx(this.touchs, identifier);
          touchData.set$originalEvent($event);
          t3 = touchData.get$global();
          t4 = t2.get$client(touchEvent);
          t4 = t4.get$x(t4);
          t5 = J.getInterceptor$x(rect);
          t6 = t5.get$left(rect);
          if (typeof t4 !== "number")
            return t4.$sub();
          if (typeof t6 !== "number")
            return H.iae(t6);
          t7 = J.$div$n(J.get$width$x(this.target), t5.get$width(rect));
          if (typeof t7 !== "number")
            return H.iae(t7);
          J.set$x$x(t3, (t4 - t6) * t7);
          t7 = touchData.get$global();
          t2 = t2.get$client(touchEvent);
          t2 = t2.get$y(t2);
          t6 = t5.get$top(rect);
          if (typeof t2 !== "number")
            return t2.$sub();
          if (typeof t6 !== "number")
            return H.iae(t6);
          t5 = J.$div$n(J.get$height$x(this.target), t5.get$height(rect));
          if (typeof t5 !== "number")
            return H.iae(t5);
          J.set$y$x(t7, (t2 - t6) * t5);
        }
        j = 0;
        while (true) {
          t2 = J.get$length$asx(this.interactiveItems);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(j < t2))
            break;
          item = J.$index$asx(this.interactiveItems, j);
          if (item.get$touchmove() != null && J.$index$asx(item.get$__touchData(), identifier) != null)
            item.touchmove$1(touchData);
          ++j;
        }
      }
    }, "call$1", "get$onTouchMove", 2, 0, 554, 815, [], "onTouchMove"],
    onTouchStart$1: [function(_, $event) {
      var ev, t1, t2, changedTouches, t3, i, touchData, t4, touchEvent, identifier, rect, t5, t6, t7, t8, t9, $length, j, item;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      if (this.isCocoonJS === true) {
        ev = P.JsObject_JsObject$fromBrowserObject($event);
        t1 = J.getInterceptor$asx(ev);
        t2 = [];
        C.JSArray_methods.addAll$1(t2, J.map$1$ax(t1.$index(ev, "changedTouches"), P._convertToJS$closure()));
        changedTouches = H.setRuntimeTypeInfo(new P.JsArray(t2), [null]);
        t1.$index(ev, "preventDefault").apply$2$thisArg([], ev);
      } else {
        t1 = J.getInterceptor$x($event);
        changedTouches = t1.get$changedTouches($event);
        t1.preventDefault$0($event);
      }
      for (t1 = J.getInterceptor$asx(changedTouches), t2 = this.pool, t3 = J.getInterceptor$asx(t2), i = 0; i < t1.get$length(changedTouches); ++i) {
        touchData = J.$gt$n(t3.get$length(t2), 0) ? t3.removeLast$0(t2) : null;
        if (touchData == null) {
          t4 = new M.Point0(null, null);
          t4.x = 0;
          t4.y = 0;
          touchData = new M.InteractionData(t4, null, null);
        }
        touchData.set$originalEvent($event);
        if (this.isCocoonJS === true) {
          touchEvent = P.JsObject_JsObject$fromBrowserObject(t1.$index(changedTouches, i));
          t4 = J.getInterceptor$asx(touchEvent);
          identifier = t4.$index(touchEvent, "identifier");
          J.set$x$x(touchData.get$global(), t4.$index(touchEvent, "clientX"));
          J.set$y$x(touchData.get$global(), t4.$index(touchEvent, "clientY"));
        } else {
          touchEvent = t1.$index(changedTouches, i);
          t4 = J.getInterceptor$x(touchEvent);
          identifier = t4.get$identifier(touchEvent);
          rect = J.getBoundingClientRect$0$x(this.interactionDOMElement);
          t5 = touchData.get$global();
          t6 = t4.get$client(touchEvent);
          t6 = t6.get$x(t6);
          t7 = J.getInterceptor$x(rect);
          t8 = t7.get$left(rect);
          if (typeof t6 !== "number")
            return t6.$sub();
          if (typeof t8 !== "number")
            return H.iae(t8);
          t9 = J.$div$n(J.get$width$x(this.target), t7.get$width(rect));
          if (typeof t9 !== "number")
            return H.iae(t9);
          J.set$x$x(t5, (t6 - t8) * t9);
          t9 = touchData.get$global();
          t4 = t4.get$client(touchEvent);
          t4 = t4.get$y(t4);
          t8 = t7.get$top(rect);
          if (typeof t4 !== "number")
            return t4.$sub();
          if (typeof t8 !== "number")
            return H.iae(t8);
          t7 = J.$div$n(J.get$height$x(this.target), t7.get$height(rect));
          if (typeof t7 !== "number")
            return H.iae(t7);
          J.set$y$x(t9, (t4 - t8) * t7);
        }
        J.$indexSet$ax(this.touchs, identifier, touchData);
        $length = J.get$length$asx(this.interactiveItems);
        if (typeof $length !== "number")
          return H.iae($length);
        j = 0;
        for (; j < $length; ++j) {
          item = J.$index$asx(this.interactiveItems, j);
          if (item.get$touchstart() != null || item.get$tap() != null) {
            item.set$__hit(this.hitTest$2(item, touchData));
            if (item.get$__hit() === true) {
              if (item.get$touchstart() != null)
                item.touchstart$1(touchData);
              item.set$__isDown(true);
              if (item.get$__touchData() == null)
                item.set$__touchData(P.LinkedHashMap_LinkedHashMap$_empty(null, null));
              J.$indexSet$ax(item.get$__touchData(), identifier, touchData);
              if (!!J.getInterceptor(item).$isDisplayObjectContainer && item.interactiveChildren !== true)
                break;
            }
          }
        }
      }
    }, "call$1", "get$onTouchStart", 2, 0, 554, 815, [], "onTouchStart"],
    onTouchEnd$1: [function(_, $event) {
      var t1, changedTouches, t2, t3, i, touchEvent, t4, identifier, touchData, rect, t5, t6, t7, t8, t9, $length, up, j, item;
      if (this.dirty === true)
        this.rebuildInteractiveGraph$0();
      if (this.isCocoonJS === true) {
        t1 = [];
        C.JSArray_methods.addAll$1(t1, J.map$1$ax(J.$index$asx(P.JsObject_JsObject$fromBrowserObject($event), "changedTouches"), P._convertToJS$closure()));
        changedTouches = H.setRuntimeTypeInfo(new P.JsArray(t1), [null]);
      } else
        changedTouches = J.get$changedTouches$x($event);
      for (t1 = J.getInterceptor$asx(changedTouches), t2 = this.pool, t3 = J.getInterceptor$ax(t2), i = 0; i < t1.get$length(changedTouches); ++i) {
        if (this.isCocoonJS === true) {
          touchEvent = P.JsObject_JsObject$fromBrowserObject(t1.$index(changedTouches, i));
          t4 = J.getInterceptor$asx(touchEvent);
          identifier = t4.$index(touchEvent, "identifier");
          touchData = J.$index$asx(this.touchs, identifier);
          J.set$x$x(touchData.get$global(), t4.$index(touchEvent, "clientX"));
          J.set$y$x(touchData.get$global(), t4.$index(touchEvent, "clientY"));
        } else {
          touchEvent = t1.$index(changedTouches, i);
          t4 = J.getInterceptor$x(touchEvent);
          identifier = t4.get$identifier(touchEvent);
          touchData = J.$index$asx(this.touchs, identifier);
          rect = J.getBoundingClientRect$0$x(this.interactionDOMElement);
          t5 = touchData.get$global();
          t6 = t4.get$client(touchEvent);
          t6 = t6.get$x(t6);
          t7 = J.getInterceptor$x(rect);
          t8 = t7.get$left(rect);
          if (typeof t6 !== "number")
            return t6.$sub();
          if (typeof t8 !== "number")
            return H.iae(t8);
          t9 = J.$div$n(J.get$width$x(this.target), t7.get$width(rect));
          if (typeof t9 !== "number")
            return H.iae(t9);
          J.set$x$x(t5, (t6 - t8) * t9);
          t9 = touchData.get$global();
          t4 = t4.get$client(touchEvent);
          t4 = t4.get$y(t4);
          t8 = t7.get$top(rect);
          if (typeof t4 !== "number")
            return t4.$sub();
          if (typeof t8 !== "number")
            return H.iae(t8);
          t7 = J.$div$n(J.get$height$x(this.target), t7.get$height(rect));
          if (typeof t7 !== "number")
            return H.iae(t7);
          J.set$y$x(t9, (t4 - t8) * t7);
        }
        $length = J.get$length$asx(this.interactiveItems);
        if (typeof $length !== "number")
          return H.iae($length);
        up = false;
        j = 0;
        for (; j < $length; ++j) {
          item = J.$index$asx(this.interactiveItems, j);
          if (item.get$__touchData() != null && J.$index$asx(item.get$__touchData(), identifier) != null) {
            item.set$__hit(this.hitTest$2(item, J.$index$asx(item.get$__touchData(), identifier)));
            touchData.set$originalEvent($event);
            if (item.get$touchend() != null || item.get$tap() != null) {
              if (item.get$__hit() === true && !up) {
                if (item.get$touchend() != null)
                  item.touchend$1(touchData);
                if (item.get$__isDown() === true)
                  if (item.get$tap() != null)
                    item.tap$1(touchData);
                if (!!J.getInterceptor(item).$isDisplayObjectContainer && item.interactiveChildren !== true)
                  up = true;
              } else if (item.get$__isDown() === true)
                if (item.get$touchendoutside() != null)
                  item.touchendoutside$1(touchData);
              item.set$__isDown(false);
            }
            J.$indexSet$ax(item.get$__touchData(), identifier, null);
          }
        }
        t3.add$1(t2, touchData);
        J.$indexSet$ax(this.touchs, identifier, null);
      }
    }, "call$1", "get$onTouchEnd", 2, 0, 554, 815, [], "onTouchEnd"],
    static: {InteractionManager$: [function(stage) {
        var t1, t2, t3, t4;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new P.DateTime(Date.now(), false);
        t4.DateTime$_now$0();
        t4 = new M.InteractionManager(stage, new M.InteractionData(t1, null, null), t2, t3, true, [], [], null, null, t4, null, "inherit", false, null);
        t4.isCocoonJS = J.contains$1$asx(window.navigator.appVersion, "CocoonJS");
        return t4;
      }, null, null, 2, 0, 92, 93, [], "new InteractionManager"]}
  },
  "+InteractionManager": [632],
  AssetLoader: {
    "^": "EventTarget0;assetURLs@-820,crossorigin@-602,loadCount@-599,onProgress*-0,onComplete*-0,listeners-821",
    onProgress$1: function($receiver, arg0) {
      return this.onProgress.call$1(arg0);
    },
    onComplete$0: function($receiver) {
      return this.onComplete.call$0();
    },
    _getDataType$1: [function(str) {
      var t1, data, sepIdx, info;
      t1 = J.getInterceptor$s(str);
      if (t1.substring$2(str, 0, 5).toLowerCase() === "data:") {
        data = t1.substring$1(str, 5);
        sepIdx = C.JSString_methods.indexOf$1(data, ",");
        if (sepIdx === -1)
          return;
        t1 = C.JSString_methods.substring$2(data, 0, sepIdx).split(";");
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        info = t1[0];
        if (info == null) {
          J.toLowerCase$0$s(info);
          t1 = false;
        } else
          t1 = true;
        if (t1)
          return "txt";
        t1 = J.split$1$s(info, "/");
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        return J.toLowerCase$0$s(t1.pop());
      }
      return;
    }, "call$1", "get$_getDataType", 2, 0, 52, 822, [], "_getDataType"],
    load$0: [function(_) {
      var t1, i, t2, fileName, fileType, loader;
      t1 = new M.AssetLoader_load_onLoad(this);
      this.loadCount = J.get$length$asx(this.assetURLs);
      i = 0;
      while (true) {
        t2 = J.get$length$asx(this.assetURLs);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        fileName = J.$index$asx(this.assetURLs, i);
        fileType = this._getDataType$1(fileName);
        if (fileType == null) {
          t2 = J.split$1$s(C.JSArray_methods.removeAt$1(J.split$1$s(fileName, "?"), 0), ".");
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          fileType = J.toLowerCase$0$s(t2.pop());
        }
        loader = M.Loader_Loader$loaderByType(fileType, fileName, this.crossorigin);
        loader.addEventListener$2(0, "loaded", t1);
        loader.load$0(0);
        ++i;
      }
    }, "call$0", "get$load", 0, 0, 13, "load"],
    onAssetLoaded$1: [function(loader) {
      var t1;
      this.loadCount = J.$sub$n(this.loadCount, 1);
      t1 = new M.PixiEvent(null, null, null);
      t1.type = "onProgress";
      t1.content = this;
      t1.loader = loader;
      this.dispatchEvent$1(0, t1);
      if (this.onProgress != null)
        this.onProgress$1(0, loader);
      if (J.$eq(this.loadCount, 0)) {
        t1 = new M.PixiEvent(null, null, null);
        t1.type = "onComplete";
        t1.content = this;
        this.dispatchEvent$1(0, t1);
        if (this.onComplete != null)
          this.onComplete$0(0);
      }
    }, "call$1", "get$onAssetLoaded", 2, 0, 63, 189, [], "onAssetLoaded"],
    static: {AssetLoader$: [function(assetURLs, crossorigin) {
        return new M.AssetLoader(assetURLs, crossorigin, 0, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      }, null, null, 2, 2, 94, 95, 96, [], 34, [], "new AssetLoader"]}
  },
  "+AssetLoader": [823],
  AssetLoader_load_onLoad: {
    "^": "Closure:63;scope_0",
    call$1: [function(evt) {
      var t1, t2, t3;
      t1 = this.scope_0;
      t2 = J.get$content$x(evt);
      t1.loadCount = J.$sub$n(t1.loadCount, 1);
      t3 = new M.PixiEvent(null, null, null);
      t3.type = "onProgress";
      t3.content = t1;
      t3.loader = t2;
      t1.dispatchEvent$1(0, t3);
      if (t1.onProgress != null)
        t1.onProgress$1(0, t2);
      if (J.$eq(t1.loadCount, 0)) {
        t2 = new M.PixiEvent(null, null, null);
        t2.type = "onComplete";
        t2.content = t1;
        t1.dispatchEvent$1(0, t2);
        if (t1.onComplete != null)
          t1.onComplete$0(0);
      }
    }, "call$1", null, 2, 0, 63, 824, [], "call"],
    $isFunction: true
  },
  AtlasLoader: {
    "^": "Loader0;atlas@-754,images@-720,currentImageId@-599,url-639,crossorigin-602,baseUrl-639,ajaxRequest-825,loaded-602,texture-826,listeners-821",
    atlas$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.atlas.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    load$0: [function(_) {
      var t1 = new XMLHttpRequest();
      this.ajaxRequest = t1;
      t1 = C.HttpRequest_methods.get$onReadyStateChange(t1);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$onAtlasLoaded()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      J.open$3$async$x(this.ajaxRequest, "GET", this.url, true);
      J.overrideMimeType$1$x(this.ajaxRequest, "application/json");
      J.send$1$x(this.ajaxRequest, null);
    }, "call$0", "get$load", 0, 0, 13, "load"],
    onAtlasLoaded$1: [function(e) {
      var result, lineCount, currentImageId, currentFrame, nameInNextLine, i, t1, text, realSize, j, textureUrl, frameData, t2, t3, rect, t4, t5, t6;
      if (J.get$readyState$x(this.ajaxRequest) === 4)
        if (J.get$status$x(this.ajaxRequest) === 200 || J.indexOf$1$asx(window.location.href, "http") === -1) {
          this.atlas = P.LinkedHashMap_LinkedHashMap$_literal(["meta", P.LinkedHashMap_LinkedHashMap$_literal(["image", []], null, null), "frames", []], null, null);
          result = J.split$1$s(J.get$responseText$x(this.ajaxRequest), $.get$Loader_resultReg());
          for (lineCount = -3, currentImageId = 0, currentFrame = null, nameInNextLine = false, i = 0; i < result.length; ++i) {
            t1 = J.replaceAll$2$s(result[i], $.get$Loader_resultSplit(), "");
            if (i >= result.length)
              return H.ioore(result, i);
            result[i] = t1;
            if (t1 === "")
              nameInNextLine = i + 1;
            if (i >= result.length)
              return H.ioore(result, i);
            if (J.$gt$n(J.get$length$asx(result[i]), 0)) {
              if (nameInNextLine === i) {
                t1 = J.$index$asx(J.$index$asx(this.atlas, "meta"), "image");
                if (i >= result.length)
                  return H.ioore(result, i);
                J.add$1$ax(t1, result[i]);
                currentImageId = J.$sub$n(J.get$length$asx(J.$index$asx(J.$index$asx(this.atlas, "meta"), "image")), 1);
                J.add$1$ax(J.$index$asx(this.atlas, "frames"), P.LinkedHashMap_LinkedHashMap$_empty(null, null));
                lineCount = -3;
              } else if (lineCount > 0) {
                t1 = C.JSInt_methods.$mod(lineCount, 7);
                if (t1 === 1) {
                  if (currentFrame != null)
                    J.$indexSet$ax(J.$index$asx(J.$index$asx(this.atlas, "frames"), currentImageId), currentFrame.get$name(currentFrame), currentFrame);
                  if (i >= result.length)
                    return H.ioore(result, i);
                  currentFrame = P.LinkedHashMap_LinkedHashMap$_literal(["name", result[i], "frame", P.LinkedHashMap_LinkedHashMap$_empty(null, null)], null, null);
                } else {
                  if (i >= result.length)
                    return H.ioore(result, i);
                  text = J.split$1$s(result[i], " ");
                  if (t1 === 3) {
                    t1 = currentFrame.get$frame();
                    if (1 >= text.length)
                      return H.ioore(text, 1);
                    t1.set$x(0, H.Primitives_parseInt(J.replaceAll$2$s(text[1], ",", ""), null, null));
                    t1 = currentFrame.get$frame();
                    if (2 >= text.length)
                      return H.ioore(text, 2);
                    t1.set$y(0, H.Primitives_parseInt(text[2], null, null));
                  } else if (t1 === 4) {
                    t1 = currentFrame.get$frame();
                    if (1 >= text.length)
                      return H.ioore(text, 1);
                    t1.set$w(H.Primitives_parseInt(J.replaceAll$2$s(text[1], ",", ""), null, null));
                    t1 = currentFrame.get$frame();
                    if (2 >= text.length)
                      return H.ioore(text, 2);
                    t1.set$h(H.Primitives_parseInt(text[2], null, null));
                  } else if (t1 === 5) {
                    if (1 >= text.length)
                      return H.ioore(text, 1);
                    t1 = H.Primitives_parseInt(J.replaceAll$2$s(text[1], ",", ""), null, null);
                    if (2 >= text.length)
                      return H.ioore(text, 2);
                    realSize = P.LinkedHashMap_LinkedHashMap$_literal(["x", 0, "y", 0, "w", t1, "h", H.Primitives_parseInt(text[2], null, null)], null, null);
                    if (J.$gt$n(realSize.$index(0, "w"), currentFrame.get$frame().get$w()) || J.$gt$n(realSize.$index(0, "h"), currentFrame.get$frame().get$h())) {
                      currentFrame.set$trimmed(true);
                      currentFrame.set$realSize(realSize);
                    } else
                      currentFrame.set$trimmed(false);
                  }
                }
              }
              ++lineCount;
            }
          }
          if (currentFrame != null)
            J.$indexSet$ax(J.$index$asx(J.$index$asx(this.atlas, "frames"), currentImageId), currentFrame.get$name(currentFrame), currentFrame);
          if (J.$gt$n(J.get$length$asx(J.$index$asx(J.$index$asx(this.atlas, "meta"), "image")), 0)) {
            this.images = [];
            j = 0;
            while (true) {
              t1 = J.get$length$asx(J.$index$asx(J.$index$asx(this.atlas, "meta"), "image"));
              if (typeof t1 !== "number")
                return H.iae(t1);
              if (!(j < t1))
                break;
              textureUrl = J.$add$ns(this.baseUrl, J.$index$asx(J.$index$asx(J.$index$asx(this.atlas, "meta"), "image"), j));
              frameData = J.$index$asx(J.$index$asx(this.atlas, "frames"), j);
              t1 = this.images;
              t2 = this.crossorigin;
              t3 = new M.ImageLoader(null, [], textureUrl, t2, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
              t3.baseUrl = J.replaceFirst$2$s(textureUrl, $.get$Loader_baseReg(), "");
              t3.PIXI$ImageLoader$texture = M.Texture_fromImage(textureUrl, t2, null);
              J.add$1$ax(t1, t3);
              for (t1 = J.getInterceptor$ax(frameData), t2 = t1.get$iterator(frameData); t2.moveNext$0();) {
                i = t2.get$current();
                rect = t1.$index(frameData, i).get$frame();
                if (rect === true) {
                  t3 = $.get$TextureCache();
                  t4 = J.$index$asx(this.images, j).get$texture().get$baseTexture();
                  t5 = new M.Rectangle0(0, 0, 0, 0);
                  t6 = J.getInterceptor$x(rect);
                  t5.x = t6.get$x(rect);
                  t5.y = t6.get$y(rect);
                  t5.width = rect.get$w();
                  t5.height = rect.get$h();
                  J.$indexSet$ax(t3, i, M.Texture$(t4, t5));
                  if (t1.$index(frameData, i).get$trimmed() === true) {
                    J.$index$asx($.get$TextureCache(), i).set$realSize(t1.$index(frameData, i).get$realSize());
                    J.set$x$x(J.get$trim$s(J.$index$asx($.get$TextureCache(), i)), 0);
                    J.set$y$x(J.get$trim$s(J.$index$asx($.get$TextureCache(), i)), 0);
                  }
                }
              }
              ++j;
            }
            this.currentImageId = 0;
            j = 0;
            while (true) {
              t1 = J.get$length$asx(this.images);
              if (typeof t1 !== "number")
                return H.iae(t1);
              if (!(j < t1))
                break;
              J.addEventListener$2$x(J.$index$asx(this.images, j), "loaded", this.get$onLoaded());
              ++j;
            }
            J.load$0$x(J.$index$asx(this.images, this.currentImageId));
          } else
            this.onLoaded$0();
        } else
          this.onError$0(0);
    }, "call$1", "get$onAtlasLoaded", 2, 0, 63, 312, [], "onAtlasLoaded"],
    onLoaded$0: [function() {
      if (J.$gt$n(J.$sub$n(J.get$length$asx(this.images), 1), this.currentImageId)) {
        var t1 = J.$add$ns(this.currentImageId, 1);
        this.currentImageId = t1;
        J.load$0$x(J.$index$asx(this.images, t1));
      } else {
        this.loaded = true;
        t1 = new M.PixiEvent(null, null, null);
        t1.type = "loaded";
        t1.content = this;
        this.dispatchEvent$1(0, t1);
      }
    }, "call$0", "get$onLoaded", 0, 0, 13, "onLoaded"],
    onError$0: [function(_) {
      var t1 = new M.PixiEvent(null, null, null);
      t1.type = "error";
      t1.content = this;
      this.dispatchEvent$1(0, t1);
    }, "call$0", "get$onError", 0, 0, 13, "onError"],
    static: {AtlasLoader$: [function(url, crossorigin) {
        var t1 = new M.AtlasLoader(null, null, 0, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
        return t1;
      }, null, null, 4, 0, 97, 88, [], 34, [], "new AtlasLoader"]}
  },
  "+AtlasLoader": [827],
  BitmapFontLoader: {
    "^": "Loader0;baseUrl:PIXI$BitmapFontLoader$baseUrl@-639,url-639,crossorigin-602,baseUrl-639,ajaxRequest-825,loaded-602,texture-826,listeners-821",
    load$0: [function(_) {
      var t1 = new XMLHttpRequest();
      this.ajaxRequest = t1;
      t1 = C.HttpRequest_methods.get$onReadyStateChange(t1);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$onXMLLoaded()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      J.open$3$async$x(this.ajaxRequest, "GET", this.url, true);
      J.send$1$x(this.ajaxRequest, null);
    }, "call$0", "get$load", 0, 0, 13, "load"],
    onXMLLoaded$1: [function(e) {
      var responseXML, t1, t2, textureUrl, image, data, info, common, letters, i, charCode, t3, t4, t5, t6, t7, kernings, first, second, amount;
      if (J.get$readyState$x(this.ajaxRequest) === 4)
        if (J.get$status$x(this.ajaxRequest) === 200 || J.indexOf$1$asx(window.location.protocol, "http") === -1) {
          responseXML = J.get$responseXml$x(this.ajaxRequest);
          if (responseXML == null)
            throw H.wrapException(P.Exception_Exception("can not load font."));
          t1 = this.PIXI$BitmapFontLoader$baseUrl;
          t2 = responseXML.getElementsByTagName("page");
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          textureUrl = J.$add$ns(t1, J.getAttribute$1$x(t2[0], "file"));
          t2 = this.crossorigin;
          image = new M.ImageLoader(null, [], textureUrl, t2, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
          image.baseUrl = J.replaceFirst$2$s(textureUrl, $.get$Loader_baseReg(), "");
          t2 = M.Texture_fromImage(textureUrl, t2, null);
          image.PIXI$ImageLoader$texture = t2;
          this.texture = t2.get$baseTexture();
          data = new M.ChartData(null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
          t2 = responseXML.getElementsByTagName("info");
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          info = t2[0];
          t2 = responseXML.getElementsByTagName("common");
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          common = t2[0];
          t2 = J.getInterceptor$x(info);
          data.font = t2.getAttribute$1(info, "face");
          data.size = H.Primitives_parseInt(t2.getAttribute$1(info, "size"), null, null);
          data.lineHeight = H.Primitives_parseInt(J.getAttribute$1$x(common, "lineHeight"), null, null);
          letters = responseXML.getElementsByTagName("char");
          for (i = 0; i < letters.length; ++i) {
            charCode = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "id"), null, null);
            if (i >= letters.length)
              return H.ioore(letters, i);
            t1 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "x"), null, null);
            if (i >= letters.length)
              return H.ioore(letters, i);
            t2 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "y"), null, null);
            if (i >= letters.length)
              return H.ioore(letters, i);
            t3 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "width"), null, null);
            if (i >= letters.length)
              return H.ioore(letters, i);
            t4 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "height"), null, null);
            t5 = data.chars;
            t6 = new M.Char(null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
            if (i >= letters.length)
              return H.ioore(letters, i);
            t6.xOffset = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "xoffset"), null, null);
            if (i >= letters.length)
              return H.ioore(letters, i);
            t6.yOffset = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "yoffset"), null, null);
            if (i >= letters.length)
              return H.ioore(letters, i);
            t6.xAdvance = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "xadvance"), null, null);
            t7 = $.get$TextureCache();
            t4 = M.Texture$(this.texture, new M.Rectangle0(t1, t2, t3, t4));
            J.$indexSet$ax(t7, charCode, t4);
            t6.texture = t4;
            J.$indexSet$ax(t5, charCode, t6);
          }
          kernings = responseXML.getElementsByTagName("kerning");
          for (i = 0; i < kernings.length; ++i) {
            first = H.Primitives_parseInt(J.getAttribute$1$x(kernings[i], "first"), null, null);
            if (i >= kernings.length)
              return H.ioore(kernings, i);
            second = H.Primitives_parseInt(J.getAttribute$1$x(kernings[i], "second"), null, null);
            if (i >= kernings.length)
              return H.ioore(kernings, i);
            amount = H.Primitives_parseInt(J.getAttribute$1$x(kernings[i], "amount"), null, null);
            J.$indexSet$ax(J.$index$asx(data.chars, second).get$kernings(), first, amount);
          }
          J.$indexSet$ax($.get$BitmapText_fonts(), data.font, data);
          image.addEventListener$2(0, "loaded", new M.BitmapFontLoader_onXMLLoaded_closure(this));
          image.load$0(0);
        }
    }, "call$1", "get$onXMLLoaded", 2, 0, 63, 312, [], "onXMLLoaded"],
    onLoaded$0: [function() {
      var t1 = new M.PixiEvent(null, null, null);
      t1.type = "loaded";
      t1.content = this;
      this.dispatchEvent$1(0, t1);
    }, "call$0", "get$onLoaded", 0, 0, 13, "onLoaded"],
    static: {BitmapFontLoader$: [function(url, crossorigin) {
        var t1 = new M.BitmapFontLoader(null, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.PIXI$BitmapFontLoader$baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
        return t1;
      }, null, null, 4, 0, 97, 88, [], 34, [], "new BitmapFontLoader"]}
  },
  "+BitmapFontLoader": [827],
  BitmapFontLoader_onXMLLoaded_closure: {
    "^": "Closure:63;scope_0",
    call$1: [function(e) {
      var t1, t2;
      t1 = this.scope_0;
      t2 = new M.PixiEvent(null, null, null);
      t2.type = "loaded";
      t2.content = t1;
      t1.dispatchEvent$1(0, t2);
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  ImageLoader: {
    "^": "Loader0;texture:PIXI$ImageLoader$texture@-670,frames@-669,url-639,crossorigin-602,baseUrl-639,ajaxRequest-825,loaded-602,texture-826,listeners-821",
    load$0: [function(_) {
      if (this.PIXI$ImageLoader$texture.get$baseTexture().get$hasLoaded() !== true)
        J.addEventListener$2$x(this.PIXI$ImageLoader$texture.get$baseTexture(), "loaded", new M.ImageLoader_load_closure(this));
      else
        this.onLoaded$0();
    }, "call$0", "get$load", 0, 0, 13, "load"],
    onLoaded$0: [function() {
      var t1 = new M.PixiEvent(null, null, null);
      t1.type = "loaded";
      t1.content = this;
      this.dispatchEvent$1(0, t1);
    }, "call$0", "get$onLoaded", 0, 0, 13, "onLoaded"],
    loadFramedSpriteSheet$3: [function(frameWidth, frameHeight, textureName) {
      var cols, rows, t1, t2, i, y, x, t3, t4, texture;
      this.frames = [];
      cols = J.floor$0$n(J.$div$n(J.get$width$x(this.PIXI$ImageLoader$texture), frameWidth));
      rows = J.floor$0$n(J.$div$n(J.get$height$x(this.PIXI$ImageLoader$texture), frameHeight));
      for (t1 = textureName === true, t2 = J.getInterceptor$ns(textureName), i = 0, y = 0; y < rows; ++y)
        for (x = 0; x < cols; ++x, ++i) {
          t3 = this.PIXI$ImageLoader$texture;
          t4 = new M.Rectangle0(0, 0, 0, 0);
          if (typeof frameWidth !== "number")
            return H.iae(frameWidth);
          t4.x = x * frameWidth;
          if (typeof frameHeight !== "number")
            return H.iae(frameHeight);
          t4.y = y * frameHeight;
          t4.width = frameWidth;
          t4.height = frameHeight;
          texture = M.Texture$(t3, t4);
          J.add$1$ax(this.frames, texture);
          if (t1)
            J.$indexSet$ax($.get$TextureCache(), J.$add$ns(t2.$add(textureName, "-"), i), texture);
        }
      if (this.PIXI$ImageLoader$texture.get$baseTexture().get$hasLoaded() !== true)
        J.addEventListener$2$x(this.PIXI$ImageLoader$texture.get$baseTexture(), "loaded", new M.ImageLoader_loadFramedSpriteSheet_closure(this));
      else
        this.onLoaded$0();
    }, "call$3", "get$loadFramedSpriteSheet", 6, 0, 117, 232, [], 233, [], 828, [], "loadFramedSpriteSheet"],
    static: {ImageLoader$: [function(url, crossorigin) {
        var t1 = new M.ImageLoader(null, [], url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
        t1.PIXI$ImageLoader$texture = M.Texture_fromImage(url, crossorigin, null);
        return t1;
      }, null, null, 4, 0, 97, 88, [], 34, [], "new ImageLoader"]}
  },
  "+ImageLoader": [827],
  ImageLoader_load_closure: {
    "^": "Closure:63;this_0",
    call$1: [function(e) {
      this.this_0.onLoaded$0();
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  ImageLoader_loadFramedSpriteSheet_closure: {
    "^": "Closure:63;scope_0",
    call$1: [function(e) {
      this.scope_0.onLoaded$0();
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  JsonLoader: {
    "^": "Loader0;json@-754,url-639,crossorigin-602,baseUrl-639,ajaxRequest-825,loaded-602,texture-826,listeners-821",
    json$3: function(arg0, arg1, arg2) {
      return this.json.call$3(arg0, arg1, arg2);
    },
    load$0: [function(_) {
      var t1 = new XMLHttpRequest();
      this.ajaxRequest = t1;
      C.HttpRequest_methods.get$onLoad(t1).listen$1(new M.JsonLoader_load_closure(this));
      J.open$3$async$x(this.ajaxRequest, "GET", this.url, true);
      J.send$0$x(this.ajaxRequest);
    }, "call$0", "get$load", 0, 0, 13, "load"],
    onJSONLoaded$0: [function() {
      var t1, textureUrl, image, frameData, t2, i, rect, t3, t4, t5, t6, actualSize, realSize, skeletonData;
      if (J.get$responseText$x(this.ajaxRequest) == null) {
        this.onError$0(0);
        return;
      }
      t1 = C.JsonCodec_null_null.decode$1(J.get$responseText$x(this.ajaxRequest));
      this.json = t1;
      if (J.$index$asx(t1, "frames") != null) {
        textureUrl = J.$add$ns(this.baseUrl, J.$index$asx(J.$index$asx(this.json, "meta"), "image"));
        t1 = this.crossorigin;
        image = new M.ImageLoader(null, [], textureUrl, t1, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        image.baseUrl = J.replaceFirst$2$s(textureUrl, $.get$Loader_baseReg(), "");
        t1 = M.Texture_fromImage(textureUrl, t1, null);
        image.PIXI$ImageLoader$texture = t1;
        frameData = J.$index$asx(this.json, "frames");
        this.texture = t1.get$baseTexture();
        image.addEventListener$2(0, "loaded", new M.JsonLoader_onJSONLoaded_closure(this));
        for (t1 = J.getInterceptor$x(frameData), t2 = J.get$iterator$ax(t1.get$keys(frameData)); t2.moveNext$0();) {
          i = t2.get$current();
          rect = J.$index$asx(t1.$index(frameData, i), "frame");
          if (rect != null) {
            t3 = $.get$TextureCache();
            t4 = this.texture;
            t5 = new M.Rectangle0(0, 0, 0, 0);
            t6 = J.getInterceptor$asx(rect);
            t5.x = t6.$index(rect, "x");
            t5.y = t6.$index(rect, "y");
            t5.width = t6.$index(rect, "w");
            t5.height = t6.$index(rect, "h");
            J.$indexSet$ax(t3, i, M.Texture$(t4, t5));
            J.$index$asx($.get$TextureCache(), i).set$crop(new M.Rectangle0(t6.$index(rect, "x"), t6.$index(rect, "y"), t6.$index(rect, "w"), t6.$index(rect, "h")));
            if (J.$index$asx(t1.$index(frameData, i), "trimmed") === true) {
              actualSize = J.$index$asx(t1.$index(frameData, i), "sourceSize");
              realSize = J.$index$asx(t1.$index(frameData, i), "spriteSourceSize");
              t3 = J.getInterceptor$asx(realSize);
              t4 = J.getInterceptor$asx(actualSize);
              J.set$trim$s(J.$index$asx($.get$TextureCache(), i), new M.Rectangle0(t3.$index(realSize, "x"), t3.$index(realSize, "y"), t4.$index(actualSize, "w"), t4.$index(actualSize, "h")));
            }
          }
        }
        image.load$0(0);
      } else if (J.$index$asx(this.json, "bones") != null) {
        skeletonData = new M.SkeletonJson(null, 1).readSkeletonData$1(this.json);
        J.$indexSet$ax($.get$AnimCache(), this.url, skeletonData);
        this.onLoaded$0();
      } else
        this.onLoaded$0();
    }, "call$0", "get$onJSONLoaded", 0, 0, 13, "onJSONLoaded"],
    onLoaded$0: [function() {
      this.loaded = true;
      var t1 = new M.PixiEvent(null, null, null);
      t1.type = "loaded";
      t1.content = this;
      this.dispatchEvent$1(0, t1);
    }, "call$0", "get$onLoaded", 0, 0, 13, "onLoaded"],
    onError$0: [function(_) {
      var t1 = new M.PixiEvent(null, null, null);
      t1.type = "error";
      t1.content = this;
      this.dispatchEvent$1(0, t1);
    }, "call$0", "get$onError", 0, 0, 13, "onError"],
    static: {JsonLoader$: [function(url, crossorigin) {
        var t1 = new M.JsonLoader(null, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
        return t1;
      }, null, null, 4, 0, 97, 88, [], 34, [], "new JsonLoader"]}
  },
  "+JsonLoader": [827],
  JsonLoader_load_closure: {
    "^": "Closure:63;this_0",
    call$1: [function(e) {
      this.this_0.onJSONLoaded$0();
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  JsonLoader_onJSONLoaded_closure: {
    "^": "Closure:63;this_0",
    call$1: [function(e) {
      this.this_0.onLoaded$0();
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  Loader0: {
    "^": "EventTarget0;url*-639,crossorigin@-602,baseUrl@-639,ajaxRequest@-825,loaded*-602,texture@-826,listeners-821",
    static: {"^": "Loader_baseReg@-785,Loader_resultReg@-785,Loader_resultSplit@-785", Loader$: [function(url, crossorigin) {
        var t1 = new M.Loader0(url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
        return t1;
      }, null, null, 4, 0, 97, 88, [], 34, [], "new Loader"], Loader_Loader$loaderByType: [function(type, url, crossorigin) {
        var t1;
        switch (type) {
          case "jpg":
          case "jpeg":
          case "png":
          case "gif":
          case "webp":
            t1 = new M.ImageLoader(null, [], url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
            t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
            t1.PIXI$ImageLoader$texture = M.Texture_fromImage(url, crossorigin, null);
            return t1;
          case "json":
            t1 = new M.JsonLoader(null, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
            t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
            return t1;
          case "atlas":
            t1 = new M.AtlasLoader(null, null, 0, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
            t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
            return t1;
          case "anim":
            t1 = new M.SpineLoader(null, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
            t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
            return t1;
          case "xml":
          case "fnt":
            t1 = new M.BitmapFontLoader(null, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
            t1.PIXI$BitmapFontLoader$baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
            return t1;
          default:
            throw H.wrapException(P.Exception_Exception(H.S(type) + " is an unsupported file type"));
        }
      }, "call$3", null, 6, 0, 98, 99, [], 88, [], 34, [], "new Loader$loaderByType"]}
  },
  "+Loader": [823],
  SpineLoader: {
    "^": "Loader0;json@-32,url-639,crossorigin-602,baseUrl-639,ajaxRequest-825,loaded-602,texture-826,listeners-821",
    json$3: function(arg0, arg1, arg2) {
      return this.json.call$3(arg0, arg1, arg2);
    },
    load$0: [function(_) {
      var t1, jsonLoader;
      t1 = this.url;
      jsonLoader = new M.JsonLoader(null, t1, this.crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      jsonLoader.baseUrl = J.replaceFirst$2$s(t1, $.get$Loader_baseReg(), "");
      jsonLoader.addEventListener$2(0, "loaded", new M.SpineLoader_load_closure(this));
      jsonLoader.load$0(0);
    }, "call$0", "get$load", 0, 0, 13, "load"],
    onLoaded$0: [function() {
      this.loaded = true;
      var t1 = new M.PixiEvent(null, null, null);
      t1.type = "loaded";
      t1.content = this;
      this.dispatchEvent$1(0, t1);
    }, "call$0", "get$onLoaded", 0, 0, 13, "onLoaded"],
    static: {SpineLoader$: [function(url, crossorigin) {
        var t1 = new M.SpineLoader(null, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
        return t1;
      }, null, null, 4, 0, 97, 88, [], 34, [], "new SpineLoader"]}
  },
  "+SpineLoader": [827],
  SpineLoader_load_closure: {
    "^": "Closure:677;scope_0",
    call$1: [function($event) {
      var t1, t2;
      t1 = this.scope_0;
      t1.json = J.get$content$x($event).get$json();
      t1.loaded = true;
      t2 = new M.PixiEvent(null, null, null);
      t2.type = "loaded";
      t2.content = t1;
      t1.dispatchEvent$1(0, t2);
    }, "call$1", null, 2, 0, 677, 815, [], "call"],
    $isFunction: true
  },
  SpriteSheetLoader: {
    "^": "Loader0;json@-32,url-639,crossorigin-602,baseUrl-639,ajaxRequest-825,loaded-602,texture-826,listeners-821",
    json$3: function(arg0, arg1, arg2) {
      return this.json.call$3(arg0, arg1, arg2);
    },
    load$0: [function(_) {
      var t1, jsonLoader;
      t1 = this.url;
      jsonLoader = new M.JsonLoader(null, t1, this.crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      jsonLoader.baseUrl = J.replaceFirst$2$s(t1, $.get$Loader_baseReg(), "");
      jsonLoader.addEventListener$2(0, "loaded", new M.SpriteSheetLoader_load_closure(this));
      jsonLoader.load$0(0);
    }, "call$0", "get$load", 0, 0, 13, "load"],
    onLoaded$0: [function() {
      var t1 = new M.PixiEvent(null, null, null);
      t1.type = "loaded";
      t1.content = this;
      this.dispatchEvent$1(0, t1);
    }, "call$0", "get$onLoaded", 0, 0, 13, "onLoaded"],
    static: {SpriteSheetLoader$: [function(url, crossorigin) {
        var t1 = new M.SpriteSheetLoader(null, url, crossorigin, null, null, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.baseUrl = J.replaceFirst$2$s(url, $.get$Loader_baseReg(), "");
        return t1;
      }, null, null, 4, 0, 97, 88, [], 34, [], "new SpriteSheetLoader"]}
  },
  "+SpriteSheetLoader": [827],
  SpriteSheetLoader_load_closure: {
    "^": "Closure:677;scope_0",
    call$1: [function($event) {
      var t1, t2;
      t1 = this.scope_0;
      t1.json = J.get$content$x($event).get$json();
      t2 = new M.PixiEvent(null, null, null);
      t2.type = "loaded";
      t2.content = t1;
      t1.dispatchEvent$1(0, t2);
    }, "call$1", null, 2, 0, 677, 815, [], "call"],
    $isFunction: true
  },
  BlendModes: {
    "^": "Object;value>-599",
    static: {"^": "BlendModes_NORMAL<-32,BlendModes_ADD<-32,BlendModes_MULTIPLY<-32,BlendModes_SCREEN<-32,BlendModes_OVERLAY<-32,BlendModes_DARKEN<-32,BlendModes_LIGHTEN<-32,BlendModes_COLOR_DODGE<-32,BlendModes_COLOR_BURN<-32,BlendModes_HARD_LIGHT<-32,BlendModes_SOFT_LIGHT<-32,BlendModes_DIFFERENCE<-32,BlendModes_EXCLUSION<-32,BlendModes_HUE<-32,BlendModes_SATURATION<-32,BlendModes_COLOR<-32,BlendModes_LUMINOSITY<-32,BlendModes_NONE<-32", BlendModes$_: [function(value) {
        return new M.BlendModes(value);
      }, null, null, 2, 0, 60, 100, [], "new BlendModes$_"]}
  },
  "+BlendModes": [632],
  scaleModes: {
    "^": "Object;value>-599",
    static: {"^": "scaleModes_DEFAULT<-32,scaleModes_LINEAR<-32,scaleModes_NEAREST<-32", scaleModes$_: [function(value) {
        return new M.scaleModes(value);
      }, null, null, 2, 0, 60, 100, [], "new scaleModes$_"]}
  },
  "+scaleModes": [632],
  GraphicsData: {
    "^": "Object;points*-681,fillAlpha@-601,fillColor@-601,fill*-602,lineWidth*-601,lineAlpha@-601,lineColor@-601,type*-599",
    fill$0: function($receiver) {
      return this.fill.call$0();
    },
    fill$6: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5) {
      return this.fill.call$6(arg0, arg1, arg2, arg3, arg4, arg5);
    },
    fill$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.fill.call$4(arg0, arg1, arg2, arg3);
    },
    static: {GraphicsData$: [function() {
        return new M.GraphicsData([], 1, 0, null, 1, 1, 0, $.Graphics_POLY);
      }, null, null, 0, 0, 101, "new GraphicsData"]}
  },
  "+GraphicsData": [632],
  Graphics0: {
    "^": "DisplayObjectContainer;fillAlpha@-601,lineWidth*-601,lineColor@-601,fillColor@-601,filling@-602,lineAlpha@-601,_graphicsData<-829,tint@-599,blendMode@-674,_currentPath@-830,_webGL@-831,_isMask@-602,bounds@-641,boundsPadding@-599,clearDirty@-602,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    set$cacheAsBitmap: [function(value) {
      if (J.$eq(this._cacheAsBitmap, value))
        return;
      if (value === true)
        this._generateCachedSprite$0();
      else {
        this._cachedSprite.get$texture().destroy$1(true);
        this._cachedSprite = null;
      }
      this._cacheAsBitmap = value;
    }, null, null, 3, 0, 650, 100, [], "cacheAsBitmap"],
    lineStyle$3: [function(lineWidth, color, alpha) {
      var t1, t2;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0)) {
        t1 = this._graphicsData;
        t2 = J.getInterceptor$asx(t1);
        if (J.$gt$n(t2.get$length(t1), 0))
          t2.removeLast$0(t1);
      }
      this.lineWidth = lineWidth;
      this.lineColor = color;
      this.lineAlpha = alpha;
      t1 = $.Graphics_POLY;
      t2 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, t1);
      t2.lineWidth = lineWidth;
      t2.lineColor = color;
      t2.lineAlpha = alpha;
      t2.fillColor = this.fillColor;
      t2.fillAlpha = this.fillAlpha;
      t2.fill = this.filling;
      t2.points = [];
      t2.type = t1;
      this._currentPath = t2;
      J.add$1$ax(this._graphicsData, t2);
      return this;
    }, function() {
      return this.lineStyle$3(0, 0, 1);
    }, "lineStyle$0", function(lineWidth) {
      return this.lineStyle$3(lineWidth, 0, 1);
    }, "lineStyle$1", function(lineWidth, color) {
      return this.lineStyle$3(lineWidth, color, 1);
    }, "lineStyle$2", "call$3", "call$0", "call$1", "call$2", "get$lineStyle", 0, 6, 832, 5, 5, 390, 833, [], 114, [], 524, [], "lineStyle"],
    moveTo$2: [function(_, x, y) {
      var t1, t2;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0)) {
        t1 = this._graphicsData;
        t2 = J.getInterceptor$asx(t1);
        if (J.$gt$n(t2.get$length(t1), 0))
          t2.removeLast$0(t1);
      }
      t1 = $.Graphics_POLY;
      t2 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, t1);
      t2.lineWidth = this.lineWidth;
      t2.lineColor = this.lineColor;
      t2.lineAlpha = this.lineAlpha;
      t2.fillColor = this.fillColor;
      t2.fillAlpha = this.fillAlpha;
      t2.fill = this.filling;
      t2.points = [];
      t2.type = t1;
      this._currentPath = t2;
      J.addAll$1$ax(t2.points, [x, y]);
      J.add$1$ax(this._graphicsData, this._currentPath);
      return this;
    }, "call$2", "get$moveTo", 4, 0, 834, 6, [], 7, [], "moveTo"],
    lineTo$2: [function(_, x, y) {
      J.addAll$1$ax(J.get$points$x(this._currentPath), [x, y]);
      this._dirty = true;
      return this;
    }, "call$2", "get$lineTo", 4, 0, 834, 6, [], 7, [], "lineTo"],
    quadraticCurveTo$4: [function(_, cpX, cpY, toX, toY) {
      var points, t1, fromX, fromY, t2, t3, t4, t5, t6, t7, i, j, xa, ya;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0))
        this.moveTo$2(0, 0, 0);
      points = J.get$points$x(this._currentPath);
      t1 = J.getInterceptor$asx(points);
      if (J.$eq(t1.get$length(points), 0))
        this.moveTo$2(0, 0, 0);
      fromX = t1.$index(points, J.$sub$n(t1.get$length(points), 2));
      fromY = t1.$index(points, J.$sub$n(t1.get$length(points), 1));
      for (t2 = J.getInterceptor$n(cpX), t3 = J.getInterceptor$ns(fromX), t4 = J.getInterceptor$n(cpY), t5 = J.getInterceptor$ns(fromY), t6 = J.getInterceptor$n(toX), t7 = J.getInterceptor$n(toY), i = 1; i <= 20; ++i) {
        j = i / 20;
        xa = t3.$add(fromX, J.$mul$ns(t2.$sub(cpX, fromX), j));
        ya = t5.$add(fromY, J.$mul$ns(t4.$sub(cpY, fromY), j));
        t1.addAll$1(points, [J.$add$ns(xa, J.$mul$ns(J.$sub$n(t2.$add(cpX, J.$mul$ns(t6.$sub(toX, cpX), j)), xa), j)), J.$add$ns(ya, J.$mul$ns(J.$sub$n(t4.$add(cpY, J.$mul$ns(t7.$sub(toY, cpY), j)), ya), j))]);
      }
      this._dirty = true;
      return this;
    }, "call$4", "get$quadraticCurveTo", 8, 0, 835, 138, [], 139, [], 140, [], 141, [], "quadraticCurveTo"],
    bezierCurveTo$6: [function(_, cpX, cpY, cpX2, cpY2, toX, toY) {
      var points, t1, fromX, fromY, i, j, dt, dt2, dt3, t2, t3, t4;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0))
        this.moveTo$2(0, 0, 0);
      points = J.get$points$x(this._currentPath);
      t1 = J.getInterceptor$asx(points);
      fromX = t1.$index(points, J.$sub$n(t1.get$length(points), 2));
      fromY = t1.$index(points, J.$sub$n(t1.get$length(points), 1));
      for (i = 1; i < 20; ++i) {
        j = i / 20;
        dt = 1 - j;
        dt2 = dt * dt;
        dt3 = dt2 * dt;
        t2 = j * j;
        t3 = t2 * j;
        if (typeof fromX !== "number")
          return H.iae(fromX);
        t4 = 3 * dt2 * j;
        if (typeof cpX !== "number")
          return H.iae(cpX);
        t2 = 3 * dt * t2;
        if (typeof cpX2 !== "number")
          return H.iae(cpX2);
        if (typeof toX !== "number")
          return H.iae(toX);
        if (typeof fromY !== "number")
          return H.iae(fromY);
        if (typeof cpY !== "number")
          return H.iae(cpY);
        if (typeof cpY2 !== "number")
          return H.iae(cpY2);
        if (typeof toY !== "number")
          return H.iae(toY);
        t1.addAll$1(points, [dt3 * fromX + t4 * cpX + t2 * cpX2 + t3 * toX, dt3 * fromY + t4 * cpY + t2 * cpY2 + t3 * toY]);
      }
      this._dirty = true;
      return this;
    }, "call$6", "get$bezierCurveTo", 12, 0, 836, 138, [], 139, [], 837, [], 838, [], 140, [], 141, [], "bezierCurveTo"],
    arcTo$5: [function(_, x1, y1, x2, y2, radius) {
      var points, t1, fromX, a1, b1, a2, b2, t2, t3, mm, dd, t4, cc, tt, t5, k1, k2, j1, t6, j2, cx, cy, px, py, qx, qy, startAngle, endAngle;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0))
        this.moveTo$2(0, x1, y1);
      points = J.get$points$x(this._currentPath);
      t1 = J.getInterceptor$asx(points);
      fromX = t1.$index(points, J.$sub$n(t1.get$length(points), 2));
      a1 = J.$sub$n(t1.$index(points, J.$sub$n(t1.get$length(points), 1)), y1);
      b1 = J.$sub$n(fromX, x1);
      a2 = J.$sub$n(y2, y1);
      b2 = J.$sub$n(x2, x1);
      t2 = J.getInterceptor$ns(a1);
      t3 = J.getInterceptor$ns(b1);
      mm = J.abs$0$n(J.$sub$n(t2.$mul(a1, b2), t3.$mul(b1, a2)));
      if (J.$lt$n(mm, 1e-8) || J.$eq(radius, 0))
        t1.addAll$1(points, [x1, y1]);
      else {
        dd = J.$add$ns(t2.$mul(a1, a1), t3.$mul(b1, b1));
        t1 = J.getInterceptor$ns(a2);
        t4 = J.getInterceptor$ns(b2);
        cc = J.$add$ns(t1.$mul(a2, a2), t4.$mul(b2, b2));
        tt = J.$add$ns(t2.$mul(a1, a2), t3.$mul(b1, b2));
        if (typeof dd !== "number")
          H.throwExpression(P.ArgumentError$(dd));
        t5 = J.getInterceptor$ns(radius);
        k1 = J.$div$n(t5.$mul(radius, Math.sqrt(dd)), mm);
        if (typeof cc !== "number")
          H.throwExpression(P.ArgumentError$(cc));
        k2 = J.$div$n(t5.$mul(radius, Math.sqrt(cc)), mm);
        t5 = J.getInterceptor$ns(k1);
        j1 = J.$div$n(t5.$mul(k1, tt), dd);
        t6 = J.getInterceptor$ns(k2);
        j2 = J.$div$n(t6.$mul(k2, tt), cc);
        cx = J.$add$ns(t5.$mul(k1, b2), t6.$mul(k2, b1));
        cy = J.$add$ns(t5.$mul(k1, a2), t6.$mul(k2, a1));
        px = t3.$mul(b1, t6.$add(k2, j1));
        py = t2.$mul(a1, t6.$add(k2, j1));
        qx = t4.$mul(b2, t5.$add(k1, j2));
        qy = t1.$mul(a2, t5.$add(k1, j2));
        t5 = J.$sub$n(py, cy);
        t1 = J.$sub$n(px, cx);
        if (typeof t5 !== "number")
          H.throwExpression(P.ArgumentError$(t5));
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        startAngle = Math.atan2(t5, t1);
        t1 = J.$sub$n(qy, cy);
        t2 = J.$sub$n(qx, cx);
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        if (typeof t2 !== "number")
          H.throwExpression(P.ArgumentError$(t2));
        endAngle = Math.atan2(t1, t2);
        this.arc$6(0, J.$add$ns(cx, x1), J.$add$ns(cy, y1), radius, startAngle, endAngle, J.$gt$n(t3.$mul(b1, a2), t4.$mul(b2, a1)));
      }
      this._dirty = true;
      return this;
    }, "call$5", "get$arcTo", 10, 0, 839, 307, [], 308, [], 309, [], 310, [], 8, [], "arcTo"],
    arc$6: [function(_, cx, cy, radius, startAngle, endAngle, anticlockwise) {
      var t1, t2, startX, startY, points, sweep, segs, theta, theta2, cTheta, sTheta, segMinus, remainder, t3, i, angle, t4, c, s;
      t1 = typeof startAngle !== "number";
      if (t1)
        H.throwExpression(P.ArgumentError$(startAngle));
      t2 = Math.cos(startAngle);
      if (typeof radius !== "number")
        return H.iae(radius);
      startX = J.$add$ns(cx, t2 * radius);
      if (t1)
        H.throwExpression(P.ArgumentError$(startAngle));
      startY = J.$add$ns(cy, Math.sin(startAngle) * radius);
      points = J.get$points$x(this._currentPath);
      t1 = J.getInterceptor$asx(points);
      if (!J.$eq(t1.get$length(points), 0) && !J.$eq(t1.$index(points, J.$sub$n(t1.get$length(points), 2)), startX) || !J.$eq(t1.$index(points, J.$sub$n(t1.get$length(points), 1)), startY)) {
        this.moveTo$2(0, startX, startY);
        points = J.get$points$x(this._currentPath);
      }
      t1 = J.getInterceptor(startAngle);
      if (t1.$eq(startAngle, endAngle))
        return this;
      t2 = anticlockwise === true;
      if (!t2 && J.$le$n(endAngle, startAngle))
        endAngle = J.$add$ns(endAngle, 6.283185307179586);
      else if (t2 && t1.$le(startAngle, endAngle))
        startAngle = t1.$add(startAngle, 6.283185307179586);
      sweep = t2 ? J.$mul$ns(J.$sub$n(startAngle, endAngle), -1) : J.$sub$n(endAngle, startAngle);
      t1 = J.getInterceptor$n(sweep);
      segs = J.$div$n(t1.abs$0(sweep), 6.283185307179586) * 40;
      if (t1.$eq(sweep, 0))
        return this;
      theta = t1.$div(sweep, segs * 2);
      t1 = J.getInterceptor$ns(theta);
      theta2 = t1.$mul(theta, 2);
      t2 = typeof theta !== "number";
      if (t2)
        H.throwExpression(P.ArgumentError$(theta));
      cTheta = Math.cos(theta);
      if (t2)
        H.throwExpression(P.ArgumentError$(theta));
      sTheta = Math.sin(theta);
      segMinus = segs - 1;
      remainder = C.JSNumber_methods.$mod(segMinus, 1) / segMinus;
      for (t2 = J.getInterceptor$ax(points), t3 = J.getInterceptor$ns(theta2), i = 0; i <= segMinus; ++i) {
        angle = J.$add$ns(t1.$add(theta, startAngle), t3.$mul(theta2, i + remainder * i));
        t4 = typeof angle !== "number";
        if (t4)
          H.throwExpression(P.ArgumentError$(angle));
        c = Math.cos(angle);
        if (t4)
          H.throwExpression(P.ArgumentError$(angle));
        s = -Math.sin(angle);
        if (typeof cx !== "number")
          return H.iae(cx);
        if (typeof cy !== "number")
          return H.iae(cy);
        t2.addAll$1(points, [(cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy]);
      }
      this._dirty = true;
      return this;
    }, function($receiver, cx, cy, radius, startAngle, endAngle) {
      return this.arc$6($receiver, cx, cy, radius, startAngle, endAngle, false);
    }, "arc$5", "call$6", "call$5", "get$arc", 10, 2, 840, 95, 200, [], 201, [], 8, [], 841, [], 842, [], 843, [], "arc"],
    drawPath$1: [function(path) {
      var t1, t2;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0)) {
        t1 = this._graphicsData;
        t2 = J.getInterceptor$asx(t1);
        if (J.$gt$n(t2.get$length(t1), 0))
          t2.removeLast$0(t1);
      }
      t1 = $.Graphics_POLY;
      t2 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, t1);
      t2.lineWidth = this.lineWidth;
      t2.lineColor = this.lineColor;
      t2.lineAlpha = this.lineAlpha;
      t2.fillColor = this.fillColor;
      t2.fillAlpha = this.fillAlpha;
      t2.fill = this.filling;
      t2.points = [];
      t2.type = t1;
      this._currentPath = t2;
      J.add$1$ax(this._graphicsData, t2);
      J.addAll$1$ax(J.get$points$x(this._currentPath), path);
      this._dirty = true;
      return this;
    }, "call$1", "get$drawPath", 2, 0, 844, 845, [], "drawPath"],
    beginFill$2: [function(color, alpha) {
      this.filling = true;
      this.fillColor = color;
      this.fillAlpha = alpha;
      return this;
    }, function() {
      return this.beginFill$2(null, 1);
    }, "beginFill$0", function(color) {
      return this.beginFill$2(color, 1);
    }, "beginFill$1", "call$2", "call$0", "call$1", "get$beginFill", 0, 4, 846, 32, 390, 114, [], 524, [], "beginFill"],
    endFill$0: [function() {
      this.filling = false;
      this.fillColor = null;
      this.fillAlpha = 1;
      return this;
    }, "call$0", "get$endFill", 0, 0, 648, "endFill"],
    drawRect$4: [function(x, y, width, height) {
      var t1, t2;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0)) {
        t1 = this._graphicsData;
        t2 = J.getInterceptor$asx(t1);
        if (J.$gt$n(t2.get$length(t1), 0))
          t2.removeLast$0(t1);
      }
      t1 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, $.Graphics_POLY);
      t1.lineWidth = this.lineWidth;
      t1.lineColor = this.lineColor;
      t1.lineAlpha = this.lineAlpha;
      t1.fillColor = this.fillColor;
      t1.fillAlpha = this.fillAlpha;
      t1.fill = this.filling;
      t1.points = [x, y, width, height];
      t1.type = $.Graphics_RECT;
      this._currentPath = t1;
      J.add$1$ax(this._graphicsData, t1);
      this._dirty = true;
      return this;
    }, "call$4", "get$drawRect", 8, 0, 835, 6, [], 7, [], 10, [], 11, [], "drawRect"],
    drawRoundedRect$5: [function(x, y, width, height, radius) {
      var t1, t2;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0)) {
        t1 = this._graphicsData;
        t2 = J.getInterceptor$asx(t1);
        if (J.$gt$n(t2.get$length(t1), 0))
          t2.removeLast$0(t1);
      }
      t1 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, $.Graphics_POLY);
      t1.lineWidth = this.lineWidth;
      t1.lineColor = this.lineColor;
      t1.lineAlpha = this.lineAlpha;
      t1.fillColor = this.fillColor;
      t1.fillAlpha = this.fillAlpha;
      t1.fill = this.filling;
      t1.points = [x, y, width, height, radius];
      t1.type = $.Graphics_RREC;
      this._currentPath = t1;
      J.add$1$ax(this._graphicsData, t1);
      this._dirty = true;
      return this;
    }, "call$5", "get$drawRoundedRect", 10, 0, 839, 6, [], 7, [], 10, [], 11, [], 8, [], "drawRoundedRect"],
    drawCircle$3: [function(x, y, radius) {
      var t1, t2;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0)) {
        t1 = this._graphicsData;
        t2 = J.getInterceptor$asx(t1);
        if (J.$gt$n(t2.get$length(t1), 0))
          t2.removeLast$0(t1);
      }
      t1 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, $.Graphics_POLY);
      t1.lineWidth = this.lineWidth;
      t1.lineColor = this.lineColor;
      t1.lineAlpha = this.lineAlpha;
      t1.fillColor = this.fillColor;
      t1.fillAlpha = this.fillAlpha;
      t1.fill = this.filling;
      t1.points = [x, y, radius, radius];
      t1.type = $.Graphics_CIRC;
      this._currentPath = t1;
      J.add$1$ax(this._graphicsData, t1);
      this._dirty = true;
      return this;
    }, "call$3", "get$drawCircle", 6, 0, 847, 6, [], 7, [], 8, [], "drawCircle"],
    drawEllipse$4: [function(x, y, width, height) {
      var t1, t2;
      if (J.$eq(J.get$length$asx(J.get$points$x(this._currentPath)), 0)) {
        t1 = this._graphicsData;
        t2 = J.getInterceptor$asx(t1);
        if (J.$gt$n(t2.get$length(t1), 0))
          t2.removeLast$0(t1);
      }
      t1 = new M.GraphicsData([], 1, 0, null, 1, 1, 0, $.Graphics_POLY);
      t1.lineWidth = this.lineWidth;
      t1.lineColor = this.lineColor;
      t1.lineAlpha = this.lineAlpha;
      t1.fillColor = this.fillColor;
      t1.fillAlpha = this.fillAlpha;
      t1.fill = this.filling;
      t1.points = [x, y, width, height];
      t1.type = $.Graphics_ELIP;
      this._currentPath = t1;
      J.add$1$ax(this._graphicsData, t1);
      this._dirty = true;
      return this;
    }, "call$4", "get$drawEllipse", 8, 0, 848, 6, [], 7, [], 10, [], 11, [], "drawEllipse"],
    clear$0: [function(_) {
      this.lineWidth = 0;
      this.filling = false;
      this._dirty = true;
      this.clearDirty = true;
      J.clear$0$ax(this._graphicsData);
      this.bounds = null;
      return this;
    }, "call$0", "get$clear", 0, 0, 648, "clear"],
    generateTexture$1: [function(renderer) {
      var bounds, t1, canvasBuffer, texture;
      bounds = this.getBounds$0();
      t1 = J.getInterceptor$x(bounds);
      canvasBuffer = M.CanvasBuffer$(t1.get$width(bounds), t1.get$height(bounds));
      texture = M.Texture$(M.BaseTexture_fromCanvas(canvasBuffer.canvas, null), null);
      J.translate$2$x(canvasBuffer.context, J.$negate$n(t1.get$x(bounds)), J.$negate$n(t1.get$y(bounds)));
      M.CanvasGraphics_renderGraphics(this, canvasBuffer.context);
      return texture;
    }, function() {
      return this.generateTexture$1(null);
    }, "generateTexture$0", "call$1", "call$0", "get$generateTexture", 0, 2, 849, 32, 175, [], "generateTexture"],
    _renderWebGL$1: [function(renderSession) {
      var blendModeWebGL, t1, j, i;
      if (J.$eq(this.visible, false) || J.$eq(this.alpha, 0) || J.$eq(this._isMask, true))
        return;
      if (this._cacheAsBitmap === true) {
        if (this._dirty === true) {
          this._generateCachedSprite$0();
          M.updateWebGLTexture(this._cachedSprite.get$texture().get$baseTexture(), renderSession.get$gl());
          this._dirty = false;
        }
        J.set$alpha$x(this._cachedSprite, this.alpha);
        this._cachedSprite._renderWebGL$1(renderSession);
        return;
      } else {
        J.stop$0$x(renderSession.get$spriteBatch());
        renderSession.get$blendModeManager().setBlendMode$1(this.blendMode);
        if (this._mask != null)
          renderSession.get$maskManager().pushMask$2(this._mask, renderSession);
        if (this._filters != null)
          renderSession.get$filterManager().pushFilter$1(this._filterBlock);
        if (!J.$eq(this.blendMode, renderSession.get$blendModeManager().get$currentBlendMode())) {
          renderSession.get$blendModeManager().set$currentBlendMode(this.blendMode);
          blendModeWebGL = J.$index$asx($.blendModesWebGL, renderSession.get$blendModeManager().get$currentBlendMode());
          t1 = J.getInterceptor$asx(blendModeWebGL);
          J.blendFunc$2$x(renderSession.get$spriteBatch().get$gl(), t1.$index(blendModeWebGL, 0), t1.$index(blendModeWebGL, 1));
        }
        M.WebGLGraphics_renderGraphics(this, renderSession);
        if (!J.$eq(J.get$length$asx(this.get$children(this)), 0)) {
          J.start$0$x(renderSession.get$spriteBatch());
          j = J.get$length$asx(this.get$children(this));
          if (typeof j !== "number")
            return H.iae(j);
          i = 0;
          for (; i < j; ++i)
            J.$index$asx(this.get$children(this), i)._renderWebGL$1(renderSession);
          J.stop$0$x(renderSession.get$spriteBatch());
        }
        if (this._filters != null)
          renderSession.get$filterManager().popFilter$0();
        if (this._mask != null)
          renderSession.get$maskManager().popMask$2(this._mask, renderSession);
        renderSession.set$drawCount(J.$add$ns(renderSession.get$drawCount(), 1));
        J.start$0$x(renderSession.get$spriteBatch());
      }
    }, "call$1", "get$_renderWebGL", 2, 0, 656, 128, [], "_renderWebGL"],
    _renderCanvas$1: [function(renderSession) {
      var t1, context, transform, j, i;
      if (J.$eq(this.visible, false) || J.$eq(this.alpha, 0) || J.$eq(this._isMask, true))
        return;
      t1 = J.getInterceptor$x(renderSession);
      context = t1.get$context(renderSession);
      transform = this._worldTransform;
      if (!J.$eq(this.blendMode, renderSession.get$currentBlendMode())) {
        renderSession.set$currentBlendMode(this.blendMode);
        J.set$globalCompositeOperation$x(context, J.$index$asx($.blendModesCanvas, renderSession.get$currentBlendMode()));
      }
      if (this._mask != null)
        renderSession.get$maskManager().pushMask$2(this._mask, t1.get$context(renderSession));
      J.setTransform$6$x(context, J.get$a$x(transform), transform.get$c(), transform.get$b(), transform.get$d(), transform.get$tx(), transform.get$ty());
      M.CanvasGraphics_renderGraphics(this, context);
      j = J.get$length$asx(this.get$children(this));
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        J.$index$asx(this.get$children(this), i)._renderCanvas$1(renderSession);
      if (this._mask != null)
        renderSession.get$maskManager().popMask$1(t1.get$context(renderSession));
    }, "call$1", "get$_renderCanvas", 2, 0, 656, 128, [], "_renderCanvas"],
    getBounds$1: [function(matrix) {
      var w0, w1, h0, h1, a, b, c, d, tx, ty, t1, t2, x1, t3, t4, y1, x2, y2, x3, y3, x4, y4, minX, minY, t5, t6, maxX, maxY, bounds;
      if (matrix == null)
        matrix = this._worldTransform;
      if (this.bounds == null)
        this._updateBounds$0();
      w0 = J.get$x$x(this.bounds);
      w1 = J.$add$ns(J.get$width$x(this.bounds), J.get$x$x(this.bounds));
      h0 = J.get$y$x(this.bounds);
      h1 = J.$add$ns(J.get$height$x(this.bounds), J.get$y$x(this.bounds));
      a = J.get$a$x(matrix);
      b = matrix.get$c();
      c = matrix.get$b();
      d = matrix.get$d();
      tx = matrix.get$tx();
      ty = matrix.get$ty();
      t1 = J.getInterceptor$ns(a);
      t2 = J.getInterceptor$ns(c);
      x1 = J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h1)), tx);
      t3 = J.getInterceptor$ns(d);
      t4 = J.getInterceptor$ns(b);
      y1 = J.$add$ns(J.$add$ns(t3.$mul(d, h1), t4.$mul(b, w1)), ty);
      x2 = J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h1)), tx);
      y2 = J.$add$ns(J.$add$ns(t3.$mul(d, h1), t4.$mul(b, w0)), ty);
      x3 = J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h0)), tx);
      y3 = J.$add$ns(J.$add$ns(t3.$mul(d, h0), t4.$mul(b, w0)), ty);
      x4 = J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h0)), tx);
      y4 = J.$add$ns(J.$add$ns(t3.$mul(d, h0), t4.$mul(b, w1)), ty);
      t1 = J.getInterceptor$n(x2);
      minX = t1.$lt(x2, x1) ? x2 : x1;
      t2 = J.getInterceptor$n(x3);
      if (t2.$lt(x3, minX))
        minX = x3;
      t3 = J.getInterceptor$n(x4);
      if (t3.$lt(x4, minX))
        minX = x4;
      t4 = J.getInterceptor$n(y2);
      minY = t4.$lt(y2, y1) ? y2 : y1;
      t5 = J.getInterceptor$n(y3);
      if (t5.$lt(y3, minY))
        minY = y3;
      t6 = J.getInterceptor$n(y4);
      if (t6.$lt(y4, minY))
        minY = y4;
      maxX = t1.$gt(x2, x1) ? x2 : x1;
      if (t2.$gt(x3, maxX))
        maxX = x3;
      if (t3.$gt(x4, maxX))
        maxX = x4;
      maxY = t4.$gt(y2, y1) ? y2 : y1;
      if (t5.$gt(y3, maxY))
        maxY = y3;
      if (t6.$gt(y4, maxY))
        maxY = y4;
      bounds = this._bounds;
      t1 = J.getInterceptor$x(bounds);
      t1.set$x(bounds, minX);
      t1.set$width(bounds, J.$sub$n(maxX, minX));
      t1.set$y(bounds, minY);
      t1.set$height(bounds, J.$sub$n(maxY, minY));
      return bounds;
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 653, 32, 537, [], "getBounds"],
    _updateBounds$0: [function() {
      var t1, t2, minX, maxX, minY, maxY, x, y, w, h, i, t3, data, type, lineWidth, points, t4, j, padding;
      t1 = this._graphicsData;
      t2 = J.getInterceptor$asx(t1);
      minX = 1 / 0;
      maxX = -1 / 0;
      minY = 1 / 0;
      maxY = -1 / 0;
      x = null;
      y = null;
      w = null;
      h = null;
      i = 0;
      while (true) {
        t3 = t2.get$length(t1);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        data = t2.$index(t1, i);
        t3 = J.getInterceptor$x(data);
        type = t3.get$type(data);
        lineWidth = t3.get$lineWidth(data);
        points = t3.get$points(data);
        t3 = J.getInterceptor(type);
        if (t3.$eq(type, $.Graphics_RECT) || t3.$eq(type, $.Graphics_RREC)) {
          t3 = J.getInterceptor$asx(points);
          t4 = J.getInterceptor$n(lineWidth);
          x = J.$sub$n(t3.$index(points, 0), t4.$div(lineWidth, 2));
          y = J.$sub$n(t3.$index(points, 1), t4.$div(lineWidth, 2));
          w = J.$add$ns(t3.$index(points, 2), lineWidth);
          h = J.$add$ns(t3.$index(points, 3), lineWidth);
          t3 = J.getInterceptor$n(x);
          if (t3.$lt(x, minX))
            minX = x;
          if (J.$gt$n(t3.$add(x, w), maxX))
            maxX = t3.$add(x, w);
          t3 = J.getInterceptor$n(y);
          if (t3.$lt(y, minY))
            minY = x;
          if (J.$gt$n(t3.$add(y, h), maxY))
            maxY = t3.$add(y, h);
        } else if (t3.$eq(type, $.Graphics_CIRC) || t3.$eq(type, $.Graphics_ELIP)) {
          t3 = J.getInterceptor$asx(points);
          x = t3.$index(points, 0);
          y = t3.$index(points, 1);
          t4 = J.getInterceptor$n(lineWidth);
          w = J.$add$ns(t3.$index(points, 2), t4.$div(lineWidth, 2));
          h = J.$add$ns(t3.$index(points, 3), t4.$div(lineWidth, 2));
          t3 = J.getInterceptor$n(x);
          if (J.$lt$n(t3.$sub(x, w), minX))
            minX = t3.$sub(x, w);
          if (J.$gt$n(t3.$add(x, w), maxX))
            maxX = t3.$add(x, w);
          t3 = J.getInterceptor$n(y);
          if (J.$lt$n(t3.$sub(y, h), minY))
            minY = t3.$sub(y, h);
          if (J.$gt$n(t3.$add(y, h), maxY))
            maxY = t3.$add(y, h);
        } else {
          t3 = J.getInterceptor$asx(points);
          j = 0;
          while (true) {
            t4 = t3.get$length(points);
            if (typeof t4 !== "number")
              return H.iae(t4);
            if (!(j < t4))
              break;
            x = t3.$index(points, j);
            y = t3.$index(points, j + 1);
            t4 = J.getInterceptor$n(x);
            if (J.$lt$n(t4.$sub(x, lineWidth), minX))
              minX = t4.$sub(x, lineWidth);
            if (J.$gt$n(t4.$add(x, lineWidth), maxX))
              maxX = t4.$add(x, lineWidth);
            t4 = J.getInterceptor$n(y);
            if (J.$lt$n(t4.$sub(y, lineWidth), minY))
              minY = t4.$sub(y, lineWidth);
            if (J.$gt$n(t4.$add(y, lineWidth), maxY))
              maxY = t4.$add(y, lineWidth);
            j += 2;
          }
        }
        ++i;
      }
      padding = this.boundsPadding;
      t1 = J.getInterceptor$ns(padding);
      this.bounds = new M.Rectangle0(J.$sub$n(minX, padding), J.$sub$n(minY, padding), J.$add$ns(J.$sub$n(maxX, minX), t1.$mul(padding, 2)), J.$add$ns(J.$sub$n(maxY, minY), t1.$mul(padding, 2)));
    }, "call$0", "get$_updateBounds", 0, 0, 13, "_updateBounds"],
    _generateCachedSprite$0: [function() {
      var bounds, t1, t2, canvasBuffer, texture, t3, t4, t5;
      bounds = this.getLocalBounds$0();
      t1 = this._cachedSprite;
      t2 = J.getInterceptor$x(bounds);
      if (t1 == null) {
        canvasBuffer = M.CanvasBuffer$(t2.get$width(bounds), t2.get$height(bounds));
        texture = M.Texture$(M.BaseTexture_fromCanvas(canvasBuffer.canvas, null), null);
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new M.Sprite(t1, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t5, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.texture = texture;
        t1._setupTexture$0();
        this._cachedSprite = t1;
        t1.buffer = canvasBuffer;
        this._cachedSprite.set$_worldTransform(this._worldTransform);
      } else
        J.resize$2$x(J.get$buffer$x(t1), t2.get$width(bounds), t2.get$height(bounds));
      t1 = J.getInterceptor$x(bounds);
      J.set$x$x(this._cachedSprite.get$anchor(), J.$negate$n(J.$div$n(t1.get$x(bounds), t1.get$width(bounds))));
      J.set$y$x(this._cachedSprite.get$anchor(), J.$negate$n(J.$div$n(t1.get$y(bounds), t1.get$height(bounds))));
      J.translate$2$x(J.get$context$x(J.get$buffer$x(this._cachedSprite)), J.$negate$n(t1.get$x(bounds)), J.$negate$n(t1.get$y(bounds)));
      M.CanvasGraphics_renderGraphics(this, J.get$context$x(J.get$buffer$x(this._cachedSprite)));
      J.set$alpha$x(this._cachedSprite, this.alpha);
    }, "call$0", "get$_generateCachedSprite", 0, 0, 13, "_generateCachedSprite"],
    _destroyCachedSprite$0: [function() {
      this._cachedSprite.get$texture().destroy$1(true);
      this._cachedSprite = null;
    }, "call$0", "get$_destroyCachedSprite", 0, 0, 13, "_destroyCachedSprite"],
    Graphics$0: function() {
      this.renderable = true;
      this.blendMode = C.BlendModes_0;
      this._dirty = true;
    },
    static: {"^": "Graphics_POLY@-599,Graphics_RECT@-599,Graphics_CIRC@-599,Graphics_ELIP@-599,Graphics_RREC@-599", Graphics$0: [function() {
        var t1, t2, t3, t4, t5, t6;
        t1 = $.Graphics_POLY;
        t2 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new M.Graphics0(1, 1, 0, 0, false, 1, [], 16777215, null, new M.GraphicsData([], 1, 0, null, 1, 1, 0, t1), t2, false, null, 0, false, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.Graphics$0();
        return t1;
      }, null, null, 0, 0, 13, "new Graphics"]}
  },
  "+Graphics": [678],
  CanvasGraphics: {
    "^": "Object;",
    static: {CanvasGraphics$: [function() {
        return new M.CanvasGraphics();
      }, null, null, 0, 0, 13, "new CanvasGraphics"], CanvasGraphics_renderGraphics: [function(graphics, context) {
        var worldAlpha, t1, i, t2, data, points, t3, j, t4, ellipseData, w, h, x, t5, y, ox, oy, xe, t6, ye, xm, ym, rx, ry, width, height, radius, maxRadius;
        worldAlpha = graphics.get$_worldAlpha();
        t1 = J.getInterceptor$x(context);
        i = 0;
        while (true) {
          t2 = J.get$length$asx(graphics.get$_graphicsData());
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          data = J.$index$asx(graphics.get$_graphicsData(), i);
          t2 = J.getInterceptor$x(data);
          points = t2.get$points(data);
          t3 = J.floor$0$n(data.get$lineColor());
          t3.toString;
          t1.set$strokeStyle(context, "#" + C.JSString_methods.padLeft$2(t3.toString(16), 6, "0"));
          t1.set$lineWidth(context, t2.get$lineWidth(data));
          if (J.$eq(t2.get$type(data), $.Graphics_POLY)) {
            t1.beginPath$0(context);
            t3 = J.getInterceptor$asx(points);
            t1.moveTo$2(context, t3.$index(points, 0), t3.$index(points, 1));
            j = 1;
            while (true) {
              t4 = J.$div$n(t3.get$length(points), 2);
              if (typeof t4 !== "number")
                return H.iae(t4);
              if (!(j < t4))
                break;
              t4 = j * 2;
              t1.lineTo$2(context, t3.$index(points, t4), t3.$index(points, t4 + 1));
              ++j;
            }
            if (J.$eq(t3.$index(points, 0), t3.$index(points, J.$sub$n(t3.get$length(points), 2))) && J.$eq(t3.$index(points, 1), t3.$index(points, J.$sub$n(t3.get$length(points), 1))))
              t1.closePath$0(context);
            if (t2.get$fill(data) === true) {
              t1.set$globalAlpha(context, J.$mul$ns(data.get$fillAlpha(), worldAlpha));
              t3 = J.floor$0$n(data.get$fillColor());
              t3.toString;
              t1.set$fillStyle(context, "#" + C.JSString_methods.padLeft$2(t3.toString(16), 6, "0"));
              t1.fill$0(context);
            }
            if (!J.$eq(t2.get$lineWidth(data), 0)) {
              t1.set$globalAlpha(context, J.$mul$ns(data.get$lineAlpha(), worldAlpha));
              t1.stroke$0(context);
            }
          } else if (J.$eq(t2.get$type(data), $.Graphics_RECT)) {
            if (t2.get$fill(data) === true) {
              t1.set$globalAlpha(context, J.$mul$ns(data.get$fillAlpha(), worldAlpha));
              t3 = J.floor$0$n(data.get$fillColor());
              t3.toString;
              t1.set$fillStyle(context, "#" + C.JSString_methods.padLeft$2(t3.toString(16), 6, "0"));
              t3 = J.getInterceptor$asx(points);
              t1.fillRect$4(context, t3.$index(points, 0), t3.$index(points, 1), t3.$index(points, 2), t3.$index(points, 3));
            }
            if (!J.$eq(t2.get$lineWidth(data), 0)) {
              t1.set$globalAlpha(context, J.$mul$ns(data.get$lineAlpha(), worldAlpha));
              t2 = J.getInterceptor$asx(points);
              t1.strokeRect$4(context, t2.$index(points, 0), t2.$index(points, 1), t2.$index(points, 2), t2.$index(points, 3));
            }
          } else if (J.$eq(t2.get$type(data), $.Graphics_CIRC)) {
            t1.beginPath$0(context);
            t3 = J.getInterceptor$asx(points);
            t1.arc$5(context, t3.$index(points, 0), t3.$index(points, 1), t3.$index(points, 2), 0, 6.283185307179586);
            t1.closePath$0(context);
            if (t2.get$fill(data) === true) {
              t1.set$globalAlpha(context, J.$mul$ns(data.get$fillAlpha(), worldAlpha));
              t3 = J.floor$0$n(data.get$fillColor());
              t3.toString;
              t1.set$fillStyle(context, "#" + C.JSString_methods.padLeft$2(t3.toString(16), 6, "0"));
              t1.fill$0(context);
            }
            if (!J.$eq(t2.get$lineWidth(data), 0)) {
              t1.set$globalAlpha(context, J.$mul$ns(data.get$lineAlpha(), worldAlpha));
              t1.stroke$0(context);
            }
          } else if (J.$eq(t2.get$type(data), $.Graphics_ELIP)) {
            ellipseData = t2.get$points(data);
            t3 = J.getInterceptor$asx(ellipseData);
            w = J.$mul$ns(t3.$index(ellipseData, 2), 2);
            h = J.$mul$ns(t3.$index(ellipseData, 3), 2);
            t4 = J.getInterceptor$n(w);
            x = J.$sub$n(t3.$index(ellipseData, 0), t4.$div(w, 2));
            t5 = J.getInterceptor$n(h);
            y = J.$sub$n(t3.$index(ellipseData, 1), t5.$div(h, 2));
            t1.beginPath$0(context);
            ox = J.$mul$ns(t4.$div(w, 2), 0.5522848);
            oy = J.$mul$ns(t5.$div(h, 2), 0.5522848);
            t3 = J.getInterceptor$ns(x);
            xe = t3.$add(x, w);
            t6 = J.getInterceptor$ns(y);
            ye = t6.$add(y, h);
            xm = t3.$add(x, t4.$div(w, 2));
            ym = t6.$add(y, t5.$div(h, 2));
            t1.moveTo$2(context, x, ym);
            t5 = J.getInterceptor$n(ym);
            t6 = J.getInterceptor$n(xm);
            t1.bezierCurveTo$6(context, x, t5.$sub(ym, oy), t6.$sub(xm, ox), y, xm, y);
            t1.bezierCurveTo$6(context, t6.$add(xm, ox), y, xe, t5.$sub(ym, oy), xe, ym);
            t1.bezierCurveTo$6(context, xe, t5.$add(ym, oy), t6.$add(xm, ox), ye, xm, ye);
            t1.bezierCurveTo$6(context, t6.$sub(xm, ox), ye, x, t5.$add(ym, oy), x, ym);
            t1.closePath$0(context);
            if (t2.get$fill(data) === true) {
              t1.set$globalAlpha(context, J.$mul$ns(data.get$fillAlpha(), worldAlpha));
              t3 = J.floor$0$n(data.get$fillColor());
              t3.toString;
              t1.set$fillStyle(context, "#" + C.JSString_methods.padLeft$2(t3.toString(16), 6, "0"));
              t1.fill$0(context);
            }
            if (!J.$eq(t2.get$lineWidth(data), 0)) {
              t1.set$globalAlpha(context, J.$mul$ns(data.get$lineAlpha(), worldAlpha));
              t1.stroke$0(context);
            }
          } else if (J.$eq(t2.get$type(data), $.Graphics_RREC)) {
            t3 = J.getInterceptor$asx(points);
            rx = t3.$index(points, 0);
            ry = t3.$index(points, 1);
            width = t3.$index(points, 2);
            height = t3.$index(points, 3);
            radius = t3.$index(points, 4);
            maxRadius = C.JSNumber_methods.toInt$0(Math.floor(P.min(width, height) / 2));
            if (J.$gt$n(radius, maxRadius))
              radius = maxRadius;
            t1.beginPath$0(context);
            t3 = J.getInterceptor$ns(ry);
            t1.moveTo$2(context, rx, t3.$add(ry, radius));
            t1.lineTo$2(context, rx, J.$sub$n(t3.$add(ry, height), radius));
            t4 = J.getInterceptor$ns(rx);
            t1.quadraticCurveTo$4(context, rx, t3.$add(ry, height), t4.$add(rx, radius), t3.$add(ry, height));
            t1.lineTo$2(context, J.$sub$n(t4.$add(rx, width), radius), t3.$add(ry, height));
            t1.quadraticCurveTo$4(context, t4.$add(rx, width), t3.$add(ry, height), t4.$add(rx, width), J.$sub$n(t3.$add(ry, height), radius));
            t1.lineTo$2(context, t4.$add(rx, width), t3.$add(ry, radius));
            t1.quadraticCurveTo$4(context, t4.$add(rx, width), ry, J.$sub$n(t4.$add(rx, width), radius), ry);
            t1.lineTo$2(context, t4.$add(rx, radius), ry);
            t1.quadraticCurveTo$4(context, rx, ry, rx, t3.$add(ry, radius));
            t1.closePath$0(context);
            if (t2.get$fill(data) === true) {
              t1.set$globalAlpha(context, J.$mul$ns(data.get$fillAlpha(), worldAlpha));
              t3 = J.floor$0$n(data.get$fillColor());
              t3.toString;
              t1.set$fillStyle(context, "#" + C.JSString_methods.padLeft$2(t3.toString(16), 6, "0"));
              t1.fill$0(context);
            }
            if (!J.$eq(t2.get$lineWidth(data), 0)) {
              t1.set$globalAlpha(context, J.$mul$ns(data.get$lineAlpha(), worldAlpha));
              t1.stroke$0(context);
            }
          }
          ++i;
        }
      }, "call$2", "CanvasGraphics_renderGraphics$closure", 4, 0, 102, 103, [], 104, [], "renderGraphics"], CanvasGraphics_renderGraphicsMask: [function(graphics, context) {
        var len, t1, i, data, t2, points, j, t3, ellipseData, w, h, x, t4, y, ox, oy, xe, t5, ye, xm, ym, rx, ry, width, height, radius, maxRadius;
        len = J.get$length$asx(graphics.get$_graphicsData());
        t1 = J.getInterceptor(len);
        if (t1.$eq(len, 0))
          return;
        if (t1.$gt(len, 1)) {
          window;
          if (typeof console != "undefined")
            console.log("Pixi.js warning: masks in canvas can only mask using the first path in the graphics object");
        }
        for (t1 = J.getInterceptor$x(context), i = 0; i < 1; ++i) {
          data = J.$index$asx(graphics.get$_graphicsData(), i);
          t2 = J.getInterceptor$x(data);
          points = t2.get$points(data);
          if (J.$eq(t2.get$type(data), $.Graphics_POLY)) {
            t1.beginPath$0(context);
            t2 = J.getInterceptor$asx(points);
            t1.moveTo$2(context, t2.$index(points, 0), t2.$index(points, 1));
            j = 1;
            while (true) {
              t3 = J.$div$n(t2.get$length(points), 2);
              if (typeof t3 !== "number")
                return H.iae(t3);
              if (!(j < t3))
                break;
              t3 = j * 2;
              t1.lineTo$2(context, t2.$index(points, t3), t2.$index(points, t3 + 1));
              ++j;
            }
            if (J.$eq(t2.$index(points, 0), t2.$index(points, J.$sub$n(t2.get$length(points), 2))) && J.$eq(t2.$index(points, 1), t2.$index(points, J.$sub$n(t2.get$length(points), 1))))
              t1.closePath$0(context);
          } else if (J.$eq(t2.get$type(data), $.Graphics_RECT)) {
            t1.beginPath$0(context);
            t2 = J.getInterceptor$asx(points);
            t1.rect$4(context, t2.$index(points, 0), t2.$index(points, 1), t2.$index(points, 2), t2.$index(points, 3));
            t1.closePath$0(context);
          } else if (J.$eq(t2.get$type(data), $.Graphics_CIRC)) {
            t1.beginPath$0(context);
            t2 = J.getInterceptor$asx(points);
            t1.arc$5(context, t2.$index(points, 0), t2.$index(points, 1), t2.$index(points, 2), 0, 6.283185307179586);
            t1.closePath$0(context);
          } else if (J.$eq(t2.get$type(data), $.Graphics_ELIP)) {
            ellipseData = t2.get$points(data);
            t2 = J.getInterceptor$asx(ellipseData);
            w = J.$mul$ns(t2.$index(ellipseData, 2), 2);
            h = J.$mul$ns(t2.$index(ellipseData, 3), 2);
            t3 = J.getInterceptor$n(w);
            x = J.$sub$n(t2.$index(ellipseData, 0), t3.$div(w, 2));
            t4 = J.getInterceptor$n(h);
            y = J.$sub$n(t2.$index(ellipseData, 1), t4.$div(h, 2));
            t1.beginPath$0(context);
            ox = J.$mul$ns(t3.$div(w, 2), 0.5522848);
            oy = J.$mul$ns(t4.$div(h, 2), 0.5522848);
            t2 = J.getInterceptor$ns(x);
            xe = t2.$add(x, w);
            t5 = J.getInterceptor$ns(y);
            ye = t5.$add(y, h);
            xm = t2.$add(x, t3.$div(w, 2));
            ym = t5.$add(y, t4.$div(h, 2));
            t1.moveTo$2(context, x, ym);
            t4 = J.getInterceptor$n(ym);
            t5 = J.getInterceptor$n(xm);
            t1.bezierCurveTo$6(context, x, t4.$sub(ym, oy), t5.$sub(xm, ox), y, xm, y);
            t1.bezierCurveTo$6(context, t5.$add(xm, ox), y, xe, t4.$sub(ym, oy), xe, ym);
            t1.bezierCurveTo$6(context, xe, t4.$add(ym, oy), t5.$add(xm, ox), ye, xm, ye);
            t1.bezierCurveTo$6(context, t5.$sub(xm, ox), ye, x, t4.$add(ym, oy), x, ym);
            t1.closePath$0(context);
          } else if (J.$eq(t2.get$type(data), $.Graphics_RREC)) {
            t2 = J.getInterceptor$asx(points);
            rx = t2.$index(points, 0);
            ry = t2.$index(points, 1);
            width = t2.$index(points, 2);
            height = t2.$index(points, 3);
            radius = t2.$index(points, 4);
            maxRadius = C.JSNumber_methods.toInt$0(Math.floor(P.min(width, height) / 2));
            if (J.$gt$n(radius, maxRadius))
              radius = maxRadius;
            t1.beginPath$0(context);
            t2 = J.getInterceptor$ns(ry);
            t1.moveTo$2(context, rx, t2.$add(ry, radius));
            t1.lineTo$2(context, rx, J.$sub$n(t2.$add(ry, height), radius));
            t3 = J.getInterceptor$ns(rx);
            t1.quadraticCurveTo$4(context, rx, t2.$add(ry, height), t3.$add(rx, radius), t2.$add(ry, height));
            t1.lineTo$2(context, J.$sub$n(t3.$add(rx, width), radius), t2.$add(ry, height));
            t1.quadraticCurveTo$4(context, t3.$add(rx, width), t2.$add(ry, height), t3.$add(rx, width), J.$sub$n(t2.$add(ry, height), radius));
            t1.lineTo$2(context, t3.$add(rx, width), t2.$add(ry, radius));
            t1.quadraticCurveTo$4(context, t3.$add(rx, width), ry, J.$sub$n(t3.$add(rx, width), radius), ry);
            t1.lineTo$2(context, t3.$add(rx, radius), ry);
            t1.quadraticCurveTo$4(context, rx, ry, rx, t2.$add(ry, radius));
            t1.closePath$0(context);
          }
        }
      }, "call$2", "CanvasGraphics_renderGraphicsMask$closure", 4, 0, 102, 103, [], 104, [], "renderGraphicsMask"]}
  },
  "+CanvasGraphics": [632],
  CanvasRenderer: {
    "^": "Renderer;clearBeforeRender@-602,roundPixels@-602,context*-850,refresh@-602,count@-599,type-599,transparent-602,antialias-602,preserveDrawingBuffer-602,width-601,height-601,view-808,projection-634,offset-634,contextLost-602,options-754,gl-851,shaderManager-852,spriteBatch-853,maskManager-854,filterManager-855,stencilManager-856,blendModeManager-857,renderSession-858,__stage-638",
    refresh$0: function() {
      return this.refresh.call$0();
    },
    render$1: [function(stage) {
      var t1;
      J.set$length$asx($.get$texturesToUpdate(), 0);
      J.set$length$asx($.get$texturesToDestroy(), 0);
      stage.updateTransform$0();
      J.setTransform$6$x(this.context, 1, 0, 0, 1, 0, 0);
      J.set$globalAlpha$x(this.context, 1);
      t1 = this.transparent === true;
      if (!t1 && this.clearBeforeRender === true) {
        J.set$fillStyle$x(this.context, stage.get$backgroundColorString());
        J.fillRect$4$x(this.context, 0, 0, this.width, this.height);
      } else if (t1 && this.clearBeforeRender === true)
        J.clearRect$4$x(this.context, 0, 0, this.width, this.height);
      this.renderDisplayObject$1(stage);
      if (stage.get$interactive() === true)
        if (stage.get$_interactiveEventsAdded() !== true) {
          stage.set$_interactiveEventsAdded(true);
          stage.get$interactionManager().setTarget$1(this);
        }
      if (J.$gt$n(J.get$length$asx($.get$Texture_frameUpdates()), 0))
        J.set$length$asx($.get$Texture_frameUpdates(), 0);
    }, "call$1", "get$render", 2, 0, 92, 93, [], "render"],
    resize$2: [function(_, width, height) {
      this.width = width;
      this.height = height;
      J.set$width$x(this.view, width);
      J.set$height$x(this.view, height);
    }, "call$2", "get$resize", 4, 0, 111, 10, [], 11, [], "resize"],
    renderDisplayObject$3: [function(displayObject, context, buffer) {
      var t1 = this.renderSession;
      J.set$context$x(t1, context == null ? this.context : context);
      displayObject._renderCanvas$1(this.renderSession);
    }, function(displayObject) {
      return this.renderDisplayObject$3(displayObject, null, null);
    }, "renderDisplayObject$1", function(displayObject, context) {
      return this.renderDisplayObject$3(displayObject, context, null);
    }, "renderDisplayObject$2", "call$3", "call$1", "call$2", "get$renderDisplayObject", 2, 4, 859, 32, 32, 805, [], 104, [], 860, [], "renderDisplayObject"],
    renderStripFlat$1: [function(strip) {
      var context, verticies, t1, $length, t2, t3, i, t4, index, x0, x1, x2, y0, y1, y2;
      context = this.context;
      verticies = strip.get$verticies();
      t1 = J.getInterceptor$asx(verticies);
      $length = J.$div$n(t1.get$length(verticies), 2);
      this.count = J.$add$ns(this.count, 1);
      t2 = J.getInterceptor$x(context);
      t2.beginPath$0(context);
      t3 = J.getInterceptor$n($length);
      i = 1;
      while (true) {
        t4 = t3.$sub($length, 2);
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (!(i < t4))
          break;
        index = i * 2;
        x0 = t1.$index(verticies, index);
        x1 = t1.$index(verticies, index + 2);
        x2 = t1.$index(verticies, index + 4);
        y0 = t1.$index(verticies, index + 1);
        y1 = t1.$index(verticies, index + 3);
        y2 = t1.$index(verticies, index + 5);
        t2.moveTo$2(context, x0, y0);
        t2.lineTo$2(context, x1, y1);
        t2.lineTo$2(context, x2, y2);
        ++i;
      }
      t2.set$fillStyle(context, "#FF0000");
      t2.fill$0(context);
      t2.closePath$0(context);
    }, "call$1", "get$renderStripFlat", 2, 0, 63, 861, [], "renderStripFlat"],
    renderStrip$1: [function(strip) {
      var context, verticies, uvs, t1, $length, t2, t3, t4, i, t5, index, x0, x1, t6, x2, t7, y0, t8, y1, t9, y2, u0, u1, u2, v0, v1, v2, delta, t10, deltaA, deltaB, deltaC, deltaD, deltaE, deltaF;
      context = this.context;
      verticies = strip.get$verticies();
      uvs = strip.get$uvs();
      t1 = J.getInterceptor$asx(verticies);
      $length = J.$div$n(t1.get$length(verticies), 2);
      this.count = J.$add$ns(this.count, 1);
      t2 = J.getInterceptor$n($length);
      t3 = J.getInterceptor$asx(uvs);
      t4 = J.getInterceptor$x(context);
      i = 1;
      while (true) {
        t5 = t2.$sub($length, 2);
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (!(i < t5))
          break;
        index = i * 2;
        x0 = t1.$index(verticies, index);
        t5 = index + 2;
        x1 = t1.$index(verticies, t5);
        t6 = index + 4;
        x2 = t1.$index(verticies, t6);
        t7 = index + 1;
        y0 = t1.$index(verticies, t7);
        t8 = index + 3;
        y1 = t1.$index(verticies, t8);
        t9 = index + 5;
        y2 = t1.$index(verticies, t9);
        u0 = J.$mul$ns(t3.$index(uvs, index), J.get$width$x(strip.get$texture()));
        u1 = J.$mul$ns(t3.$index(uvs, t5), J.get$width$x(strip.get$texture()));
        u2 = J.$mul$ns(t3.$index(uvs, t6), J.get$width$x(strip.get$texture()));
        v0 = J.$mul$ns(t3.$index(uvs, t7), J.get$height$x(strip.get$texture()));
        v1 = J.$mul$ns(t3.$index(uvs, t8), J.get$height$x(strip.get$texture()));
        v2 = J.$mul$ns(t3.$index(uvs, t9), J.get$height$x(strip.get$texture()));
        t4.save$0(context);
        t4.beginPath$0(context);
        t4.moveTo$2(context, x0, y0);
        t4.lineTo$2(context, x1, y1);
        t4.lineTo$2(context, x2, y2);
        t4.closePath$0(context);
        t4.clip$0(context);
        t9 = J.getInterceptor$ns(u0);
        t8 = J.getInterceptor$ns(v0);
        t7 = J.getInterceptor$ns(u1);
        t6 = J.getInterceptor$ns(v1);
        delta = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t9.$mul(u0, v1), t8.$mul(v0, u2)), t7.$mul(u1, v2)), t6.$mul(v1, u2)), t8.$mul(v0, u1)), t9.$mul(u0, v2));
        t5 = J.getInterceptor$ns(x0);
        t10 = J.getInterceptor$ns(x1);
        deltaA = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t5.$mul(x0, v1), t8.$mul(v0, x2)), t10.$mul(x1, v2)), t6.$mul(v1, x2)), t8.$mul(v0, x1)), t5.$mul(x0, v2));
        deltaB = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t9.$mul(u0, x1), t5.$mul(x0, u2)), t7.$mul(u1, x2)), t10.$mul(x1, u2)), t5.$mul(x0, u1)), t9.$mul(u0, x2));
        deltaC = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(J.$mul$ns(t9.$mul(u0, v1), x2), J.$mul$ns(t8.$mul(v0, x1), u2)), J.$mul$ns(t5.$mul(x0, u1), v2)), J.$mul$ns(t5.$mul(x0, v1), u2)), J.$mul$ns(t8.$mul(v0, u1), x2)), J.$mul$ns(t9.$mul(u0, x1), v2));
        t5 = J.getInterceptor$ns(y0);
        t10 = J.getInterceptor$ns(y1);
        deltaD = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t5.$mul(y0, v1), t8.$mul(v0, y2)), t10.$mul(y1, v2)), t6.$mul(v1, y2)), t8.$mul(v0, y1)), t5.$mul(y0, v2));
        deltaE = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(t9.$mul(u0, y1), t5.$mul(y0, u2)), t7.$mul(u1, y2)), t10.$mul(y1, u2)), t5.$mul(y0, u1)), t9.$mul(u0, y2));
        deltaF = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(J.$mul$ns(t9.$mul(u0, v1), y2), J.$mul$ns(t8.$mul(v0, y1), u2)), J.$mul$ns(t5.$mul(y0, u1), v2)), J.$mul$ns(t5.$mul(y0, v1), u2)), J.$mul$ns(t8.$mul(v0, u1), y2)), J.$mul$ns(t9.$mul(u0, y1), v2));
        t4.transform$6(context, J.$div$n(deltaA, delta), J.$div$n(deltaD, delta), J.$div$n(deltaB, delta), J.$div$n(deltaE, delta), J.$div$n(deltaC, delta), J.$div$n(deltaF, delta));
        t4.drawImage$3(context, J.get$source$x(strip.get$texture().get$baseTexture()), 0, 0);
        t4.restore$0(context);
        ++i;
      }
    }, "call$1", "get$renderStrip", 2, 0, 63, 861, [], "renderStrip"],
    CanvasRenderer$5: function(width, height, view, transparent, antialias) {
      var t1, t2, t3;
      $.defaultRenderer = this;
      this.type = 1;
      this.width = J.toInt$0$n(width);
      this.height = J.toInt$0$n(height);
      this.transparent = transparent;
      this.antialias = antialias;
      if (view == null)
        view = W.CanvasElement_CanvasElement(null, null);
      this.view = view;
      J.set$width$x(view, J.toInt$0$n(this.width));
      J.set$height$x(this.view, J.toInt$0$n(this.height));
      if ($.blendModesCanvas == null) {
        $.blendModesCanvas = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = M.canUseNewCanvasBlendModes();
        t2 = $.blendModesCanvas;
        if (t1) {
          J.$indexSet$ax(t2, C.BlendModes_0, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_1, "lighter");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_2, "multiply");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_3, "screen");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_4, "overlay");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_5, "darken");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_6, "lighten");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_7, "color-dodge");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_8, "color-burn");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_9, "hard-light");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_10, "soft-light");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_11, "difference");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_12, "exclusion");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_13, "hue");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_14, "saturation");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_15, "color");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_16, "luminosity");
        } else {
          J.$indexSet$ax(t2, C.BlendModes_0, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_1, "lighter");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_2, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_3, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_4, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_5, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_6, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_7, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_8, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_9, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_10, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_11, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_12, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_13, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_14, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_15, "source-over");
          J.$indexSet$ax($.blendModesCanvas, C.BlendModes_16, "source-over");
        }
      }
      t1 = J.getContext$2$x(this.view, "2d", P.LinkedHashMap_LinkedHashMap$_literal(["alpha", this.transparent], null, null));
      this.context = t1;
      t2 = new M.CanvasMaskManager();
      this.maskManager = t2;
      t3 = new M.RenderSession(null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null);
      t3.context = t1;
      t3.maskManager = t2;
      t3.scaleMode = null;
      t3.smoothProperty = null;
      this.renderSession = t3;
    },
    static: {CanvasRenderer$: [function(width, height, view, transparent, antialias) {
        var t1 = new M.CanvasRenderer(true, false, null, true, 0, 0, false, false, false, 100, 100, null, null, null, false, null, null, null, null, null, null, null, null, null, null);
        t1.CanvasRenderer$5(width, height, view, transparent, antialias);
        return t1;
      }, null, null, 0, 10, 105, 106, 107, 32, 95, 95, 10, [], 11, [], 108, [], 109, [], 110, [], "new CanvasRenderer"]}
  },
  "+CanvasRenderer": [809],
  CanvasBuffer: {
    "^": "Object;width*-601,height*-601,canvas*-808,context*-850",
    clear$0: [function(_) {
      J.clearRect$4$x(this.context, 0, 0, this.width, this.height);
    }, "call$0", "get$clear", 0, 0, 13, "clear"],
    resize$2: [function(_, width, height) {
      J.set$width$x(this.canvas, width);
      this.width = width;
      J.set$height$x(this.canvas, height);
      this.height = height;
    }, "call$2", "get$resize", 4, 0, 111, 10, [], 11, [], "resize"],
    CanvasBuffer$2: function(width, height) {
      var t1 = document.createElement("canvas", null);
      this.canvas = t1;
      J.set$width$x(t1, J.toInt$0$n(this.width));
      J.set$height$x(this.canvas, J.toInt$0$n(this.height));
      this.context = J.getContext$1$x(this.canvas, "2d");
    },
    static: {CanvasBuffer$: [function(width, height) {
        var t1 = new M.CanvasBuffer(width, height, null, null);
        t1.CanvasBuffer$2(width, height);
        return t1;
      }, null, null, 4, 0, 111, 10, [], 11, [], "new CanvasBuffer"]}
  },
  "+CanvasBuffer": [632],
  CanvasMaskManager: {
    "^": "MaskManager;",
    pushMask$2: [function(maskData, context) {
      var t1, cacheAlpha, transform;
      t1 = J.getInterceptor$x(context);
      t1.save$0(context);
      cacheAlpha = J.get$alpha$x(maskData);
      transform = maskData.get$_worldTransform();
      t1.setTransform$6(context, J.get$a$x(transform), transform.get$c(), transform.get$b(), transform.get$d(), transform.get$tx(), transform.get$ty());
      M.CanvasGraphics_renderGraphicsMask(maskData, context);
      t1.clip$0(context);
      maskData.set$_worldAlpha(cacheAlpha);
    }, function(maskData) {
      return this.pushMask$2(maskData, null);
    }, "pushMask$1", "call$2", "call$1", "get$pushMask", 2, 2, 862, 32, 863, [], 104, [], "pushMask"],
    popMask$2: [function(context, renderSession) {
      J.restore$0$x(context);
    }, function(context) {
      return this.popMask$2(context, null);
    }, "popMask$1", "call$2", "call$1", "get$popMask", 2, 2, 864, 32, 104, [], 128, [], "popMask"],
    destroy$0: [function() {
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    setContext$1: [function(a) {
    }, "call$1", "get$setContext", 2, 0, 121, 304, [], "setContext"],
    static: {CanvasMaskManager$: [function() {
        return new M.CanvasMaskManager();
      }, null, null, 0, 0, 13, "new CanvasMaskManager"]}
  },
  "+CanvasMaskManager": [854],
  CanvasTinter: {
    "^": "Object;",
    static: {"^": "CanvasTinter_cacheStepsPerColorChannel@-599,CanvasTinter_convertTintToImage@-602,CanvasTinter_canUseMultiply@-602,CanvasTinter_tintMethod@-32,CanvasTinter_canvas@-808", CanvasTinter$: [function() {
        return new M.CanvasTinter();
      }, null, null, 0, 0, 13, "new CanvasTinter"], CanvasTinter_getTintedTexture: [function(sprite, color) {
        var texture, step, rgbValues, t1, t2, stringColor, canvas, tintImage;
        texture = sprite.get$texture();
        step = $.CanvasTinter_cacheStepsPerColorChannel;
        rgbValues = M.hex2rgb(color);
        if (0 >= rgbValues.length)
          return H.ioore(rgbValues, 0);
        t1 = P.min(255, J.$mul$ns(J.$div$n(rgbValues[0], step), step));
        t2 = rgbValues.length;
        if (0 >= t2)
          return H.ioore(rgbValues, 0);
        rgbValues[0] = t1;
        if (1 >= t2)
          return H.ioore(rgbValues, 1);
        t2 = P.min(255, J.$mul$ns(J.$div$n(rgbValues[1], step), step));
        t1 = rgbValues.length;
        if (1 >= t1)
          return H.ioore(rgbValues, 1);
        rgbValues[1] = t2;
        if (2 >= t1)
          return H.ioore(rgbValues, 2);
        t1 = P.min(255, J.$mul$ns(J.$div$n(rgbValues[2], step), step));
        if (2 >= rgbValues.length)
          return H.ioore(rgbValues, 2);
        rgbValues[2] = t1;
        color = C.JSNumber_methods.toInt$0(Math.floor(M.rgb2hex(rgbValues)));
        stringColor = "#" + C.JSString_methods.padLeft$2(C.JSInt_methods.toRadixString$1(color, 16), 6, "0");
        if (texture.get$tintCache() == null)
          texture.set$tintCache(P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        if (J.$index$asx(texture.get$tintCache(), stringColor) != null)
          return J.$index$asx(texture.get$tintCache(), stringColor);
        canvas = $.CanvasTinter_canvas;
        canvas = canvas != null ? canvas : W.CanvasElement_CanvasElement(null, null);
        $.get$CanvasTinter_tintMethod().call$3(texture, color, canvas);
        if ($.CanvasTinter_convertTintToImage === true) {
          tintImage = W.ImageElement_ImageElement(null, null, null);
          J.set$src$x(tintImage, J.toDataUrl$0$x(canvas));
          J.$indexSet$ax(texture.get$tintCache(), stringColor, tintImage);
        } else {
          J.$indexSet$ax(texture.get$tintCache(), stringColor, canvas);
          $.CanvasTinter_canvas = null;
        }
        return canvas;
      }, "call$2", "CanvasTinter_getTintedTexture$closure", 4, 0, 112, 113, [], 114, [], "getTintedTexture"], CanvasTinter_tintWithMultiply: [function(texture, color, canvas) {
        var t1, context, frame, t2;
        t1 = J.getInterceptor$x(canvas);
        context = t1.getContext$1(canvas, "2d");
        frame = texture.get$frame();
        t2 = J.getInterceptor$x(frame);
        t1.set$width(canvas, t2.get$width(frame));
        t1.set$height(canvas, t2.get$height(frame));
        t1 = J.getInterceptor$x(context);
        t1.set$fillStyle(context, "#" + C.JSString_methods.padLeft$2(J.toRadixString$1$n(color, 16), 6, "0"));
        t1.fillRect$4(context, 0, 0, t2.get$width(frame), t2.get$height(frame));
        t1.set$globalCompositeOperation(context, "multiply");
        t1.drawImageScaledFromSource$9(context, J.get$source$x(texture.get$baseTexture()), t2.get$x(frame), t2.get$y(frame), t2.get$width(frame), t2.get$height(frame), 0, 0, t2.get$width(frame), t2.get$height(frame));
        t1.set$globalCompositeOperation(context, "destination-atop");
        t1.drawImageScaledFromSource$9(context, J.get$source$x(texture.get$baseTexture()), t2.get$x(frame), t2.get$y(frame), t2.get$width(frame), t2.get$height(frame), 0, 0, t2.get$width(frame), t2.get$height(frame));
      }, "call$3", "CanvasTinter_tintWithMultiply$closure", 6, 0, 115, 28, [], 114, [], 116, [], "tintWithMultiply"], CanvasTinter_tintWithOverlay: [function(texture, color, canvas) {
        var t1, context, frame, t2;
        t1 = J.getInterceptor$x(canvas);
        context = t1.getContext$1(canvas, "2d");
        frame = texture.get$frame();
        t2 = J.getInterceptor$x(frame);
        t1.set$width(canvas, t2.get$width(frame));
        t1.set$height(canvas, t2.get$height(frame));
        t1 = J.getInterceptor$x(context);
        t1.set$globalCompositeOperation(context, "copy");
        t1.set$fillStyle(context, "#" + C.JSString_methods.padLeft$2(J.toRadixString$1$n(color, 16), 6, "0"));
        t1.fillRect$4(context, 0, 0, t2.get$width(frame), t2.get$height(frame));
        t1.set$globalCompositeOperation(context, "destination-atop");
        t1.drawImageScaledFromSource$9(context, J.get$source$x(texture.get$baseTexture()), t2.get$x(frame), t2.get$y(frame), t2.get$width(frame), t2.get$height(frame), 0, 0, t2.get$width(frame), t2.get$height(frame));
      }, "call$3", "CanvasTinter_tintWithOverlay$closure", 6, 0, 115, 28, [], 114, [], 116, [], "tintWithOverlay"], CanvasTinter_tintWithPerPixel: [function(texture, color, canvas) {
        var t1, context, frame, t2, rgbValues, t3, r, g, b, pixelData, pixels, i, t4;
        t1 = J.getInterceptor$x(canvas);
        context = t1.getContext$1(canvas, "2d");
        frame = texture.get$frame();
        t2 = J.getInterceptor$x(frame);
        t1.set$width(canvas, t2.get$width(frame));
        t1.set$height(canvas, t2.get$height(frame));
        t1 = J.getInterceptor$x(context);
        t1.set$globalCompositeOperation(context, "copy");
        t1.drawImage$9(context, J.get$source$x(texture.get$baseTexture()), t2.get$x(frame), t2.get$y(frame), t2.get$width(frame), t2.get$height(frame), 0, 0, t2.get$width(frame), t2.get$height(frame));
        rgbValues = M.hex2rgb(color);
        t3 = rgbValues.length;
        if (0 >= t3)
          return H.ioore(rgbValues, 0);
        r = rgbValues[0];
        if (1 >= t3)
          return H.ioore(rgbValues, 1);
        g = rgbValues[1];
        if (2 >= t3)
          return H.ioore(rgbValues, 2);
        b = rgbValues[2];
        pixelData = t1.getImageData$4(context, 0, 0, t2.get$width(frame), t2.get$height(frame));
        pixels = J.get$data$x(pixelData);
        for (t2 = pixels.length, i = 0; i < t2; i += 4) {
          t3 = pixels[i];
          if (typeof r !== "number")
            return H.iae(r);
          pixels[i] = t3 * r;
          t3 = i + 1;
          if (t3 >= t2)
            return H.ioore(pixels, t3);
          t4 = pixels[t3];
          if (typeof g !== "number")
            return H.iae(g);
          pixels[t3] = t4 * g;
          t4 = i + 2;
          if (t4 >= t2)
            return H.ioore(pixels, t4);
          t3 = pixels[t4];
          if (typeof b !== "number")
            return H.iae(b);
          pixels[t4] = t3 * b;
        }
        t1.putImageData$3(context, pixelData, 0, 0);
      }, "call$3", "CanvasTinter_tintWithPerPixel$closure", 6, 0, 117, 28, [], 114, [], 116, [], "tintWithPerPixel"], CanvasTinter_roundColor: [function(color) {
        var step, rgbValues, t1, t2;
        step = $.CanvasTinter_cacheStepsPerColorChannel;
        rgbValues = M.hex2rgb(color);
        if (0 >= rgbValues.length)
          return H.ioore(rgbValues, 0);
        t1 = P.min(255, J.$mul$ns(J.$div$n(rgbValues[0], step), step));
        t2 = rgbValues.length;
        if (0 >= t2)
          return H.ioore(rgbValues, 0);
        rgbValues[0] = t1;
        if (1 >= t2)
          return H.ioore(rgbValues, 1);
        t2 = P.min(255, J.$mul$ns(J.$div$n(rgbValues[1], step), step));
        t1 = rgbValues.length;
        if (1 >= t1)
          return H.ioore(rgbValues, 1);
        rgbValues[1] = t2;
        if (2 >= t1)
          return H.ioore(rgbValues, 2);
        t1 = P.min(255, J.$mul$ns(J.$div$n(rgbValues[2], step), step));
        if (2 >= rgbValues.length)
          return H.ioore(rgbValues, 2);
        rgbValues[2] = t1;
        return C.JSNumber_methods.toInt$0(Math.floor(M.rgb2hex(rgbValues)));
      }, "call$1", "CanvasTinter_roundColor$closure", 2, 0, 118, 114, [], "roundColor"]}
  },
  "+CanvasTinter": [632],
  MaskManager: {
    "^": "Object;",
    static: {MaskManager$: [function() {
        return new M.MaskManager();
      }, null, null, 0, 0, 119, "new MaskManager"]}
  },
  "+MaskManager": [632],
  RenderSession: {
    "^": "Object;gl@-851,projection@-634,offset*-634,drawCount@-599,shaderManager@-852,maskManager@-854,filterManager@-855,spriteBatch@-853,blendModeManager@-857,stencilManager@-856,renderer@-809,currentBlendMode@-674,scaleMode@-865,smoothProperty@-639,context*-850,roundPixels@-32",
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    spriteBatch$3: function(arg0, arg1, arg2) {
      return this.spriteBatch.call$3(arg0, arg1, arg2);
    },
    static: {RenderSession$: [function() {
        return new M.RenderSession(null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null);
      }, null, null, 0, 0, 120, "new RenderSession"]}
  },
  "+RenderSession": [632],
  Renderer: {
    "^": "Object;type*-599,transparent@-602,antialias@-602,preserveDrawingBuffer@-602,width*-601,height*-601,view*-808,projection@-634,offset*-634,contextLost@-602,options*-754,gl@-851,shaderManager@-852,spriteBatch@-853,maskManager@-854,filterManager@-855,stencilManager@-856,blendModeManager@-857,renderSession@-858,__stage@-638",
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    spriteBatch$3: function(arg0, arg1, arg2) {
      return this.spriteBatch.call$3(arg0, arg1, arg2);
    },
    static: {Renderer$: [function() {
        return new M.Renderer(0, false, false, false, 100, 100, null, null, null, false, null, null, null, null, null, null, null, null, null, null);
      }, null, null, 0, 0, 13, "new Renderer"]}
  },
  "+Renderer": [632],
  ComplexPrimitiveShader: {
    "^": "Shader;gl@-851,program@-866,fragmentSrc@-820,vertexSrc@-820,attributes:PIXI$ComplexPrimitiveShader$attributes*-720,uniforms@-32,uSampler-867,projectionVector-867,offsetVector-867,dimensions-867,uMatrix-867,tintColor-867,color-867,translationMatrix-867,alpha-867,aVertexPosition-599,aPositionCoord-599,aScale-599,aRotation-599,aTextureCoord-599,colorAttribute-599,attributes-720,_UID-599",
    init$0: [function() {
      var program, t1;
      program = M.compileProgram(this.gl, this.vertexSrc, this.fragmentSrc);
      J.useProgram$1$x(this.gl, program);
      this.projectionVector = J.getUniformLocation$2$x(this.gl, program, "projectionVector");
      this.offsetVector = J.getUniformLocation$2$x(this.gl, program, "offsetVector");
      this.tintColor = J.getUniformLocation$2$x(this.gl, program, "tint");
      this.color = J.getUniformLocation$2$x(this.gl, program, "color");
      t1 = J.getAttribLocation$2$x(this.gl, program, "aVertexPosition");
      this.aVertexPosition = t1;
      this.PIXI$ComplexPrimitiveShader$attributes = [t1, this.colorAttribute];
      this.translationMatrix = J.getUniformLocation$2$x(this.gl, program, "translationMatrix");
      this.alpha = J.getUniformLocation$2$x(this.gl, program, "alpha");
      this.program = program;
    }, "call$0", "get$init", 0, 0, 13, "init"],
    destroy$0: [function() {
      J.deleteProgram$1$x(this.gl, this.program);
      this.uniforms = null;
      this.gl = null;
      this.PIXI$ComplexPrimitiveShader$attributes = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    ComplexPrimitiveShader$1: function(gl) {
      var t1 = $._UID;
      $._UID = J.$add$ns(t1, 1);
      $._UID = t1;
      this.program = null;
      this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"];
      this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"];
      this.init$0();
    },
    static: {ComplexPrimitiveShader$: [function(gl) {
        var t1 = new M.ComplexPrimitiveShader(gl, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.ComplexPrimitiveShader$1(gl);
        return t1;
      }, null, null, 2, 0, 121, 122, [], "new ComplexPrimitiveShader"]}
  },
  "+ComplexPrimitiveShader": [868],
  PixiFastShader: {
    "^": "Shader;gl@-851,program@-866,fragmentSrc@-820,vertexSrc@-820,textureCount@-599,uSampler:PIXI$PixiFastShader$uSampler@-867,projectionVector:PIXI$PixiFastShader$projectionVector@-867,offsetVector:PIXI$PixiFastShader$offsetVector@-867,dimensions:PIXI$PixiFastShader$dimensions@-867,uMatrix:PIXI$PixiFastShader$uMatrix@-867,aVertexPosition:PIXI$PixiFastShader$aVertexPosition@-599,aPositionCoord:PIXI$PixiFastShader$aPositionCoord@-599,aScale:PIXI$PixiFastShader$aScale@-599,aRotation:PIXI$PixiFastShader$aRotation@-599,aTextureCoord:PIXI$PixiFastShader$aTextureCoord@-599,colorAttribute:PIXI$PixiFastShader$colorAttribute@-599,attributes:PIXI$PixiFastShader$attributes*-720,uniforms@-32,uSampler-867,projectionVector-867,offsetVector-867,dimensions-867,uMatrix-867,tintColor-867,color-867,translationMatrix-867,alpha-867,aVertexPosition-599,aPositionCoord-599,aScale-599,aRotation-599,aTextureCoord-599,colorAttribute-599,attributes-720,_UID-599",
    init$0: [function() {
      var program, t1;
      program = M.compileProgram(this.gl, this.vertexSrc, this.fragmentSrc);
      J.useProgram$1$x(this.gl, program);
      this.PIXI$PixiFastShader$uSampler = J.getUniformLocation$2$x(this.gl, program, "uSampler");
      this.PIXI$PixiFastShader$projectionVector = J.getUniformLocation$2$x(this.gl, program, "projectionVector");
      this.PIXI$PixiFastShader$offsetVector = J.getUniformLocation$2$x(this.gl, program, "offsetVector");
      this.PIXI$PixiFastShader$dimensions = J.getUniformLocation$2$x(this.gl, program, "dimensions");
      this.PIXI$PixiFastShader$uMatrix = J.getUniformLocation$2$x(this.gl, program, "uMatrix");
      this.PIXI$PixiFastShader$aVertexPosition = J.getAttribLocation$2$x(this.gl, program, "aVertexPosition");
      this.PIXI$PixiFastShader$aPositionCoord = J.getAttribLocation$2$x(this.gl, program, "aPositionCoord");
      this.PIXI$PixiFastShader$aScale = J.getAttribLocation$2$x(this.gl, program, "aScale");
      this.PIXI$PixiFastShader$aRotation = J.getAttribLocation$2$x(this.gl, program, "aRotation");
      this.PIXI$PixiFastShader$aTextureCoord = J.getAttribLocation$2$x(this.gl, program, "aTextureCoord");
      t1 = J.getAttribLocation$2$x(this.gl, program, "aColor");
      this.PIXI$PixiFastShader$colorAttribute = t1;
      if (t1 === -1)
        this.PIXI$PixiFastShader$colorAttribute = 2;
      this.PIXI$PixiFastShader$attributes = [this.PIXI$PixiFastShader$aVertexPosition, this.PIXI$PixiFastShader$aPositionCoord, this.PIXI$PixiFastShader$aScale, this.PIXI$PixiFastShader$aRotation, this.PIXI$PixiFastShader$aTextureCoord, this.PIXI$PixiFastShader$colorAttribute];
      this.program = program;
    }, "call$0", "get$init", 0, 0, 13, "init"],
    destroy$0: [function() {
      J.deleteProgram$1$x(this.gl, this.program);
      this.uniforms = null;
      this.gl = null;
      this.PIXI$PixiFastShader$attributes = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    static: {PixiFastShader$: [function(gl) {
        var t1, t2;
        t1 = new M.PixiFastShader(gl, null, ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t2 = $._UID;
        $._UID = J.$add$ns(t2, 1);
        t1._UID = t2;
        t1.init$0();
        return t1;
      }, null, null, 2, 0, 121, 122, [], "new PixiFastShader"]}
  },
  "+PixiFastShader": [868],
  PixiShader: {
    "^": "Shader;gl@-851,program@-866,fragmentSrc@-820,vertexSrc@-820,textureCount@-599,uSampler:PIXI$PixiShader$uSampler@-867,projectionVector:PIXI$PixiShader$projectionVector@-867,offsetVector:PIXI$PixiShader$offsetVector@-867,dimensions:PIXI$PixiShader$dimensions@-867,uMatrix:PIXI$PixiShader$uMatrix@-867,aVertexPosition:PIXI$PixiShader$aVertexPosition@-599,aPositionCoord:PIXI$PixiShader$aPositionCoord@-599,aScale:PIXI$PixiShader$aScale@-599,aRotation:PIXI$PixiShader$aRotation@-599,aTextureCoord:PIXI$PixiShader$aTextureCoord@-599,colorAttribute:PIXI$PixiShader$colorAttribute@-599,attributes:PIXI$PixiShader$attributes*-720,uniforms@-754,uSampler-867,projectionVector-867,offsetVector-867,dimensions-867,uMatrix-867,tintColor-867,color-867,translationMatrix-867,alpha-867,aVertexPosition-599,aPositionCoord-599,aScale-599,aRotation-599,aTextureCoord-599,colorAttribute-599,attributes-720,_UID-599",
    init$0: [function() {
      var t1, t2, program, key;
      t1 = this.gl;
      t2 = this.vertexSrc;
      if (t2 == null)
        t2 = $.get$PixiShader_defaultVertexSrc();
      program = M.compileProgram(t1, t2, this.fragmentSrc);
      J.useProgram$1$x(this.gl, program);
      this.PIXI$PixiShader$uSampler = J.getUniformLocation$2$x(this.gl, program, "uSampler");
      this.PIXI$PixiShader$projectionVector = J.getUniformLocation$2$x(this.gl, program, "projectionVector");
      this.PIXI$PixiShader$offsetVector = J.getUniformLocation$2$x(this.gl, program, "offsetVector");
      this.PIXI$PixiShader$dimensions = J.getUniformLocation$2$x(this.gl, program, "dimensions");
      this.PIXI$PixiShader$aVertexPosition = J.getAttribLocation$2$x(this.gl, program, "aVertexPosition");
      this.PIXI$PixiShader$aTextureCoord = J.getAttribLocation$2$x(this.gl, program, "aTextureCoord");
      t2 = J.getAttribLocation$2$x(this.gl, program, "aColor");
      this.PIXI$PixiShader$colorAttribute = t2;
      if (t2 === -1)
        this.PIXI$PixiShader$colorAttribute = 2;
      this.PIXI$PixiShader$attributes = [this.PIXI$PixiShader$aVertexPosition, this.PIXI$PixiShader$aTextureCoord, this.PIXI$PixiShader$colorAttribute];
      for (t1 = J.get$iterator$ax(J.get$keys$x(this.uniforms)); t1.moveNext$0();) {
        key = t1.get$current();
        J.$indexSet$ax(J.$index$asx(this.uniforms, key), "uniformLocation", J.getUniformLocation$2$x(this.gl, program, key));
      }
      this.initUniforms$0();
      this.program = program;
    }, "call$0", "get$init", 0, 0, 13, "init"],
    initUniforms$0: [function() {
      var gl, t1, t2, key, uniform, t3, type, t4, line;
      this.textureCount = 1;
      gl = this.gl;
      for (t1 = J.get$iterator$ax(J.get$keys$x(this.uniforms)), t2 = J.getInterceptor$x(gl); t1.moveNext$0();) {
        key = t1.get$current();
        uniform = J.$index$asx(this.uniforms, key);
        t3 = J.getInterceptor$asx(uniform);
        type = t3.$index(uniform, "type");
        t4 = J.getInterceptor(type);
        if (t4.$eq(type, "sampler2D")) {
          t3.$indexSet(uniform, "_init", false);
          if (t3.$index(uniform, "value") != null)
            this.initSampler2D$1(uniform);
        } else if (t4.$eq(type, "mat2") || t4.$eq(type, "mat3") || t4.$eq(type, "mat4")) {
          t3.$indexSet(uniform, "glMatrix", true);
          t3.$indexSet(uniform, "glValueLength", 1);
          if (t4.$eq(type, "mat2"))
            t3.$indexSet(uniform, "glFunc", t2.get$uniformMatrix2fv(gl));
          else if (t4.$eq(type, "mat3"))
            t3.$indexSet(uniform, "glFunc", t2.get$uniformMatrix3fv(gl));
          else if (t4.$eq(type, "mat4"))
            t3.$indexSet(uniform, "glFunc", t2.get$uniformMatrix4fv(gl));
        } else {
          switch (type) {
            case "1f":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform1f(gl));
              t3.$indexSet(uniform, "glValueLength", 1);
              break;
            case "1i":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform1i(gl));
              t3.$indexSet(uniform, "glValueLength", 1);
              break;
            case "2f":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform2f(gl));
              t3.$indexSet(uniform, "glValueLength", 2);
              break;
            case "2i":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform2i(gl));
              t3.$indexSet(uniform, "glValueLength", 2);
              break;
            case "2fv":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform2fv(gl));
              t3.$indexSet(uniform, "glValueLength", 1);
              break;
            case "3f":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform3f(gl));
              t3.$indexSet(uniform, "glValueLength", 3);
              break;
            case "3i":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform3i(gl));
              t3.$indexSet(uniform, "glValueLength", 3);
              break;
            case "3fv":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform3fv(gl));
              t3.$indexSet(uniform, "glValueLength", 1);
              break;
            case "4f":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform4f(gl));
              t3.$indexSet(uniform, "glValueLength", 4);
              break;
            case "4i":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform4i(gl));
              t3.$indexSet(uniform, "glValueLength", 4);
              break;
            case "4fv":
              t3.$indexSet(uniform, "glFunc", t2.get$uniform4fv(gl));
              t3.$indexSet(uniform, "glValueLength", 1);
              break;
          }
          if (t3.$index(uniform, "glFunc") == null) {
            line = H.S(type);
            H.printString(line);
            throw H.wrapException(P.Exception_Exception("no shuch function!"));
          }
        }
      }
    }, "call$0", "get$initUniforms", 0, 0, 13, "initUniforms"],
    initSampler2D$1: [function(uniform) {
      var t1, line, t2, t3, data, magFilter, minFilter, wrapS, wrapT, width, height;
      t1 = J.getInterceptor$asx(uniform);
      if (t1.$index(uniform, "value") == null || t1.$index(uniform, "value").get$baseTexture() == null || t1.$index(uniform, "value").get$baseTexture().get$hasLoaded() !== true)
        return;
      line = H.S(this.textureCount);
      H.printString(line);
      t2 = this.gl;
      t3 = this.textureCount;
      if (typeof t3 !== "number")
        return H.iae(t3);
      J.activeTexture$1$x(t2, 33984 + t3);
      J.bindTexture$2$x(this.gl, 3553, J.$index$asx(t1.$index(uniform, "value").get$baseTexture().get$_glTextures(), this.gl));
      if (t1.$index(uniform, "textureData") != null) {
        data = t1.$index(uniform, "textureData");
        magFilter = data.get$magFilter() === true ? data.get$magFilter() : 9729;
        minFilter = data.get$minFilter() === true ? data.get$minFilter() : 9729;
        data.get$wrapS();
        data.get$wrapT();
        data.get$luminance();
        t2 = J.getInterceptor$asx(data);
        if (t2.$index(data, "repeat") != null) {
          wrapS = 10497;
          wrapT = 10497;
        } else {
          wrapS = 33071;
          wrapT = 33071;
        }
        t3 = this.gl;
        J.pixelStorei$2$x(t3, 37440, data.get$flipY() === true ? 1 : 0);
        if (t2.get$width(data) === true) {
          width = t2.get$width(data) === true ? t2.get$width(data) : 512;
          height = t2.get$height(data) === true ? t2.get$height(data) : 2;
          t2.get$border(data);
          J.texImage2D$9$x(this.gl, 3553, 0, 6408, width, height, 0, 6408, 5121, null);
        } else
          J.texImage2D$6$x(this.gl, 3553, 0, 6408, 6408, 5121, J.get$source$x(J.$index$asx(t1.$index(uniform, "value"), "baseTexture")));
        J.texParameteri$3$x(this.gl, 3553, 10240, magFilter);
        J.texParameteri$3$x(this.gl, 3553, 10241, minFilter);
        J.texParameteri$3$x(this.gl, 3553, 10242, wrapS);
        J.texParameteri$3$x(this.gl, 3553, 10243, wrapT);
      }
      J.uniform1i$2$x(this.gl, t1.$index(uniform, "uniformLocation"), this.textureCount);
      t1.$indexSet(uniform, "_init", true);
      this.textureCount = J.$add$ns(this.textureCount, 1);
    }, "call$1", "get$initSampler2D", 2, 0, 771, 869, [], "initSampler2D"],
    syncUniforms$0: [function() {
      var gl, t1, t2, key, uniform, t3, $location, flist, transpose, t4, texture;
      this.textureCount = 1;
      gl = this.gl;
      for (t1 = J.get$iterator$ax(J.get$keys$x(this.uniforms)), t2 = J.getInterceptor$x(gl); t1.moveNext$0();) {
        key = t1.get$current();
        uniform = J.$index$asx(this.uniforms, key);
        t3 = J.getInterceptor$asx(uniform);
        if (J.$eq(t3.$index(uniform, "glValueLength"), 1))
          if (J.$eq(t3.$index(uniform, "glMatrix"), true)) {
            $location = t3.$index(uniform, "uniformLocation");
            flist = new Float32Array(H._ensureNativeList(t3.$index(uniform, "value")));
            transpose = t3.$index(uniform, "transpose") != null && t3.$index(uniform, "transpose");
            t3.$index(uniform, "glFunc").call$3($location, transpose, flist);
          } else {
            $location = t3.$index(uniform, "uniformLocation");
            if (!!J.getInterceptor(t3.$index(uniform, "value")).$isList) {
              flist = new Float32Array(H._ensureNativeList(t3.$index(uniform, "value")));
              t3.$index(uniform, "glFunc").call$2($location, flist);
            } else
              t3.$index(uniform, "glFunc").call$2($location, t3.$index(uniform, "value"));
          }
        else if (J.$eq(t3.$index(uniform, "glValueLength"), 2))
          t3.$index(uniform, "glFunc").call$3(t3.$index(uniform, "uniformLocation"), J.$index$asx(t3.$index(uniform, "value"), "x"), J.$index$asx(t3.$index(uniform, "value"), "y"));
        else if (J.$eq(t3.$index(uniform, "glValueLength"), 3))
          t3.$index(uniform, "glFunc").call$4(t3.$index(uniform, "uniformLocation"), J.$index$asx(t3.$index(uniform, "value"), "x"), J.$index$asx(t3.$index(uniform, "value"), "y"), J.$index$asx(t3.$index(uniform, "value"), "z"));
        else if (J.$eq(t3.$index(uniform, "glValueLength"), 4))
          t3.$index(uniform, "glFunc").call$5(t3.$index(uniform, "uniformLocation"), J.$index$asx(t3.$index(uniform, "value"), 0), J.$index$asx(t3.$index(uniform, "value"), 1), J.$index$asx(t3.$index(uniform, "value"), 2), J.$index$asx(t3.$index(uniform, "value"), 3));
        else if (J.$eq(t3.$index(uniform, "type"), "sampler2D"))
          if (t3.$index(uniform, "_init") != null) {
            t4 = this.textureCount;
            if (typeof t4 !== "number")
              return H.iae(t4);
            t2.activeTexture$1(gl, 33984 + t4);
            texture = J.$index$asx(t3.$index(uniform, "value").get$baseTexture().get$_glTextures(), gl);
            t2.bindTexture$2(gl, 3553, texture == null ? M.createWebGLTexture(t3.$index(uniform, "value").get$baseTexture(), gl) : texture);
            t2.uniform1i$2(gl, t3.$index(uniform, "uniformLocation"), this.textureCount);
            this.textureCount = J.$add$ns(this.textureCount, 1);
          } else
            this.initSampler2D$1(uniform);
      }
    }, "call$0", "get$syncUniforms", 0, 0, 13, "syncUniforms"],
    destroy$0: [function() {
      J.deleteProgram$1$x(this.gl, this.program);
      this.uniforms = null;
      this.gl = null;
      this.PIXI$PixiShader$attributes = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    static: {"^": "PixiShader_defaultVertexSrc@-820", PixiShader$: [function(gl) {
        var t1, t2;
        t1 = new M.PixiShader(gl, null, ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], null, 0, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t2 = $._UID;
        $._UID = J.$add$ns(t2, 1);
        t1._UID = t2;
        t1.init$0();
        return t1;
      }, null, null, 2, 0, 121, 122, [], "new PixiShader"]}
  },
  "+PixiShader": [868],
  PrimitiveShader: {
    "^": "Shader;gl@-851,program@-32,fragmentSrc@-820,vertexSrc@-820,projectionVector:PIXI$PrimitiveShader$projectionVector@-867,offsetVector:PIXI$PrimitiveShader$offsetVector@-867,tintColor:PIXI$PrimitiveShader$tintColor@-867,translationMatrix:PIXI$PrimitiveShader$translationMatrix@-867,alpha:PIXI$PrimitiveShader$alpha*-867,aVertexPosition:PIXI$PrimitiveShader$aVertexPosition@-599,colorAttribute:PIXI$PrimitiveShader$colorAttribute@-599,attributes:PIXI$PrimitiveShader$attributes*-715,uniforms@-32,uSampler-867,projectionVector-867,offsetVector-867,dimensions-867,uMatrix-867,tintColor-867,color-867,translationMatrix-867,alpha-867,aVertexPosition-599,aPositionCoord-599,aScale-599,aRotation-599,aTextureCoord-599,colorAttribute-599,attributes-720,_UID-599",
    init$0: [function() {
      var program, t1;
      program = M.compileProgram(this.gl, this.vertexSrc, this.fragmentSrc);
      J.useProgram$1$x(this.gl, program);
      this.PIXI$PrimitiveShader$projectionVector = J.getUniformLocation$2$x(this.gl, program, "projectionVector");
      this.PIXI$PrimitiveShader$offsetVector = J.getUniformLocation$2$x(this.gl, program, "offsetVector");
      this.PIXI$PrimitiveShader$tintColor = J.getUniformLocation$2$x(this.gl, program, "tint");
      this.PIXI$PrimitiveShader$aVertexPosition = J.getAttribLocation$2$x(this.gl, program, "aVertexPosition");
      t1 = J.getAttribLocation$2$x(this.gl, program, "aColor");
      this.PIXI$PrimitiveShader$colorAttribute = t1;
      this.PIXI$PrimitiveShader$attributes = [this.PIXI$PrimitiveShader$aVertexPosition, t1];
      this.PIXI$PrimitiveShader$translationMatrix = J.getUniformLocation$2$x(this.gl, program, "translationMatrix");
      this.PIXI$PrimitiveShader$alpha = J.getUniformLocation$2$x(this.gl, program, "alpha");
      this.program = program;
    }, "call$0", "get$init", 0, 0, 13, "init"],
    destroy$0: [function() {
      J.deleteProgram$1$x(this.gl, this.program);
      this.uniforms = null;
      this.gl = null;
      this.PIXI$PrimitiveShader$attributes = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    static: {PrimitiveShader$: [function(gl) {
        var t1, t2;
        t1 = new M.PrimitiveShader(gl, null, ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t2 = $._UID;
        $._UID = J.$add$ns(t2, 1);
        t1._UID = t2;
        t1.init$0();
        return t1;
      }, null, null, 2, 0, 121, 122, [], "new PrimitiveShader"]}
  },
  "+PrimitiveShader": [868],
  Shader: {
    "^": "Object;uSampler@-867,projectionVector@-867,offsetVector@-867,dimensions@-867,uMatrix@-867,tintColor@-867,color*-867,translationMatrix@-867,alpha*-867,aVertexPosition@-599,aPositionCoord@-599,aScale@-599,aRotation@-599,aTextureCoord@-599,colorAttribute@-599,attributes*-720,_UID@-599",
    static: {Shader$: [function() {
        return new M.Shader(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      }, null, null, 0, 0, 123, "new Shader"]}
  },
  "+Shader": [632],
  StripShader: {
    "^": "Shader;program@-866,gl@-851,fragmentSrc@-820,vertexSrc@-820,uSampler:PIXI$StripShader$uSampler@-867,projectionVector:PIXI$StripShader$projectionVector@-867,offsetVector:PIXI$StripShader$offsetVector@-867,dimensions:PIXI$StripShader$dimensions@-867,uMatrix:PIXI$StripShader$uMatrix@-867,translationMatrix:PIXI$StripShader$translationMatrix@-867,alpha:PIXI$StripShader$alpha*-867,aVertexPosition:PIXI$StripShader$aVertexPosition@-599,aPositionCoord:PIXI$StripShader$aPositionCoord@-599,aScale:PIXI$StripShader$aScale@-599,aRotation:PIXI$StripShader$aRotation@-599,aTextureCoord:PIXI$StripShader$aTextureCoord@-599,colorAttribute:PIXI$StripShader$colorAttribute@-599,attributes:PIXI$StripShader$attributes*-720,uSampler-867,projectionVector-867,offsetVector-867,dimensions-867,uMatrix-867,tintColor-867,color-867,translationMatrix-867,alpha-867,aVertexPosition-599,aPositionCoord-599,aScale-599,aRotation-599,aTextureCoord-599,colorAttribute-599,attributes-720,_UID-599",
    init$0: [function() {
      var program, t1;
      program = M.compileProgram(this.gl, this.vertexSrc, this.fragmentSrc);
      J.useProgram$1$x(this.gl, program);
      this.PIXI$StripShader$uSampler = J.getUniformLocation$2$x(this.gl, program, "uSampler");
      this.PIXI$StripShader$projectionVector = J.getUniformLocation$2$x(this.gl, program, "projectionVector");
      this.PIXI$StripShader$offsetVector = J.getUniformLocation$2$x(this.gl, program, "offsetVector");
      this.PIXI$StripShader$colorAttribute = J.getAttribLocation$2$x(this.gl, program, "aColor");
      this.PIXI$StripShader$aVertexPosition = J.getAttribLocation$2$x(this.gl, program, "aVertexPosition");
      t1 = J.getAttribLocation$2$x(this.gl, program, "aTextureCoord");
      this.PIXI$StripShader$aTextureCoord = t1;
      this.PIXI$StripShader$attributes = [this.PIXI$StripShader$aVertexPosition, t1];
      this.PIXI$StripShader$translationMatrix = J.getUniformLocation$2$x(this.gl, program, "translationMatrix");
      this.PIXI$StripShader$alpha = J.getUniformLocation$2$x(this.gl, program, "alpha");
      this.program = program;
    }, "call$0", "get$init", 0, 0, 13, "init"],
    destroy$0: [function() {
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    static: {StripShader$: [function(gl) {
        var t1, t2;
        t1 = new M.StripShader(null, gl, ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "}"], ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t2 = $._UID;
        $._UID = J.$add$ns(t2, 1);
        t1._UID = t2;
        t1.init$0();
        return t1;
      }, null, null, 2, 0, 121, 122, [], "new StripShader"]}
  },
  "+StripShader": [868],
  FilterTexture: {
    "^": "Object;gl@-851,frameBuffer@-870,renderBuffer@-871,texture@-32,width*-599,height*-599",
    clear$0: [function(_) {
      var gl, t1;
      gl = this.gl;
      t1 = J.getInterceptor$x(gl);
      t1.clearColor$4(gl, 0, 0, 0, 0);
      t1.clear$1(gl, 16384);
    }, "call$0", "get$clear", 0, 0, 13, "clear"],
    resize$2: [function(_, width, height) {
      var gl, t1;
      width = J.toInt$0$n(width);
      height = J.toInt$0$n(height);
      if (J.$eq(this.width, width) && J.$eq(this.height, height))
        return;
      this.width = width;
      this.height = height;
      gl = this.gl;
      t1 = J.getInterceptor$x(gl);
      t1.bindTexture$2(gl, 3553, this.texture);
      W.ImageElement_ImageElement(null, null, null);
      t1.texImage2DTyped$9(gl, 3553, 0, 6408, width, height, 0, 6408, 5121, null);
      t1.bindRenderbuffer$2(gl, 36161, this.renderBuffer);
      t1.renderbufferStorage$4(gl, 36161, 34041, width, height);
    }, "call$2", "get$resize", 4, 0, 111, 10, [], 11, [], "resize"],
    destroy$0: [function() {
      var gl, t1;
      gl = this.gl;
      t1 = J.getInterceptor$x(gl);
      t1.deleteFramebuffer$1(gl, this.frameBuffer);
      t1.deleteTexture$1(gl, this.texture);
      this.frameBuffer = null;
      this.texture = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    FilterTexture$4: function(gl, width, height, scaleMode) {
      var t1, t2;
      this.frameBuffer = J.createFramebuffer$0$x(this.gl);
      t1 = J.createTexture$0$x(this.gl);
      this.texture = t1;
      J.bindTexture$2$x(this.gl, 3553, t1);
      t1 = this.gl;
      t2 = J.getInterceptor(scaleMode);
      J.texParameteri$3$x(t1, 3553, 10240, t2.$eq(scaleMode, C.scaleModes_1) ? 9729 : 9728);
      t1 = this.gl;
      J.texParameteri$3$x(t1, 3553, 10241, t2.$eq(scaleMode, C.scaleModes_1) ? 9729 : 9728);
      J.texParameteri$3$x(this.gl, 3553, 10242, 33071);
      J.texParameteri$3$x(this.gl, 3553, 10243, 33071);
      J.bindFramebuffer$2$x(this.gl, 36160, this.frameBuffer);
      J.framebufferTexture2D$5$x(this.gl, 36160, 36064, 3553, this.texture, 0);
      t1 = J.createRenderbuffer$0$x(this.gl);
      this.renderBuffer = t1;
      J.bindRenderbuffer$2$x(this.gl, 36161, t1);
      J.framebufferRenderbuffer$4$x(this.gl, 36160, 33306, 36161, this.renderBuffer);
      this.resize$2(0, width, height);
    },
    static: {FilterTexture$: [function(gl, width, height, scaleMode) {
        var t1 = new M.FilterTexture(gl, null, null, null, null, null);
        t1.FilterTexture$4(gl, width, height, scaleMode);
        return t1;
      }, null, null, 6, 2, 124, 125, 122, [], 10, [], 11, [], 35, [], "new FilterTexture"]}
  },
  "+FilterTexture": [632],
  WebGLBlendModeManager: {
    "^": "Object;gl@-851,currentBlendMode@-674",
    setBlendMode$1: [function(blendMode) {
      var blendModeWebGL, t1;
      if (J.$eq(this.currentBlendMode, blendMode))
        return false;
      this.currentBlendMode = blendMode;
      blendModeWebGL = J.$index$asx($.blendModesWebGL, blendMode);
      t1 = J.getInterceptor$asx(blendModeWebGL);
      J.blendFunc$2$x(this.gl, t1.$index(blendModeWebGL, 0), t1.$index(blendModeWebGL, 1));
      return true;
    }, "call$1", "get$setBlendMode", 2, 0, 872, 873, [], "setBlendMode"],
    destroy$0: [function() {
      this.gl = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    static: {WebGLBlendModeManager$: [function(gl) {
        var t1 = new M.WebGLBlendModeManager(gl, null);
        t1.currentBlendMode = C.BlendModes_99999;
        return t1;
      }, null, null, 2, 0, 121, 122, [], "new WebGLBlendModeManager"]}
  },
  "+WebGLBlendModeManager": [632],
  WebGLFastSpriteBatch: {
    "^": "Object;gl@-851,vertSize@-599,maxSize@-599,size*-599,numVerts@-599,numIndices@-599,vertices@-630,indices@-685,vertexBuffer@-686,indexBuffer@-686,lastIndexCount@-599,drawing@-602,currentBatchSize@-599,currentBaseTexture@-826,currentBlendMode@-674,renderSession@-858,shader@-868,matrix@-630",
    size$1: function($receiver, arg0) {
      return this.size.call$1(arg0);
    },
    setContext$1: [function(gl) {
      var t1, t2;
      this.gl = gl;
      t1 = J.getInterceptor$x(gl);
      this.vertexBuffer = t1.createBuffer$0(gl);
      t2 = t1.createBuffer$0(gl);
      this.indexBuffer = t2;
      t1.bindBuffer$2(gl, 34963, t2);
      t1.bufferData$3(gl, 34963, this.indices, 35044);
      t1.bindBuffer$2(gl, 34962, this.vertexBuffer);
      t1.bufferData$3(gl, 34962, this.vertices, 35048);
      this.currentBlendMode = C.BlendModes_99999;
    }, "call$1", "get$setContext", 2, 0, 121, 122, [], "setContext"],
    begin$2: [function(spriteBatch, renderSession) {
      this.renderSession = renderSession;
      this.shader = renderSession.get$shaderManager().get$fastShader();
      this.matrix = spriteBatch.get$_worldTransform().toArray$1(true);
      this.start$0(0);
    }, "call$2", "get$begin", 4, 0, 874, 875, [], 128, [], "begin"],
    end$0: [function() {
      this.flush$0(0);
    }, "call$0", "get$end", 0, 0, 13, "end"],
    render$1: [function(spriteBatch) {
      var children, t1, sprite, j, i;
      children = J.get$children$x(spriteBatch);
      t1 = J.getInterceptor$asx(children);
      sprite = t1.$index(children, 0);
      if (sprite.get$texture().get$_uvs() == null)
        return;
      this.currentBaseTexture = sprite.get$texture().get$baseTexture();
      if (!J.$eq(sprite.get$blendMode(), this.currentBlendMode))
        this.setBlendMode$1(sprite.get$blendMode());
      j = t1.get$length(children);
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        this.renderSprite$1(t1.$index(children, i));
      this.flush$0(0);
    }, "call$1", "get$render", 2, 0, 876, 875, [], "render"],
    renderSprite$1: [function(sprite) {
      var verticies, uvs, trim, t1, w1, w0, h1, h0, t2, index, index0, t3;
      if (sprite.get$visible() !== true)
        return;
      if (!J.$eq(sprite.get$texture().get$baseTexture(), this.currentBaseTexture)) {
        this.flush$0(0);
        this.currentBaseTexture = sprite.get$texture().get$baseTexture();
        if (sprite.get$texture().get$_uvs() == null)
          return;
      }
      verticies = this.vertices;
      uvs = sprite.get$texture().get$_uvs();
      J.get$width$x(sprite.get$texture().get$frame());
      J.get$height$x(sprite.get$texture().get$frame());
      if (J.get$trim$s(sprite.get$texture()) != null) {
        trim = J.get$trim$s(sprite.get$texture());
        t1 = J.getInterceptor$x(trim);
        w1 = J.$sub$n(t1.get$x(trim), J.$mul$ns(J.get$x$x(sprite.get$anchor()), t1.get$width(trim)));
        w0 = J.$add$ns(w1, J.get$width$x(sprite.get$texture().get$frame()));
        h1 = J.$sub$n(t1.get$y(trim), J.$mul$ns(J.get$y$x(sprite.get$anchor()), t1.get$height(trim)));
        h0 = J.$add$ns(h1, J.get$height$x(sprite.get$texture().get$frame()));
      } else {
        t1 = J.get$width$x(sprite.get$texture().get$frame());
        t2 = J.get$x$x(sprite.get$anchor());
        if (typeof t2 !== "number")
          return H.iae(t2);
        w0 = J.$mul$ns(t1, 1 - t2);
        w1 = J.$mul$ns(J.get$width$x(sprite.get$texture().get$frame()), J.$negate$n(J.get$x$x(sprite.get$anchor())));
        t2 = J.get$height$x(sprite.get$texture().get$frame());
        t1 = J.get$y$x(sprite.get$anchor());
        if (typeof t1 !== "number")
          return H.iae(t1);
        h0 = J.$mul$ns(t2, 1 - t1);
        h1 = J.$mul$ns(J.get$height$x(sprite.get$texture().get$frame()), J.$negate$n(J.get$y$x(sprite.get$anchor())));
      }
      index = J.$mul$ns(J.$mul$ns(this.currentBatchSize, 4), this.vertSize);
      index0 = J.$add$ns(index, 1);
      t1 = J.getInterceptor$ax(verticies);
      t1.$indexSet(verticies, index, w1);
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, h1);
      index0 = J.$add$ns(index, 1);
      t2 = J.getInterceptor$x(sprite);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$position(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$position(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$scale(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$scale(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, sprite.get$rotation());
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, uvs.get$x0());
      index0 = J.$add$ns(index, 1);
      t3 = J.getInterceptor$x(uvs);
      t1.$indexSet(verticies, index, t3.get$y1(uvs));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.toDouble$0$n(t2.get$alpha(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, w0);
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, h1);
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$position(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$position(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$scale(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$scale(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, sprite.get$rotation());
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, t3.get$x1(uvs));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, t3.get$y1(uvs));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.toDouble$0$n(t2.get$alpha(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, w0);
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, h0);
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$position(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$position(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$scale(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$scale(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, sprite.get$rotation());
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, t3.get$x2(uvs));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, t3.get$y2(uvs));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.toDouble$0$n(t2.get$alpha(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, w1);
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, h0);
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$position(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$position(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, J.get$x$x(t2.get$scale(sprite)));
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.get$y$x(t2.get$scale(sprite)));
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, sprite.get$rotation());
      index = J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, uvs.get$x3());
      index0 = J.$add$ns(index, 1);
      t1.$indexSet(verticies, index, uvs.get$y3());
      J.$add$ns(index0, 1);
      t1.$indexSet(verticies, index0, J.toDouble$0$n(t2.get$alpha(sprite)));
      t2 = J.$add$ns(this.currentBatchSize, 1);
      this.currentBatchSize = t2;
      if (J.$ge$n(t2, this.size))
        this.flush$0(0);
    }, "call$1", "get$renderSprite", 2, 0, 877, 113, [], "renderSprite"],
    flush$0: [function(_) {
      var gl, t1, t2, t3;
      if (J.$eq(this.currentBatchSize, 0))
        return;
      gl = this.gl;
      if (J.$index$asx(this.currentBaseTexture.get$_glTextures(), gl) == null)
        M.createWebGLTexture(this.currentBaseTexture, gl);
      t1 = J.getInterceptor$x(gl);
      t1.bindTexture$2(gl, 3553, J.$index$asx(this.currentBaseTexture.get$_glTextures(), gl));
      t2 = J.$gt$n(this.currentBatchSize, J.$mul$ns(this.size, 0.5));
      t3 = this.vertices;
      if (t2)
        t1.bufferSubData$3(gl, 34962, 0, t3);
      else
        t1.bufferSubData$3(gl, 34962, 0, J.sublist$2$ax(t3, 0, J.$mul$ns(J.$mul$ns(this.currentBatchSize, 4), this.vertSize)));
      t1.drawElements$4(gl, 4, J.$mul$ns(this.currentBatchSize, 6), 5123, 0);
      this.currentBatchSize = 0;
      t1 = this.renderSession;
      t1.set$drawCount(J.$add$ns(t1.get$drawCount(), 1));
    }, "call$0", "get$flush", 0, 0, 13, "flush"],
    stop$0: [function(_) {
      this.flush$0(0);
    }, "call$0", "get$stop", 0, 0, 13, "stop"],
    start$0: [function(_) {
      var gl, t1, projection, t2, stride;
      gl = this.gl;
      t1 = J.getInterceptor$x(gl);
      t1.activeTexture$1(gl, 33984);
      t1.bindBuffer$2(gl, 34962, this.vertexBuffer);
      t1.bindBuffer$2(gl, 34963, this.indexBuffer);
      projection = this.renderSession.get$projection();
      t2 = J.getInterceptor$x(projection);
      t1.uniform2f$3(gl, this.shader.get$projectionVector(), t2.get$x(projection), t2.get$y(projection));
      t1.uniformMatrix3fv$3(gl, this.shader.get$uMatrix(), false, this.matrix);
      stride = J.$mul$ns(this.vertSize, 4);
      t1.vertexAttribPointer$6(gl, this.shader.get$aVertexPosition(), 2, 5126, false, stride, 0);
      t1.vertexAttribPointer$6(gl, this.shader.get$aPositionCoord(), 2, 5126, false, stride, 8);
      t1.vertexAttribPointer$6(gl, this.shader.get$aScale(), 2, 5126, false, stride, 16);
      t1.vertexAttribPointer$6(gl, this.shader.get$aRotation(), 1, 5126, false, stride, 24);
      t1.vertexAttribPointer$6(gl, this.shader.get$aTextureCoord(), 2, 5126, false, stride, 28);
      t1.vertexAttribPointer$6(gl, this.shader.get$colorAttribute(), 1, 5126, false, stride, 36);
      if (!J.$eq(this.currentBlendMode, C.BlendModes_0))
        this.setBlendMode$1(C.BlendModes_0);
    }, "call$0", "get$start", 0, 0, 13, "start"],
    setBlendMode$1: [function(blendMode) {
      var blendModeWebGL, t1;
      this.flush$0(0);
      this.currentBlendMode = blendMode;
      blendModeWebGL = J.$index$asx($.blendModesWebGL, blendMode);
      t1 = J.getInterceptor$asx(blendModeWebGL);
      J.blendFunc$2$x(this.gl, t1.$index(blendModeWebGL, 0), t1.$index(blendModeWebGL, 1));
    }, "call$1", "get$setBlendMode", 2, 0, 878, 873, [], "setBlendMode"],
    WebGLFastSpriteBatch$1: function(gl) {
      var t1, i, j;
      t1 = this.maxSize;
      this.size = t1;
      this.numVerts = J.$mul$ns(J.$mul$ns(t1, 4), this.vertSize);
      this.numIndices = J.$mul$ns(this.maxSize, 6);
      t1 = this.numVerts;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.vertices = new Float32Array(t1);
      t1 = this.numIndices;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.indices = new Uint16Array(t1);
      i = 0;
      j = 0;
      while (true) {
        t1 = this.numIndices;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$indexSet$ax(this.indices, i, j);
        J.$indexSet$ax(this.indices, i + 1, j + 1);
        t1 = j + 2;
        J.$indexSet$ax(this.indices, i + 2, t1);
        J.$indexSet$ax(this.indices, i + 3, j);
        J.$indexSet$ax(this.indices, i + 4, t1);
        J.$indexSet$ax(this.indices, i + 5, j + 3);
        i += 6;
        j += 4;
      }
      this.setContext$1(gl);
    },
    static: {WebGLFastSpriteBatch$: [function(gl) {
        var t1 = new M.WebGLFastSpriteBatch(null, 10, 6000, null, null, null, null, null, null, null, 0, false, 0, null, C.BlendModes_0, null, null, null);
        t1.WebGLFastSpriteBatch$1(gl);
        return t1;
      }, null, null, 2, 0, 121, 122, [], "new WebGLFastSpriteBatch"]}
  },
  "+WebGLFastSpriteBatch": [632],
  WebGLFilterManager: {
    "^": "Object;gl@-851,transparent@-602,filterStack@-879,offsetX@-601,offsetY@-601,texturePool@-880,renderSession@-858,width*-599,height*-599,defaultShader@-881,vertexArray@-630,uvArray@-630,colorBuffer@-686,indexBuffer@-686,vertexBuffer@-686,uvBuffer@-686,buffer*-870,colorArray@-630",
    setContext$1: [function(gl) {
      var t1;
      this.gl = gl;
      this.texturePool = [];
      t1 = J.getInterceptor$x(gl);
      this.vertexBuffer = t1.createBuffer$0(gl);
      this.uvBuffer = t1.createBuffer$0(gl);
      this.colorBuffer = t1.createBuffer$0(gl);
      this.indexBuffer = t1.createBuffer$0(gl);
      this.vertexArray = new Float32Array(H._ensureNativeList([0, 0, 1, 0, 0, 1, 1, 1]));
      t1.bindBuffer$2(gl, 34962, this.vertexBuffer);
      t1.bufferData$3(gl, 34962, this.vertexArray, 35044);
      this.uvArray = new Float32Array(H._ensureNativeList([0, 0, 1, 0, 0, 1, 1, 1]));
      t1.bindBuffer$2(gl, 34962, this.uvBuffer);
      t1.bufferData$3(gl, 34962, this.uvArray, 35044);
      this.colorArray = new Float32Array(H._ensureNativeList([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]));
      t1.bindBuffer$2(gl, 34962, this.colorBuffer);
      t1.bufferData$3(gl, 34962, this.colorArray, 35044);
      t1.bindBuffer$2(gl, 34963, this.indexBuffer);
      t1.bufferData$3(gl, 34963, new Uint16Array(H._ensureNativeList([0, 1, 2, 1, 3, 2])), 35044);
    }, "call$1", "get$setContext", 2, 0, 63, 122, [], "setContext"],
    begin$2: [function(renderSession, buffer) {
      var projection, t1;
      this.renderSession = renderSession;
      this.defaultShader = renderSession.get$shaderManager().get$defaultShader();
      projection = this.renderSession.get$projection();
      t1 = J.getInterceptor$x(projection);
      this.width = J.toInt$0$n(J.$mul$ns(t1.get$x(projection), 2));
      this.height = J.toInt$0$n(J.$mul$ns(J.$negate$n(t1.get$y(projection)), 2));
      this.buffer = buffer;
    }, "call$2", "get$begin", 4, 0, 882, 128, [], 860, [], "begin"],
    pushFilter$1: [function(filterBlock) {
      var gl, projection, offset, t1, filter, texture, t2, filterArea, padding, t3;
      gl = this.gl;
      projection = this.renderSession.get$projection();
      offset = J.get$offset$x(this.renderSession);
      t1 = J.getInterceptor$x(filterBlock);
      filterBlock.set$_filterArea(t1.get$target(filterBlock).get$filterArea() == null ? t1.get$target(filterBlock).getBounds$0() : t1.get$target(filterBlock).get$filterArea());
      J.add$1$ax(this.filterStack, filterBlock);
      filter = J.$index$asx(filterBlock.get$filterPasses(), 0);
      this.offsetX = J.$add$ns(this.offsetX, J.get$x$x(filterBlock.get$_filterArea()));
      this.offsetY = J.$add$ns(this.offsetY, J.get$y$x(filterBlock.get$_filterArea()));
      texture = J.$gt$n(J.get$length$asx(this.texturePool), 0) ? J.removeLast$0$ax(this.texturePool) : null;
      t1 = this.width;
      t2 = this.height;
      if (texture == null)
        texture = M.FilterTexture$(this.gl, t1, t2, C.scaleModes_0);
      else
        J.resize$2$x(texture, t1, t2);
      t1 = J.getInterceptor$x(gl);
      t1.bindTexture$2(gl, 3553, texture.get$texture());
      filterArea = filterBlock.get$_filterArea();
      padding = J.get$padding$x(filter);
      t2 = J.getInterceptor$x(filterArea);
      t2.set$x(filterArea, J.$sub$n(t2.get$x(filterArea), padding));
      t2.set$y(filterArea, J.$sub$n(t2.get$y(filterArea), padding));
      t3 = J.getInterceptor$ns(padding);
      t2.set$width(filterArea, J.$add$ns(t2.get$width(filterArea), t3.$mul(padding, 2)));
      t2.set$height(filterArea, J.$add$ns(t2.get$height(filterArea), t3.$mul(padding, 2)));
      if (J.$lt$n(t2.get$x(filterArea), 0))
        t2.set$x(filterArea, 0);
      if (J.$gt$n(t2.get$width(filterArea), this.width))
        t2.set$width(filterArea, this.width);
      if (J.$lt$n(t2.get$y(filterArea), 0))
        t2.set$y(filterArea, 0);
      if (J.$gt$n(t2.get$height(filterArea), this.height))
        t2.set$height(filterArea, this.height);
      t1.bindFramebuffer$2(gl, 36160, texture.get$frameBuffer());
      t1.viewport$4(gl, 0, 0, J.toInt$0$n(t2.get$width(filterArea)), J.toInt$0$n(t2.get$height(filterArea)));
      t3 = J.getInterceptor$x(projection);
      t3.set$x(projection, J.$div$n(t2.get$width(filterArea), 2));
      t3.set$y(projection, J.$div$n(J.$negate$n(t2.get$height(filterArea)), 2));
      t3 = J.getInterceptor$x(offset);
      t3.set$x(offset, J.$negate$n(t2.get$x(filterArea)));
      t3.set$y(offset, J.$negate$n(t2.get$y(filterArea)));
      this.renderSession.get$shaderManager().setShader$1(this.defaultShader);
      t1.uniform2f$3(gl, this.defaultShader.get$projectionVector(), J.$div$n(t2.get$width(filterArea), 2), J.$div$n(J.$negate$n(t2.get$height(filterArea)), 2));
      t1.uniform2f$3(gl, this.defaultShader.get$offsetVector(), -J.toDouble$0$n(t2.get$x(filterArea)), -J.toDouble$0$n(t2.get$y(filterArea)));
      t1.colorMask$4(gl, true, true, true, true);
      t1.clearColor$4(gl, 0, 0, 0, 0);
      t1.clear$1(gl, 16384);
      filterBlock.set$_glFilterTexture(texture);
    }, "call$1", "get$pushFilter", 2, 0, 883, 884, [], "pushFilter"],
    popFilter$0: [function() {
      var filterBlock, filterArea, texture, projection, offset, t1, outputTexture, inputTexture, i, t2, filterPass, t0, filter, sizeX, sizeY, buffer, offsetX, offsetY, currentFilter, t3, x, y, t4, t5;
      filterBlock = J.removeLast$0$ax(this.filterStack);
      filterArea = filterBlock.get$_filterArea();
      texture = filterBlock.get$_glFilterTexture();
      projection = this.renderSession.get$projection();
      offset = J.get$offset$x(this.renderSession);
      if (J.$gt$n(J.get$length$asx(filterBlock.get$filterPasses()), 1)) {
        t1 = J.getInterceptor$x(filterArea);
        J.viewport$4$x(this.gl, 0, 0, J.toInt$0$n(t1.get$width(filterArea)), J.toInt$0$n(t1.get$height(filterArea)));
        J.bindBuffer$2$x(this.gl, 34962, this.vertexBuffer);
        J.$indexSet$ax(this.vertexArray, 0, 0);
        J.$indexSet$ax(this.vertexArray, 1, J.toDouble$0$n(t1.get$height(filterArea)));
        J.$indexSet$ax(this.vertexArray, 2, J.toDouble$0$n(t1.get$width(filterArea)));
        J.$indexSet$ax(this.vertexArray, 3, J.toDouble$0$n(t1.get$height(filterArea)));
        J.$indexSet$ax(this.vertexArray, 4, 0);
        J.$indexSet$ax(this.vertexArray, 5, 0);
        J.$indexSet$ax(this.vertexArray, 6, J.toDouble$0$n(t1.get$width(filterArea)));
        J.$indexSet$ax(this.vertexArray, 7, 0);
        J.bufferSubData$3$x(this.gl, 34962, 0, this.vertexArray);
        J.bindBuffer$2$x(this.gl, 34962, this.uvBuffer);
        J.$indexSet$ax(this.uvArray, 2, J.$div$n(t1.get$width(filterArea), this.width));
        J.$indexSet$ax(this.uvArray, 5, J.$div$n(t1.get$height(filterArea), this.height));
        J.$indexSet$ax(this.uvArray, 6, J.$div$n(t1.get$width(filterArea), this.width));
        J.$indexSet$ax(this.uvArray, 7, J.$div$n(t1.get$height(filterArea), this.height));
        J.bufferSubData$3$x(this.gl, 34962, 0, this.uvArray);
        outputTexture = J.$gt$n(J.get$length$asx(this.texturePool), 0) ? J.removeLast$0$ax(this.texturePool) : null;
        if (outputTexture == null)
          outputTexture = M.FilterTexture$(this.gl, this.width, this.height, C.scaleModes_0);
        J.resize$2$x(outputTexture, this.width, this.height);
        J.bindFramebuffer$2$x(this.gl, 36160, outputTexture.get$frameBuffer());
        J.clear$1$ax(this.gl, 16384);
        J.disable$1$x(this.gl, 3042);
        inputTexture = texture;
        i = 0;
        while (true) {
          t2 = J.$sub$n(J.get$length$asx(filterBlock.get$filterPasses()), 1);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          filterPass = J.$index$asx(filterBlock.get$filterPasses(), i);
          J.bindFramebuffer$2$x(this.gl, 36160, outputTexture.get$frameBuffer());
          J.activeTexture$1$x(this.gl, 33984);
          J.bindTexture$2$x(this.gl, 3553, inputTexture.get$texture());
          this.applyFilterPass$4(filterPass, filterArea, t1.get$width(filterArea), t1.get$height(filterArea));
          ++i;
          t0 = outputTexture;
          outputTexture = inputTexture;
          inputTexture = t0;
        }
        J.enable$1$x(this.gl, 3042);
        J.add$1$ax(this.texturePool, outputTexture);
        texture = inputTexture;
      }
      filter = J.$index$asx(filterBlock.get$filterPasses(), J.$sub$n(J.get$length$asx(filterBlock.get$filterPasses()), 1));
      t1 = J.getInterceptor$x(filterArea);
      this.offsetX = J.$sub$n(this.offsetX, t1.get$x(filterArea));
      this.offsetY = J.$sub$n(this.offsetY, t1.get$y(filterArea));
      sizeX = this.width;
      sizeY = this.height;
      buffer = this.buffer;
      if (J.$eq(J.get$length$asx(this.filterStack), 0)) {
        J.colorMask$4$x(this.gl, true, true, true, true);
        offsetX = 0;
        offsetY = 0;
      } else {
        t1 = this.filterStack;
        t2 = J.getInterceptor$asx(t1);
        currentFilter = t2.$index(t1, J.$sub$n(t2.get$length(t1), 1));
        filterArea = currentFilter.get$_filterArea();
        t1 = J.getInterceptor$x(filterArea);
        sizeX = t1.get$width(filterArea);
        sizeY = t1.get$height(filterArea);
        offsetX = t1.get$x(filterArea);
        offsetY = t1.get$y(filterArea);
        buffer = currentFilter.get$_glFilterTexture().get$frameBuffer();
      }
      t1 = J.getInterceptor$n(sizeX);
      t2 = J.getInterceptor$x(projection);
      t2.set$x(projection, t1.$div(sizeX, 2));
      t3 = J.getInterceptor$n(sizeY);
      t2.set$y(projection, J.$div$n(t3.$negate(sizeY), 2));
      t2 = J.getInterceptor$x(offset);
      t2.set$x(offset, offsetX);
      t2.set$y(offset, offsetY);
      filterArea = filterBlock.get$_filterArea();
      t2 = J.getInterceptor$x(filterArea);
      x = J.$add$ns(J.$sub$n(t2.get$x(filterArea), offsetX), 0);
      y = J.$add$ns(J.$sub$n(t2.get$y(filterArea), offsetY), 0);
      J.bindBuffer$2$x(this.gl, 34962, this.vertexBuffer);
      J.$indexSet$ax(this.vertexArray, 0, x);
      t4 = J.getInterceptor$ns(y);
      J.$indexSet$ax(this.vertexArray, 1, t4.$add(y, t2.get$height(filterArea)));
      t5 = J.getInterceptor$ns(x);
      J.$indexSet$ax(this.vertexArray, 2, t5.$add(x, t2.get$width(filterArea)));
      J.$indexSet$ax(this.vertexArray, 3, t4.$add(y, t2.get$height(filterArea)));
      J.$indexSet$ax(this.vertexArray, 4, x);
      J.$indexSet$ax(this.vertexArray, 5, y);
      J.$indexSet$ax(this.vertexArray, 6, t5.$add(x, t2.get$width(filterArea)));
      J.$indexSet$ax(this.vertexArray, 7, y);
      J.bufferSubData$3$x(this.gl, 34962, 0, this.vertexArray);
      J.bindBuffer$2$x(this.gl, 34962, this.uvBuffer);
      J.$indexSet$ax(this.uvArray, 2, J.$div$n(t2.get$width(filterArea), this.width));
      J.$indexSet$ax(this.uvArray, 5, J.$div$n(t2.get$height(filterArea), this.height));
      J.$indexSet$ax(this.uvArray, 6, J.$div$n(t2.get$width(filterArea), this.width));
      J.$indexSet$ax(this.uvArray, 7, J.$div$n(t2.get$height(filterArea), this.height));
      J.bufferSubData$3$x(this.gl, 34962, 0, this.uvArray);
      J.viewport$4$x(this.gl, 0, 0, t1.toInt$0(sizeX), t3.toInt$0(sizeY));
      J.bindFramebuffer$2$x(this.gl, 36160, buffer);
      J.activeTexture$1$x(this.gl, 33984);
      J.bindTexture$2$x(this.gl, 3553, texture.get$texture());
      this.applyFilterPass$4(filter, filterArea, sizeX, sizeY);
      this.renderSession.get$shaderManager().setShader$1(this.defaultShader);
      J.uniform2f$3$x(this.gl, this.defaultShader.get$projectionVector(), t1.$div(sizeX, 2), J.$div$n(t3.$negate(sizeY), 2));
      J.uniform2f$3$x(this.gl, this.defaultShader.get$offsetVector(), J.$negate$n(offsetX), J.$negate$n(offsetY));
      J.add$1$ax(this.texturePool, texture);
      filterBlock.set$_glFilterTexture(null);
    }, "call$0", "get$popFilter", 0, 0, 13, "popFilter"],
    applyFilterPass$4: [function(filter, filterArea, width, height) {
      var shader, t1;
      shader = J.$index$asx(filter.get$shaders(), this.gl);
      if (shader == null) {
        shader = new M.PixiShader(this.gl, null, ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], null, 0, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1 = $._UID;
        $._UID = J.$add$ns(t1, 1);
        shader._UID = t1;
        shader.init$0();
        shader.fragmentSrc = filter.get$fragmentSrc();
        shader.uniforms = filter.get$uniforms();
        shader.init$0();
        J.$indexSet$ax(filter.get$shaders(), this.gl, shader);
      }
      this.renderSession.get$shaderManager().setShader$1(shader);
      J.uniform2f$3$x(this.gl, shader.get$projectionVector(), J.$div$n(width, 2), J.$div$n(J.$negate$n(height), 2));
      J.uniform2f$3$x(this.gl, shader.get$offsetVector(), 0, 0);
      if (J.$index$asx(filter.get$uniforms(), "dimensions") != null) {
        J.$indexSet$ax(J.$index$asx(J.$index$asx(filter.get$uniforms(), "dimensions"), "value"), 0, J.toDouble$0$n(this.width));
        J.$indexSet$ax(J.$index$asx(J.$index$asx(filter.get$uniforms(), "dimensions"), "value"), 1, J.toDouble$0$n(this.height));
        J.$indexSet$ax(J.$index$asx(J.$index$asx(filter.get$uniforms(), "dimensions"), "value"), 2, J.toDouble$0$n(J.$index$asx(this.vertexArray, 0)));
        J.$indexSet$ax(J.$index$asx(J.$index$asx(filter.get$uniforms(), "dimensions"), "value"), 3, J.toDouble$0$n(J.$index$asx(this.vertexArray, 5)));
      }
      shader.syncUniforms$0();
      J.bindBuffer$2$x(this.gl, 34962, this.vertexBuffer);
      J.vertexAttribPointer$6$x(this.gl, shader.get$aVertexPosition(), 2, 5126, false, 0, 0);
      J.bindBuffer$2$x(this.gl, 34962, this.uvBuffer);
      J.vertexAttribPointer$6$x(this.gl, shader.get$aTextureCoord(), 2, 5126, false, 0, 0);
      J.bindBuffer$2$x(this.gl, 34962, this.colorBuffer);
      J.vertexAttribPointer$6$x(this.gl, shader.get$colorAttribute(), 2, 5126, false, 0, 0);
      J.bindBuffer$2$x(this.gl, 34963, this.indexBuffer);
      J.drawElements$4$x(this.gl, 4, 6, 5123, 0);
      t1 = this.renderSession;
      t1.set$drawCount(J.$add$ns(t1.get$drawCount(), 1));
    }, "call$4", "get$applyFilterPass", 8, 0, 885, 886, [], 887, [], 10, [], 11, [], "applyFilterPass"],
    initShaderBuffers$0: [function() {
      var gl, t1;
      gl = this.gl;
      t1 = J.getInterceptor$x(gl);
      this.vertexBuffer = t1.createBuffer$0(gl);
      this.uvBuffer = t1.createBuffer$0(gl);
      this.colorBuffer = t1.createBuffer$0(gl);
      this.indexBuffer = t1.createBuffer$0(gl);
      this.vertexArray = new Float32Array(H._ensureNativeList([0, 0, 1, 0, 0, 1, 1, 1]));
      t1.bindBuffer$2(gl, 34962, this.vertexBuffer);
      t1.bufferData$3(gl, 34962, this.vertexArray, 35044);
      this.uvArray = new Float32Array(H._ensureNativeList([0, 0, 1, 0, 0, 1, 1, 1]));
      t1.bindBuffer$2(gl, 34962, this.uvBuffer);
      t1.bufferData$3(gl, 34962, this.uvArray, 35044);
      this.colorArray = new Float32Array(H._ensureNativeList([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]));
      t1.bindBuffer$2(gl, 34962, this.colorBuffer);
      t1.bufferData$3(gl, 34962, this.colorArray, 35044);
      t1.bindBuffer$2(gl, 34963, this.indexBuffer);
      t1.bufferData$3(gl, 34963, new Uint16Array(H._ensureNativeList([0, 1, 2, 1, 3, 2])), 35044);
    }, "call$0", "get$initShaderBuffers", 0, 0, 13, "initShaderBuffers"],
    destroy$0: [function() {
      var gl, i, t1;
      gl = this.gl;
      this.filterStack = null;
      this.offsetX = 0;
      this.offsetY = 0;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.texturePool);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$index$asx(this.texturePool, i).destroy$0();
        ++i;
      }
      this.texturePool = null;
      t1 = J.getInterceptor$x(gl);
      t1.deleteBuffer$1(gl, this.vertexBuffer);
      t1.deleteBuffer$1(gl, this.uvBuffer);
      t1.deleteBuffer$1(gl, this.colorBuffer);
      t1.deleteBuffer$1(gl, this.indexBuffer);
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    static: {WebGLFilterManager$: [function(gl, transparent) {
        var t1 = new M.WebGLFilterManager(null, transparent, [], 0, 0, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.setContext$1(gl);
        return t1;
      }, null, null, 4, 0, 126, 122, [], 109, [], "new WebGLFilterManager"]}
  },
  "+WebGLFilterManager": [632],
  WebGLGraphicsData: {
    "^": "Object;gl@-851,color*-681,points*-681,indices@-681,lastIndex@-599,buffer*-686,indexBuffer@-686,mode*-599,alpha*-601,dirty@-602,glPoints@-630,glIndicies@-685,data*-888",
    reset$0: [function(_) {
      this.points = [];
      this.indices = [];
      this.lastIndex = 0;
    }, "call$0", "get$reset", 0, 0, 13, "reset"],
    upload$0: [function(_) {
      var gl, t1;
      gl = this.gl;
      this.glPoints = new Float32Array(H._ensureNativeList(J.toList$0$ax(J.map$1$ax(this.points, new M.WebGLGraphicsData_upload_closure()))));
      t1 = J.getInterceptor$x(gl);
      t1.bindBuffer$2(gl, 34962, this.buffer);
      t1.bufferData$3(gl, 34962, this.glPoints, 35044);
      this.glIndicies = new Uint16Array(H._ensureNativeList(J.toList$0$ax(J.map$1$ax(this.indices, new M.WebGLGraphicsData_upload_closure0()))));
      t1.bindBuffer$2(gl, 34963, this.indexBuffer);
      t1.bufferData$3(gl, 34963, this.glIndicies, 35044);
      this.dirty = false;
    }, "call$0", "get$upload", 0, 0, 13, "upload"],
    WebGLGraphicsData$1: function(gl) {
      this.color = [0, 0, 0];
      this.points = [];
      this.indices = [];
      this.lastIndex = 0;
      this.buffer = J.createBuffer$0$x(this.gl);
      this.indexBuffer = J.createBuffer$0$x(this.gl);
      this.mode = 1;
      this.alpha = 1;
      this.dirty = true;
    },
    static: {WebGLGraphicsData$: [function(gl) {
        var t1 = new M.WebGLGraphicsData(gl, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.WebGLGraphicsData$1(gl);
        return t1;
      }, null, null, 2, 0, 121, 122, [], "new WebGLGraphicsData"]}
  },
  "+WebGLGraphicsData": [632],
  WebGLGraphicsData_upload_closure: {
    "^": "Closure:63;",
    call$1: [function(s) {
      return J.toDouble$0$n(s);
    }, "call$1", null, 2, 0, 63, 502, [], "call"],
    $isFunction: true
  },
  WebGLGraphicsData_upload_closure0: {
    "^": "Closure:605;",
    call$1: [function(s) {
      return J.toInt$0$n(s);
    }, "call$1", null, 2, 0, 605, 502, [], "call"],
    $isFunction: true
  },
  WebGLGraphics: {
    "^": "Object;",
    static: {"^": "WebGLGraphics_graphicsDataPool@-888,WebGLGraphics_last@-599", WebGLGraphics$: [function() {
        return new M.WebGLGraphics();
      }, null, null, 0, 0, 13, "new WebGLGraphics"], WebGLGraphics_renderGraphics: [function(graphics, renderSession) {
        var gl, projection, offset, shader, webGL, t1, t2, t3, t4, i, t5, webGLData, t6, colorList, tintColor;
        gl = renderSession.get$gl();
        projection = renderSession.get$projection();
        offset = J.get$offset$x(renderSession);
        shader = renderSession.get$shaderManager().get$primitiveShader();
        if (graphics.get$_dirty() === true)
          M.WebGLGraphics_updateGraphics(graphics, gl);
        webGL = J.$index$asx(graphics.get$_webGL(), gl);
        t1 = J.getInterceptor$x(webGL);
        t2 = J.getInterceptor$x(gl);
        t3 = J.getInterceptor$x(projection);
        t4 = J.getInterceptor$x(offset);
        i = 0;
        while (true) {
          t5 = J.get$length$asx(t1.get$data(webGL));
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (!(i < t5))
            break;
          if (J.$eq(J.get$mode$x(J.$index$asx(t1.get$data(webGL), i)), 1)) {
            webGLData = J.$index$asx(t1.get$data(webGL), i);
            renderSession.get$stencilManager().pushStencil$3(graphics, webGLData, renderSession);
            t2.drawElements$4(gl, 6, 4, 5123, J.$mul$ns(J.$sub$n(J.get$length$asx(webGLData.get$indices()), 4), 2));
            renderSession.get$stencilManager().popStencil$3(graphics, webGLData, renderSession);
            $.WebGLGraphics_last = J.get$mode$x(webGLData);
          } else {
            webGLData = J.$index$asx(t1.get$data(webGL), i);
            t5 = graphics.get$tint();
            t6 = J.getInterceptor$n(t5);
            colorList = [(t6.$shr(t5, 16) & 255) / 255, (t6.$shr(t5, 8) & 255) / 255, t6.$and(t5, 255) / 255];
            tintColor = new Float32Array(3);
            t5 = colorList.length;
            if (0 >= t5)
              return H.ioore(colorList, 0);
            tintColor[0] = colorList[0];
            if (1 >= t5)
              return H.ioore(colorList, 1);
            tintColor[1] = colorList[1];
            if (2 >= t5)
              return H.ioore(colorList, 2);
            tintColor[2] = colorList[2];
            renderSession.get$shaderManager().setShader$1(shader);
            shader = renderSession.get$shaderManager().get$primitiveShader();
            t2.uniformMatrix3fv$3(gl, shader.get$translationMatrix(), false, graphics.get$_worldTransform().toArray$1(true));
            t2.uniform2f$3(gl, shader.get$projectionVector(), t3.get$x(projection), J.$negate$n(t3.get$y(projection)));
            t2.uniform2f$3(gl, shader.get$offsetVector(), J.$negate$n(t4.get$x(offset)), J.$negate$n(t4.get$y(offset)));
            t2.uniform3fv$2(gl, shader.get$tintColor(), tintColor);
            t2.uniform1f$2(gl, J.get$alpha$x(shader), graphics.get$_worldAlpha());
            t2.bindBuffer$2(gl, 34962, J.get$buffer$x(webGLData));
            t2.vertexAttribPointer$6(gl, shader.get$aVertexPosition(), 2, 5126, false, 24, 0);
            t2.vertexAttribPointer$6(gl, shader.get$colorAttribute(), 4, 5126, false, 24, 8);
            t2.bindBuffer$2(gl, 34963, webGLData.get$indexBuffer());
            t2.drawElements$4(gl, 5, J.get$length$asx(webGLData.get$indices()), 5123, 0);
          }
          ++i;
        }
      }, "call$2", "WebGLGraphics_renderGraphics$closure", 4, 0, 127, 103, [], 128, [], "renderGraphics"], WebGLGraphics_updateGraphics: [function(graphics, gl) {
        var webGL, t1, i, t2, graphicsData, webGLData, data, rectData, t3, x, y, width, height, t4, color, alpha, r, g, b, verts, indices, vertPos, t5, tempPoints;
        webGL = J.$index$asx(graphics.get$_webGL(), gl);
        if (webGL == null) {
          t1 = graphics.get$_webGL();
          webGL = M.WebGLGraphicsData$(gl);
          webGL.lastIndex = 0;
          webGL.data = [];
          webGL.gl = gl;
          J.$indexSet$ax(t1, gl, webGL);
        }
        graphics.set$_dirty(false);
        if (graphics.get$clearDirty() === true) {
          graphics.set$clearDirty(false);
          t1 = J.getInterceptor$x(webGL);
          i = 0;
          while (true) {
            t2 = J.get$length$asx(t1.get$data(webGL));
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            graphicsData = J.$index$asx(t1.get$data(webGL), i);
            J.reset$0$x(graphicsData);
            J.add$1$ax($.get$WebGLGraphics_graphicsDataPool(), graphicsData);
            ++i;
          }
          t1.set$data(webGL, []);
          webGL.set$lastIndex(0);
        }
        for (i = webGL.get$lastIndex(), webGLData = null; t1 = J.getInterceptor$n(i), t1.$lt(i, J.get$length$asx(graphics.get$_graphicsData())); i = t1.$add(i, 1)) {
          data = J.$index$asx(graphics.get$_graphicsData(), i);
          t2 = J.getInterceptor$x(data);
          if (J.$eq(t2.get$type(data), $.Graphics_POLY)) {
            if (t2.get$fill(data) === true)
              if (J.$gt$n(J.get$length$asx(t2.get$points(data)), 6))
                if (J.$gt$n(J.get$length$asx(t2.get$points(data)), 10)) {
                  webGLData = M.WebGLGraphics_switchMode(webGL, 1);
                  M.WebGLGraphics_buildComplexPoly(data, webGLData);
                } else {
                  webGLData = M.WebGLGraphics_switchMode(webGL, 0);
                  M.WebGLGraphics_buildPoly(data, webGLData);
                }
            if (J.$gt$n(t2.get$lineWidth(data), 0)) {
              webGLData = M.WebGLGraphics_switchMode(webGL, 0);
              M.WebGLGraphics_buildLine(data, webGLData);
            }
          } else {
            webGLData = M.WebGLGraphics_switchMode(webGL, 0);
            if (J.$eq(t2.get$type(data), $.Graphics_RECT)) {
              rectData = t2.get$points(data);
              t3 = J.getInterceptor$asx(rectData);
              x = t3.$index(rectData, 0);
              y = t3.$index(rectData, 1);
              width = t3.$index(rectData, 2);
              height = t3.$index(rectData, 3);
              if (t2.get$fill(data) === true) {
                t3 = data.get$fillColor();
                t4 = J.getInterceptor$n(t3);
                color = [(t4.$shr(t3, 16) & 255) / 255, (t4.$shr(t3, 8) & 255) / 255, t4.$and(t3, 255) / 255];
                alpha = data.get$fillAlpha();
                if (0 >= color.length)
                  return H.ioore(color, 0);
                r = J.$mul$ns(color[0], alpha);
                if (1 >= color.length)
                  return H.ioore(color, 1);
                g = J.$mul$ns(color[1], alpha);
                if (2 >= color.length)
                  return H.ioore(color, 2);
                b = J.$mul$ns(color[2], alpha);
                verts = J.get$points$x(webGLData);
                indices = webGLData.get$indices();
                t3 = J.getInterceptor$asx(verts);
                vertPos = J.$div$n(t3.get$length(verts), 6);
                t3.addAll$1(verts, [x, y]);
                t3.addAll$1(verts, [r, g, b, alpha]);
                t4 = J.getInterceptor$ns(x);
                t3.addAll$1(verts, [t4.$add(x, width), y]);
                t3.addAll$1(verts, [r, g, b, alpha]);
                t5 = J.getInterceptor$ns(y);
                t3.addAll$1(verts, [x, t5.$add(y, height)]);
                t3.addAll$1(verts, [r, g, b, alpha]);
                t3.addAll$1(verts, [t4.$add(x, width), t5.$add(y, height)]);
                t3.addAll$1(verts, [r, g, b, alpha]);
                t3 = J.getInterceptor$ns(vertPos);
                J.addAll$1$ax(indices, [vertPos, vertPos, t3.$add(vertPos, 1), t3.$add(vertPos, 2), t3.$add(vertPos, 3), t3.$add(vertPos, 3)]);
              }
              if (!J.$eq(t2.get$lineWidth(data), 0)) {
                tempPoints = t2.get$points(data);
                t3 = J.getInterceptor$ns(x);
                t4 = J.getInterceptor$ns(y);
                t2.set$points(data, [x, y, t3.$add(x, width), y, t3.$add(x, width), t4.$add(y, height), x, t4.$add(y, height), x, y]);
                M.WebGLGraphics_buildLine(data, webGLData);
                t2.set$points(data, tempPoints);
              }
            } else if (J.$eq(t2.get$type(data), $.Graphics_CIRC) || J.$eq(t2.get$type(data), $.Graphics_ELIP))
              M.WebGLGraphics_buildCircle(data, webGLData);
            else if (J.$eq(t2.get$type(data), $.Graphics_RREC))
              M.WebGLGraphics_buildRoundedRectangle(data, webGLData);
          }
          webGL.set$lastIndex(J.$add$ns(webGL.get$lastIndex(), 1));
        }
        t1 = J.getInterceptor$x(webGL);
        i = 0;
        while (true) {
          t2 = J.get$length$asx(t1.get$data(webGL));
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          webGLData = J.$index$asx(t1.get$data(webGL), i);
          if (webGLData.get$dirty() === true)
            J.upload$0$x(webGLData);
          ++i;
        }
      }, "call$2", "WebGLGraphics_updateGraphics$closure", 4, 0, 129, 103, [], 122, [], "updateGraphics"], WebGLGraphics_switchMode: [function(webGL, type) {
        var t1, webGLData;
        t1 = J.getInterceptor$x(webGL);
        if (J.$eq(J.get$length$asx(t1.get$data(webGL)), 0)) {
          webGLData = J.$gt$n(J.get$length$asx($.get$WebGLGraphics_graphicsDataPool()), 0) ? J.removeLast$0$ax($.get$WebGLGraphics_graphicsDataPool()) : null;
          if (webGLData == null)
            webGLData = M.WebGLGraphicsData$(webGL.get$gl());
          J.set$mode$x(webGLData, type);
          J.add$1$ax(t1.get$data(webGL), webGLData);
        } else {
          webGLData = J.$index$asx(t1.get$data(webGL), J.$sub$n(J.get$length$asx(t1.get$data(webGL)), 1));
          if (!J.$eq(J.get$mode$x(webGLData), type) || J.$eq(type, 1)) {
            webGLData = J.$gt$n(J.get$length$asx($.get$WebGLGraphics_graphicsDataPool()), 0) ? J.removeLast$0$ax($.get$WebGLGraphics_graphicsDataPool()) : M.WebGLGraphicsData$(webGL.get$gl());
            J.set$mode$x(webGLData, type);
            J.add$1$ax(t1.get$data(webGL), webGLData);
          }
        }
        webGLData.set$dirty(true);
        return webGLData;
      }, "call$2", "WebGLGraphics_switchMode$closure", 4, 0, 130, 131, [], 99, [], "switchMode"], WebGLGraphics_buildRectangle: [function(graphicsData, webGLData) {
        var t1, rectData, t2, x, y, width, height, t3, color, alpha, r, g, b, verts, indices, vertPos, t4, tempPoints;
        t1 = J.getInterceptor$x(graphicsData);
        rectData = t1.get$points(graphicsData);
        t2 = J.getInterceptor$asx(rectData);
        x = t2.$index(rectData, 0);
        y = t2.$index(rectData, 1);
        width = t2.$index(rectData, 2);
        height = t2.$index(rectData, 3);
        if (t1.get$fill(graphicsData) === true) {
          t2 = graphicsData.get$fillColor();
          t3 = J.getInterceptor$n(t2);
          color = [(t3.$shr(t2, 16) & 255) / 255, (t3.$shr(t2, 8) & 255) / 255, t3.$and(t2, 255) / 255];
          alpha = graphicsData.get$fillAlpha();
          if (0 >= color.length)
            return H.ioore(color, 0);
          r = J.$mul$ns(color[0], alpha);
          if (1 >= color.length)
            return H.ioore(color, 1);
          g = J.$mul$ns(color[1], alpha);
          if (2 >= color.length)
            return H.ioore(color, 2);
          b = J.$mul$ns(color[2], alpha);
          verts = J.get$points$x(webGLData);
          indices = webGLData.get$indices();
          t2 = J.getInterceptor$asx(verts);
          vertPos = J.$div$n(t2.get$length(verts), 6);
          t2.addAll$1(verts, [x, y]);
          t2.addAll$1(verts, [r, g, b, alpha]);
          t3 = J.getInterceptor$ns(x);
          t2.addAll$1(verts, [t3.$add(x, width), y]);
          t2.addAll$1(verts, [r, g, b, alpha]);
          t4 = J.getInterceptor$ns(y);
          t2.addAll$1(verts, [x, t4.$add(y, height)]);
          t2.addAll$1(verts, [r, g, b, alpha]);
          t2.addAll$1(verts, [t3.$add(x, width), t4.$add(y, height)]);
          t2.addAll$1(verts, [r, g, b, alpha]);
          t2 = J.getInterceptor$ns(vertPos);
          J.addAll$1$ax(indices, [vertPos, vertPos, t2.$add(vertPos, 1), t2.$add(vertPos, 2), t2.$add(vertPos, 3), t2.$add(vertPos, 3)]);
        }
        if (!J.$eq(t1.get$lineWidth(graphicsData), 0)) {
          tempPoints = t1.get$points(graphicsData);
          t2 = J.getInterceptor$ns(x);
          t3 = J.getInterceptor$ns(y);
          t1.set$points(graphicsData, [x, y, t2.$add(x, width), y, t2.$add(x, width), t3.$add(y, height), x, t3.$add(y, height), x, y]);
          M.WebGLGraphics_buildLine(graphicsData, webGLData);
          t1.set$points(graphicsData, tempPoints);
        }
      }, "call$2", "WebGLGraphics_buildRectangle$closure", 4, 0, 132, 133, [], 134, [], "buildRectangle"], WebGLGraphics_quadraticBezierCurve: [function(fromX, fromY, cpX, cpY, toX, toY) {
        var points, t1, i, j, xa, ya, xb, yb;
        points = [];
        t1 = new M.WebGLGraphics_quadraticBezierCurve_getPt();
        for (i = 0; i <= 20; ++i) {
          j = i / 20;
          xa = t1.call$3(fromX, cpX, j);
          ya = t1.call$3(fromY, cpY, j);
          xb = t1.call$3(cpX, toX, j);
          yb = t1.call$3(cpY, toY, j);
          C.JSArray_methods.addAll$1(points, [t1.call$3(xa, xb, j), t1.call$3(ya, yb, j)]);
        }
        return points;
      }, "call$6", "WebGLGraphics_quadraticBezierCurve$closure", 12, 0, 135, 136, [], 137, [], 138, [], 139, [], 140, [], 141, [], "quadraticBezierCurve"], WebGLGraphics_buildRoundedRectangle: [function(graphicsData, webGLData) {
        var t1, points, t2, x, y, width, height, radius, recPoints, t3, color, alpha, r, g, b, verts, indices, vecPos, triangles, i, t4, tempPoints;
        t1 = J.getInterceptor$x(graphicsData);
        points = t1.get$points(graphicsData);
        t2 = J.getInterceptor$asx(points);
        x = t2.$index(points, 0);
        y = t2.$index(points, 1);
        width = t2.$index(points, 2);
        height = t2.$index(points, 3);
        radius = t2.$index(points, 4);
        recPoints = [];
        t2 = J.getInterceptor$ns(y);
        C.JSArray_methods.addAll$1(recPoints, [x, t2.$add(y, radius)]);
        t3 = J.getInterceptor$ns(x);
        C.JSArray_methods.addAll$1(recPoints, M.WebGLGraphics_quadraticBezierCurve(x, J.$sub$n(t2.$add(y, height), radius), x, t2.$add(y, height), t3.$add(x, radius), t2.$add(y, height)));
        C.JSArray_methods.addAll$1(recPoints, M.WebGLGraphics_quadraticBezierCurve(J.$sub$n(t3.$add(x, width), radius), t2.$add(y, height), t3.$add(x, width), t2.$add(y, height), t3.$add(x, width), J.$sub$n(t2.$add(y, height), radius)));
        C.JSArray_methods.addAll$1(recPoints, M.WebGLGraphics_quadraticBezierCurve(t3.$add(x, width), t2.$add(y, radius), t3.$add(x, width), y, J.$sub$n(t3.$add(x, width), radius), y));
        C.JSArray_methods.addAll$1(recPoints, M.WebGLGraphics_quadraticBezierCurve(t3.$add(x, radius), y, x, y, x, t2.$add(y, radius)));
        if (t1.get$fill(graphicsData) === true) {
          t2 = graphicsData.get$fillColor();
          t3 = J.getInterceptor$n(t2);
          color = [(t3.$shr(t2, 16) & 255) / 255, (t3.$shr(t2, 8) & 255) / 255, t3.$and(t2, 255) / 255];
          alpha = graphicsData.get$fillAlpha();
          if (0 >= color.length)
            return H.ioore(color, 0);
          r = J.$mul$ns(color[0], alpha);
          if (1 >= color.length)
            return H.ioore(color, 1);
          g = J.$mul$ns(color[1], alpha);
          if (2 >= color.length)
            return H.ioore(color, 2);
          b = J.$mul$ns(color[2], alpha);
          verts = J.get$points$x(webGLData);
          indices = webGLData.get$indices();
          t2 = J.getInterceptor$asx(verts);
          vecPos = J.$div$n(t2.get$length(verts), 6);
          triangles = M.PolyK_Triangulate(recPoints);
          for (t3 = J.getInterceptor$ax(indices), i = 0; i < triangles.length; i += 3) {
            t3.add$1(indices, J.$add$ns(triangles[i], vecPos));
            if (i >= triangles.length)
              return H.ioore(triangles, i);
            t3.add$1(indices, J.$add$ns(triangles[i], vecPos));
            t4 = i + 1;
            if (t4 >= triangles.length)
              return H.ioore(triangles, t4);
            t3.add$1(indices, J.$add$ns(triangles[t4], vecPos));
            t4 = i + 2;
            if (t4 >= triangles.length)
              return H.ioore(triangles, t4);
            t3.add$1(indices, J.$add$ns(triangles[t4], vecPos));
            if (t4 >= triangles.length)
              return H.ioore(triangles, t4);
            t3.add$1(indices, J.$add$ns(triangles[t4], vecPos));
          }
          for (i = 0; t3 = recPoints.length, i < t3; ++i) {
            t4 = recPoints[i];
            ++i;
            if (i >= t3)
              return H.ioore(recPoints, i);
            t2.addAll$1(verts, [t4, recPoints[i], r, g, b, alpha]);
          }
        }
        if (!J.$eq(t1.get$lineWidth(graphicsData), 0)) {
          tempPoints = t1.get$points(graphicsData);
          t1.set$points(graphicsData, recPoints);
          M.WebGLGraphics_buildLine(graphicsData, webGLData);
          t1.set$points(graphicsData, tempPoints);
        }
      }, "call$2", "WebGLGraphics_buildRoundedRectangle$closure", 4, 0, 132, 133, [], 134, [], "buildRoundedRectangle"], WebGLGraphics_buildCircle: [function(graphicsData, webGLData) {
        var t1, rectData, t2, x, y, width, height, t3, color, alpha, r, g, b, verts, indices, vecPos, t4, t5, i, t6, t7, vecPos0, vecPos1, tempPoints;
        t1 = J.getInterceptor$x(graphicsData);
        rectData = t1.get$points(graphicsData);
        t2 = J.getInterceptor$asx(rectData);
        x = t2.$index(rectData, 0);
        y = t2.$index(rectData, 1);
        width = t2.$index(rectData, 2);
        height = t2.$index(rectData, 3);
        if (t1.get$fill(graphicsData) === true) {
          t2 = graphicsData.get$fillColor();
          t3 = J.getInterceptor$n(t2);
          color = [(t3.$shr(t2, 16) & 255) / 255, (t3.$shr(t2, 8) & 255) / 255, t3.$and(t2, 255) / 255];
          alpha = graphicsData.get$fillAlpha();
          if (0 >= color.length)
            return H.ioore(color, 0);
          r = J.$mul$ns(color[0], alpha);
          if (1 >= color.length)
            return H.ioore(color, 1);
          g = J.$mul$ns(color[1], alpha);
          if (2 >= color.length)
            return H.ioore(color, 2);
          b = J.$mul$ns(color[2], alpha);
          verts = J.get$points$x(webGLData);
          indices = webGLData.get$indices();
          t2 = J.getInterceptor$asx(verts);
          vecPos = J.$div$n(t2.get$length(verts), 6);
          t3 = J.getInterceptor$ax(indices);
          t3.add$1(indices, vecPos);
          for (t4 = J.getInterceptor$ns(y), t5 = J.getInterceptor$ns(x), i = 0; i < 41; ++i, vecPos = vecPos1) {
            t2.addAll$1(verts, [x, y, r, g, b, alpha]);
            t6 = 0.15707963267948966 * i;
            t7 = Math.sin(t6);
            if (typeof width !== "number")
              return H.iae(width);
            t7 = t5.$add(x, t7 * width);
            t6 = Math.cos(t6);
            if (typeof height !== "number")
              return H.iae(height);
            t2.addAll$1(verts, [t7, t4.$add(y, t6 * height), r, g, b, alpha]);
            vecPos0 = J.$add$ns(vecPos, 1);
            vecPos1 = J.$add$ns(vecPos0, 1);
            t3.addAll$1(indices, [vecPos, vecPos0]);
          }
          t3.add$1(indices, J.$sub$n(vecPos, 1));
        }
        if (!J.$eq(t1.get$lineWidth(graphicsData), 0)) {
          tempPoints = t1.get$points(graphicsData);
          t1.set$points(graphicsData, []);
          for (t2 = J.getInterceptor$ns(y), t3 = J.getInterceptor$ns(x), i = 0; i < 41; ++i) {
            t4 = t1.get$points(graphicsData);
            t5 = 0.15707963267948966 * i;
            t6 = Math.sin(t5);
            if (typeof width !== "number")
              return H.iae(width);
            t6 = t3.$add(x, t6 * width);
            t5 = Math.cos(t5);
            if (typeof height !== "number")
              return H.iae(height);
            J.addAll$1$ax(t4, [t6, t2.$add(y, t5 * height)]);
          }
          M.WebGLGraphics_buildLine(graphicsData, webGLData);
          t1.set$points(graphicsData, tempPoints);
        }
      }, "call$2", "WebGLGraphics_buildCircle$closure", 4, 0, 132, 133, [], 134, [], "buildCircle"], WebGLGraphics_buildLine: [function(graphicsData, webGLData) {
        var t1, points, t2, i, t3, t4, firstPoint, t5, lastPoint, t6, midPointX, midPointY, verts, indices, $length, indexCount, indexStart, width, color, alpha, r, g, b, p1x, p1y, p2x, perpx, perpy, t7, dist, px, py, perp3x, perp3y, pdist, p2y, p3x, p3y, perp2x, perp2y, a1, b1, c1, a2, b2, c2, denom, indexStart0;
        t1 = J.getInterceptor$x(graphicsData);
        points = t1.get$points(graphicsData);
        t2 = J.getInterceptor$asx(points);
        if (J.$eq(t2.get$length(points), 0))
          return;
        if (J.$mod$n(t1.get$lineWidth(graphicsData), 2) !== 0) {
          i = 0;
          while (true) {
            t3 = t2.get$length(points);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(i < t3))
              break;
            t2.$indexSet(points, i, J.$add$ns(t2.$index(points, i), 0.5));
            ++i;
          }
        }
        t3 = t2.$index(points, 0);
        t4 = t2.$index(points, 1);
        firstPoint = new M.Point0(null, null);
        firstPoint.x = t3;
        firstPoint.y = t4;
        t5 = t2.$index(points, J.$sub$n(t2.get$length(points), 2));
        t2 = t2.$index(points, J.$sub$n(t2.get$length(points), 1));
        lastPoint = new M.Point0(null, null);
        lastPoint.x = t5;
        lastPoint.y = t2;
        if (J.$eq(t3, t5) && J.$eq(t4, t2)) {
          points = P.List_List$from(points, true, null);
          if (0 >= points.length)
            return H.ioore(points, 0);
          points.pop();
          if (0 >= points.length)
            return H.ioore(points, 0);
          points.pop();
          t2 = points.length;
          t5 = t2 - 2;
          if (t5 < 0)
            return H.ioore(points, t5);
          t5 = points[t5];
          t6 = t2 - 1;
          if (t6 < 0)
            return H.ioore(points, t6);
          t6 = points[t6];
          lastPoint = new M.Point0(null, null);
          lastPoint.x = t5;
          lastPoint.y = t6;
          midPointX = J.$add$ns(t5, J.$mul$ns(J.$sub$n(t3, t5), 0.5));
          midPointY = J.$add$ns(t6, J.$mul$ns(J.$sub$n(t4, t6), 0.5));
          H.IterableMixinWorkaround_insertAllList(points, 0, [midPointX, midPointY]);
          C.JSArray_methods.addAll$1(points, [midPointX, midPointY]);
        }
        verts = J.get$points$x(webGLData);
        indices = webGLData.get$indices();
        t2 = J.getInterceptor$asx(points);
        $length = J.$tdiv$n(t2.get$length(points), 2);
        indexCount = t2.get$length(points);
        t3 = J.getInterceptor$asx(verts);
        indexStart = J.$tdiv$n(t3.get$length(verts), 6);
        width = J.$div$n(t1.get$lineWidth(graphicsData), 2);
        t1 = graphicsData.get$lineColor();
        t4 = J.getInterceptor$n(t1);
        color = [(t4.$shr(t1, 16) & 255) / 255, (t4.$shr(t1, 8) & 255) / 255, t4.$and(t1, 255) / 255];
        alpha = graphicsData.get$lineAlpha();
        if (0 >= color.length)
          return H.ioore(color, 0);
        r = J.$mul$ns(color[0], alpha);
        if (1 >= color.length)
          return H.ioore(color, 1);
        g = J.$mul$ns(color[1], alpha);
        if (2 >= color.length)
          return H.ioore(color, 2);
        b = J.$mul$ns(color[2], alpha);
        p1x = t2.$index(points, 0);
        p1y = t2.$index(points, 1);
        p2x = t2.$index(points, 2);
        t1 = J.getInterceptor$n(p1y);
        perpx = J.$negate$n(t1.$sub(p1y, t2.$index(points, 3)));
        t4 = J.getInterceptor$n(p1x);
        perpy = t4.$sub(p1x, p2x);
        t5 = J.getInterceptor$ns(perpx);
        t6 = J.getInterceptor$ns(perpy);
        t7 = J.$add$ns(t5.$mul(perpx, perpx), t6.$mul(perpy, perpy));
        if (typeof t7 !== "number")
          H.throwExpression(P.ArgumentError$(t7));
        dist = Math.sqrt(t7);
        perpx = t5.$div(perpx, dist);
        perpy = t6.$div(perpy, dist);
        if (typeof width !== "number")
          return H.iae(width);
        perpx *= width;
        perpy = J.$mul$ns(perpy, width);
        t3.addAll$1(verts, [t4.$sub(p1x, perpx), t1.$sub(p1y, perpy), r, g, b, alpha]);
        t3.addAll$1(verts, [t4.$add(p1x, perpx), t1.$add(p1y, perpy), r, g, b, alpha]);
        t1 = J.getInterceptor$n($length);
        i = 1;
        px = null;
        py = null;
        perp3x = null;
        perp3y = null;
        pdist = null;
        while (true) {
          t4 = t1.$sub($length, 1);
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(i < t4))
            break;
          c$0: {
            t4 = (i - 1) * 2;
            p1x = t2.$index(points, t4);
            p1y = t2.$index(points, t4 + 1);
            t4 = i * 2;
            p2x = t2.$index(points, t4);
            p2y = t2.$index(points, t4 + 1);
            ++i;
            t4 = i * 2;
            p3x = t2.$index(points, t4);
            p3y = t2.$index(points, t4 + 1);
            perpx = J.$negate$n(J.$sub$n(p1y, p2y));
            perpy = J.$sub$n(p1x, p2x);
            t4 = J.getInterceptor$ns(perpx);
            t5 = J.getInterceptor$ns(perpy);
            t6 = J.$add$ns(t4.$mul(perpx, perpx), t5.$mul(perpy, perpy));
            if (typeof t6 !== "number")
              H.throwExpression(P.ArgumentError$(t6));
            dist = Math.sqrt(t6);
            perpx = t4.$div(perpx, dist) * width;
            perpy = J.$mul$ns(t5.$div(perpy, dist), width);
            perp2x = J.$negate$n(J.$sub$n(p2y, p3y));
            perp2y = J.$sub$n(p2x, p3x);
            t4 = J.getInterceptor$ns(perp2x);
            t5 = J.getInterceptor$ns(perp2y);
            t6 = J.$add$ns(t4.$mul(perp2x, perp2x), t5.$mul(perp2y, perp2y));
            if (typeof t6 !== "number")
              H.throwExpression(P.ArgumentError$(t6));
            dist = Math.sqrt(t6);
            perp2x = t4.$div(perp2x, dist) * width;
            perp2y = J.$mul$ns(t5.$div(perp2y, dist), width);
            t4 = J.getInterceptor$n(perpy);
            t5 = t4.$negate(perpy);
            if (typeof p1y !== "number")
              return H.iae(p1y);
            t6 = t4.$negate(perpy);
            if (typeof p2y !== "number")
              return H.iae(p2y);
            a1 = t5 + p1y - (t6 + p2y);
            t6 = -perpx;
            if (typeof p2x !== "number")
              return H.iae(p2x);
            t5 = t6 + p2x;
            if (typeof p1x !== "number")
              return H.iae(p1x);
            t6 += p1x;
            b1 = t5 - t6;
            c1 = t6 * (t4.$negate(perpy) + p2y) - t5 * (t4.$negate(perpy) + p1y);
            t5 = J.getInterceptor$n(perp2y);
            t6 = t5.$negate(perp2y);
            if (typeof p3y !== "number")
              return H.iae(p3y);
            a2 = t6 + p3y - (t5.$negate(perp2y) + p2y);
            t6 = -perp2x;
            t7 = t6 + p2x;
            if (typeof p3x !== "number")
              return H.iae(p3x);
            t6 += p3x;
            b2 = t7 - t6;
            c2 = t6 * (t5.$negate(perp2y) + p2y) - t7 * (t5.$negate(perp2y) + p3y);
            denom = a1 * b2 - a2 * b1;
            if ((denom < 0 ? -denom : denom) < 0.1) {
              if (typeof perpy !== "number")
                return H.iae(perpy);
              t3.addAll$1(verts, [p2x - perpx, p2y - perpy, r, g, b, alpha]);
              t3.addAll$1(verts, [p2x + perpx, p2y + perpy, r, g, b, alpha]);
              break c$0;
            }
            px = (b1 * c2 - b2 * c1) / denom;
            py = (a2 * c1 - a1 * c2) / denom;
            t5 = px - p2x;
            t6 = py - p2y;
            pdist = t5 * t5 + t6 + t6;
            if (pdist > 19600) {
              perp3x = perpx - perp2x;
              perp3y = t4.$sub(perpy, perp2y);
              t4 = J.getInterceptor$ns(perp3y);
              t5 = t4.$mul(perp3y, perp3y);
              if (typeof t5 !== "number")
                return H.iae(t5);
              dist = Math.sqrt(perp3x * perp3x + t5);
              perp3x = perp3x / dist * width;
              perp3y = J.$mul$ns(t4.$div(perp3y, dist), width);
              t4 = p2x - perp3x;
              if (typeof perp3y !== "number")
                return H.iae(perp3y);
              t5 = p2y - perp3y;
              t3.addAll$1(verts, [t4, t5]);
              t3.addAll$1(verts, [r, g, b, alpha]);
              t3.addAll$1(verts, [p2x + perp3x, p2y + perp3y]);
              t3.addAll$1(verts, [r, g, b, alpha]);
              t3.addAll$1(verts, [t4, t5]);
              t3.addAll$1(verts, [r, g, b, alpha]);
              indexCount = J.$add$ns(indexCount, 1);
            } else {
              t3.addAll$1(verts, [px, py]);
              t3.addAll$1(verts, [r, g, b, alpha]);
              t3.addAll$1(verts, [p2x - t5, p2y - t6]);
              t3.addAll$1(verts, [r, g, b, alpha]);
            }
          }
        }
        p1x = t2.$index(points, J.$mul$ns(t1.$sub($length, 2), 2));
        p1y = t2.$index(points, J.$add$ns(J.$mul$ns(t1.$sub($length, 2), 2), 1));
        p2x = t2.$index(points, J.$mul$ns(t1.$sub($length, 1), 2));
        p2y = t2.$index(points, J.$add$ns(J.$mul$ns(t1.$sub($length, 1), 2), 1));
        perpx = J.$negate$n(J.$sub$n(p1y, p2y));
        perpy = J.$sub$n(p1x, p2x);
        t1 = J.getInterceptor$ns(perpx);
        t2 = J.getInterceptor$ns(perpy);
        t4 = J.$add$ns(t1.$mul(perpx, perpx), t2.$mul(perpy, perpy));
        if (typeof t4 !== "number")
          H.throwExpression(P.ArgumentError$(t4));
        dist = Math.sqrt(t4);
        perpx = t1.$div(perpx, dist) * width;
        perpy = J.$mul$ns(t2.$div(perpy, dist), width);
        t1 = J.getInterceptor$n(p2x);
        t2 = J.getInterceptor$n(p2y);
        t3.addAll$1(verts, [t1.$sub(p2x, perpx), t2.$sub(p2y, perpy)]);
        t3.addAll$1(verts, [r, g, b, alpha]);
        t3.addAll$1(verts, [t1.$add(p2x, perpx), t2.$add(p2y, perpy)]);
        t3.addAll$1(verts, [r, g, b, alpha]);
        t3 = J.getInterceptor$ax(indices);
        t3.add$1(indices, indexStart);
        if (typeof indexCount !== "number")
          return H.iae(indexCount);
        i = 0;
        for (; i < indexCount; ++i, indexStart = indexStart0) {
          indexStart0 = J.$add$ns(indexStart, 1);
          t3.add$1(indices, indexStart);
        }
        t3.add$1(indices, J.$sub$n(indexStart, 1));
      }, "call$2", "WebGLGraphics_buildLine$closure", 4, 0, 132, 133, [], 134, [], "buildLine"], WebGLGraphics_buildComplexPoly: [function(graphicsData, webGLData) {
        var points, indices, t1, t2, t3, minX, maxX, minY, maxY, i, x, y, $length;
        points = P.List_List$from(J.get$points$x(graphicsData), true, null);
        if (points.length < 6)
          return;
        indices = webGLData.get$indices();
        t1 = J.getInterceptor$x(webGLData);
        t1.set$points(webGLData, points);
        t1.set$alpha(webGLData, graphicsData.get$fillAlpha());
        t2 = graphicsData.get$fillColor();
        t3 = J.getInterceptor$n(t2);
        t1.set$color(webGLData, [(t3.$shr(t2, 16) & 255) / 255, (t3.$shr(t2, 8) & 255) / 255, t3.$and(t2, 255) / 255]);
        for (minX = 1 / 0, maxX = -1 / 0, minY = 1 / 0, maxY = -1 / 0, i = 0; t1 = points.length, i < t1; i += 2) {
          x = points[i];
          t2 = i + 1;
          if (t2 >= t1)
            return H.ioore(points, t2);
          y = points[t2];
          t1 = J.getInterceptor$n(x);
          if (t1.$lt(x, minX))
            minX = x;
          if (t1.$gt(x, maxX))
            maxX = x;
          t1 = J.getInterceptor$n(y);
          if (t1.$lt(y, minY))
            minY = y;
          if (t1.$gt(y, maxY))
            maxY = y;
        }
        C.JSArray_methods.addAll$1(points, [minX, minY, maxX, minY, maxX, maxY, minX, maxY]);
        $length = C.JSInt_methods._tdivFast$1(points.length, 2);
        for (t1 = J.getInterceptor$ax(indices), i = 0; i < $length; ++i)
          t1.add$1(indices, i);
      }, "call$2", "WebGLGraphics_buildComplexPoly$closure", 4, 0, 132, 133, [], 134, [], "buildComplexPoly"], WebGLGraphics_buildPoly: [function(graphicsData, webGLData) {
        var points, t1, verts, indices, $length, t2, t3, color, alpha, r, g, b, triangles, vertPos, i, t4;
        points = J.get$points$x(graphicsData);
        t1 = J.getInterceptor$asx(points);
        if (J.$lt$n(t1.get$length(points), 6))
          return;
        verts = J.get$points$x(webGLData);
        indices = webGLData.get$indices();
        $length = J.$div$n(t1.get$length(points), 2);
        t2 = graphicsData.get$fillColor();
        t3 = J.getInterceptor$n(t2);
        color = [(t3.$shr(t2, 16) & 255) / 255, (t3.$shr(t2, 8) & 255) / 255, t3.$and(t2, 255) / 255];
        alpha = graphicsData.get$fillAlpha();
        if (0 >= color.length)
          return H.ioore(color, 0);
        r = J.$mul$ns(color[0], alpha);
        if (1 >= color.length)
          return H.ioore(color, 1);
        g = J.$mul$ns(color[1], alpha);
        if (2 >= color.length)
          return H.ioore(color, 2);
        b = J.$mul$ns(color[2], alpha);
        triangles = M.PolyK_Triangulate(points);
        t2 = J.getInterceptor$asx(verts);
        vertPos = J.$div$n(t2.get$length(verts), 6);
        for (t3 = J.getInterceptor$ax(indices), i = 0; i < triangles.length; i += 3) {
          t3.add$1(indices, J.$add$ns(triangles[i], vertPos));
          if (i >= triangles.length)
            return H.ioore(triangles, i);
          t3.add$1(indices, J.$add$ns(triangles[i], vertPos));
          t4 = i + 1;
          if (t4 >= triangles.length)
            return H.ioore(triangles, t4);
          t3.add$1(indices, J.$add$ns(triangles[t4], vertPos));
          t4 = i + 2;
          if (t4 >= triangles.length)
            return H.ioore(triangles, t4);
          t3.add$1(indices, J.$add$ns(triangles[t4], vertPos));
          if (t4 >= triangles.length)
            return H.ioore(triangles, t4);
          t3.add$1(indices, J.$add$ns(triangles[t4], vertPos));
        }
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          t3 = i * 2;
          t2.addAll$1(verts, [t1.$index(points, t3), t1.$index(points, t3 + 1), r, g, b, alpha]);
        }
      }, "call$2", "WebGLGraphics_buildPoly$closure", 4, 0, 132, 133, [], 134, [], "buildPoly"]}
  },
  "+WebGLGraphics": [632],
  WebGLGraphics_quadraticBezierCurve_getPt: {
    "^": "Closure:351;",
    call$3: [function(n1, n2, perc) {
      return J.$add$ns(n1, J.$mul$ns(J.$sub$n(n2, n1), perc));
    }, "call$3", null, 6, 0, 351, 889, [], 890, [], 891, [], "call"],
    $isFunction: true
  },
  WebGLMaskManager: {
    "^": "MaskManager;maskStack@-720,maskPosition*-599,gl@-851,reverse@-602,count@-599",
    reverse$0: function() {
      return this.reverse.call$0();
    },
    setContext$1: [function(gl) {
      this.gl = gl;
    }, "call$1", "get$setContext", 2, 0, 63, 122, [], "setContext"],
    pushMask$2: [function(maskData, renderSession) {
      var gl = renderSession.get$gl();
      if (maskData.get$_dirty() === true)
        M.WebGLGraphics_updateGraphics(maskData, gl);
      if (J.$eq(J.get$length$asx(J.get$data$x(J.$index$asx(maskData.get$_webGL(), gl))), 0))
        return;
      renderSession.get$stencilManager().pushStencil$3(maskData, J.$index$asx(J.get$data$x(J.$index$asx(maskData.get$_webGL(), gl)), 0), renderSession);
    }, function(maskData) {
      return this.pushMask$2(maskData, null);
    }, "pushMask$1", "call$2", "call$1", "get$pushMask", 2, 2, 864, 32, 863, [], 128, [], "pushMask"],
    popMask$2: [function(maskData, renderSession) {
      var gl = this.gl;
      if (J.$eq(J.get$length$asx(J.get$data$x(J.$index$asx(maskData.get$_webGL(), gl))), 0))
        return;
      renderSession.get$stencilManager().popStencil$3(maskData, J.$index$asx(J.get$data$x(J.$index$asx(maskData.get$_webGL(), gl)), 0), renderSession);
    }, function(maskData) {
      return this.popMask$2(maskData, null);
    }, "popMask$1", "call$2", "call$1", "get$popMask", 2, 2, 892, 32, 863, [], 128, [], "popMask"],
    destroy$0: [function() {
      this.maskStack = null;
      this.gl = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    WebGLMaskManager$1: function(gl) {
      this.gl = gl;
      this.reverse = false;
      this.count = 0;
    },
    static: {WebGLMaskManager$: [function(gl) {
        var t1 = new M.WebGLMaskManager([], 0, null, null, null);
        t1.WebGLMaskManager$1(gl);
        return t1;
      }, null, null, 2, 0, 63, 122, [], "new WebGLMaskManager"]}
  },
  "+WebGLMaskManager": [854],
  WebGLShaderManager: {
    "^": "Object;gl@-851,maxAttibs@-599,_currentId@-599,attribState@-893,tempAttribState@-893,shaderMap@-754,primitiveShader@-894,defaultShader@-881,fastShader@-895,currentShader@-868,complexPrimativeShader@-896,stripShader@-897",
    setContext$1: [function(gl) {
      var t1, t2;
      this.gl = gl;
      t1 = new M.PrimitiveShader(gl, null, ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2 = $._UID;
      $._UID = J.$add$ns(t2, 1);
      t1._UID = t2;
      t1.init$0();
      this.primitiveShader = t1;
      t1 = new M.ComplexPrimitiveShader(gl, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t1.ComplexPrimitiveShader$1(gl);
      this.complexPrimativeShader = t1;
      t1 = new M.PixiShader(gl, null, ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], null, 0, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2 = $._UID;
      $._UID = J.$add$ns(t2, 1);
      t1._UID = t2;
      t1.init$0();
      this.defaultShader = t1;
      t1 = new M.PixiFastShader(gl, null, ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2 = $._UID;
      $._UID = J.$add$ns(t2, 1);
      t1._UID = t2;
      t1.init$0();
      this.fastShader = t1;
      t1 = new M.StripShader(null, gl, ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "}"], ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2 = $._UID;
      $._UID = J.$add$ns(t2, 1);
      t1._UID = t2;
      t1.init$0();
      this.stripShader = t1;
      this.setShader$1(this.defaultShader);
    }, "call$1", "get$setContext", 2, 0, 63, 122, [], "setContext"],
    setAttribs$1: [function(attribs) {
      var t1, key, i, t2, attribId;
      for (t1 = J.get$iterator$ax(J.get$keys$x(this.tempAttribState)); t1.moveNext$0();) {
        key = t1.get$current();
        J.$indexSet$ax(this.tempAttribState, key, false);
      }
      t1 = J.getInterceptor$asx(attribs);
      i = 0;
      while (true) {
        t2 = t1.get$length(attribs);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        attribId = t1.$index(attribs, i);
        J.$indexSet$ax(this.tempAttribState, attribId, true);
        ++i;
      }
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.attribState);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (!J.$eq(J.$index$asx(this.attribState, i), J.$index$asx(this.tempAttribState, i))) {
          J.$indexSet$ax(this.attribState, i, J.$index$asx(this.tempAttribState, i));
          t1 = J.$eq(J.$index$asx(this.tempAttribState, i), true);
          t2 = this.gl;
          if (t1)
            J.enableVertexAttribArray$1$x(t2, i);
          else
            J.disableVertexAttribArray$1$x(t2, i);
        }
        ++i;
      }
    }, "call$1", "get$setAttribs", 2, 0, 898, 899, [], "setAttribs"],
    setShader$1: [function(shader) {
      if (J.$eq(this._currentId, shader.get$_UID()))
        return false;
      this._currentId = shader.get$_UID();
      this.currentShader = shader;
      J.useProgram$1$x(this.gl, shader.get$program());
      this.setAttribs$1(J.get$attributes$x(shader));
      return true;
    }, "call$1", "get$setShader", 2, 0, 63, 900, [], "setShader"],
    destroy$0: [function() {
      this.attribState = null;
      this.tempAttribState = null;
      this.primitiveShader.destroy$0();
      this.defaultShader.destroy$0();
      this.fastShader.destroy$0();
      this.stripShader.destroy$0();
      this.gl = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    WebGLShaderManager$1: function(gl) {
      var i, t1;
      i = 0;
      while (true) {
        t1 = this.maxAttibs;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$indexSet$ax(this.attribState, i, false);
        ++i;
      }
      this.setContext$1(gl);
    },
    static: {WebGLShaderManager$: [function(gl) {
        var t1 = new M.WebGLShaderManager(null, 10, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, null, null, null, null, null);
        t1.WebGLShaderManager$1(gl);
        return t1;
      }, null, null, 2, 0, 63, 122, [], "new WebGLShaderManager"]}
  },
  "+WebGLShaderManager": [632],
  WebGLShaderUtils: {
    "^": "Object;",
    static: {WebGLShaderUtils$: [function() {
        return new M.WebGLShaderUtils();
      }, null, null, 0, 0, 13, "new WebGLShaderUtils"]}
  },
  "+WebGLShaderUtils": [632],
  WebGLSpriteBatch: {
    "^": "Object;gl@-851,vertSize@-599,maxSize@-599,size*-599,numVerts@-599,numIndices@-599,vertices@-630,indices@-685,vertexBuffer@-686,indexBuffer@-686,lastIndexCount@-599,drawing@-602,currentBatchSize@-599,currentBaseTexture@-826,renderSession@-858,shader@-881,matrix@-640,dirty@-602,textures@-901,blendModes@-902",
    size$1: function($receiver, arg0) {
      return this.size.call$1(arg0);
    },
    setContext$1: [function(gl) {
      var t1, t2;
      this.gl = gl;
      t1 = J.getInterceptor$x(gl);
      this.vertexBuffer = t1.createBuffer$0(gl);
      t2 = t1.createBuffer$0(gl);
      this.indexBuffer = t2;
      t1.bindBuffer$2(gl, 34963, t2);
      t1.bufferData$3(gl, 34963, this.indices, 35044);
      t1.bindBuffer$2(gl, 34962, this.vertexBuffer);
      t1.bufferData$3(gl, 34962, this.vertices, 35048);
    }, "call$1", "get$setContext", 2, 0, 121, 122, [], "setContext"],
    begin$1: [function(renderSession) {
      this.renderSession = renderSession;
      this.shader = renderSession.get$shaderManager().get$defaultShader();
      this.dirty = true;
    }, "call$1", "get$begin", 2, 0, 655, 128, [], "begin"],
    end$0: [function() {
      this.flush$0(0);
    }, "call$0", "get$end", 0, 0, 13, "end"],
    render$1: [function(sprite) {
      var texture, uvs, alpha, tint, verticies, aX, aY, t1, trim, w1, w0, h1, h0, index, worldTransform, a, b, c, d, tx, ty, index0, t2, t3, t4, t5, t6;
      texture = sprite.get$texture();
      if (J.$ge$n(this.currentBatchSize, this.size)) {
        this.flush$0(0);
        this.currentBaseTexture = texture.get$baseTexture();
      }
      uvs = texture.get$_uvs();
      if (uvs == null)
        return;
      alpha = sprite.get$_worldAlpha();
      tint = J.toDouble$0$n(sprite.get$tint());
      verticies = this.vertices;
      aX = J.get$x$x(sprite.get$anchor());
      aY = J.get$y$x(sprite.get$anchor());
      t1 = J.getInterceptor$s(texture);
      if (t1.get$trim(texture) != null) {
        trim = t1.get$trim(texture);
        t1 = J.getInterceptor$x(trim);
        w1 = J.$sub$n(t1.get$x(trim), J.$mul$ns(aX, t1.get$width(trim)));
        w0 = J.$add$ns(w1, J.get$width$x(texture.get$crop()));
        h1 = J.$sub$n(t1.get$y(trim), J.$mul$ns(aY, t1.get$height(trim)));
        h0 = J.$add$ns(h1, J.get$height$x(texture.get$crop()));
      } else {
        t1 = J.get$width$x(texture.get$frame());
        if (typeof aX !== "number")
          return H.iae(aX);
        w0 = J.$mul$ns(t1, 1 - aX);
        w1 = J.$mul$ns(J.get$width$x(texture.get$frame()), -aX);
        t1 = J.get$height$x(texture.get$frame());
        if (typeof aY !== "number")
          return H.iae(aY);
        h0 = J.$mul$ns(t1, 1 - aY);
        h1 = J.$mul$ns(J.get$height$x(texture.get$frame()), -aY);
      }
      index = J.$mul$ns(J.$mul$ns(this.currentBatchSize, 4), this.vertSize);
      worldTransform = sprite.get$_worldTransform();
      a = J.get$a$x(worldTransform);
      b = worldTransform.get$c();
      c = worldTransform.get$b();
      d = worldTransform.get$d();
      tx = worldTransform.get$tx();
      ty = worldTransform.get$ty();
      index0 = J.$add$ns(index, 1);
      t1 = J.getInterceptor$ns(a);
      t2 = J.getInterceptor$ns(c);
      t3 = J.getInterceptor$ax(verticies);
      t3.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h1)), tx));
      index = J.$add$ns(index0, 1);
      t4 = J.getInterceptor$ns(d);
      t5 = J.getInterceptor$ns(b);
      t3.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t4.$mul(d, h1), t5.$mul(b, w1)), ty));
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, uvs.get$x0());
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, uvs.get$y0());
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, alpha);
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, tint);
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h1)), tx));
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t4.$mul(d, h1), t5.$mul(b, w0)), ty));
      index0 = J.$add$ns(index, 1);
      t6 = J.getInterceptor$x(uvs);
      t3.$indexSet(verticies, index, t6.get$x1(uvs));
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, t6.get$y1(uvs));
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, alpha);
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, tint);
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w0), t2.$mul(c, h0)), tx));
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t4.$mul(d, h0), t5.$mul(b, w0)), ty));
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, t6.get$x2(uvs));
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, t6.get$y2(uvs));
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, alpha);
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, tint);
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w1), t2.$mul(c, h0)), tx));
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t4.$mul(d, h0), t5.$mul(b, w1)), ty));
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, uvs.get$x3());
      index = J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, uvs.get$y3());
      index0 = J.$add$ns(index, 1);
      t3.$indexSet(verticies, index, alpha);
      J.$add$ns(index0, 1);
      t3.$indexSet(verticies, index0, tint);
      t1 = J.$le$n(J.get$length$asx(this.textures), this.currentBatchSize);
      t2 = this.textures;
      if (t1)
        J.add$1$ax(t2, sprite.get$texture().get$baseTexture());
      else
        J.$indexSet$ax(t2, this.currentBatchSize, sprite.get$texture().get$baseTexture());
      t1 = J.$le$n(J.get$length$asx(this.blendModes), this.currentBatchSize);
      t2 = this.blendModes;
      if (t1)
        J.add$1$ax(t2, sprite.get$blendMode());
      else
        J.$indexSet$ax(t2, this.currentBatchSize, sprite.get$blendMode());
      this.currentBatchSize = J.$add$ns(this.currentBatchSize, 1);
    }, "call$1", "get$render", 2, 0, 877, 113, [], "render"],
    renderTilingSprite$1: [function(tilingSprite) {
      var texture, uvs, t1, t2, offsetX, offsetY, scaleX, scaleY, t3, t4, t5, alpha, tint, verticies, width, height, aX, aY, w0, w1, h0, h1, index, worldTransform, a, b, c, d, tx, ty, index0, t6;
      texture = tilingSprite.get$tilingTexture();
      if (J.$ge$n(this.currentBatchSize, this.size)) {
        this.flush$0(0);
        this.currentBaseTexture = texture.get$baseTexture();
      }
      if (tilingSprite.get$_uvs() == null)
        tilingSprite.set$_uvs(new M.TextureUvs(0, 0, 0, 0, 0, 0, 0, 0));
      uvs = tilingSprite.get$_uvs();
      t1 = tilingSprite.get$tilePosition();
      t2 = J.getInterceptor$x(t1);
      t2.set$x(t1, J.$mod$n(t2.get$x(t1), J.$mul$ns(J.get$width$x(texture.get$baseTexture()), J.get$x$x(tilingSprite.get$tileScaleOffset()))));
      t1 = tilingSprite.get$tilePosition();
      t2 = J.getInterceptor$x(t1);
      t2.set$y(t1, J.$mod$n(t2.get$y(t1), J.$mul$ns(J.get$height$x(texture.get$baseTexture()), J.get$y$x(tilingSprite.get$tileScaleOffset()))));
      offsetX = J.$div$n(J.get$x$x(tilingSprite.get$tilePosition()), J.$mul$ns(J.get$width$x(texture.get$baseTexture()), J.get$x$x(tilingSprite.get$tileScaleOffset())));
      offsetY = J.$div$n(J.get$y$x(tilingSprite.get$tilePosition()), J.$mul$ns(J.get$height$x(texture.get$baseTexture()), J.get$y$x(tilingSprite.get$tileScaleOffset())));
      t1 = J.getInterceptor$x(tilingSprite);
      scaleX = J.$div$n(J.$div$n(t1.get$width(tilingSprite), J.get$width$x(texture.get$baseTexture())), J.$mul$ns(J.get$x$x(tilingSprite.get$tileScale()), J.get$x$x(tilingSprite.get$tileScaleOffset())));
      scaleY = J.$div$n(J.$div$n(t1.get$height(tilingSprite), J.get$height$x(texture.get$baseTexture())), J.$mul$ns(J.get$y$x(tilingSprite.get$tileScale()), J.get$y$x(tilingSprite.get$tileScaleOffset())));
      if (typeof offsetX !== "number")
        return H.iae(offsetX);
      t2 = 0 - offsetX;
      uvs.set$x0(t2);
      if (typeof offsetY !== "number")
        return H.iae(offsetY);
      t3 = 0 - offsetY;
      uvs.set$y0(t3);
      if (typeof scaleX !== "number")
        return H.iae(scaleX);
      t4 = scaleX - offsetX;
      t5 = J.getInterceptor$x(uvs);
      t5.set$x1(uvs, t4);
      t5.set$y1(uvs, t3);
      t5.set$x2(uvs, t4);
      if (typeof scaleY !== "number")
        return H.iae(scaleY);
      t4 = scaleY - offsetY;
      t5.set$y2(uvs, t4);
      uvs.set$x3(t2);
      uvs.set$y3(t4);
      alpha = tilingSprite.get$_worldAlpha();
      tint = J.toDouble$0$n(tilingSprite.get$tint());
      verticies = this.vertices;
      width = t1.get$width(tilingSprite);
      height = t1.get$height(tilingSprite);
      aX = J.get$x$x(tilingSprite.get$anchor());
      aY = J.get$y$x(tilingSprite.get$anchor());
      if (typeof aX !== "number")
        return H.iae(aX);
      t1 = J.getInterceptor$ns(width);
      w0 = t1.$mul(width, 1 - aX);
      w1 = t1.$mul(width, -aX);
      if (typeof aY !== "number")
        return H.iae(aY);
      t1 = J.getInterceptor$ns(height);
      h0 = t1.$mul(height, 1 - aY);
      h1 = t1.$mul(height, -aY);
      index = J.$mul$ns(J.$mul$ns(this.currentBatchSize, 4), this.vertSize);
      worldTransform = tilingSprite.get$_worldTransform();
      a = J.get$a$x(worldTransform);
      b = worldTransform.get$c();
      c = worldTransform.get$b();
      d = worldTransform.get$d();
      tx = worldTransform.get$tx();
      ty = worldTransform.get$ty();
      index0 = J.$add$ns(index, 1);
      t1 = J.getInterceptor$ns(a);
      t4 = J.getInterceptor$ns(c);
      t2 = J.getInterceptor$ax(verticies);
      t2.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w1), t4.$mul(c, h1)), tx));
      index = J.$add$ns(index0, 1);
      t3 = J.getInterceptor$ns(d);
      t6 = J.getInterceptor$ns(b);
      t2.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t3.$mul(d, h1), t6.$mul(b, w1)), ty));
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, uvs.get$x0());
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, uvs.get$y0());
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, alpha);
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, tint);
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w0), t4.$mul(c, h1)), tx));
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t3.$mul(d, h1), t6.$mul(b, w0)), ty));
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, t5.get$x1(uvs));
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, t5.get$y1(uvs));
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, alpha);
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, tint);
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w0), t4.$mul(c, h0)), tx));
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t3.$mul(d, h0), t6.$mul(b, w0)), ty));
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, t5.get$x2(uvs));
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, t5.get$y2(uvs));
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, alpha);
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, tint);
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, J.$add$ns(J.$add$ns(t1.$mul(a, w1), t4.$mul(c, h0)), tx));
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, J.$add$ns(J.$add$ns(t3.$mul(d, h0), t6.$mul(b, w1)), ty));
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, uvs.get$x3());
      index = J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, uvs.get$y3());
      index0 = J.$add$ns(index, 1);
      t2.$indexSet(verticies, index, alpha);
      J.$add$ns(index0, 1);
      t2.$indexSet(verticies, index0, tint);
      t1 = J.$le$n(J.get$length$asx(this.textures), this.currentBatchSize);
      t2 = this.textures;
      if (t1)
        J.add$1$ax(t2, texture.get$baseTexture());
      else
        J.$indexSet$ax(t2, this.currentBatchSize, texture.get$baseTexture());
      t1 = J.$le$n(J.get$length$asx(this.blendModes), this.currentBatchSize);
      t2 = this.blendModes;
      if (t1)
        J.add$1$ax(t2, tilingSprite.get$blendMode());
      else
        J.$indexSet$ax(t2, this.currentBatchSize, tilingSprite.get$blendMode());
      this.currentBatchSize = J.$add$ns(this.currentBatchSize, 1);
    }, "call$1", "get$renderTilingSprite", 2, 0, 903, 904, [], "renderTilingSprite"],
    flush$0: [function(_) {
      var projection, t1, stride, t2, view, currentBlendMode, j, batchSize, start, currentBaseTexture, i, nextTexture, nextBlendMode;
      if (J.$eq(this.currentBatchSize, 0))
        return;
      this.renderSession.get$shaderManager().setShader$1(this.renderSession.get$shaderManager().get$defaultShader());
      if (this.dirty === true) {
        this.dirty = false;
        J.activeTexture$1$x(this.gl, 33984);
        J.bindBuffer$2$x(this.gl, 34962, this.vertexBuffer);
        J.bindBuffer$2$x(this.gl, 34963, this.indexBuffer);
        projection = this.renderSession.get$projection();
        t1 = J.getInterceptor$x(projection);
        J.uniform2f$3$x(this.gl, this.shader.get$projectionVector(), t1.get$x(projection), t1.get$y(projection));
        stride = J.$mul$ns(this.vertSize, 4);
        J.vertexAttribPointer$6$x(this.gl, this.shader.get$aVertexPosition(), 2, 5126, false, stride, 0);
        J.vertexAttribPointer$6$x(this.gl, this.shader.get$aTextureCoord(), 2, 5126, false, stride, 8);
        J.vertexAttribPointer$6$x(this.gl, this.shader.get$colorAttribute(), 2, 5126, false, stride, 16);
      }
      t1 = J.$gt$n(this.currentBatchSize, J.$mul$ns(this.size, 0.5));
      t2 = this.vertices;
      if (t1)
        J.bufferSubData$3$x(this.gl, 34962, 0, t2);
      else {
        view = J.sublist$2$ax(t2, 0, J.$mul$ns(J.$mul$ns(this.currentBatchSize, 4), this.vertSize));
        J.bufferSubData$3$x(this.gl, 34962, 0, view);
      }
      currentBlendMode = this.renderSession.get$blendModeManager().get$currentBlendMode();
      j = this.currentBatchSize;
      if (typeof j !== "number")
        return H.iae(j);
      batchSize = 0;
      start = 0;
      currentBaseTexture = null;
      i = 0;
      for (; i < j; ++i) {
        nextTexture = J.$index$asx(this.textures, i);
        nextBlendMode = J.$index$asx(this.blendModes, i);
        if (!J.$eq(currentBaseTexture, nextTexture) || !J.$eq(currentBlendMode, nextBlendMode)) {
          this.renderBatch$3(currentBaseTexture, batchSize, start);
          this.renderSession.get$blendModeManager().setBlendMode$1(nextBlendMode);
          currentBlendMode = nextBlendMode;
          currentBaseTexture = nextTexture;
          start = i;
          batchSize = 0;
        }
        ++batchSize;
      }
      this.renderBatch$3(currentBaseTexture, batchSize, start);
      this.currentBatchSize = 0;
    }, "call$0", "get$flush", 0, 0, 13, "flush"],
    renderBatch$3: [function(texture, size, startIndex) {
      var t1, t2, t3;
      t1 = J.getInterceptor(size);
      if (t1.$eq(size, 0))
        return;
      t2 = J.$index$asx(texture.get$_glTextures(), this.gl);
      t3 = this.gl;
      if (t2 != null)
        J.bindTexture$2$x(t3, 3553, J.$index$asx(texture.get$_glTextures(), this.gl));
      else
        J.bindTexture$2$x(t3, 3553, M.createWebGLTexture(texture, t3));
      if (J.$eq(J.$index$asx(texture.get$_dirty(), this.gl), true))
        M.updateWebGLTexture(this.currentBaseTexture, this.gl);
      J.drawElements$4$x(this.gl, 4, t1.$mul(size, 6), 5123, J.$mul$ns(J.$mul$ns(startIndex, 6), 2));
      t1 = this.renderSession;
      t1.set$drawCount(J.$add$ns(t1.get$drawCount(), 1));
    }, "call$3", "get$renderBatch", 6, 0, 905, 28, [], 270, [], 387, [], "renderBatch"],
    stop$0: [function(_) {
      this.flush$0(0);
    }, "call$0", "get$stop", 0, 0, 13, "stop"],
    start$0: [function(_) {
      this.dirty = true;
    }, "call$0", "get$start", 0, 0, 13, "start"],
    destroy$0: [function() {
      this.vertices = null;
      this.indices = null;
      J.deleteBuffer$1$x(this.gl, this.vertexBuffer);
      J.deleteBuffer$1$x(this.gl, this.indexBuffer);
      this.currentBaseTexture = null;
      this.gl = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    WebGLSpriteBatch$1: function(gl) {
      var t1, i, j;
      t1 = this.maxSize;
      this.size = t1;
      this.numVerts = J.$mul$ns(J.$mul$ns(t1, 4), this.vertSize);
      this.numIndices = J.$mul$ns(this.maxSize, 6);
      t1 = this.numVerts;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.vertices = new Float32Array(t1);
      t1 = this.numIndices;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.indices = new Uint16Array(t1);
      i = 0;
      j = 0;
      while (true) {
        t1 = this.numIndices;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$indexSet$ax(this.indices, i, j);
        J.$indexSet$ax(this.indices, i + 1, j + 1);
        t1 = j + 2;
        J.$indexSet$ax(this.indices, i + 2, t1);
        J.$indexSet$ax(this.indices, i + 3, j);
        J.$indexSet$ax(this.indices, i + 4, t1);
        J.$indexSet$ax(this.indices, i + 5, j + 3);
        i += 6;
        j += 4;
      }
      this.setContext$1(gl);
      this.textures = [];
      this.blendModes = [];
      this.dirty = true;
    },
    static: {WebGLSpriteBatch$: [function(gl) {
        var t1 = new M.WebGLSpriteBatch(null, 6, 6000, null, null, null, null, null, null, null, 0, false, 0, null, null, null, null, false, null, null);
        t1.WebGLSpriteBatch$1(gl);
        return t1;
      }, null, null, 2, 0, 121, 122, [], "new WebGLSpriteBatch"]}
  },
  "+WebGLSpriteBatch": [632],
  WebGLStencilManager: {
    "^": "Object;gl@-851,stencilStack@-720,reverse@-602,count@-599,maskStack@-720,_currentGraphics@-642",
    reverse$0: function() {
      return this.reverse.call$0();
    },
    setContext$1: [function(gl) {
      this.gl = gl;
    }, "call$1", "get$setContext", 2, 0, 63, 122, [], "setContext"],
    pushStencil$3: [function(graphics, webGLData, renderSession) {
      var gl, t1, level, t2;
      gl = this.gl;
      this.bindGraphics$3(graphics, webGLData, renderSession);
      if (J.$eq(J.get$length$asx(this.stencilStack), 0)) {
        t1 = J.getInterceptor$x(gl);
        t1.enable$1(gl, 2960);
        t1.clear$1(gl, 1024);
        this.reverse = true;
        this.count = 0;
      }
      J.add$1$ax(this.stencilStack, webGLData);
      level = this.count;
      t1 = J.getInterceptor$x(gl);
      t1.colorMask$4(gl, false, false, false, false);
      t1.stencilFunc$3(gl, 519, 0, 255);
      t1.stencilOp$3(gl, 7680, 7680, 5386);
      if (J.$eq(J.get$mode$x(webGLData), 1)) {
        t1.drawElements$4(gl, 6, J.$sub$n(J.get$length$asx(webGLData.get$indices()), 4), 5123, 0);
        if (this.reverse === true) {
          if (typeof level !== "number")
            return H.iae(level);
          t1.stencilFunc$3(gl, 514, 255 - level, 255);
          t1.stencilOp$3(gl, 7680, 7680, 7683);
        } else {
          t1.stencilFunc$3(gl, 514, level, 255);
          t1.stencilOp$3(gl, 7680, 7680, 7682);
        }
        t1.drawElements$4(gl, 6, 4, 5123, J.$mul$ns(J.$sub$n(J.get$length$asx(webGLData.get$indices()), 4), 2));
        t2 = J.getInterceptor$ns(level);
        if (this.reverse === true) {
          t2 = t2.$add(level, 1);
          if (typeof t2 !== "number")
            return H.iae(t2);
          t1.stencilFunc$3(gl, 514, 255 - t2, 255);
        } else
          t1.stencilFunc$3(gl, 514, t2.$add(level, 1), 255);
        this.reverse = this.reverse !== true;
      } else {
        if (this.reverse !== true) {
          if (typeof level !== "number")
            return H.iae(level);
          t1.stencilFunc$3(gl, 514, 255 - level, 255);
          t1.stencilOp$3(gl, 7680, 7680, 7683);
        } else {
          t1.stencilFunc$3(gl, 514, level, 255);
          t1.stencilOp$3(gl, 7680, 7680, 7682);
        }
        t1.drawElements$4(gl, 5, J.get$length$asx(webGLData.get$indices()), 5123, 0);
        t2 = J.getInterceptor$ns(level);
        if (this.reverse !== true) {
          t2 = t2.$add(level, 1);
          if (typeof t2 !== "number")
            return H.iae(t2);
          t1.stencilFunc$3(gl, 514, 255 - t2, 255);
        } else
          t1.stencilFunc$3(gl, 514, t2.$add(level, 1), 255);
      }
      t1.colorMask$4(gl, true, true, true, true);
      t1.stencilOp$3(gl, 7680, 7680, 7680);
      this.count = J.$add$ns(this.count, 1);
    }, "call$3", "get$pushStencil", 6, 0, 906, 103, [], 134, [], 128, [], "pushStencil"],
    bindGraphics$3: [function(graphics, webGLData, renderSession) {
      var projection, offset, t1, t2, t3, shader;
      this._currentGraphics = graphics;
      projection = renderSession.get$projection();
      offset = J.get$offset$x(renderSession);
      t1 = J.getInterceptor$x(webGLData);
      t2 = J.getInterceptor$x(projection);
      t3 = J.getInterceptor$x(offset);
      if (J.$eq(t1.get$mode(webGLData), 1)) {
        shader = renderSession.get$shaderManager().get$complexPrimativeShader();
        renderSession.get$shaderManager().setShader$1(shader);
        J.uniformMatrix3fv$3$x(this.gl, shader.get$translationMatrix(), false, graphics.get$_worldTransform().toArray$1(true));
        J.uniform2f$3$x(this.gl, shader.get$projectionVector(), t2.get$x(projection), J.$negate$n(t2.get$y(projection)));
        J.uniform2f$3$x(this.gl, shader.get$offsetVector(), J.$negate$n(t3.get$x(offset)), J.$negate$n(t3.get$y(offset)));
        J.uniform3fv$2$x(this.gl, shader.get$tintColor(), new Float32Array(H._ensureNativeList(M.hex2rgb(graphics.get$tint()))));
        t2 = J.getInterceptor$x(shader);
        J.uniform3fv$2$x(this.gl, t2.get$color(shader), new Float32Array(H._ensureNativeList(t1.get$color(webGLData))));
        J.uniform1f$2$x(this.gl, t2.get$alpha(shader), J.$mul$ns(graphics.get$_worldAlpha(), t1.get$alpha(webGLData)));
        J.bindBuffer$2$x(this.gl, 34962, t1.get$buffer(webGLData));
        J.vertexAttribPointer$6$x(this.gl, shader.get$aVertexPosition(), 2, 5126, false, 8, 0);
        J.bindBuffer$2$x(this.gl, 34963, webGLData.get$indexBuffer());
      } else {
        shader = renderSession.get$shaderManager().get$primitiveShader();
        renderSession.get$shaderManager().setShader$1(shader);
        J.uniformMatrix3fv$3$x(this.gl, shader.get$translationMatrix(), false, graphics.get$_worldTransform().toArray$1(true));
        J.uniform2f$3$x(this.gl, shader.get$projectionVector(), t2.get$x(projection), J.$negate$n(t2.get$y(projection)));
        J.uniform2f$3$x(this.gl, shader.get$offsetVector(), J.$negate$n(t3.get$x(offset)), J.$negate$n(t3.get$y(offset)));
        J.uniform3fv$2$x(this.gl, shader.get$tintColor(), new Float32Array(H._ensureNativeList(M.hex2rgb(graphics.get$tint()))));
        J.uniform1f$2$x(this.gl, J.get$alpha$x(shader), graphics.get$_worldAlpha());
        J.bindBuffer$2$x(this.gl, 34962, t1.get$buffer(webGLData));
        J.vertexAttribPointer$6$x(this.gl, shader.get$aVertexPosition(), 2, 5126, false, 24, 0);
        J.vertexAttribPointer$6$x(this.gl, shader.get$colorAttribute(), 4, 5126, false, 24, 8);
        J.bindBuffer$2$x(this.gl, 34963, webGLData.get$indexBuffer());
      }
    }, "call$3", "get$bindGraphics", 6, 0, 906, 103, [], 134, [], 128, [], "bindGraphics"],
    popStencil$3: [function(graphics, webGLData, renderSession) {
      var gl, t1, level, t2, t3;
      gl = this.gl;
      J.removeLast$0$ax(this.stencilStack);
      this.count = J.$sub$n(this.count, 1);
      t1 = J.getInterceptor$x(gl);
      if (J.$eq(J.get$length$asx(this.stencilStack), 0))
        t1.disable$1(gl, 2960);
      else {
        level = this.count;
        this.bindGraphics$3(graphics, webGLData, renderSession);
        t1.colorMask$4(gl, false, false, false, false);
        if (J.$eq(J.get$mode$x(webGLData), 1)) {
          t2 = this.reverse !== true;
          this.reverse = t2;
          t3 = J.getInterceptor$ns(level);
          if (t2) {
            t2 = t3.$add(level, 1);
            if (typeof t2 !== "number")
              return H.iae(t2);
            t1.stencilFunc$3(gl, 514, 255 - t2, 255);
            t1.stencilOp$3(gl, 7680, 7680, 7682);
          } else {
            t1.stencilFunc$3(gl, 514, t3.$add(level, 1), 255);
            t1.stencilOp$3(gl, 7680, 7680, 7683);
          }
          t1.drawElements$4(gl, 6, 4, 5123, J.$mul$ns(J.$sub$n(J.get$length$asx(webGLData.get$indices()), 4), 2));
          t1.stencilFunc$3(gl, 519, 0, 255);
          t1.stencilOp$3(gl, 7680, 7680, 5386);
          t1.drawElements$4(gl, 6, J.$sub$n(J.get$length$asx(webGLData.get$indices()), 4), 5123, 0);
          if (this.reverse !== true) {
            if (typeof level !== "number")
              return H.iae(level);
            t1.stencilFunc$3(gl, 514, 255 - level, 255);
          } else
            t1.stencilFunc$3(gl, 514, level, 255);
        } else {
          t2 = J.getInterceptor$ns(level);
          if (this.reverse !== true) {
            t2 = t2.$add(level, 1);
            if (typeof t2 !== "number")
              return H.iae(t2);
            t1.stencilFunc$3(gl, 514, 255 - t2, 255);
            t1.stencilOp$3(gl, 7680, 7680, 7682);
          } else {
            t1.stencilFunc$3(gl, 514, t2.$add(level, 1), 255);
            t1.stencilOp$3(gl, 7680, 7680, 7683);
          }
          t1.drawElements$4(gl, 5, J.get$length$asx(webGLData.get$indices()), 5123, 0);
          if (this.reverse !== true) {
            if (typeof level !== "number")
              return H.iae(level);
            t1.stencilFunc$3(gl, 514, 255 - level, 255);
          } else
            t1.stencilFunc$3(gl, 514, level, 255);
        }
        t1.colorMask$4(gl, true, true, true, true);
        t1.stencilOp$3(gl, 7680, 7680, 7680);
      }
    }, "call$3", "get$popStencil", 6, 0, 117, 103, [], 134, [], 128, [], "popStencil"],
    destroy$0: [function() {
      this.maskStack = null;
      this.gl = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    WebGLStencilManager$1: function(gl) {
      this.stencilStack = [];
      this.gl = this.gl;
      this.reverse = true;
      this.count = 0;
    },
    static: {WebGLStencilManager$: [function(gl) {
        var t1 = new M.WebGLStencilManager(gl, null, null, null, null, null);
        t1.WebGLStencilManager$1(gl);
        return t1;
      }, null, null, 2, 0, 121, 122, [], "new WebGLStencilManager"]}
  },
  "+WebGLStencilManager": [632],
  WebGLRenderer: {
    "^": "Renderer;type-599,transparent-602,antialias-602,preserveDrawingBuffer-602,width-601,height-601,view-808,projection-634,offset-634,contextLost-602,options-754,gl-851,shaderManager-852,spriteBatch-853,maskManager-854,filterManager-855,stencilManager-856,blendModeManager-857,renderSession-858,__stage-638",
    render$1: [function(stage) {
      var t1, t2;
      if (this.contextLost === true)
        return;
      if (!J.$eq(this.__stage, stage)) {
        if (stage.get$interactive() === true)
          stage.get$interactionManager().removeEvents$0();
        this.__stage = stage;
      }
      M.WebGLRenderer_updateTextures(this.gl);
      stage.updateTransform$0();
      J.viewport$4$x(this.gl, 0, 0, this.width, this.height);
      J.bindFramebuffer$2$x(this.gl, 36160, null);
      t1 = J.$eq(this.transparent, true);
      t2 = this.gl;
      if (t1)
        J.clearColor$4$x(t2, 0, 0, 0, 0);
      else
        J.clearColor$4$x(t2, J.$index$asx(stage.get$backgroundColorSplit(), 0), J.$index$asx(stage.get$backgroundColorSplit(), 1), J.$index$asx(stage.get$backgroundColorSplit(), 2), 1);
      J.clear$1$ax(this.gl, 16384);
      this.renderDisplayObject$2(stage, this.projection);
      if (stage.get$interactive() === true) {
        if (stage.get$_interactiveEventsAdded() !== true) {
          stage.set$_interactiveEventsAdded(true);
          stage.get$interactionManager().setTarget$1(this);
        }
      } else if (stage.get$_interactiveEventsAdded() === true) {
        stage.set$_interactiveEventsAdded(false);
        stage.get$interactionManager().setTarget$1(this);
      }
    }, "call$1", "get$render", 2, 0, 92, 93, [], "render"],
    renderDisplayObject$3: [function(displayObject, projection, buffer) {
      this.renderSession.get$blendModeManager().setBlendMode$1(C.BlendModes_0);
      this.renderSession.set$drawCount(0);
      this.renderSession.set$currentBlendMode(C.BlendModes_99999);
      this.renderSession.set$projection(projection);
      J.set$offset$x(this.renderSession, this.offset);
      this.spriteBatch.begin$1(this.renderSession);
      this.filterManager.begin$2(this.renderSession, buffer);
      displayObject._renderWebGL$1(this.renderSession);
      this.spriteBatch.end$0();
    }, function(displayObject, projection) {
      return this.renderDisplayObject$3(displayObject, projection, null);
    }, "renderDisplayObject$2", function(displayObject) {
      return this.renderDisplayObject$3(displayObject, null, null);
    }, "renderDisplayObject$1", "call$3", "call$2", "call$1", "get$renderDisplayObject", 2, 4, 907, 32, 32, 805, [], 908, [], 860, [], "renderDisplayObject"],
    resize$2: [function(_, width, height) {
      var t1;
      window;
      if (typeof console != "undefined")
        console.log(width);
      this.width = width;
      this.height = height;
      J.set$width$x(this.view, width);
      J.set$height$x(this.view, height);
      t1 = this.gl;
      if (t1 != null)
        J.viewport$4$x(t1, 0, 0, this.width, this.height);
      J.set$x$x(this.projection, J.$div$n(this.width, 2));
      J.set$y$x(this.projection, J.$div$n(J.$negate$n(this.height), 2));
    }, "call$2", "get$resize", 4, 0, 909, 10, [], 11, [], "resize"],
    handleContextLost$1: [function($event) {
      J.preventDefault$0$x($event);
      this.contextLost = true;
    }, "call$1", "get$handleContextLost", 2, 0, 63, 815, [], "handleContextLost"],
    handleContextRestored$1: [function($event) {
      var exception, gl, t1, key;
      try {
        this.gl = J.getContext$2$x(this.view, "experimental-webgl", this.options);
      } catch (exception) {
        H.unwrapException(exception);
        try {
          this.gl = J.getContext$2$x(this.view, "webgl", this.options);
        } catch (exception) {
          H.unwrapException(exception);
          throw H.wrapException(P.Exception_Exception(" This browser does not support webGL. Try using the canvas renderer this"));
        }

      }

      gl = this.gl;
      this.shaderManager.setContext$1(gl);
      this.spriteBatch.setContext$1(gl);
      this.maskManager.setContext$1(gl);
      this.filterManager.setContext$1(gl);
      this.renderSession.set$gl(this.gl);
      t1 = J.getInterceptor$x(gl);
      t1.disable$1(gl, 2929);
      t1.disable$1(gl, 2884);
      t1.enable$1(gl, 3042);
      t1.colorMask$4(gl, true, true, true, this.transparent);
      J.viewport$4$x(this.gl, 0, 0, this.width, this.height);
      for (t1 = J.get$iterator$ax(J.get$keys$x($.get$TextureCache())); t1.moveNext$0();) {
        key = t1.get$current();
        J.$index$asx($.get$TextureCache(), key).get$baseTexture().set$_glTextures(P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      }
      this.contextLost = false;
    }, "call$1", "get$handleContextRestored", 2, 0, 63, 815, [], "handleContextRestored"],
    destroy$0: [function() {
      J.removeEventListener$2$x(this.view, "webglcontextlost", this.get$handleContextLost());
      J.removeEventListener$2$x(this.view, "webglcontextrestored", this.get$handleContextRestored());
      J.remove$1$ax($.get$glContexts(), this.gl);
      this.projection = null;
      this.offset = null;
      this.shaderManager.destroy$0();
      this.spriteBatch.destroy$0();
      this.maskManager.destroy$0();
      this.filterManager.destroy$0();
      this.shaderManager = null;
      this.spriteBatch = null;
      this.maskManager = null;
      this.filterManager = null;
      this.gl = null;
      this.renderSession = null;
    }, "call$0", "get$destroy", 0, 0, 550, "destroy"],
    WebGLRenderer$6: function(width, height, view, transparent, antialias, preserveDrawingBuffer) {
      var t1, exception, t2;
      if ($.defaultRenderer == null)
        $.defaultRenderer = this;
      this.type = 0;
      this.width = J.toInt$0$n(width);
      this.height = J.toInt$0$n(height);
      this.transparent = transparent;
      this.antialias = antialias;
      this.preserveDrawingBuffer = preserveDrawingBuffer;
      if (view == null)
        view = W.CanvasElement_CanvasElement(null, null);
      this.view = view;
      J.set$width$x(view, this.width);
      J.set$height$x(this.view, this.height);
      t1 = J.get$onWebGlContextLost$x(this.view);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$handleContextLost()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = J.get$onWebGlContextRestored$x(this.view);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$handleContextRestored()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = P.LinkedHashMap_LinkedHashMap$_literal(["alpha", this.transparent, "antialias", this.antialias, "premultipliedAlpha", transparent, "stencil", true, "preserveDrawingBuffer", preserveDrawingBuffer], null, null);
      this.options = t1;
      try {
        this.gl = J.getContext$2$x(this.view, "experimental-webgl", t1);
      } catch (exception) {
        H.unwrapException(exception);
        try {
          this.gl = J.getContext$2$x(this.view, "webgl", this.options);
        } catch (exception) {
          H.unwrapException(exception);
          throw H.wrapException(P.Exception_Exception(" This browser does not support webGL. Try using the canvas renderer " + this.toString$0(0)));
        }

      }

      J.add$1$ax($.get$glContexts(), this.gl);
      if ($.blendModesWebGL == null) {
        t1 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        $.blendModesWebGL = t1;
        t1.$indexSet(0, C.BlendModes_0, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_1, [770, 772]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_2, [774, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_3, [770, 1]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_4, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_5, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_6, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_7, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_8, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_9, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_10, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_11, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_12, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_13, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_14, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_15, [1, 771]);
        J.$indexSet$ax($.blendModesWebGL, C.BlendModes_16, [1, 771]);
      }
      t1 = new M.Point0(null, null);
      t1.x = 0;
      t1.y = 0;
      this.projection = t1;
      t1.x = J.$div$n(this.width, 2);
      J.set$y$x(this.projection, J.$div$n(J.$negate$n(this.height), 2));
      t1 = new M.Point0(null, null);
      t1.x = 0;
      t1.y = 0;
      this.offset = t1;
      this.resize$2(0, this.width, this.height);
      this.contextLost = false;
      this.shaderManager = M.WebGLShaderManager$(this.gl);
      this.spriteBatch = M.WebGLSpriteBatch$(this.gl);
      t1 = new M.WebGLMaskManager([], 0, null, null, null);
      t1.WebGLMaskManager$1(this.gl);
      this.maskManager = t1;
      t1 = this.gl;
      t2 = new M.WebGLFilterManager(null, this.transparent, [], 0, 0, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2.setContext$1(t1);
      this.filterManager = t2;
      t2 = this.gl;
      t1 = new M.WebGLStencilManager(t2, null, null, null, null, null);
      t1.WebGLStencilManager$1(t2);
      this.stencilManager = t1;
      t1 = this.gl;
      t2 = new M.WebGLBlendModeManager(t1, null);
      t2.currentBlendMode = C.BlendModes_99999;
      this.blendModeManager = t2;
      t2 = new M.RenderSession(null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null);
      this.renderSession = t2;
      t2.gl = t1;
      this.renderSession.set$drawCount(0);
      this.renderSession.set$shaderManager(this.shaderManager);
      this.renderSession.set$maskManager(this.maskManager);
      this.renderSession.set$filterManager(this.filterManager);
      this.renderSession.set$blendModeManager(this.blendModeManager);
      this.renderSession.set$spriteBatch(this.spriteBatch);
      this.renderSession.set$stencilManager(this.stencilManager);
      this.renderSession.set$renderer(this);
      J.useProgram$1$x(this.gl, this.shaderManager.get$defaultShader().get$program());
      J.disable$1$x(this.gl, 2929);
      J.disable$1$x(this.gl, 2884);
      J.enable$1$x(this.gl, 3042);
      J.colorMask$4$x(this.gl, true, true, true, this.transparent);
    },
    static: {WebGLRenderer$: [function(width, height, view, transparent, antialias, preserveDrawingBuffer) {
        var t1 = new M.WebGLRenderer(0, false, false, false, 100, 100, null, null, null, false, null, null, null, null, null, null, null, null, null, null);
        t1.WebGLRenderer$6(width, height, view, transparent, antialias, preserveDrawingBuffer);
        return t1;
      }, null, null, 0, 12, 149, 106, 107, 32, 95, 95, 95, 10, [], 11, [], 108, [], 109, [], 110, [], 150, [], "new WebGLRenderer"], WebGLRenderer_updateTextures: [function(gl) {
        var i, t1;
        i = 0;
        while (true) {
          t1 = J.get$length$asx($.get$Texture_frameUpdates());
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          J.$index$asx($.get$Texture_frameUpdates(), i)._updateWebGLuvs$0();
          ++i;
        }
        i = 0;
        while (true) {
          t1 = J.get$length$asx($.get$texturesToDestroy());
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          M.WebGLRenderer_destroyTexture(J.$index$asx($.get$texturesToDestroy(), i), gl);
          ++i;
        }
        J.set$length$asx($.get$texturesToUpdate(), 0);
        J.set$length$asx($.get$texturesToDestroy(), 0);
        J.set$length$asx($.get$Texture_frameUpdates(), 0);
      }, "call$1", "WebGLRenderer_updateTextures$closure", 2, 0, 151, 122, [], "updateTextures"], WebGLRenderer_destroyTexture: [function(texture, gl) {
        var t1, t2;
        for (t1 = J.get$iterator$ax(J.get$values$x(texture.get$_glTextures())), t2 = J.getInterceptor$x(gl); t1.moveNext$0();)
          t2.deleteTexture$1(gl, t1.get$current());
        J.clear$0$ax(texture.get$_glTextures());
      }, "call$2", "WebGLRenderer_destroyTexture$closure", 4, 0, 152, 28, [], 122, [], "destroyTexture"], WebGLRenderer_updateTextureFrame: [function(texture) {
        texture._updateWebGLuvs$0();
      }, "call$1", "WebGLRenderer_updateTextureFrame$closure", 2, 0, 27, 28, [], "updateTextureFrame"]}
  },
  "+WebGLRenderer": [809],
  ChartData: {
    "^": "Object;font*-639,size*-601,lineHeight*-601,chars@-754",
    size$1: function($receiver, arg0) {
      return this.size.call$1(arg0);
    },
    static: {ChartData$: [function() {
        return new M.ChartData(null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      }, null, null, 0, 0, 153, "new ChartData"]}
  },
  "+ChartData": [632],
  Char: {
    "^": "Object;texture@-670,line@-599,charCode*-599,position*-634,xOffset@-599,yOffset@-599,xAdvance@-599,kernings@-754",
    line$1: function(arg0) {
      return this.line.call$1(arg0);
    },
    static: {Char$: [function() {
        return new M.Char(null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      }, null, null, 0, 0, 154, "new Char"]}
  },
  "+Char": [632],
  BitmapText: {
    "^": "DisplayObjectContainer;text*-639,_style@-910,_pool@-720,_dirty:PIXI$BitmapText$_dirty@-602,tint@-599,fontName@-639,fontSize*-601,_textWidth@-601,_textHeight@-601,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    text$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.text.call$4(arg0, arg1, arg2, arg3);
    },
    text$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.text.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    text$3: function($receiver, arg0, arg1, arg2) {
      return this.text.call$3(arg0, arg1, arg2);
    },
    get$style: [function(_) {
      return this._style;
    }, null, null, 1, 0, 911, "style"],
    get$textWidth: [function() {
      return this._textWidth;
    }, null, null, 1, 0, 604, "textWidth"],
    get$textHeight: [function() {
      return this._textHeight;
    }, null, null, 1, 0, 604, "textHeight"],
    setText$1: [function(text) {
      this.set$text(0, text);
      this.PIXI$BitmapText$_dirty = true;
    }, "call$1", "get$setText", 2, 0, 63, 85, [], "setText"],
    setStyle$1: [function(style) {
      var font, t1, t2;
      this._style = style;
      font = J.split$1$s(J.get$font$x(style), " ");
      t1 = font.length;
      t2 = t1 - 1;
      if (t2 < 0)
        return H.ioore(font, t2);
      t2 = font[t2];
      this.fontName = t2;
      this.set$fontSize(0, t1 >= 2 ? H.Primitives_parseInt(J.replaceAll$2$s(font[t1 - 2], $.get$BitmapText__numReg(), ""), null, null) : J.get$size$x(J.$index$asx($.get$BitmapText_fonts(), t2)));
      this.PIXI$BitmapText$_dirty = true;
      this.set$tint(style.get$tint());
    }, "call$1", "get$setStyle", 2, 0, 912, 156, [], "setStyle"],
    updateText$0: [function() {
      var data, pos, chars, lineWidths, t1, scale, prevCharCode, maxLineWidth, line, i, t2, charCode, charData, t3, t4, t5, lineAlignOffsets, alignOffset, lenChildren, lenChars, tint, c, t6, t7, child;
      data = J.$index$asx($.get$BitmapText_fonts(), this.fontName);
      pos = new M.Point0(null, null);
      pos.x = 0;
      pos.y = 0;
      chars = [];
      lineWidths = [];
      t1 = J.getInterceptor$x(data);
      scale = J.$div$n(this.get$fontSize(this), t1.get$size(data));
      prevCharCode = null;
      maxLineWidth = 0;
      line = 0;
      i = 0;
      while (true) {
        t2 = J.get$length$asx(this.get$text(this));
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        c$0: {
          charCode = J.codeUnitAt$1$s(this.get$text(this), i);
          if (J.$eq(J.$index$asx(this.get$text(this), i), "\n") || J.$eq(J.$index$asx(this.get$text(this), i), "\r") || J.$eq(J.$index$asx(this.get$text(this), i), "\r\n")) {
            lineWidths.push(pos.x);
            maxLineWidth = P.max(maxLineWidth, pos.x);
            ++line;
            pos.x = 0;
            pos.y = J.$add$ns(pos.y, t1.get$lineHeight(data));
            prevCharCode = null;
            break c$0;
          }
          charData = J.$index$asx(data.get$chars(), charCode);
          if (charData == null)
            break c$0;
          if (prevCharCode != null && J.containsKey$1$x(charData.get$kernings(), prevCharCode) === true)
            pos.x = J.$add$ns(pos.x, J.$index$asx(charData.get$kernings(), prevCharCode));
          t2 = new M.Char(null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
          t2.texture = charData.get$texture();
          t2.line = line;
          t2.charCode = charCode;
          t3 = J.$add$ns(pos.x, charData.get$xOffset());
          t4 = J.$add$ns(pos.y, charData.get$yOffset());
          t5 = new M.Point0(null, null);
          t5.x = t3;
          t5.y = t4;
          t2.position = t5;
          chars.push(t2);
          pos.x = J.$add$ns(pos.x, charData.get$xAdvance());
          prevCharCode = charCode;
        }
        ++i;
      }
      lineWidths.push(pos.x);
      maxLineWidth = P.max(maxLineWidth, pos.x);
      lineAlignOffsets = [];
      for (i = 0; i <= line; ++i) {
        if (J.$eq(this._style.get$align(), "right")) {
          if (i >= lineWidths.length)
            return H.ioore(lineWidths, i);
          t2 = lineWidths[i];
          if (typeof t2 !== "number")
            return H.iae(t2);
          alignOffset = maxLineWidth - t2;
        } else if (J.$eq(this._style.get$align(), "center")) {
          if (i >= lineWidths.length)
            return H.ioore(lineWidths, i);
          t2 = lineWidths[i];
          if (typeof t2 !== "number")
            return H.iae(t2);
          alignOffset = (maxLineWidth - t2) / 2;
        } else
          alignOffset = 0;
        lineAlignOffsets.push(alignOffset);
      }
      lenChildren = J.get$length$asx(this.get$children(this));
      lenChars = chars.length;
      tint = this.get$tint();
      for (i = 0; i < lenChars; ++i) {
        if (typeof lenChildren !== "number")
          return H.iae(lenChildren);
        c = i < lenChildren ? J.$index$asx(this.get$children(this), i) : null;
        if (c == null && J.$gt$n(J.get$length$asx(this._pool), 0))
          c = J.removeLast$0$ax(this._pool);
        t2 = chars.length;
        t3 = chars[i];
        if (c != null) {
          if (i >= t2)
            return H.ioore(chars, i);
          c.setTexture$1(t3.texture);
        } else {
          if (i >= t2)
            return H.ioore(chars, i);
          t2 = t3.texture;
          t3 = new M.Point0(null, null);
          t3.x = 0;
          t3.y = 0;
          t4 = new M.Point0(null, null);
          t4.x = 0;
          t4.y = 0;
          t5 = new M.Point0(null, null);
          t5.x = 1;
          t5.y = 1;
          t6 = new M.Point0(null, null);
          t6.x = 0;
          t6.y = 0;
          t7 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
          c = new M.Sprite(t3, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t4, t5, t6, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t7, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
          c.texture = t2;
          if (t2.get$baseTexture().get$hasLoaded() === true)
            c._onTextureUpdate$1(null);
          else
            J.addEventListener$2$x(t2, "update", c.get$_onTextureUpdate());
        }
        t2 = J.getInterceptor$x(c);
        t3 = t2.get$position(c);
        if (i >= chars.length)
          return H.ioore(chars, i);
        t4 = J.get$x$x(chars[i].position);
        if (i >= chars.length)
          return H.ioore(chars, i);
        t5 = chars[i].line;
        if (t5 >>> 0 !== t5 || t5 >= lineAlignOffsets.length)
          return H.ioore(lineAlignOffsets, t5);
        J.set$x$x(t3, J.$mul$ns(J.$add$ns(t4, lineAlignOffsets[t5]), scale));
        t5 = t2.get$position(c);
        if (i >= chars.length)
          return H.ioore(chars, i);
        J.set$y$x(t5, J.$mul$ns(J.get$y$x(chars[i].position), scale));
        t5 = t2.get$scale(c);
        J.set$y$x(t2.get$scale(c), scale);
        J.set$x$x(t5, scale);
        c.set$tint(tint);
        if (c.get$_parent() == null)
          this.addChildAt$2(c, J.get$length$asx(this.get$children(this)));
      }
      for (; J.$gt$n(J.get$length$asx(this.get$children(this)), lenChars);) {
        child = this.getChildAt$1(J.$sub$n(J.get$length$asx(this.get$children(this)), 1));
        J.add$1$ax(this._pool, child);
        this.removeChildAt$1(J.indexOf$1$asx(this.get$children(this), child));
      }
      if (typeof scale !== "number")
        return H.iae(scale);
      this._textWidth = maxLineWidth * scale;
      this._textHeight = J.$mul$ns(J.$add$ns(pos.y, t1.get$lineHeight(data)), scale);
    }, "call$0", "get$updateText", 0, 0, 13, "updateText"],
    updateTransform$0: [function() {
      if (this.PIXI$BitmapText$_dirty === true) {
        this.updateText$0();
        this.PIXI$BitmapText$_dirty = false;
      }
      M.DisplayObjectContainer.prototype.updateTransform$0.call(this);
    }, "call$0", "get$updateTransform", 0, 0, 13, "updateTransform"],
    BitmapText$2: function(text, style) {
      this.set$text(0, text);
      if (style == null)
        style = M.TextStyle$0("left", "black", "bold 20pt Arial", "black", 0, 16777215);
      this._style = style;
      this._pool = [];
      this.set$text(0, text);
      this.PIXI$BitmapText$_dirty = true;
      this.setStyle$1(style);
      this.updateText$0();
      this.PIXI$BitmapText$_dirty = false;
    },
    static: {"^": "BitmapText_fonts@-754,BitmapText__charCodeReg@-785,BitmapText__numReg@-785", BitmapText$0: [function(text, style) {
        var t1, t2, t3, t4;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 1;
        t2.y = 1;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new M.BitmapText(null, null, null, null, 16777215, null, null, null, null, [], false, 0, 0, t1, t2, t3, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t4, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.BitmapText$2(text, style);
        return t1;
      }, null, null, 2, 2, 155, 32, 85, [], 156, [], "new BitmapText"]}
  },
  "+BitmapText": [678],
  TextStyle: {
    "^": "Object;fill*-639,font*-639,align@-639,stroke*-639,strokeThickness@-601,wordWrap*-602,wordWrapWidth@-601,dropShadow@-602,dropShadowAngle@-601,dropShadowDistance@-601,dropShadowColor@-639,tint@-601",
    fill$0: function($receiver) {
      return this.fill.call$0();
    },
    fill$6: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5) {
      return this.fill.call$6(arg0, arg1, arg2, arg3, arg4, arg5);
    },
    fill$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.fill.call$4(arg0, arg1, arg2, arg3);
    },
    stroke$0: function($receiver) {
      return this.stroke.call$0();
    },
    wordWrap$1: function($receiver, arg0) {
      return this.wordWrap.call$1(arg0);
    },
    TextStyle$6$align$fill$font$stroke$strokeThickness$tint: function(align, fill, font, stroke, strokeThickness, tint) {
      this.fill = fill;
      this.font = font;
      this.align = align;
      this.stroke = stroke;
      this.strokeThickness = strokeThickness;
      this.tint = tint;
    },
    static: {TextStyle$0: [function(align, fill, font, stroke, strokeThickness, tint) {
        var t1 = new M.TextStyle("black", "bold 20pt Arial", "left", "black", 0, false, 100, false, 0.5235987755982988, 4, "black", 16777215);
        t1.TextStyle$6$align$fill$font$stroke$strokeThickness$tint(align, fill, font, stroke, strokeThickness, tint);
        return t1;
      }, null, null, 0, 13, 157, 158, 159, 160, 158, 5, 161, 162, [], 163, [], 164, [], 165, [], 166, [], 167, [], "new TextStyle"]}
  },
  "+TextStyle": [632],
  Text: {
    "^": "Sprite;_PIXI$_text@-639,_style@-910,_canvas@-808,_context@-850,_dirty:PIXI$Text$_dirty@-602,_requiresUpdate@-602,anchor-634,texture-670,updateFrame-602,PIXI$Sprite$_width-601,PIXI$Sprite$_height-601,_uvs-671,tintedTexture-672,buffer-673,tint-599,cachedTint-599,blendMode-674,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    get$style: [function(_) {
      return this._style;
    }, null, null, 1, 0, 911, "style"],
    get$canvas: [function(_) {
      return this._canvas;
    }, null, null, 1, 0, 913, "canvas"],
    get$context: [function(_) {
      return this._context;
    }, null, null, 1, 0, 914, "context"],
    get$text: [function(_) {
      return this._PIXI$_text;
    }, null, null, 1, 0, 782, "text"],
    text$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.get$text(this).call$4(arg0, arg1, arg2, arg3);
    },
    text$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.get$text(this).call$5(arg0, arg1, arg2, arg3, arg4);
    },
    text$3: function($receiver, arg0, arg1, arg2) {
      return this.get$text(this).call$3(arg0, arg1, arg2);
    },
    set$text: [function(_, value) {
      this._PIXI$_text = J.toString$0(value);
      this.PIXI$Text$_dirty = true;
    }, null, null, 3, 0, 52, 100, [], "text"],
    setStyle$1: [function(style) {
      this._style = style;
      this.PIXI$Text$_dirty = true;
    }, "call$1", "get$setStyle", 2, 0, 912, 156, [], "setStyle"],
    setText$1: [function(text) {
      this._PIXI$_text = J.toString$0(text);
      this.PIXI$Text$_dirty = true;
    }, "call$1", "get$setText", 2, 0, 915, 85, [], "setText"],
    get$width: [function(_) {
      if (this.PIXI$Text$_dirty === true) {
        this.updateText$0();
        this.PIXI$Text$_dirty = false;
      }
      return J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.texture.get$frame()));
    }, null, null, 1, 0, 604, "width"],
    set$width: [function(_, value) {
      J.set$x$x(this.scale, J.$div$n(value, J.get$width$x(this.texture.get$frame())));
      this.PIXI$Sprite$_width = value;
    }, null, null, 3, 0, 605, 100, [], "width"],
    get$height: [function(_) {
      if (this.PIXI$Text$_dirty === true) {
        this.updateText$0();
        this.PIXI$Text$_dirty = false;
      }
      return J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.texture.get$frame()));
    }, null, null, 1, 0, 604, "height"],
    set$height: [function(_, value) {
      J.set$y$x(this.scale, J.$div$n(value, J.get$height$x(this.texture.get$frame())));
      this.PIXI$Sprite$_height = value;
    }, null, null, 3, 0, 605, 100, [], "height"],
    updateText$0: [function() {
      var outputText, lines, lineWidths, t1, maxLineWidth, i, lineWidth, t2, width, t3, lineHeight, height, xShadowOffset, yShadowOffset, linePositionX, linePositionY;
      J.set$font$x(this._context, J.get$font$x(this.get$style(this)));
      outputText = this.get$text(this);
      if (J.get$wordWrap$x(this.get$style(this)) === true)
        outputText = this.wordWrap$1(0, this.get$text(this));
      lines = J.split$1$s(outputText, $.get$Text_splitReg());
      lineWidths = H.setRuntimeTypeInfo(Array(lines.length), [P.num]);
      for (t1 = lineWidths.length, maxLineWidth = 0, i = 0; i < lines.length; ++i) {
        lineWidth = J.measureText$1$x(this._context, lines[i]).width;
        if (i >= t1)
          return H.ioore(lineWidths, i);
        lineWidths[i] = lineWidth;
        maxLineWidth = P.max(maxLineWidth, lineWidth);
      }
      t2 = this.get$style(this).get$strokeThickness();
      if (typeof t2 !== "number")
        return H.iae(t2);
      width = maxLineWidth + t2;
      if (this.get$style(this).get$dropShadow() === true) {
        t2 = this.get$style(this).get$dropShadowDistance();
        if (typeof t2 !== "number")
          return H.iae(t2);
        width += t2;
      }
      t2 = this._canvas;
      t3 = J.get$lineWidth$x(this._context);
      if (typeof t3 !== "number")
        return H.iae(t3);
      J.set$width$x(t2, C.JSNumber_methods.toInt$0(Math.floor(width + t3)));
      lineHeight = J.$add$ns(this.determineFontHeight$1(C.JSString_methods.$add("font: ", J.get$font$x(this.get$style(this))) + ";"), this.get$style(this).get$strokeThickness());
      height = J.$mul$ns(lineHeight, lines.length);
      if (this.get$style(this).get$dropShadow() === true)
        height = J.$add$ns(height, this.get$style(this).get$dropShadowDistance());
      J.set$height$x(this._canvas, height);
      J.set$font$x(this._context, J.get$font$x(this.get$style(this)));
      J.set$strokeStyle$x(this._context, J.get$stroke$x(this.get$style(this)));
      J.set$lineWidth$x(this._context, this.get$style(this).get$strokeThickness());
      J.set$textBaseline$x(this._context, "top");
      if (this.get$style(this).get$dropShadow() === true) {
        J.set$fillStyle$x(this._context, this.get$style(this).get$dropShadowColor());
        t2 = this.get$style(this).get$dropShadowAngle();
        if (typeof t2 !== "number")
          H.throwExpression(P.ArgumentError$(t2));
        t2 = Math.sin(t2);
        t3 = this.get$style(this).get$dropShadowDistance();
        if (typeof t3 !== "number")
          return H.iae(t3);
        xShadowOffset = t2 * t3;
        t3 = this.get$style(this).get$dropShadowAngle();
        if (typeof t3 !== "number")
          H.throwExpression(P.ArgumentError$(t3));
        t2 = Math.cos(t3);
        t3 = this.get$style(this).get$dropShadowDistance();
        if (typeof t3 !== "number")
          return H.iae(t3);
        yShadowOffset = t2 * t3;
        for (i = 0; i < lines.length; ++i) {
          linePositionX = J.$div$n(this.get$style(this).get$strokeThickness(), 2);
          t2 = J.$div$n(this.get$style(this).get$strokeThickness(), 2);
          if (typeof lineHeight !== "number")
            return H.iae(lineHeight);
          linePositionY = J.$add$ns(t2, i * lineHeight);
          if (J.$eq(this.get$style(this).get$align(), "right")) {
            if (i >= t1)
              return H.ioore(lineWidths, i);
            t2 = lineWidths[i];
            if (typeof t2 !== "number")
              return H.iae(t2);
            linePositionX = J.$add$ns(linePositionX, maxLineWidth - t2);
          } else if (J.$eq(this.get$style(this).get$align(), "center")) {
            if (i >= t1)
              return H.ioore(lineWidths, i);
            t2 = lineWidths[i];
            if (typeof t2 !== "number")
              return H.iae(t2);
            linePositionX = J.$add$ns(linePositionX, (maxLineWidth - t2) / 2);
          }
          if (J.get$fill$x(this.get$style(this)) != null) {
            t2 = this._context;
            if (i >= lines.length)
              return H.ioore(lines, i);
            J.fillText$3$x(t2, lines[i], J.$add$ns(linePositionX, xShadowOffset), J.$add$ns(linePositionY, yShadowOffset));
          }
        }
      }
      J.set$fillStyle$x(this._context, J.get$fill$x(this.get$style(this)));
      for (i = 0; i < lines.length; ++i) {
        linePositionX = J.$div$n(this.get$style(this).get$strokeThickness(), 2);
        t2 = J.$div$n(this.get$style(this).get$strokeThickness(), 2);
        if (typeof lineHeight !== "number")
          return H.iae(lineHeight);
        linePositionY = J.$add$ns(t2, i * lineHeight);
        if (J.$eq(this.get$style(this).get$align(), "right")) {
          if (i >= t1)
            return H.ioore(lineWidths, i);
          t2 = lineWidths[i];
          if (typeof t2 !== "number")
            return H.iae(t2);
          linePositionX = J.$add$ns(linePositionX, maxLineWidth - t2);
        } else if (J.$eq(this.get$style(this).get$align(), "center")) {
          if (i >= t1)
            return H.ioore(lineWidths, i);
          t2 = lineWidths[i];
          if (typeof t2 !== "number")
            return H.iae(t2);
          linePositionX = J.$add$ns(linePositionX, (maxLineWidth - t2) / 2);
        }
        if (J.get$stroke$x(this.get$style(this)) != null && !J.$eq(this.get$style(this).get$strokeThickness(), 0)) {
          t2 = this._context;
          if (i >= lines.length)
            return H.ioore(lines, i);
          J.strokeText$3$x(t2, lines[i], linePositionX, linePositionY);
        }
        if (J.get$fill$x(this.get$style(this)) != null) {
          t2 = this._context;
          if (i >= lines.length)
            return H.ioore(lines, i);
          J.fillText$3$x(t2, lines[i], linePositionX, linePositionY);
        }
      }
      this.updateTexture$0();
    }, "call$0", "get$updateText", 0, 0, 13, "updateText"],
    updateTexture$0: [function() {
      var t1, t2, t3;
      J.set$width$x(this.texture.get$baseTexture(), J.get$width$x(this._canvas));
      J.set$height$x(this.texture.get$baseTexture(), J.get$height$x(this._canvas));
      t1 = this.texture.get$crop();
      t2 = this.texture.get$frame();
      t3 = J.get$width$x(this._canvas);
      J.set$width$x(t2, t3);
      J.set$width$x(t1, t3);
      t3 = this.texture.get$crop();
      t1 = this.texture.get$frame();
      t2 = J.get$height$x(this._canvas);
      J.set$height$x(t1, t2);
      J.set$height$x(t3, t2);
      this.PIXI$Sprite$_width = J.get$width$x(this._canvas);
      this.PIXI$Sprite$_height = J.get$height$x(this._canvas);
      this._requiresUpdate = true;
    }, "call$0", "get$updateTexture", 0, 0, 13, "updateTexture"],
    _renderWebGL$1: [function(renderSession) {
      if (this._requiresUpdate === true) {
        this._requiresUpdate = false;
        M.updateWebGLTexture(this.texture.get$baseTexture(), renderSession.get$gl());
      }
      M.Sprite.prototype._renderWebGL$1.call(this, renderSession);
    }, "call$1", "get$_renderWebGL", 2, 0, 655, 128, [], "_renderWebGL"],
    updateTransform$0: [function() {
      if (this.PIXI$Text$_dirty === true) {
        this.updateText$0();
        this.PIXI$Text$_dirty = false;
      }
      M.DisplayObjectContainer.prototype.updateTransform$0.call(this);
    }, "call$0", "get$updateTransform", 0, 0, 13, "updateTransform"],
    determineFontHeight$1: [function(fontStyle) {
      var result, t1, body, dummy;
      result = J.$index$asx($.get$Text_heightCache(), fontStyle);
      if (result == null) {
        t1 = document.getElementsByTagName("body");
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        body = t1[0];
        dummy = document.createElement("div", null);
        dummy.textContent = "M";
        dummy.setAttribute("style", J.$add$ns(fontStyle, ";position:absolute;top:0;left:0"));
        body.appendChild(dummy);
        result = C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(dummy.offsetHeight));
        J.$indexSet$ax($.get$Text_heightCache(), fontStyle, result);
        J.remove$0$ax(dummy);
      }
      return result;
    }, "call$1", "get$determineFontHeight", 2, 0, 916, 917, [], "determineFontHeight"],
    wordWrap$1: [function(_, text) {
      var lines, result, i, spaceLeft, words, j, wordWidth, t1, wordWidthWithSpace;
      lines = J.split$1$s(text, "\n");
      for (result = "", i = 0; i < lines.length; ++i) {
        spaceLeft = this.get$style(this).get$wordWrapWidth();
        if (i >= lines.length)
          return H.ioore(lines, i);
        words = J.split$1$s(lines[i], " ");
        for (j = 0; j < words.length; ++j) {
          wordWidth = J.measureText$1$x(this._context, words[j]).width;
          t1 = J.measureText$1$x(this._context, " ").width;
          if (typeof wordWidth !== "number")
            return wordWidth.$add();
          if (typeof t1 !== "number")
            return H.iae(t1);
          wordWidthWithSpace = wordWidth + t1;
          if (j !== 0) {
            if (typeof spaceLeft !== "number")
              return H.iae(spaceLeft);
            t1 = wordWidthWithSpace > spaceLeft;
          } else
            t1 = true;
          if (t1) {
            if (j > 0)
              result += "\n";
            if (j >= words.length)
              return H.ioore(words, j);
            result = C.JSString_methods.$add(result, words[j]);
            spaceLeft = J.$sub$n(this.get$style(this).get$wordWrapWidth(), wordWidth);
          } else {
            spaceLeft = J.$sub$n(spaceLeft, wordWidthWithSpace);
            if (j >= words.length)
              return H.ioore(words, j);
            result += C.JSString_methods.$add(" ", words[j]);
          }
        }
        if (i < lines.length - 1)
          result += "\n";
      }
      return result;
    }, "call$1", "get$wordWrap", 2, 0, 918, 85, [], "wordWrap"],
    destroy$1: [function(destroyBaseTexture) {
      var t1;
      this._context = null;
      this._canvas = null;
      t1 = this.texture;
      t1.destroy$1(destroyBaseTexture == null ? true : destroyBaseTexture);
    }, function() {
      return this.destroy$1(null);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 919, 32, 920, [], "destroy"],
    Text$2: function(text, style) {
      var t1;
      this._PIXI$_text = text;
      this._style = style;
      t1 = W.CanvasElement_CanvasElement(null, null);
      this._canvas = t1;
      this._context = J.getContext$1$x(t1, "2d");
      this.texture = M.Texture$(M.BaseTexture_fromCanvas(this._canvas, null), null);
      this._setupTexture$0();
      this._PIXI$_text = J.toString$0(text);
      this.PIXI$Text$_dirty = true;
      this.setStyle$1(style);
    },
    static: {"^": "Text_splitReg@-785,Text_heightCache@-921", Text$0: [function(text, style) {
        var t1, t2, t3, t4, t5;
        t1 = new M.Point0(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new M.Text(null, null, null, null, null, null, t1, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t5, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.renderable = true;
        t1.Text$2(text, style);
        return t1;
      }, null, null, 4, 0, 168, 85, [], 156, [], "new Text"]}
  },
  "+Text": [643],
  BaseTexture: {
    "^": "EventTarget0;id*-599,width*-601,height*-601,scaleMode@-865,_hasLoaded@-602,source*-32,_glTextures@-922,imageUrl@-639,_powerOf2@-602,onLoaded@-923,premultipliedAlpha@-602,_dirty@-754,listeners-821",
    get$hasLoaded: [function() {
      return this._hasLoaded;
    }, null, null, 1, 0, 209, "hasLoaded"],
    set$hasLoaded: [function(value) {
      this._hasLoaded = value;
    }, null, null, 3, 0, 554, 100, [], "hasLoaded"],
    onLoaded$0: function() {
      return this.onLoaded.call$0();
    },
    destroy$0: [function() {
      var t1, sor;
      t1 = this.imageUrl;
      if (t1 != null) {
        J.remove$1$ax($.get$BaseTextureCache(), t1);
        J.remove$1$ax($.get$TextureCache(), this.imageUrl);
        this.imageUrl = null;
        J.set$src$x(this.source, null);
      } else {
        sor = H.interceptedTypeCast(this.source, "$isHtmlElement");
        if (sor != null && sor.getAttribute("data-" + new W._DataAttributeMap(new W._ElementAttributeMap(sor))._toHyphenedName$1("_pixiId")) != null) {
          t1 = $.get$BaseTextureCache();
          sor.toString;
          J.remove$1$ax(t1, sor.getAttribute("data-" + new W._DataAttributeMap(new W._ElementAttributeMap(sor))._toHyphenedName$1("_pixiId")));
        }
      }
      this.source = null;
      J.add$1$ax($.get$texturesToDestroy(), this);
    }, "call$0", "get$destroy", 0, 0, 550, "destroy"],
    updateSourceImage$1: [function(newSrc) {
      this._hasLoaded = false;
      J.set$src$x(this.source, null);
      J.set$src$x(this.source, newSrc);
    }, "call$1", "get$updateSourceImage", 2, 0, 52, 924, [], "updateSourceImage"],
    BaseTexture$2: function(source, scaleMode) {
      var t1, t2;
      this.premultipliedAlpha = true;
      this._dirty = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      t1 = this.source;
      if (t1 == null)
        return;
      t2 = J.getInterceptor(t1);
      if ((!!t2.$isImageElement && J.$eq(t2.get$complete(t1), true) || !!J.getInterceptor(this.source).$isCanvasElement) && !J.$eq(J.get$width$x(this.source), 0) && !J.$eq(J.get$height$x(this.source), 0)) {
        this._hasLoaded = true;
        this.set$width(0, J.get$width$x(this.source));
        this.set$height(0, J.get$height$x(this.source));
        J.add$1$ax($.get$texturesToUpdate(), this);
      } else {
        J.get$onLoad$x(this.source).listen$1(new M.BaseTexture_closure(this));
        J.get$onError$x(this.source).listen$1(new M.BaseTexture_closure0(this));
      }
    },
    $isBaseTexture: true,
    static: {BaseTexture$: [function(source, scaleMode) {
        var t1 = $.BaseTextureCacheIdGenerator;
        $.BaseTextureCacheIdGenerator = J.$add$ns(t1, 1);
        t1 = new M.BaseTexture(t1, 100, 100, scaleMode, false, source, P.LinkedHashMap_LinkedHashMap(null, null, null, P.RenderingContext, null), null, false, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.BaseTexture$2(source, scaleMode);
        return t1;
      }, null, null, 0, 4, 169, 32, 125, 170, [], 35, [], "new BaseTexture"], BaseTexture_fromImage: [function(imageUrl, crossorigin, scaleMode) {
        var baseTexture, image;
        baseTexture = J.$index$asx($.get$BaseTextureCache(), imageUrl);
        if (crossorigin == null && J.$eq(J.indexOf$1$asx(imageUrl, "data:"), -1))
          crossorigin = true;
        if (baseTexture == null) {
          image = W.ImageElement_ImageElement(null, null, null);
          if (crossorigin === true)
            J.set$crossOrigin$x(image, "");
          J.set$src$x(image, imageUrl);
          baseTexture = M.BaseTexture$(image, scaleMode);
          baseTexture.imageUrl = imageUrl;
          J.$indexSet$ax($.get$BaseTextureCache(), imageUrl, baseTexture);
        }
        return baseTexture;
      }, "call$3", "BaseTexture_fromImage$closure", 6, 0, 171, 172, [], 34, [], 35, [], "fromImage"], BaseTexture_fromCanvas: [function(canvas, scaleMode) {
        var t1, t2, t3, baseTexture;
        t1 = J.getInterceptor$x(canvas);
        t2 = t1.get$dataset(canvas);
        if (t2._attributes._element.getAttribute("data-" + t2._toHyphenedName$1("_pixiId")) == null) {
          t2 = t1.get$dataset(canvas);
          t3 = $.TextureCacheIdGenerator;
          $.TextureCacheIdGenerator = J.$add$ns(t3, 1);
          t3 = "canvas_" + H.S(t3);
          t2._attributes._element.setAttribute("data-" + t2._toHyphenedName$1("_pixiId"), t3);
        }
        t2 = $.get$BaseTextureCache();
        t3 = t1.get$dataset(canvas);
        baseTexture = J.$index$asx(t2, t3._attributes._element.getAttribute("data-" + t3._toHyphenedName$1("_pixiId")));
        if (baseTexture == null) {
          baseTexture = M.BaseTexture$(canvas, scaleMode);
          t2 = $.get$BaseTextureCache();
          t1 = t1.get$dataset(canvas);
          J.$indexSet$ax(t2, t1._attributes._element.getAttribute("data-" + t1._toHyphenedName$1("_pixiId")), baseTexture);
        }
        return baseTexture;
      }, "call$2", "BaseTexture_fromCanvas$closure", 4, 0, 173, 116, [], 35, [], "fromCanvas"]}
  },
  "+BaseTexture": [823],
  BaseTexture_closure: {
    "^": "Closure:63;scope_0",
    call$1: [function(e) {
      var t1, i, t2;
      t1 = this.scope_0;
      t1._hasLoaded = true;
      t1.set$width(0, J.get$width$x(t1.source));
      t1.set$height(0, J.get$height$x(t1.source));
      i = 0;
      while (true) {
        t2 = J.get$length$asx(t1._glTextures);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        J.$indexSet$ax(t1._dirty, i, true);
        ++i;
      }
      t1.dispatchEvent$1(0, new M.PixiEvent("loaded", t1, null));
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  BaseTexture_closure0: {
    "^": "Closure:63;scope_1",
    call$1: [function(e) {
      var t1, t2;
      t1 = this.scope_1;
      t2 = new M.PixiEvent(null, null, null);
      t2.type = "error";
      t2.content = t1;
      t1.dispatchEvent$1(0, t2);
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  RenderTexture0: {
    "^": "Texture;renderer@-809,width:PIXI$RenderTexture0$width*-599,height:PIXI$RenderTexture0$height*-599,frame:PIXI$RenderTexture0$frame@-641,scaleMode:PIXI$RenderTexture0$scaleMode@-865,baseTexture:PIXI$RenderTexture0$baseTexture@-826,textureBuffer@-32,projection@-634,render@-925,valid:PIXI$RenderTexture0$valid@-602,noFrame-602,updateFrame-602,frame-641,trim-641,scope-826,_uvs-671,valid-602,baseTexture-826,PIXI$Texture$width-601,PIXI$Texture$height-601,sourceWidth-601,sourceHeight-601,tintCache-754,needsUpdate-602,isTiling-602,canvasBuffer-673,crop-641,id-599,width-601,height-601,scaleMode-865,_hasLoaded-602,source-32,_glTextures-922,imageUrl-639,_powerOf2-602,onLoaded-923,premultipliedAlpha-602,_dirty-754,listeners-821",
    render$1: function(arg0) {
      return this.render.call$1(arg0);
    },
    render$0: function() {
      return this.render.call$0();
    },
    render$3: function(arg0, arg1, arg2) {
      return this.render.call$3(arg0, arg1, arg2);
    },
    render$2: function(arg0, arg1) {
      return this.render.call$2(arg0, arg1);
    },
    clear$0: [function(_) {
      if (J.$eq(J.get$type$x(this.renderer), 0))
        J.bindFramebuffer$2$x(this.renderer.get$gl(), 36160, this.textureBuffer.get$frameBuffer());
      J.clear$0$ax(this.textureBuffer);
    }, "call$0", "get$clear", 0, 0, 13, "clear"],
    resize$3: [function(_, width, height, updateBase) {
      width = J.toInt$0$n(width);
      height = J.toInt$0$n(height);
      if (width === this.PIXI$RenderTexture0$width && height === this.PIXI$RenderTexture0$height)
        return;
      J.set$width$x(this.PIXI$RenderTexture0$frame, width);
      this.PIXI$RenderTexture0$width = width;
      J.set$height$x(this.PIXI$RenderTexture0$frame, height);
      this.PIXI$RenderTexture0$height = height;
      if (updateBase === true) {
        J.set$width$x(this.PIXI$RenderTexture0$baseTexture, this.PIXI$RenderTexture0$width);
        J.set$height$x(this.PIXI$RenderTexture0$baseTexture, this.PIXI$RenderTexture0$height);
      }
      if (J.$eq(J.get$type$x(this.renderer), 0)) {
        J.set$x$x(this.projection, J.$div$n(this.PIXI$RenderTexture0$width, 2));
        J.set$y$x(this.projection, J.$div$n(J.$negate$n(this.PIXI$RenderTexture0$height), 2));
      }
      J.resize$2$x(this.textureBuffer, this.PIXI$RenderTexture0$width, this.PIXI$RenderTexture0$height);
    }, function($receiver, width, height) {
      return this.resize$3($receiver, width, height, false);
    }, "resize$2", "call$3", "call$2", "get$resize", 4, 2, 926, 95, 10, [], 11, [], 927, [], "resize"],
    renderWebGL$3: [function(displayObject, position, clear) {
      var gl, t1, children, originalWorldTransform, t2, j, i;
      gl = this.renderer.get$gl();
      t1 = J.getInterceptor$x(gl);
      t1.colorMask$4(gl, true, true, true, true);
      t1.viewport$4(gl, 0, 0, this.PIXI$RenderTexture0$width, this.PIXI$RenderTexture0$height);
      t1.bindFramebuffer$2(gl, 36160, this.textureBuffer.get$frameBuffer());
      if (clear === true)
        J.clear$0$ax(this.textureBuffer);
      children = J.get$children$x(displayObject);
      originalWorldTransform = displayObject.get$_worldTransform();
      displayObject.set$_worldTransform($.get$RenderTexture_tempMatrix());
      displayObject.get$_worldTransform().set$d(-1);
      displayObject.get$_worldTransform().set$ty(J.$mul$ns(J.get$y$x(this.projection), -2));
      if (position != null) {
        t1 = J.getInterceptor$x(position);
        displayObject.get$_worldTransform().set$tx(J.toDouble$0$n(t1.get$x(position)));
        t2 = displayObject.get$_worldTransform();
        t2.set$ty(J.$sub$n(t2.get$ty(), J.toDouble$0$n(t1.get$y(position))));
      }
      t1 = J.getInterceptor$asx(children);
      j = t1.get$length(children);
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        t1.$index(children, i).updateTransform$0();
      M.WebGLRenderer_updateTextures(gl);
      this.renderer.get$spriteBatch().set$dirty(true);
      this.renderer.renderDisplayObject$3(displayObject, this.projection, this.textureBuffer.get$frameBuffer());
      displayObject.set$_worldTransform(originalWorldTransform);
      this.renderer.get$spriteBatch().set$dirty(true);
    }, function(displayObject, position) {
      return this.renderWebGL$3(displayObject, position, false);
    }, "renderWebGL$2", "call$3", "call$2", "get$renderWebGL", 4, 2, 928, 95, 805, [], 929, [], 930, [], "renderWebGL"],
    renderCanvas$3: [function(displayObject, position, clear) {
      var children, originalWorldTransform, t1, j, i, context;
      children = J.get$children$x(displayObject);
      originalWorldTransform = displayObject.get$_worldTransform();
      displayObject.set$_worldTransform($.get$RenderTexture_tempMatrix());
      if (position != null) {
        t1 = J.getInterceptor$x(position);
        displayObject.get$_worldTransform().set$tx(t1.get$x(position));
        displayObject.get$_worldTransform().set$ty(t1.get$y(position));
      } else {
        displayObject.get$_worldTransform().set$tx(0);
        displayObject.get$_worldTransform().set$ty(0);
      }
      t1 = J.getInterceptor$asx(children);
      j = t1.get$length(children);
      if (typeof j !== "number")
        return H.iae(j);
      i = 0;
      for (; i < j; ++i)
        t1.$index(children, i).updateTransform$0();
      if (clear === true)
        J.clear$0$ax(this.textureBuffer);
      context = this.textureBuffer.get$_context();
      this.renderer.renderDisplayObject$2(displayObject, context);
      J.setTransform$6$x(context, 1, 0, 0, 1, 0, 0);
      displayObject.set$_worldTransform(originalWorldTransform);
    }, function(displayObject, position) {
      return this.renderCanvas$3(displayObject, position, false);
    }, "renderCanvas$2", "call$3", "call$2", "get$renderCanvas", 4, 2, 931, 95, 805, [], 929, [], 930, [], "renderCanvas"],
    RenderTexture$4: function(width, height, renderer, scaleMode) {
      var t1, t2, gl, t3;
      if (this.renderer == null)
        this.renderer = $.defaultRenderer;
      t1 = this.PIXI$RenderTexture0$width;
      t2 = this.PIXI$RenderTexture0$height;
      this.PIXI$RenderTexture0$frame = new M.Rectangle0(0, 0, t1, t2);
      this.crop = new M.Rectangle0(0, 0, t1, t2);
      J.set$width$x(this.PIXI$RenderTexture0$baseTexture, t1);
      J.set$height$x(this.PIXI$RenderTexture0$baseTexture, this.PIXI$RenderTexture0$height);
      this.PIXI$RenderTexture0$baseTexture.set$scaleMode(this.PIXI$RenderTexture0$scaleMode);
      this.PIXI$RenderTexture0$baseTexture.set$hasLoaded(true);
      if (J.$eq(J.get$type$x(this.renderer), 0)) {
        gl = this.renderer.get$gl();
        this.textureBuffer = M.FilterTexture$(gl, this.PIXI$RenderTexture0$width, this.PIXI$RenderTexture0$height, this.PIXI$RenderTexture0$baseTexture.get$scaleMode());
        J.$indexSet$ax(this.PIXI$RenderTexture0$baseTexture.get$_glTextures(), gl, this.textureBuffer.get$texture());
        this.render = this.get$renderWebGL();
        t1 = J.$div$n(this.PIXI$RenderTexture0$width, 2);
        t2 = J.$div$n(J.$negate$n(this.PIXI$RenderTexture0$height), 2);
        t3 = new M.Point0(null, null);
        t3.x = t1;
        t3.y = t2;
        this.projection = t3;
      } else {
        this.render = this.get$renderCanvas();
        t1 = M.CanvasBuffer$(this.PIXI$RenderTexture0$width, this.PIXI$RenderTexture0$height);
        this.textureBuffer = t1;
        J.set$source$x(this.PIXI$RenderTexture0$baseTexture, t1.get$_canvas());
      }
      this.PIXI$RenderTexture0$valid = true;
      J.add$1$ax($.get$Texture_frameUpdates(), this);
    },
    $isRenderTexture0: true,
    static: {"^": "RenderTexture_tempMatrix@-640", RenderTexture$0: [function(width, height, renderer, scaleMode) {
        var t1, t2;
        t1 = M.BaseTexture$(null, C.scaleModes_0);
        t2 = $.BaseTextureCacheIdGenerator;
        $.BaseTextureCacheIdGenerator = J.$add$ns(t2, 1);
        t2 = new M.RenderTexture0(renderer, width, height, null, scaleMode, t1, null, null, null, null, false, false, null, null, null, null, false, null, 0, 0, 0, 0, null, true, null, null, null, t2, 100, 100, C.scaleModes_0, false, null, P.LinkedHashMap_LinkedHashMap(null, null, null, P.RenderingContext, null), null, false, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t2.BaseTexture$2(null, C.scaleModes_0);
        t2.scope = t2;
        t2.RenderTexture$4(width, height, renderer, scaleMode);
        return t2;
      }, null, null, 0, 8, 174, 90, 90, 32, 125, 10, [], 11, [], 175, [], 35, [], "new RenderTexture"]}
  },
  "+RenderTexture": [670],
  Texture: {
    "^": "BaseTexture;noFrame@-602,updateFrame@-602,frame@-641,trim*-641,scope@-826,_uvs@-671,valid@-602,baseTexture@-826,width:PIXI$Texture$width*-601,height:PIXI$Texture$height*-601,sourceWidth@-601,sourceHeight@-601,tintCache@-754,needsUpdate@-602,isTiling@-602,canvasBuffer@-673,crop@-641,id-599,width-601,height-601,scaleMode-865,_hasLoaded-602,source-32,_glTextures-922,imageUrl-639,_powerOf2-602,onLoaded-923,premultipliedAlpha-602,_dirty-754,listeners-821",
    trim$0: function($receiver) {
      return this.trim.call$0();
    },
    trim$1: function($receiver, arg0) {
      return this.trim.call$1(arg0);
    },
    crop$1: function(arg0) {
      return this.crop.call$1(arg0);
    },
    crop$2: function(arg0, arg1) {
      return this.crop.call$2(arg0, arg1);
    },
    onBaseTextureLoaded$0: [function() {
      var baseTexture, t1;
      baseTexture = this.get$baseTexture();
      t1 = J.getInterceptor$x(baseTexture);
      t1.removeEventListener$2(baseTexture, "loaded", this.get$onBaseTextureLoaded());
      if (this.noFrame === true)
        this.set$frame(new M.Rectangle0(0, 0, t1.get$width(baseTexture), t1.get$height(baseTexture)));
      this.setFrame$1(this.get$frame());
      J.dispatchEvent$1$x(this.scope, new M.PixiEvent("update", this, null));
    }, "call$0", "get$onBaseTextureLoaded", 0, 0, 550, "onBaseTextureLoaded"],
    destroy$1: [function(destroyBase) {
      if (destroyBase === true)
        this.get$baseTexture().destroy$0();
      this.set$valid(false);
    }, function() {
      return this.destroy$1(false);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 932, 95, 933, [], "destroy"],
    setFrame$1: [function(frame) {
      var t1, t2;
      this.noFrame = false;
      this.set$frame(frame);
      t1 = J.getInterceptor$x(frame);
      this.set$width(0, t1.get$width(frame));
      this.set$height(0, t1.get$height(frame));
      J.set$x$x(this.crop, t1.get$x(frame));
      J.set$y$x(this.crop, t1.get$y(frame));
      J.set$width$x(this.crop, t1.get$width(frame));
      J.set$height$x(this.crop, t1.get$height(frame));
      if (this.trim == null)
        t2 = J.$gt$n(J.$add$ns(t1.get$x(frame), t1.get$width(frame)), J.get$width$x(this.get$baseTexture())) || J.$gt$n(J.$add$ns(t1.get$y(frame), t1.get$height(frame)), J.get$height$x(this.get$baseTexture()));
      else
        t2 = false;
      if (t2)
        throw H.wrapException(P.Exception_Exception("Texture Error: frame does not fit inside the base Texture dimensions"));
      this.set$valid(frame != null && t1.get$width(frame) != null && !J.$eq(t1.get$width(frame), 0) && t1.get$height(frame) != null && !J.$eq(t1.get$height(frame), 0) && J.get$source$x(this.get$baseTexture()) != null && this.get$baseTexture().get$hasLoaded() === true);
      J.add$1$ax($.get$Texture_frameUpdates(), this);
    }, "call$1", "get$setFrame", 2, 0, 934, 178, [], "setFrame"],
    _updateWebGLuvs$0: [function() {
      var frame, tw, th, t1;
      if (this._uvs == null)
        this._uvs = new M.TextureUvs(0, 0, 0, 0, 0, 0, 0, 0);
      frame = this.crop;
      tw = J.get$width$x(this.get$baseTexture());
      th = J.get$height$x(this.get$baseTexture());
      t1 = J.getInterceptor$x(frame);
      this._uvs.set$x0(J.$div$n(t1.get$x(frame), tw));
      this._uvs.set$y0(J.$div$n(t1.get$y(frame), th));
      J.set$x1$x(this._uvs, J.$div$n(J.$add$ns(t1.get$x(frame), t1.get$width(frame)), tw));
      J.set$y1$x(this._uvs, J.$div$n(t1.get$y(frame), th));
      J.set$x2$x(this._uvs, J.$div$n(J.$add$ns(t1.get$x(frame), t1.get$width(frame)), tw));
      J.set$y2$x(this._uvs, J.$div$n(J.$add$ns(t1.get$y(frame), t1.get$height(frame)), th));
      this._uvs.set$x3(J.$div$n(t1.get$x(frame), tw));
      this._uvs.set$y3(J.$div$n(J.$add$ns(t1.get$y(frame), t1.get$height(frame)), th));
    }, "call$0", "get$_updateWebGLuvs", 0, 0, 550, "_updateWebGLuvs"],
    Texture$2: function(baseTexture, frame) {
      var t1;
      this.scope = this;
      if (this.get$frame() == null) {
        this.noFrame = true;
        this.set$frame(new M.Rectangle0(0, 0, 1, 1));
      }
      if (!!J.getInterceptor(baseTexture).$isTexture)
        baseTexture = baseTexture.get$baseTexture();
      this.set$baseTexture(baseTexture);
      this.crop = new M.Rectangle0(0, 0, 1, 1);
      if (baseTexture.get$hasLoaded() === true) {
        if (this.noFrame === true) {
          t1 = J.getInterceptor$x(baseTexture);
          this.set$frame(new M.Rectangle0(0, 0, t1.get$width(baseTexture), t1.get$height(baseTexture)));
        }
        this.setFrame$1(this.get$frame());
      } else
        J.addEventListener$2$x(baseTexture, "loaded", new M.Texture_closure(this));
    },
    $isTexture: true,
    static: {"^": "Texture_frameUpdates@-669", Texture$_: [function() {
        var t1 = $.BaseTextureCacheIdGenerator;
        $.BaseTextureCacheIdGenerator = J.$add$ns(t1, 1);
        t1 = new M.Texture(false, false, null, null, null, null, false, null, 0, 0, 0, 0, null, true, null, null, null, t1, 100, 100, C.scaleModes_0, false, null, P.LinkedHashMap_LinkedHashMap(null, null, null, P.RenderingContext, null), null, false, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.BaseTexture$2(null, C.scaleModes_0);
        t1.scope = t1;
        return t1;
      }, null, null, 0, 0, 13, "new Texture$_"], Texture$: [function(baseTexture, frame) {
        var t1 = $.BaseTextureCacheIdGenerator;
        $.BaseTextureCacheIdGenerator = J.$add$ns(t1, 1);
        t1 = new M.Texture(false, false, frame, null, null, null, false, null, 0, 0, 0, 0, null, true, null, null, null, t1, 100, 100, C.scaleModes_0, false, null, P.LinkedHashMap_LinkedHashMap(null, null, null, P.RenderingContext, null), null, false, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1.BaseTexture$2(null, C.scaleModes_0);
        t1.Texture$2(baseTexture, frame);
        return t1;
      }, null, null, 2, 2, 176, 32, 177, [], 178, [], "new Texture"], Texture_fromImage: [function(imageUrl, crossorigin, scaleMode) {
        var texture, baseTexture, image;
        texture = J.$index$asx($.get$TextureCache(), imageUrl);
        if (texture == null) {
          baseTexture = J.$index$asx($.get$BaseTextureCache(), imageUrl);
          if (crossorigin == null && J.$eq(J.indexOf$1$asx(imageUrl, "data:"), -1))
            crossorigin = true;
          if (baseTexture == null) {
            image = W.ImageElement_ImageElement(null, null, null);
            if (crossorigin === true)
              J.set$crossOrigin$x(image, "");
            J.set$src$x(image, imageUrl);
            baseTexture = M.BaseTexture$(image, scaleMode);
            baseTexture.imageUrl = imageUrl;
            J.$indexSet$ax($.get$BaseTextureCache(), imageUrl, baseTexture);
          }
          texture = M.Texture$(baseTexture, null);
          J.$indexSet$ax($.get$TextureCache(), imageUrl, texture);
        }
        return texture;
      }, function(imageUrl) {
        return M.Texture_fromImage(imageUrl, null, null);
      }, null, function(imageUrl, crossorigin) {
        return M.Texture_fromImage(imageUrl, crossorigin, null);
      }, null, "call$3", "call$1", "call$2", "Texture_fromImage$closure", 2, 4, 179, 32, 32, 172, [], 34, [], 35, [], "fromImage"], Texture_fromFrame: [function(frameId) {
        var texture = J.$index$asx($.get$TextureCache(), frameId);
        if (texture == null)
          throw H.wrapException(P.Exception_Exception("The frameId \"" + H.S(frameId) + "\" does not exist in the texture cache"));
        return texture;
      }, "call$1", "Texture_fromFrame$closure", 2, 0, 180, 30, [], "fromFrame"], Texture_fromCanvas: [function(canvas, scaleMode) {
        return M.Texture$(M.BaseTexture_fromCanvas(canvas, scaleMode), null);
      }, function(canvas) {
        return M.Texture_fromCanvas(canvas, null);
      }, null, "call$2", "call$1", "Texture_fromCanvas$closure", 2, 2, 181, 32, 116, [], 35, [], "fromCanvas"], Texture_addTextureToCache: [function(texture, id) {
        J.$indexSet$ax($.get$TextureCache(), id, texture);
      }, "call$2", "Texture_addTextureToCache$closure", 4, 0, 182, 28, [], 183, [], "addTextureToCache"], Texture_removeTextureFromCache: [function(id) {
        var texture = J.$index$asx($.get$TextureCache(), id);
        J.remove$1$ax($.get$TextureCache(), id);
        J.remove$1$ax($.get$BaseTextureCache(), id);
        return texture;
      }, "call$1", "Texture_removeTextureFromCache$closure", 2, 0, 184, 183, [], "removeTextureFromCache"]}
  },
  "+Texture": [826],
  Texture_closure: {
    "^": "Closure:63;scope_0",
    call$1: [function(e) {
      this.scope_0.onBaseTextureLoaded$0();
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  TextureUvs: {
    "^": "Object;x0@-601,y0@-601,x1*-601,y1*-601,x2*-601,y2*-601,x3@-601,y3@-601",
    static: {TextureUvs$: [function() {
        return new M.TextureUvs(0, 0, 0, 0, 0, 0, 0, 0);
      }, null, null, 0, 0, 185, "new TextureUvs"]}
  },
  "+TextureUvs": [632],
  PixiEvent: {
    "^": "Object;type*-639,content*-32,loader@-32",
    static: {PixiEvent$: [function($content, loader, type) {
        return new M.PixiEvent(type, $content, loader);
      }, null, null, 0, 7, 187, 32, 32, 32, 99, [], 188, [], 189, [], "new PixiEvent"]}
  },
  "+PixiEvent": [632],
  EventTarget0: {
    "^": "Object;listeners@-821",
    addEventListener$2: [function(_, type, listener) {
      if (J.$index$asx(this.listeners, type) == null)
        J.$indexSet$ax(this.listeners, type, []);
      if (J.$eq(J.indexOf$1$asx(J.$index$asx(this.listeners, type), listener), -1))
        J.insert$2$ax(J.$index$asx(this.listeners, type), 0, listener);
    }, "call$2", "get$addEventListener", 4, 0, 935, 99, [], 936, [], "addEventListener"],
    dispatchEvent$1: [function(_, $event) {
      var t1, i, t2;
      t1 = J.getInterceptor$x($event);
      if (J.$index$asx(this.listeners, t1.get$type($event)) == null || J.$eq(J.get$length$asx(J.$index$asx(this.listeners, t1.get$type($event))), 0))
        return;
      for (i = J.$sub$n(J.get$length$asx(J.$index$asx(this.listeners, t1.get$type($event))), 1); t2 = J.getInterceptor$n(i), t2.$ge(i, 0); i = t2.$sub(i, 1))
        J.$index$asx(J.$index$asx(this.listeners, t1.get$type($event)), i).call$1($event);
    }, "call$1", "get$dispatchEvent", 2, 0, 677, 815, [], "dispatchEvent"],
    removeEventListener$2: [function(_, type, listener) {
      var index;
      if (J.$index$asx(this.listeners, type) == null)
        return;
      index = J.indexOf$1$asx(J.$index$asx(this.listeners, type), listener);
      if (!J.$eq(index, -1))
        J.removeAt$1$ax(J.$index$asx(this.listeners, type), index);
    }, "call$2", "get$removeEventListener", 4, 0, 935, 99, [], 936, [], "removeEventListener"],
    removeAllEventListeners$1: [function(type) {
      var a = J.$index$asx(this.listeners, type);
      if (a === true)
        J.set$length$asx(a, 0);
    }, "call$1", "get$removeAllEventListeners", 2, 0, 63, 99, [], "removeAllEventListeners"],
    static: {EventTarget$: [function() {
        return new M.EventTarget0(P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      }, null, null, 0, 0, 190, "new EventTarget"]}
  },
  "+EventTarget": [632],
  PolyK: {
    "^": "Object;",
    static: {PolyK$_: [function() {
        return new M.PolyK();
      }, null, null, 0, 0, 13, "new PolyK$_"], PolyK_Triangulate: [function(p) {
        var t1, n, tgs, avl, i, al, sign, t2, t3, i0, i1, i10, t4, i2, ax, ay, bx, by, cx, cy, t5, earFound, t6, j, vi, t7, t8, v0x, v0y, v1x, v1y, v2x, v2y, dot00, dot01, dot02, dot11, dot12, t9, invDenom, u, v;
        t1 = J.getInterceptor$asx(p);
        n = J.$shr$n(t1.get$length(p), 1);
        if (n < 3)
          return [];
        tgs = [];
        avl = [];
        for (i = 0; i < n; ++i)
          avl.push(i);
        for (al = n, sign = true; al > 3;) {
          t2 = C.JSInt_methods.$mod(i, al);
          t3 = avl.length;
          if (t2 >= t3)
            return H.ioore(avl, t2);
          i0 = avl[t2];
          i1 = i + 1;
          t2 = C.JSInt_methods.$mod(i1, al);
          if (t2 >= t3)
            return H.ioore(avl, t2);
          i10 = avl[t2];
          t4 = C.JSInt_methods.$mod(i + 2, al);
          if (t4 >= t3)
            return H.ioore(avl, t4);
          i2 = avl[t4];
          t4 = 2 * i0;
          ax = t1.$index(p, t4);
          ay = t1.$index(p, t4 + 1);
          t4 = 2 * i10;
          bx = t1.$index(p, t4);
          by = t1.$index(p, t4 + 1);
          t4 = 2 * i2;
          cx = t1.$index(p, t4);
          cy = t1.$index(p, t4 + 1);
          t3 = J.getInterceptor$n(cx);
          t4 = J.getInterceptor$n(bx);
          t5 = J.getInterceptor$n(cy);
          if (J.$ge$n(J.$add$ns(J.$mul$ns(J.$sub$n(ay, by), t3.$sub(cx, bx)), J.$mul$ns(t4.$sub(bx, ax), t5.$sub(cy, by))), 0) === sign) {
            t6 = J.getInterceptor$n(by);
            j = 0;
            while (true) {
              if (!(j < al)) {
                earFound = true;
                break;
              }
              c$1: {
                if (j >= avl.length)
                  return H.ioore(avl, j);
                vi = avl[j];
                if (vi === i0 || vi === i10 || vi === i2)
                  break c$1;
                t7 = 2 * vi;
                t8 = t1.$index(p, t7);
                t7 = t1.$index(p, t7 + 1);
                v0x = t3.$sub(cx, ax);
                v0y = t5.$sub(cy, ay);
                v1x = t4.$sub(bx, ax);
                v1y = t6.$sub(by, ay);
                v2x = J.$sub$n(t8, ax);
                v2y = J.$sub$n(t7, ay);
                t7 = J.getInterceptor$ns(v0x);
                t8 = J.getInterceptor$ns(v0y);
                dot00 = J.$add$ns(t7.$mul(v0x, v0x), t8.$mul(v0y, v0y));
                dot01 = J.$add$ns(t7.$mul(v0x, v1x), t8.$mul(v0y, v1y));
                dot02 = J.$add$ns(t7.$mul(v0x, v2x), t8.$mul(v0y, v2y));
                t8 = J.getInterceptor$ns(v1x);
                t7 = J.getInterceptor$ns(v1y);
                dot11 = J.$add$ns(t8.$mul(v1x, v1x), t7.$mul(v1y, v1y));
                dot12 = J.$add$ns(t8.$mul(v1x, v2x), t7.$mul(v1y, v2y));
                t7 = J.getInterceptor$ns(dot00);
                t8 = J.getInterceptor$ns(dot01);
                t9 = J.$sub$n(t7.$mul(dot00, dot11), t8.$mul(dot01, dot01));
                if (typeof t9 !== "number")
                  return H.iae(t9);
                invDenom = 1 / t9;
                u = J.$mul$ns(J.$sub$n(J.$mul$ns(dot11, dot02), t8.$mul(dot01, dot12)), invDenom);
                v = J.$mul$ns(J.$sub$n(t7.$mul(dot00, dot12), t8.$mul(dot01, dot02)), invDenom);
                t7 = J.getInterceptor$n(u);
                if (t7.$ge(u, 0) && J.$ge$n(v, 0) && J.$lt$n(t7.$add(u, v), 1)) {
                  earFound = false;
                  break;
                }
              }
              ++j;
            }
          } else
            earFound = false;
          if (earFound) {
            C.JSArray_methods.addAll$1(tgs, [i0, i10, i2]);
            C.JSArray_methods.removeAt$1(avl, t2);
            --al;
            i = 0;
          } else if (i > 3 * al) {
            if (sign) {
              tgs = [];
              avl = [];
              for (i = 0; i < n; ++i)
                avl.push(i);
            } else {
              window;
              if (typeof console != "undefined")
                console.log("PIXI Warning: shape too complex to fill");
              return [];
            }
            al = n;
            sign = false;
            i = 0;
          } else
            i = i1;
        }
        t1 = avl.length;
        if (0 >= t1)
          return H.ioore(avl, 0);
        t2 = avl[0];
        if (1 >= t1)
          return H.ioore(avl, 1);
        t3 = avl[1];
        if (2 >= t1)
          return H.ioore(avl, 2);
        C.JSArray_methods.addAll$1(tgs, [t2, t3, avl[2]]);
        return tgs;
      }, "call$1", "PolyK_Triangulate$closure", 2, 0, 191, 192, [], "Triangulate"], PolyK__PointInTriangle: [function(px, py, ax, ay, bx, by, cx, cy) {
        var v0x, v0y, v1x, v1y, v2x, v2y, t1, t2, dot00, dot01, dot02, dot11, dot12, t3, invDenom, u, v;
        v0x = J.$sub$n(cx, ax);
        v0y = J.$sub$n(cy, ay);
        v1x = J.$sub$n(bx, ax);
        v1y = J.$sub$n(by, ay);
        v2x = J.$sub$n(px, ax);
        v2y = J.$sub$n(py, ay);
        t1 = J.getInterceptor$ns(v0x);
        t2 = J.getInterceptor$ns(v0y);
        dot00 = J.$add$ns(t1.$mul(v0x, v0x), t2.$mul(v0y, v0y));
        dot01 = J.$add$ns(t1.$mul(v0x, v1x), t2.$mul(v0y, v1y));
        dot02 = J.$add$ns(t1.$mul(v0x, v2x), t2.$mul(v0y, v2y));
        t2 = J.getInterceptor$ns(v1x);
        t1 = J.getInterceptor$ns(v1y);
        dot11 = J.$add$ns(t2.$mul(v1x, v1x), t1.$mul(v1y, v1y));
        dot12 = J.$add$ns(t2.$mul(v1x, v2x), t1.$mul(v1y, v2y));
        t1 = J.getInterceptor$ns(dot00);
        t2 = J.getInterceptor$ns(dot01);
        t3 = J.$sub$n(t1.$mul(dot00, dot11), t2.$mul(dot01, dot01));
        if (typeof t3 !== "number")
          return H.iae(t3);
        invDenom = 1 / t3;
        u = J.$mul$ns(J.$sub$n(J.$mul$ns(dot11, dot02), t2.$mul(dot01, dot12)), invDenom);
        v = J.$mul$ns(J.$sub$n(t1.$mul(dot00, dot12), t2.$mul(dot01, dot02)), invDenom);
        t1 = J.getInterceptor$n(u);
        return t1.$ge(u, 0) && J.$ge$n(v, 0) && J.$lt$n(t1.$add(u, v), 1);
      }, "call$8", "PolyK__PointInTriangle$closure", 16, 0, 193, 194, [], 195, [], 196, [], 197, [], 198, [], 199, [], 200, [], 201, [], "_PointInTriangle"], PolyK__convex: [function(ax, ay, bx, by, cx, cy, sign) {
        return J.$ge$n(J.$add$ns(J.$mul$ns(J.$sub$n(ay, by), J.$sub$n(cx, bx)), J.$mul$ns(J.$sub$n(bx, ax), J.$sub$n(cy, by))), 0) === sign;
      }, "call$7", "PolyK__convex$closure", 14, 0, 202, 196, [], 197, [], 198, [], 199, [], 200, [], 201, [], 203, [], "_convex"]}
  },
  "+PolyK": [632],
  "^": "TextureCacheIdGenerator@-599,FrameCache@-754,TextureCache@-754,BaseTextureCacheIdGenerator@-599,texturesToDestroy@-720,texturesToUpdate@-720,BaseTextureCache@-1712,glContexts@-1713,AttachmentType@-754,AnimCache@-754,EmptyRectangle@-641,Matrix2@-1057,IdentityMatrix@-640,requestAnimFrame@-0,_UID@-599,DEG_TO_RAD<-601,RAD_TO_DEG<-601,AUTO_PREVENT_DEFAULT<-602,INTERACTION_FREQUENCY<-599,VERSION<-639,CANVAS_RENDERER<-599,WEBGL_RENDERER<-599,blendModesCanvas@-754,blendModesWebGL@-754,defaultRenderer@-809",
  InteractionHandler: {"^": ":636;"},
  "+InteractionHandler": "",
  EventFunc: {"^": ":923;"},
  "+EventFunc": "",
  Render: {"^": ":925;"},
  "+Render": ""
}],
["Phaser", "package:alienzed/phaser.dart", , R, {
  "^": "",
  Animation: {
    "^": "Object;game@-598,_Phaser$_parent@-937,name*-639,_frameData@-938,_frames@-681,delay@-601,loop*-602,loopCount@-599,killOnComplete@-602,isFinished@-602,isPlaying@-602,_isPaused@-602,_pauseStartTime@-601,_frameIndex@-599,_frameDiff@-601,_frameSkip@-601,currentFrame@-939,onStart@-940,onComplete*-940,onLoop@-940,_timeLastFrame@-629,_timeNextFrame@-629",
    delay$1: function(arg0) {
      return this.delay.call$1(arg0);
    },
    loop$0: function($receiver) {
      return this.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return this.loop.call$3(arg0, arg1, arg2);
    },
    get$paused: [function(_) {
      return this._isPaused;
    }, null, null, 1, 0, 209, "paused"],
    paused$0: function($receiver) {
      return this.get$paused(this).call$0();
    },
    set$paused: [function(_, value) {
      this._isPaused = value;
      if (value === true)
        this._pauseStartTime = this.game.get$time().get$now();
      else if (this.isPlaying === true)
        this._timeNextFrame = J.$add$ns(this.game.get$time().get$now(), this.delay);
    }, null, null, 3, 0, 650, 100, [], "paused"],
    get$frameTotal: [function() {
      return J.get$length$asx(this._frames);
    }, null, null, 1, 0, 604, "frameTotal"],
    get$frame: [function() {
      var t1 = this.currentFrame;
      if (t1 != null)
        return J.get$index$x(t1);
      else
        return this._frameIndex;
    }, null, null, 1, 0, 367, "frame"],
    set$frame: [function(value) {
      var t1 = this._frameData.getFrame$1(J.$index$asx(this._frames, value));
      this.currentFrame = t1;
      if (t1 != null) {
        this._frameIndex = value;
        this._Phaser$_parent.setTexture$1(J.$index$asx($.get$TextureCache(), t1.get$uuid()));
      }
    }, null, null, 3, 0, 60, 100, [], "frame"],
    get$speed: [function() {
      var t1 = this.delay;
      if (typeof t1 !== "number")
        return H.iae(t1);
      return C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(1000 / t1));
    }, null, null, 1, 0, 604, "speed"],
    set$speed: [function(value) {
      if (J.$ge$n(value, 1)) {
        if (typeof value !== "number")
          return H.iae(value);
        this.delay = 1000 / value;
      }
    }, null, null, 3, 0, 605, 100, [], "speed"],
    play$3: [function(_, frameRate, loop, killOnComplete) {
      var t1;
      if (typeof frameRate === "number")
        this.delay = 1000 / frameRate;
      if (typeof loop === "boolean")
        this.loop = loop;
      if (killOnComplete != null)
        this.killOnComplete = killOnComplete;
      this.isPlaying = true;
      this.isFinished = false;
      this.set$paused(0, false);
      this.loopCount = 0;
      this._timeLastFrame = this.game.get$time().get$now();
      this._timeNextFrame = J.$add$ns(this.game.get$time().get$now(), this.delay);
      this._frameIndex = 0;
      t1 = this._frameData.getFrame$1(J.$index$asx(this._frames, 0));
      this.currentFrame = t1;
      this._Phaser$_parent.setTexture$1(J.$index$asx($.get$TextureCache(), t1.get$uuid()));
      if (this._Phaser$_parent.get$__tilePattern() != null) {
        this._Phaser$_parent.set$__tilePattern(null);
        this._Phaser$_parent.set$tilingTexture(null);
      }
      J.get$onAnimationStart$x(this._Phaser$_parent.get$events()).dispatch$1([this._Phaser$_parent, this]);
      this.onStart.dispatch$1([this._Phaser$_parent, this]);
      return this;
    }, function($receiver, frameRate) {
      return this.play$3($receiver, frameRate, null, false);
    }, "play$1", function($receiver) {
      return this.play$3($receiver, null, null, false);
    }, "play$0", function($receiver, frameRate, loop) {
      return this.play$3($receiver, frameRate, loop, false);
    }, "play$2", "call$3", "call$1", "call$0", "call$2", "get$play", 0, 6, 941, 32, 32, 95, 218, [], 219, [], 942, [], "play"],
    restart$0: [function() {
      this.isPlaying = true;
      this.isFinished = false;
      this.set$paused(0, false);
      this.loopCount = 0;
      this._timeLastFrame = this.game.get$time().get$now();
      this._timeNextFrame = J.$add$ns(this.game.get$time().get$now(), this.delay);
      this._frameIndex = 0;
      this.currentFrame = this._frameData.getFrame$1(J.$index$asx(this._frames, 0));
      this.onStart.dispatch$1([this._Phaser$_parent, this]);
    }, "call$0", "get$restart", 0, 0, 13, "restart"],
    setFrame$2: [function(frameId, useLocalFrameIndex) {
      var t1, frameIndex, i;
      t1 = J.getInterceptor(frameId);
      if (t1.$eq(frameId, C.Type_Ejg)) {
        frameIndex = null;
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this._frames);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$eq(J.get$name$x(this._frameData.getFrame$1(J.$index$asx(this._frames, i))), frameId))
            frameIndex = i;
          ++i;
        }
      } else if (t1.$eq(frameId, C.Type_xM7))
        if (useLocalFrameIndex === true)
          frameIndex = frameId;
        else {
          frameIndex = null;
          i = 0;
          while (true) {
            t1 = J.get$length$asx(this._frames);
            if (typeof t1 !== "number")
              return H.iae(t1);
            if (!(i < t1))
              break;
            if (J.$eq(J.$index$asx(this._frames, i), frameIndex))
              frameIndex = i;
            ++i;
          }
        }
      else
        frameIndex = null;
      if (frameIndex != null && !J.$eq(frameIndex, 0)) {
        this._frameIndex = J.$sub$n(frameIndex, 1);
        this._timeNextFrame = this.game.get$time().get$now();
        this.update$0();
      }
    }, function(frameId) {
      return this.setFrame$2(frameId, false);
    }, "setFrame$1", "call$2", "call$1", "get$setFrame", 2, 2, 943, 95, 30, [], 944, [], "setFrame"],
    stop$2: [function(_, resetFrame, dispatchComplete) {
      this.isPlaying = false;
      this.isFinished = true;
      this.set$paused(0, false);
      if (resetFrame != null)
        this.currentFrame = this._frameData.getFrame$1(J.$index$asx(this._frames, 0));
      if (dispatchComplete === true) {
        this._Phaser$_parent.get$events().get$onAnimationComplete().dispatch$1([this._Phaser$_parent, this]);
        this.onComplete.dispatch$1([this._Phaser$_parent, this]);
      }
    }, function($receiver) {
      return this.stop$2($receiver, false, false);
    }, "stop$0", function($receiver, resetFrame) {
      return this.stop$2($receiver, resetFrame, false);
    }, "stop$1", "call$2", "call$0", "call$1", "get$stop", 0, 4, 945, 95, 95, 946, [], 947, [], "stop"],
    _onPause$0: [function() {
      if (this.isPlaying === true)
        this._frameDiff = J.$sub$n(this._timeNextFrame, this.game.get$time().get$now());
    }, "call$0", "get$_onPause", 0, 0, 13, "_onPause"],
    _onResume$0: [function() {
      if (this.isPlaying === true)
        this._timeNextFrame = J.$add$ns(this.game.get$time().get$now(), this._frameDiff);
    }, "call$0", "get$_onResume", 0, 0, 13, "_onResume"],
    update$0: [function() {
      var t1, t2, t3;
      if (this._isPaused === true)
        return false;
      if (J.$eq(this.isPlaying, true) && J.$ge$n(this.game.get$time().get$now(), this._timeNextFrame)) {
        this._frameSkip = 1;
        this._frameDiff = J.$sub$n(this.game.get$time().get$now(), this._timeNextFrame);
        this._timeLastFrame = this.game.get$time().get$now();
        if (J.$gt$n(this._frameDiff, this.delay)) {
          t1 = J.floor$0$n(J.$div$n(this._frameDiff, this.delay));
          this._frameSkip = t1;
          t2 = this._frameDiff;
          t3 = this.delay;
          if (typeof t3 !== "number")
            return H.iae(t3);
          this._frameDiff = J.$sub$n(t2, t1 * t3);
        }
        this._timeNextFrame = J.$add$ns(this.game.get$time().get$now(), J.$sub$n(this.delay, this._frameDiff));
        t1 = J.$add$ns(this._frameIndex, this._frameSkip);
        this._frameIndex = t1;
        if (J.$ge$n(t1, J.get$length$asx(this._frames)))
          if (this.loop === true) {
            t1 = J.$mod$n(this._frameIndex, J.get$length$asx(this._frames));
            this._frameIndex = t1;
            t1 = this._frameData.getFrame$1(J.$index$asx(this._frames, t1));
            this.currentFrame = t1;
            if (t1 != null) {
              this._Phaser$_parent.setTexture$1(J.$index$asx($.get$TextureCache(), t1.get$uuid()));
              if (this._Phaser$_parent.get$__tilePattern() != null) {
                this._Phaser$_parent.set$__tilePattern(null);
                this._Phaser$_parent.set$tilingTexture(null);
              }
            }
            this.loopCount = J.$add$ns(this.loopCount, 1);
            this._Phaser$_parent.get$events().get$onAnimationLoop().dispatch$1([this._Phaser$_parent, this]);
            this.onLoop.dispatch$1([this._Phaser$_parent, this]);
          } else
            this.complete$0(0);
        else {
          t1 = this._frameData.getFrame$1(J.$index$asx(this._frames, this._frameIndex));
          this.currentFrame = t1;
          if (t1 != null) {
            this._Phaser$_parent.setTexture$1(J.$index$asx($.get$TextureCache(), t1.get$uuid()));
            if (this._Phaser$_parent.get$__tilePattern() != null) {
              this._Phaser$_parent.set$__tilePattern(null);
              this._Phaser$_parent.set$tilingTexture(null);
            }
          }
        }
        return true;
      }
      return false;
    }, "call$0", "get$update", 0, 0, 13, "update"],
    next$1: [function(quantity) {
      var frame, t1, t2, t3;
      frame = J.$add$ns(this._frameIndex, quantity);
      t1 = J.getInterceptor$n(frame);
      if (t1.$ge(frame, J.get$length$asx(this._frames))) {
        t2 = this.loop;
        t3 = this._frames;
        frame = t2 === true ? t1.$mod(frame, J.get$length$asx(t3)) : J.$sub$n(J.get$length$asx(t3), 1);
      }
      if (!J.$eq(frame, this._frameIndex)) {
        this._frameIndex = frame;
        t1 = this._frameData.getFrame$1(J.$index$asx(this._frames, frame));
        this.currentFrame = t1;
        if (t1 != null) {
          this._Phaser$_parent.setFrame$1(t1);
          if (this._Phaser$_parent.get$__tilePattern() != null) {
            this._Phaser$_parent.set$__tilePattern(null);
            this._Phaser$_parent.set$tilingTexture(null);
          }
        }
      }
    }, function() {
      return this.next$1(1);
    }, "next$0", "call$1", "call$0", "get$next", 0, 2, 948, 390, 949, [], "next"],
    previous$1: [function(quantity) {
      var frame, t1;
      frame = J.$sub$n(this._frameIndex, quantity);
      t1 = J.getInterceptor$n(frame);
      if (t1.$lt(frame, 0))
        frame = this.loop === true ? J.$add$ns(J.get$length$asx(this._frames), frame) : t1.$add(frame, 1);
      if (!J.$eq(frame, this._frameIndex)) {
        this._frameIndex = frame;
        t1 = this._frameData.getFrame$1(J.$index$asx(this._frames, frame));
        this.currentFrame = t1;
        if (t1 != null) {
          this._Phaser$_parent.setFrame$1(t1);
          if (this._Phaser$_parent.get$__tilePattern() != null) {
            this._Phaser$_parent.set$__tilePattern(null);
            this._Phaser$_parent.set$tilingTexture(null);
          }
        }
      }
    }, function() {
      return this.previous$1(1);
    }, "previous$0", "call$1", "call$0", "get$previous", 0, 2, 948, 390, 949, [], "previous"],
    updateFrameData$1: [function(frameData) {
      var t1, t2;
      this._frameData = frameData;
      if (frameData != null) {
        t1 = this._frames;
        t2 = J.getInterceptor$asx(t1);
        t1 = frameData.getFrame$1(t2.$index(t1, J.$mod$n(this._frameIndex, t2.get$length(t1))));
      } else
        t1 = null;
      this.currentFrame = t1;
    }, "call$1", "get$updateFrameData", 2, 0, 950, 951, [], "updateFrameData"],
    destroy$0: [function() {
      J.remove$1$ax(J.get$onPause$x(this.game), this.get$_onPause());
      J.remove$1$ax(this.game.get$onResume(), this.get$_onResume());
      this.game = null;
      this._Phaser$_parent = null;
      this._frames = null;
      this._frameData = null;
      this.currentFrame = null;
      this.isPlaying = false;
      this.onStart.dispose$0();
      this.onLoop.dispose$0();
      this.onComplete.dispose$0();
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    complete$0: [function(_) {
      this.isPlaying = false;
      this.isFinished = true;
      this.set$paused(0, false);
      this._Phaser$_parent.get$events().get$onAnimationComplete().dispatch$1([this._Phaser$_parent, this]);
      this.onComplete.dispatch$1([this._Phaser$_parent, this]);
      if (this.killOnComplete === true)
        this._Phaser$_parent.kill$0();
    }, "call$0", "get$complete", 0, 0, 13, "complete"],
    Animation$7: function(game, _parent, $name, _frameData, _frames, frameRate, loop) {
      this.currentFrame = this._frameData.getFrame$1(J.$index$asx(this._frames, this._frameIndex));
      this.onStart = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onComplete = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onLoop = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      if (this._frames == null)
        this._frames = [];
      if (typeof frameRate === "number")
        this.delay = 1000 / frameRate;
      J.add$1$ax(J.get$onPause$x(this.game), this.get$_onPause());
      J.add$1$ax(this.game.get$onResume(), this.get$_onResume());
    },
    static: {Animation$0: [function(game, _parent, $name, _frameData, _frames, frameRate, loop) {
        var t1 = new R.Animation(game, _parent, $name, _frameData, _frames, null, loop, 0, false, false, false, false, 0, 0, 0, 1, null, null, null, null, null, null);
        t1.Animation$7(game, _parent, $name, _frameData, _frames, frameRate, loop);
        return t1;
      }, null, null, 8, 6, 212, 32, 213, 95, 214, [], 215, [], 44, [], 216, [], 217, [], 218, [], 219, [], "new Animation"], Animation_generateFrameNames: [function(prefix, start, $stop, suffix, zeroPad) {
        var output, t1, t2, i, t3;
        output = [];
        if (J.$lt$n(start, $stop))
          for (t1 = J.getInterceptor$ns(prefix), t2 = typeof zeroPad === "number", i = start; t3 = J.getInterceptor$n(i), t3.$le(i, $stop); i = t3.$add(i, 1))
            output.push(J.$add$ns(t1.$add(prefix, t2 ? J.padLeft$2$s(t3.toString$0(i), zeroPad, "0") : t3.toString$0(i)), suffix));
        else
          for (t1 = J.getInterceptor$ns(prefix), t2 = typeof zeroPad === "number", i = start; t3 = J.getInterceptor$n(i), t3.$ge(i, $stop); i = t3.$sub(i, 1))
            output.push(J.$add$ns(t1.$add(prefix, t2 ? J.padLeft$2$s(t3.toString$0(i), zeroPad, "0") : t3.toString$0(i)), suffix));
        return output;
      }, function() {
        return R.Animation_generateFrameNames("", null, null, null, null);
      }, null, function(prefix) {
        return R.Animation_generateFrameNames(prefix, null, null, null, null);
      }, null, function(prefix, start) {
        return R.Animation_generateFrameNames(prefix, start, null, null, null);
      }, null, function(prefix, start, stop) {
        return R.Animation_generateFrameNames(prefix, start, stop, null, null);
      }, null, function(prefix, start, stop, suffix) {
        return R.Animation_generateFrameNames(prefix, start, stop, suffix, null);
      }, null, "call$5", "call$0", "call$1", "call$2", "call$3", "call$4", "Animation_generateFrameNames$closure", 0, 10, 220, 221, 32, 32, 32, 32, 222, [], 223, [], 224, [], 225, [], 226, [], "generateFrameNames"]}
  },
  "+Animation": [632],
  AnimationManager: {
    "^": "Object;sprite@-952,game@-598,currentFrame@-939,currentAnim@-953,updateIfVisible@-602,isLoaded@-602,_frameData@-938,_anims@-954,_outputFrames@-720,_frameIndex@-599,__tilePattern@-602,tilingTexture@-602",
    sprite$3: function(arg0, arg1, arg2) {
      return this.sprite.call$3(arg0, arg1, arg2);
    },
    sprite$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.sprite.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    sprite$4: function(arg0, arg1, arg2, arg3) {
      return this.sprite.call$4(arg0, arg1, arg2, arg3);
    },
    get$frameData: [function() {
      return this._frameData;
    }, null, null, 1, 0, 955, "frameData"],
    get$frameTotal: [function() {
      return J.get$total$x(this._frameData);
    }, null, null, 1, 0, 367, "frameTotal"],
    get$paused: [function(_) {
      return this.currentAnim.get$_isPaused();
    }, null, null, 1, 0, 209, "paused"],
    paused$0: function($receiver) {
      return this.get$paused(this).call$0();
    },
    set$paused: [function(_, value) {
      this.currentAnim.set$_isPaused(value);
    }, null, null, 3, 0, 650, 100, [], "paused"],
    get$frame: [function() {
      if (this.currentFrame != null)
        return this._frameIndex;
      return -1;
    }, null, null, 1, 0, 367, "frame"],
    set$frame: [function(value) {
      var t1;
      if (typeof value === "number") {
        t1 = this._frameData;
        t1 = t1 != null && t1.getFrame$1(value) != null;
      } else
        t1 = false;
      if (t1) {
        t1 = this._frameData.getFrame$1(value);
        this.currentFrame = t1;
        if (t1 != null) {
          this._frameIndex = value;
          this.sprite.setTexture$1(J.$index$asx($.get$TextureCache(), t1.get$uuid()));
          if (this.sprite.get$__tilePattern() != null) {
            this.__tilePattern = false;
            this.tilingTexture = false;
          }
        }
      }
    }, null, null, 3, 0, 60, 100, [], "frame"],
    get$frameName: [function() {
      var t1 = this.currentFrame;
      if (t1 != null)
        return J.get$name$x(t1);
      else
        return;
    }, null, null, 1, 0, 782, "frameName"],
    set$frameName: [function(value) {
      var t1;
      if (typeof value === "string") {
        t1 = this._frameData;
        t1 = t1 != null && t1.getFrameByName$1(value) != null;
      } else
        t1 = false;
      if (t1) {
        t1 = this._frameData.getFrameByName$1(value);
        this.currentFrame = t1;
        if (t1 != null) {
          this._frameIndex = J.get$index$x(t1);
          this.sprite.setTexture$1(J.$index$asx($.get$TextureCache(), this.currentFrame.get$uuid()));
          if (this.sprite.get$__tilePattern() != null) {
            this.__tilePattern = false;
            this.tilingTexture = false;
          }
        }
      } else {
        window;
        t1 = C.JSString_methods.$add("Cannot set frameName: ", value);
        if (typeof console != "undefined")
          console.warn(t1);
      }
    }, null, null, 3, 0, 52, 100, [], "frameName"],
    loadFrameData$2: [function(frameData, frame) {
      var t1, anim;
      if (this.isLoaded === true)
        for (t1 = J.get$iterator$ax(J.get$keys$x(this._anims)); t1.moveNext$0();) {
          anim = t1.get$current();
          J.$index$asx(this._anims, anim).updateFrameData$1(frameData);
        }
      this._frameData = frameData;
      if (frame == null)
        this.set$frame(0);
      else if (typeof frame === "string")
        this.set$frameName(frame);
      else
        this.set$frame(frame);
      this.isLoaded = true;
      if (this._frameData != null)
        return true;
      else
        return false;
    }, function(frameData) {
      return this.loadFrameData$2(frameData, 0);
    }, "loadFrameData$1", "call$2", "call$1", "get$loadFrameData", 2, 2, 956, 5, 951, [], 178, [], "loadFrameData"],
    add$5: [function(_, $name, $frames, frameRate, loop, useNumericIndex) {
      var t1, t2, t3, t4, t5, t6;
      if ($frames == null) {
        $frames = [];
        useNumericIndex = true;
      }
      if (this._frameData == null) {
        window;
        t1 = C.JSString_methods.$add("No FrameData available for Phaser.Animation ", $name);
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      if (useNumericIndex == null) {
        t1 = J.$index$asx($frames, 0);
        useNumericIndex = typeof t1 === "number" && Math.floor(t1) === t1 && true;
      }
      if (J.get$onAnimationStart$x(this.sprite.get$events()) == null) {
        J.set$onAnimationStart$x(this.sprite.get$events(), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
        this.sprite.get$events().set$onAnimationComplete(H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
        this.sprite.get$events().set$onAnimationLoop(H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
      }
      t1 = [];
      this._outputFrames = t1;
      this._frameData.getFrameIndexes$3($frames, useNumericIndex, t1);
      t1 = this._anims;
      t2 = this.game;
      t3 = this.sprite;
      t4 = this._frameData;
      t5 = this._outputFrames;
      t6 = new R.Animation(t2, t3, $name, t4, t5, null, loop, 0, false, false, false, false, 0, 0, 0, 1, null, null, null, null, null, null);
      t6.Animation$7(t2, t3, $name, t4, t5, frameRate, loop);
      J.$indexSet$ax(t1, $name, t6);
      t6 = J.$index$asx(this._anims, $name);
      this.currentAnim = t6;
      t6 = t6.get$currentFrame();
      this.currentFrame = t6;
      this.sprite.setTexture$1(J.$index$asx($.get$TextureCache(), t6.get$uuid()));
      if (this.sprite.get$__tilePattern() != null) {
        this.__tilePattern = false;
        this.tilingTexture = false;
      }
      return J.$index$asx(this._anims, $name);
    }, function($receiver, name, frames) {
      return this.add$5($receiver, name, frames, 60, true, null);
    }, "add$2", function($receiver, name) {
      return this.add$5($receiver, name, null, 60, true, null);
    }, "add$1", function($receiver, name, frames, frameRate, loop) {
      return this.add$5($receiver, name, frames, frameRate, loop, null);
    }, "add$4", function($receiver, name, frames, frameRate) {
      return this.add$5($receiver, name, frames, frameRate, true, null);
    }, "add$3", "call$5", "call$2", "call$1", "call$4", "call$3", "get$add", 2, 8, 957, 32, 213, 39, 32, 44, [], 25, [], 218, [], 219, [], 958, [], "add"],
    validateFrames$2: [function($frames, useNumericIndex) {
      var t1, t2, i, t3;
      t1 = J.getInterceptor$asx($frames);
      t2 = J.getInterceptor(useNumericIndex);
      i = 0;
      while (true) {
        t3 = t1.get$length($frames);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        if (t2.$eq(useNumericIndex, true)) {
          if (J.$gt$n(t1.$index($frames, i), J.get$total$x(this._frameData)))
            return false;
        } else if (!this._frameData.checkFrameName$1(t1.$index($frames, i)))
          return false;
        ++i;
      }
      return true;
    }, function(frames) {
      return this.validateFrames$2(frames, true);
    }, "validateFrames$1", "call$2", "call$1", "get$validateFrames", 2, 2, 959, 39, 25, [], 958, [], "validateFrames"],
    play$4: [function(_, $name, frameRate, loop, killOnComplete) {
      var t1;
      if (J.$index$asx(this._anims, $name) != null)
        if (J.$eq(this.currentAnim, J.$index$asx(this._anims, $name))) {
          if (J.$eq(this.currentAnim.get$isPlaying(), false)) {
            J.set$paused$x(this.currentAnim, false);
            return J.play$3$x(this.currentAnim, frameRate, loop, killOnComplete);
          }
        } else {
          t1 = this.currentAnim;
          if (t1 != null && t1.get$isPlaying() === true)
            J.stop$0$x(this.currentAnim);
          t1 = J.$index$asx(this._anims, $name);
          this.currentAnim = t1;
          J.set$paused$x(t1, false);
          return J.play$3$x(this.currentAnim, frameRate, loop, killOnComplete);
        }
    }, function($receiver, name) {
      return this.play$4($receiver, name, null, null, false);
    }, "play$1", function($receiver, name, frameRate, loop) {
      return this.play$4($receiver, name, frameRate, loop, false);
    }, "play$3", function($receiver, name, frameRate) {
      return this.play$4($receiver, name, frameRate, null, false);
    }, "play$2", "call$4", "call$1", "call$3", "call$2", "get$play", 2, 6, 960, 32, 32, 95, 44, [], 218, [], 219, [], 942, [], "play"],
    stop$2: [function(_, $name, resetFrame) {
      var t1;
      if (typeof $name === "string") {
        if (J.$index$asx(this._anims, $name) != null) {
          t1 = J.$index$asx(this._anims, $name);
          this.currentAnim = t1;
          J.stop$1$x(t1, resetFrame);
        }
      } else {
        t1 = this.currentAnim;
        if (t1 != null)
          J.stop$1$x(t1, resetFrame);
      }
    }, function($receiver) {
      return this.stop$2($receiver, null, false);
    }, "stop$0", function($receiver, name) {
      return this.stop$2($receiver, name, false);
    }, "stop$1", "call$2", "call$0", "call$1", "get$stop", 0, 4, 961, 32, 95, 44, [], 946, [], "stop"],
    update$0: [function() {
      if (this.updateIfVisible === true && this.sprite.get$visible() !== true)
        return false;
      var t1 = this.currentAnim;
      if (t1 != null && J.$eq(t1.update$0(), true)) {
        this.currentFrame = this.currentAnim.get$currentFrame();
        return true;
      }
      return false;
    }, "call$0", "get$update", 0, 0, 209, "update"],
    getAnimation$1: [function($name) {
      if (typeof $name === "string")
        if (J.$index$asx(this._anims, $name) != null)
          return J.$index$asx(this._anims, $name);
      return;
    }, "call$1", "get$getAnimation", 2, 0, 962, 44, [], "getAnimation"],
    refreshFrame$0: [function() {
      this.sprite.setTexture$1(J.$index$asx($.get$TextureCache(), this.currentFrame.get$uuid()));
      if (this.sprite.get$__tilePattern() != null) {
        this.__tilePattern = false;
        this.tilingTexture = false;
      }
    }, "call$0", "get$refreshFrame", 0, 0, 13, "refreshFrame"],
    destroy$0: [function() {
      var t1, anim;
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._anims)); t1.moveNext$0();) {
        anim = t1.get$current();
        J.$index$asx(this._anims, anim).destroy$0();
      }
      this._anims = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._frameData = null;
      this._frameIndex = 0;
      this.currentAnim = null;
      this.currentFrame = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    static: {AnimationManager$: [function(sprite) {
        var t1 = new R.AnimationManager(sprite, null, null, null, true, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), [], 0, null, null);
        t1.game = sprite.get$game();
        return t1;
      }, null, null, 2, 0, 227, 113, [], "new AnimationManager"]}
  },
  "+AnimationManager": [632],
  AnimationParser: {
    "^": "Object;",
    static: {AnimationParser$: [function() {
        return new R.AnimationParser();
      }, null, null, 0, 0, 228, "new AnimationParser"], AnimationParser_spriteSheet: [function(game, key, frameWidth, frameHeight, frameMax, margin, spacing) {
        var img, t1, width, height, t2, t3, t4, total, data, y, x, i, uuid, t5;
        img = game.get$cache().getImage$1(key);
        if (img == null)
          return;
        t1 = J.getInterceptor$x(img);
        width = t1.get$width(img);
        height = t1.get$height(img);
        if (J.$le$n(frameWidth, 0))
          frameWidth = C.JSNumber_methods.floor$0(J.$div$n(J.$negate$n(width), P.min(-1, frameWidth)));
        if (J.$le$n(frameHeight, 0))
          frameHeight = C.JSNumber_methods.floor$0(J.$div$n(J.$negate$n(height), P.min(-1, frameHeight)));
        t1 = J.getInterceptor$n(width);
        t2 = J.getInterceptor$ns(frameWidth);
        t3 = J.getInterceptor$n(height);
        t4 = J.getInterceptor$ns(frameHeight);
        total = J.floor$0$n(J.$div$n(t1.$sub(width, margin), t2.$add(frameWidth, spacing))) * J.floor$0$n(J.$div$n(t3.$sub(height, margin), t4.$add(frameHeight, spacing)));
        if (!J.$eq(frameMax, -1))
          total = frameMax;
        if (t1.$eq(width, 0) || t3.$eq(height, 0) || t1.$lt(width, frameWidth) || t3.$lt(height, frameHeight) || J.$eq(total, 0)) {
          window;
          if (typeof console != "undefined")
            console.warn("Phaser.AnimationParser.spriteSheet: width/height zero or width/height < given frameWidth/frameHeight");
          return;
        }
        data = new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        if (typeof total !== "number")
          return H.iae(total);
        y = margin;
        x = y;
        i = 0;
        for (; i < total; ++i) {
          uuid = game.get$rnd().uuid$0();
          t1 = new R.Frame(i, x, y, frameWidth, frameHeight, "", uuid, null, null, null, false, "cw", false, null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          t1.centerX = J.floor$0$n(J.$div$n(frameWidth, 2));
          t1.centerY = J.floor$0$n(J.$div$n(frameHeight, 2));
          t1.sourceSizeW = frameWidth;
          t1.sourceSizeH = frameHeight;
          data.addFrame$1(t1);
          t1 = $.get$TextureCache();
          t3 = J.$index$asx($.get$BaseTextureCache(), key);
          t5 = new M.Rectangle0(0, 0, 0, 0);
          t5.x = x;
          t5.y = y;
          t5.width = frameWidth;
          t5.height = frameHeight;
          J.$indexSet$ax(t1, uuid, M.Texture$(t3, t5));
          x = J.$add$ns(x, t2.$add(frameWidth, spacing));
          if (J.$gt$n(J.$add$ns(x, frameWidth), width)) {
            y = J.$add$ns(y, t4.$add(frameHeight, spacing));
            x = margin;
          }
        }
        return data;
      }, function(game, key, frameWidth, frameHeight) {
        return R.AnimationParser_spriteSheet(game, key, frameWidth, frameHeight, -1, 0, 0);
      }, null, function(game, key, frameWidth, frameHeight, frameMax, margin) {
        return R.AnimationParser_spriteSheet(game, key, frameWidth, frameHeight, frameMax, margin, 0);
      }, null, function(game, key, frameWidth, frameHeight, frameMax) {
        return R.AnimationParser_spriteSheet(game, key, frameWidth, frameHeight, frameMax, 0, 0);
      }, null, "call$7", "call$4", "call$6", "call$5", "AnimationParser_spriteSheet$closure", 8, 6, 229, 230, 5, 5, 214, [], 231, [], 232, [], 233, [], 234, [], 235, [], 236, [], "spriteSheet"], AnimationParser_JSONData: [function(game, json, cacheKey) {
        var t1, data, $frames, i, t2, uuid, t3, t4, t5, newFrame;
        t1 = J.getInterceptor$asx(json);
        if (t1.$index(json, "frames") == null) {
          window;
          if (typeof console != "undefined")
            console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array");
          window;
          if (typeof console != "undefined")
            console.log(json);
          return;
        }
        data = new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        $frames = t1.$index(json, "frames");
        t1 = J.getInterceptor$asx($frames);
        i = 0;
        while (true) {
          t2 = t1.get$length($frames);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          uuid = game.get$rnd().uuid$0();
          t2 = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "x");
          t3 = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "y");
          t4 = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "w");
          t5 = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "h");
          t3 = new R.Frame(i, t2, t3, t4, t5, J.$index$asx(t1.$index($frames, i), "filename"), uuid, null, null, null, false, "cw", false, null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          t3.centerX = J.floor$0$n(J.$div$n(t4, 2));
          t3.centerY = J.floor$0$n(J.$div$n(t5, 2));
          t3.sourceSizeW = t4;
          t3.sourceSizeH = t5;
          newFrame = data.addFrame$1(t3);
          t3 = $.get$TextureCache();
          t5 = J.$index$asx($.get$BaseTextureCache(), cacheKey);
          t4 = new M.Rectangle0(0, 0, 0, 0);
          t4.x = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "x");
          t4.y = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "y");
          t4.width = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "w");
          t4.height = J.$index$asx(J.$index$asx(t1.$index($frames, i), "frame"), "h");
          J.$indexSet$ax(t3, uuid, M.Texture$(t5, t4));
          if (J.$index$asx(t1.$index($frames, i), "trimmed") === true) {
            newFrame.setTrim$7(J.$index$asx(t1.$index($frames, i), "trimmed"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "sourceSize"), "w"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "sourceSize"), "h"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "spriteSourceSize"), "x"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "spriteSourceSize"), "y"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "spriteSourceSize"), "w"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "spriteSourceSize"), "h"));
            J.set$trim$s(J.$index$asx($.get$TextureCache(), uuid), new R.Rectangle1(J.$index$asx(J.$index$asx(t1.$index($frames, i), "spriteSourceSize"), "x"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "spriteSourceSize"), "y"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "sourceSize"), "w"), J.$index$asx(J.$index$asx(t1.$index($frames, i), "sourceSize"), "h"), 0, 0, 0, 0));
          }
          ++i;
        }
        return data;
      }, "call$3", "AnimationParser_JSONData$closure", 6, 0, 237, 214, [], 238, [], 239, [], "JSONData"], AnimationParser_JSONDataHash: [function(game, json, cacheKey) {
        var t1, data, $frames, t2, i, key, uuid, t3, t4, t5, t6, newFrame;
        t1 = J.getInterceptor$asx(json);
        if (t1.$index(json, "frames") == null) {
          window;
          if (typeof console != "undefined")
            console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object");
          window;
          if (typeof console != "undefined")
            console.log(json);
          return;
        }
        data = new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        $frames = t1.$index(json, "frames");
        for (t1 = J.getInterceptor$x($frames), t2 = J.get$iterator$ax(t1.get$keys($frames)), i = 0; t2.moveNext$0();) {
          key = t2.get$current();
          uuid = game.get$rnd().uuid$0();
          t3 = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "x");
          t4 = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "y");
          t5 = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "w");
          t6 = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "h");
          t4 = new R.Frame(i, t3, t4, t5, t6, key, uuid, null, null, null, false, "cw", false, null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          t4.centerX = J.floor$0$n(J.$div$n(t5, 2));
          t4.centerY = J.floor$0$n(J.$div$n(t6, 2));
          t4.sourceSizeW = t5;
          t4.sourceSizeH = t6;
          newFrame = data.addFrame$1(t4);
          t4 = $.get$TextureCache();
          t6 = J.$index$asx($.get$BaseTextureCache(), cacheKey);
          t5 = new M.Rectangle0(0, 0, 0, 0);
          t5.x = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "x");
          t5.y = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "y");
          t5.width = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "w");
          t5.height = J.$index$asx(J.$index$asx(t1.$index($frames, key), "frame"), "h");
          J.$indexSet$ax(t4, uuid, M.Texture$(t6, t5));
          if (J.$index$asx(t1.$index($frames, key), "trimmed") === true) {
            newFrame.setTrim$7(J.$index$asx(t1.$index($frames, key), "trimmed"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "sourceSize"), "w"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "sourceSize"), "h"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "spriteSourceSize"), "x"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "spriteSourceSize"), "y"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "spriteSourceSize"), "w"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "spriteSourceSize"), "h"));
            J.set$trim$s(J.$index$asx($.get$TextureCache(), uuid), new R.Rectangle1(J.$index$asx(J.$index$asx(t1.$index($frames, key), "spriteSourceSize"), "x"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "spriteSourceSize"), "y"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "sourceSize"), "w"), J.$index$asx(J.$index$asx(t1.$index($frames, key), "sourceSize"), "h"), 0, 0, 0, 0));
          }
          ++i;
        }
        return data;
      }, "call$3", "AnimationParser_JSONDataHash$closure", 6, 0, 237, 214, [], 238, [], 239, [], "JSONDataHash"], AnimationParser_XMLData: [function(game, xml, cacheKey) {
        var t1, data, $frames, frameWidth, frameHeight, i, uuid, $name, x, y, width, height, frameX, frameY, newFrame, t2, t3;
        t1 = J.getInterceptor$x(xml);
        t1.getElementsByTagName$1(xml, "TextureAtlas");
        data = new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        $frames = t1.getElementsByTagName$1(xml, "SubTexture");
        for (frameWidth = null, frameHeight = null, i = 0; i < $frames.length; ++i) {
          uuid = game.get$rnd().uuid$0();
          if (i >= $frames.length)
            return H.ioore($frames, i);
          t1 = J.get$attributes$x($frames[i])._element;
          $name = t1.getAttribute("name");
          x = H.Primitives_parseInt(t1.getAttribute("x"), null, null);
          y = H.Primitives_parseInt(t1.getAttribute("y"), null, null);
          width = H.Primitives_parseInt(t1.getAttribute("width"), null, null);
          height = H.Primitives_parseInt(t1.getAttribute("height"), null, null);
          if (t1.hasAttribute("frameX") === true) {
            frameX = J.abs$0$n(H.Primitives_parseInt(t1.getAttribute("frameX"), null, null));
            frameY = J.abs$0$n(H.Primitives_parseInt(t1.getAttribute("frameY"), null, null));
            frameWidth = J.abs$0$n(H.Primitives_parseInt(t1.getAttribute("frameWidth"), null, null));
            frameHeight = J.abs$0$n(H.Primitives_parseInt(t1.getAttribute("frameHeight"), null, null));
          } else {
            frameX = null;
            frameY = null;
          }
          t1 = new R.Frame(i, x, y, width, height, $name, uuid, null, null, null, false, "cw", false, null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          t1.centerX = J.floor$0$n(J.$div$n(width, 2));
          t1.centerY = J.floor$0$n(J.$div$n(height, 2));
          t1.sourceSizeW = width;
          t1.sourceSizeH = height;
          newFrame = data.addFrame$1(t1);
          t1 = $.get$TextureCache();
          t2 = J.$index$asx($.get$BaseTextureCache(), cacheKey);
          t3 = new M.Rectangle0(0, 0, 0, 0);
          t3.x = x;
          t3.y = y;
          t3.width = width;
          t3.height = height;
          J.$indexSet$ax(t1, uuid, M.Texture$(t2, t3));
          if (frameX != null || frameY != null) {
            newFrame.setTrim$7(true, width, height, frameX, frameY, frameWidth, frameHeight);
            J.set$trim$s(J.$index$asx($.get$TextureCache(), uuid), new R.Rectangle1(frameX, frameY, width, height, 0, 0, 0, 0));
          }
        }
        return data;
      }, "call$3", "AnimationParser_XMLData$closure", 6, 0, 240, 214, [], 241, [], 239, [], "XMLData"]}
  },
  "+AnimationParser": [632],
  Frame: {
    "^": "Rectangle1;index*-599,x:Phaser$Frame$x*-601,y:Phaser$Frame$y*-601,width:Phaser$Frame$width*-601,height:Phaser$Frame$height*-601,name*-639,uuid@-639,centerX@-601,centerY@-601,distance@-601,rotate*-602,rotationDirection@-639,trimmed@-602,sourceSizeW@-601,sourceSizeH@-601,spriteSourceSizeX@-601,spriteSourceSizeY@-601,spriteSourceSizeW@-601,spriteSourceSizeH@-601,Phaser$Rectangle1$x-601,Phaser$Rectangle1$y-601,Phaser$Rectangle1$width-601,Phaser$Rectangle1$height-601,x-601,y-601,width-601,height-601",
    uuid$0: function() {
      return this.uuid.call$0();
    },
    distance$2: function(arg0, arg1) {
      return this.distance.call$2(arg0, arg1);
    },
    rotate$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.rotate.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    setTrim$7: [function(trimmed, actualWidth, actualHeight, destX, destY, destWidth, destHeight) {
      this.trimmed = trimmed;
      if (trimmed === true) {
        this.Phaser$Frame$width = actualWidth;
        this.Phaser$Frame$height = actualHeight;
        this.sourceSizeW = actualWidth;
        this.sourceSizeH = actualHeight;
        this.centerX = J.floor$0$n(J.$div$n(actualWidth, 2));
        this.centerY = J.floor$0$n(J.$div$n(actualHeight, 2));
        this.spriteSourceSizeX = destX;
        this.spriteSourceSizeY = destY;
        this.spriteSourceSizeW = destWidth;
        this.spriteSourceSizeH = destHeight;
      }
    }, "call$7", "get$setTrim", 14, 0, 963, 964, [], 965, [], 966, [], 967, [], 968, [], 969, [], 970, [], "setTrim"],
    getRect$1: [function(out) {
      var t1, t2, t3, t4;
      t1 = this.Phaser$Frame$x;
      t2 = this.Phaser$Frame$y;
      t3 = this.Phaser$Frame$width;
      t4 = this.Phaser$Frame$height;
      if (out == null)
        out = new R.Rectangle1(t1, t2, t3, t4, 0, 0, 0, 0);
      else
        out.setTo$4(t1, t2, t3, t4);
      return out;
    }, function() {
      return this.getRect$1(null);
    }, "getRect$0", "call$1", "call$0", "get$getRect", 0, 2, 971, 32, 317, [], "getRect"],
    clone$1: [function(_, output) {
      var t1;
      if (output != null) {
        t1 = J.getInterceptor$x(output);
        t1.set$index(output, this.index);
        t1.set$x(output, this.Phaser$Frame$x);
        t1.set$y(output, this.Phaser$Frame$y);
        t1.set$width(output, this.Phaser$Frame$width);
        t1.set$height(output, this.Phaser$Frame$height);
        t1.set$name(output, this.name);
        output.set$uuid(this.uuid);
        return output;
      }
      return R.Frame$(this.index, this.Phaser$Frame$x, this.Phaser$Frame$y, this.Phaser$Frame$width, this.Phaser$Frame$height, this.name, this.uuid);
    }, function($receiver) {
      return this.clone$1($receiver, null);
    }, "clone$0", "call$1", "call$0", "get$clone", 0, 2, 972, 32, 973, [], "clone"],
    Frame$7: function(index, x, y, width, height, $name, uuid) {
      this.centerX = J.floor$0$n(J.$div$n(this.Phaser$Frame$width, 2));
      this.centerY = J.floor$0$n(J.$div$n(this.Phaser$Frame$height, 2));
      this.sourceSizeW = this.Phaser$Frame$width;
      this.sourceSizeH = this.Phaser$Frame$height;
    },
    static: {Frame$: [function(index, x, y, width, height, $name, uuid) {
        var t1 = new R.Frame(index, x, y, width, height, $name, uuid, null, null, null, false, "cw", false, null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        t1.Frame$7(index, x, y, width, height, $name, uuid);
        return t1;
      }, null, null, 14, 0, 242, 243, [], 6, [], 7, [], 10, [], 11, [], 44, [], 244, [], "new Frame"]}
  },
  "+Frame": [974],
  FrameData: {
    "^": "Object;_frames@-975,_frameNames@-921",
    get$total: [function(_) {
      return J.get$length$asx(this._frames);
    }, null, null, 1, 0, 367, "total"],
    addFrame$1: [function(frame) {
      var t1 = J.getInterceptor$x(frame);
      t1.set$index(frame, J.get$length$asx(this._frames));
      J.add$1$ax(this._frames, frame);
      if (!J.$eq(t1.get$name(frame), ""))
        J.$indexSet$ax(this._frameNames, t1.get$name(frame), t1.get$index(frame));
      return frame;
    }, "call$1", "get$addFrame", 2, 0, 976, 178, [], "addFrame"],
    getFrame$1: [function(index) {
      if (J.$gt$n(index, J.get$length$asx(this._frames)))
        index = 0;
      return J.$index$asx(this._frames, index);
    }, "call$1", "get$getFrame", 2, 0, 977, 243, [], "getFrame"],
    getFrameByName$1: [function($name) {
      var t1 = J.$index$asx(this._frameNames, $name);
      if (typeof t1 === "number")
        return J.$index$asx(this._frames, J.$index$asx(this._frameNames, $name));
      return;
    }, "call$1", "get$getFrameByName", 2, 0, 978, 44, [], "getFrameByName"],
    checkFrameName$1: [function($name) {
      if (J.$index$asx(this._frameNames, $name) == null)
        return false;
      return true;
    }, "call$1", "get$checkFrameName", 2, 0, 979, 44, [], "checkFrameName"],
    getFrameRange$3: [function(start, end, output) {
      var t1, i, t2;
      if (output == null)
        output = [];
      for (t1 = J.getInterceptor$ax(output), i = start; t2 = J.getInterceptor$n(i), t2.$le(i, end); i = t2.$add(i, 1))
        t1.add$1(output, J.$index$asx(this._frames, i));
      return output;
    }, function(start, end) {
      return this.getFrameRange$3(start, end, null);
    }, "getFrameRange$2", "call$3", "call$2", "get$getFrameRange", 4, 2, 980, 32, 223, [], 666, [], 973, [], "getFrameRange"],
    getFrames$3: [function($frames, useNumericIndex, output) {
      var t1, i, t2, len, t3, index;
      if (useNumericIndex == null)
        useNumericIndex = true;
      if (output == null)
        output = [];
      if ($frames == null || J.$eq(J.get$length$asx($frames), 0)) {
        t1 = J.getInterceptor$ax(output);
        i = 0;
        while (true) {
          t2 = J.get$length$asx(this._frames);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          t1.add$1(output, J.$index$asx(this._frames, i));
          ++i;
        }
      } else {
        t1 = J.getInterceptor$asx($frames);
        len = t1.get$length($frames);
        if (typeof len !== "number")
          return H.iae(len);
        t2 = J.getInterceptor$ax(output);
        t3 = useNumericIndex === true;
        i = 0;
        for (; i < len; ++i)
          if (t3) {
            index = t1.$index($frames, i);
            if (J.$gt$n(index, J.get$length$asx(this._frames)))
              index = 0;
            t2.add$1(output, J.$index$asx(this._frames, index));
          } else
            t2.add$1(output, this.getFrameByName$1(t1.$index($frames, i)));
      }
      return output;
    }, function() {
      return this.getFrames$3(null, null, null);
    }, "getFrames$0", function(frames) {
      return this.getFrames$3(frames, null, null);
    }, "getFrames$1", function(frames, useNumericIndex) {
      return this.getFrames$3(frames, useNumericIndex, null);
    }, "getFrames$2", "call$3", "call$0", "call$1", "call$2", "get$getFrames", 0, 6, 981, 32, 32, 32, 25, [], 958, [], 973, [], "getFrames"],
    getFrameIndexes$3: [function($frames, useNumericIndex, output) {
      var len, t1, i, t2, t3;
      if (useNumericIndex == null)
        useNumericIndex = true;
      if (output == null)
        output = [];
      if ($frames == null || J.$eq(J.get$length$asx($frames), 0)) {
        len = J.get$length$asx(this._frames);
        if (typeof len !== "number")
          return H.iae(len);
        t1 = J.getInterceptor$ax(output);
        i = 0;
        for (; i < len; ++i)
          t1.add$1(output, J.get$index$x(J.$index$asx(this._frames, i)));
      } else {
        t1 = J.getInterceptor$asx($frames);
        len = t1.get$length($frames);
        if (typeof len !== "number")
          return H.iae(len);
        t2 = useNumericIndex === true;
        t3 = J.getInterceptor$ax(output);
        i = 0;
        for (; i < len; ++i)
          if (t2)
            t3.add$1(output, t1.$index($frames, i));
          else if (this.getFrameByName$1(t1.$index($frames, i)) != null)
            t3.add$1(output, J.get$index$x(this.getFrameByName$1(t1.$index($frames, i))));
      }
      return output;
    }, function() {
      return this.getFrameIndexes$3(null, null, null);
    }, "getFrameIndexes$0", function(frames) {
      return this.getFrameIndexes$3(frames, null, null);
    }, "getFrameIndexes$1", function(frames, useNumericIndex) {
      return this.getFrameIndexes$3(frames, useNumericIndex, null);
    }, "getFrameIndexes$2", "call$3", "call$0", "call$1", "call$2", "get$getFrameIndexes", 0, 6, 982, 32, 32, 32, 25, [], 958, [], 973, [], "getFrameIndexes"],
    static: {FrameData$: [function() {
        return new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      }, null, null, 0, 0, 13, "new FrameData"]}
  },
  "+FrameData": [632],
  AtLimit: {
    "^": "Object;x*-602,y*-602",
    static: {AtLimit$: [function() {
        return new R.AtLimit(false, false);
      }, null, null, 0, 0, 245, "new AtLimit"]}
  },
  "+AtLimit": [632],
  Camera: {
    "^": "Object;game@-598,world@-983,id*-599,view*-974,screenView@-974,bounds@-974,deadzone@-974,visible@-602,atLimit@-984,target*-937,_edge@-601,displayObject@-668,scale*-600",
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    get$x: [function(_) {
      return J.get$x$x(this.view);
    }, null, null, 1, 0, 604, "x"],
    set$x: [function(_, value) {
      J.set$x$x(this.view, value);
      if (this.bounds != null)
        this.checkBounds$0();
    }, null, null, 3, 0, 605, 100, [], "x"],
    get$y: [function(_) {
      return J.get$y$x(this.view);
    }, null, null, 1, 0, 604, "y"],
    set$y: [function(_, value) {
      J.set$y$x(this.view, value);
      if (this.bounds != null)
        this.checkBounds$0();
    }, null, null, 3, 0, 605, 100, [], "y"],
    get$width: [function(_) {
      return J.get$width$x(this.view);
    }, null, null, 1, 0, 604, "width"],
    set$width: [function(_, value) {
      J.set$width$x(this.view, value);
    }, null, null, 3, 0, 605, 100, [], "width"],
    get$height: [function(_) {
      return J.get$height$x(this.view);
    }, null, null, 1, 0, 604, "height"],
    set$height: [function(_, value) {
      J.set$height$x(this.view, value);
    }, null, null, 3, 0, 605, 100, [], "height"],
    follow$2: [function(target, style) {
      var w, h, helper;
      this.target = target;
      switch (style) {
        case 1:
          w = J.$div$n(J.get$width$x(this.view), 8);
          h = J.$div$n(J.get$height$x(this.view), 3);
          this.deadzone = new R.Rectangle1(J.$div$n(J.$sub$n(J.get$width$x(this.view), w), 2), J.$sub$n(J.$div$n(J.$sub$n(J.get$height$x(this.view), h), 2), J.$mul$ns(h, 0.25)), w, h, 0, 0, 0, 0);
          break;
        case 2:
          helper = P.max(J.get$width$x(this.view), J.get$height$x(this.view)) / 4;
          this.deadzone = new R.Rectangle1(J.$div$n(J.$sub$n(J.get$width$x(this.view), helper), 2), J.$div$n(J.$sub$n(J.get$height$x(this.view), helper), 2), helper, helper, 0, 0, 0, 0);
          break;
        case 3:
          helper = P.max(J.get$width$x(this.view), J.get$height$x(this.view)) / 8;
          this.deadzone = new R.Rectangle1(J.$div$n(J.$sub$n(J.get$width$x(this.view), helper), 2), J.$div$n(J.$sub$n(J.get$height$x(this.view), helper), 2), helper, helper, 0, 0, 0, 0);
          break;
        case 0:
          this.deadzone = null;
          break;
        default:
          this.deadzone = null;
          break;
      }
    }, function(target) {
      return this.follow$2(target, 0);
    }, "follow$1", "call$2", "call$1", "get$follow", 2, 2, 985, 5, 58, [], 156, [], "follow"],
    unfollow$0: [function() {
      this.target = null;
    }, "call$0", "get$unfollow", 0, 0, 13, "unfollow"],
    focusOn$1: [function(displayObject) {
      var t1 = J.getInterceptor$x(displayObject);
      this.setPosition$2(J.round$0$n(J.$sub$n(t1.get$x(displayObject), this.view.get$halfWidth())), J.round$0$n(J.$sub$n(t1.get$y(displayObject), this.view.get$halfHeight())));
    }, "call$1", "get$focusOn", 2, 0, 277, 805, [], "focusOn"],
    focusOnXY$2: [function(x, y) {
      this.setPosition$2(J.round$0$n(J.$sub$n(x, this.view.get$halfWidth())), J.round$0$n(J.$sub$n(y, this.view.get$halfHeight())));
    }, "call$2", "get$focusOnXY", 4, 0, 111, 6, [], 7, [], "focusOnXY"],
    update$0: [function() {
      var t1, t2;
      t1 = this.target;
      if (t1 != null) {
        t2 = J.getInterceptor$x(t1);
        if (this.deadzone != null) {
          t1 = J.$sub$n(t2.get$x(t1), J.get$x$x(this.view));
          this._edge = t1;
          if (J.$lt$n(t1, J.get$left$x(this.deadzone)))
            J.set$x$x(this.view, J.$sub$n(J.get$x$x(this.target), J.get$left$x(this.deadzone)));
          else if (J.$gt$n(this._edge, J.get$right$x(this.deadzone)))
            J.set$x$x(this.view, J.$sub$n(J.get$x$x(this.target), J.get$right$x(this.deadzone)));
          t1 = J.$sub$n(J.get$y$x(this.target), J.get$y$x(this.view));
          this._edge = t1;
          if (J.$lt$n(t1, J.get$top$x(this.deadzone)))
            J.set$y$x(this.view, J.$sub$n(J.get$y$x(this.target), J.get$top$x(this.deadzone)));
          else if (J.$gt$n(this._edge, J.get$bottom$x(this.deadzone)))
            J.set$y$x(this.view, J.$sub$n(J.get$y$x(this.target), J.get$bottom$x(this.deadzone)));
        } else {
          J.set$x$x(this.view, J.$sub$n(t2.get$x(t1), this.view.get$halfWidth()));
          J.set$y$x(this.view, J.$sub$n(J.get$y$x(this.target), this.view.get$halfHeight()));
        }
      }
      if (this.bounds != null)
        this.checkBounds$0();
      J.set$x$x(J.get$position$x(this.displayObject), J.$negate$n(J.get$x$x(this.view)));
      J.set$y$x(J.get$position$x(this.displayObject), J.$negate$n(J.get$y$x(this.view)));
    }, "call$0", "get$update", 0, 0, 13, "update"],
    updateTarget$0: [function() {
      var t1, t2;
      t1 = this.deadzone;
      t2 = this.target;
      if (t1 != null) {
        t1 = J.$sub$n(J.get$x$x(t2), J.get$x$x(this.view));
        this._edge = t1;
        if (J.$lt$n(t1, J.get$left$x(this.deadzone)))
          J.set$x$x(this.view, J.$sub$n(J.get$x$x(this.target), J.get$left$x(this.deadzone)));
        else if (J.$gt$n(this._edge, J.get$right$x(this.deadzone)))
          J.set$x$x(this.view, J.$sub$n(J.get$x$x(this.target), J.get$right$x(this.deadzone)));
        t1 = J.$sub$n(J.get$y$x(this.target), J.get$y$x(this.view));
        this._edge = t1;
        if (J.$lt$n(t1, J.get$top$x(this.deadzone)))
          J.set$y$x(this.view, J.$sub$n(J.get$y$x(this.target), J.get$top$x(this.deadzone)));
        else if (J.$gt$n(this._edge, J.get$bottom$x(this.deadzone)))
          J.set$y$x(this.view, J.$sub$n(J.get$y$x(this.target), J.get$bottom$x(this.deadzone)));
      } else {
        J.set$x$x(this.view, J.$sub$n(J.get$x$x(t2), this.view.get$halfWidth()));
        J.set$y$x(this.view, J.$sub$n(J.get$y$x(this.target), this.view.get$halfHeight()));
      }
    }, "call$0", "get$updateTarget", 0, 0, 13, "updateTarget"],
    setBoundsToWorld$0: [function() {
      this.bounds.setTo$4(J.get$x$x(this.game.get$world().get$bounds()), J.get$y$x(this.game.get$world().get$bounds()), J.get$width$x(this.game.get$world().get$bounds()), J.get$height$x(this.game.get$world().get$bounds()));
    }, "call$0", "get$setBoundsToWorld", 0, 0, 13, "setBoundsToWorld"],
    checkBounds$0: [function() {
      J.set$x$x(this.atLimit, false);
      J.set$y$x(this.atLimit, false);
      if (J.$le$n(J.get$x$x(this.view), J.get$x$x(this.bounds))) {
        J.set$x$x(this.atLimit, true);
        J.set$x$x(this.view, J.get$x$x(this.bounds));
      }
      if (J.$ge$n(J.get$right$x(this.view), J.get$right$x(this.bounds))) {
        J.set$x$x(this.atLimit, true);
        J.set$x$x(this.view, J.$sub$n(J.get$right$x(this.bounds), J.get$width$x(this.view)));
      }
      if (J.$le$n(J.get$y$x(this.view), J.get$top$x(this.bounds))) {
        J.set$y$x(this.atLimit, true);
        J.set$y$x(this.view, J.get$top$x(this.bounds));
      }
      if (J.$ge$n(J.get$bottom$x(this.view), J.get$bottom$x(this.bounds))) {
        J.set$y$x(this.atLimit, true);
        J.set$y$x(this.view, J.$sub$n(J.get$bottom$x(this.bounds), J.get$height$x(this.view)));
      }
      J.floor$0$n(this.view);
    }, "call$0", "get$checkBounds", 0, 0, 13, "checkBounds"],
    setPosition$2: [function(x, y) {
      J.set$x$x(this.view, x);
      J.set$y$x(this.view, y);
      if (this.bounds != null)
        this.checkBounds$0();
    }, "call$2", "get$setPosition", 4, 0, 111, 6, [], 7, [], "setPosition"],
    setSize$2: [function(width, height) {
      J.set$width$x(this.view, width);
      J.set$height$x(this.view, height);
    }, "call$2", "get$setSize", 4, 0, 111, 10, [], 11, [], "setSize"],
    reset$0: [function(_) {
      this.target = null;
      J.set$x$x(this.view, 0);
      J.set$y$x(this.view, 0);
    }, "call$0", "get$reset", 0, 0, 13, "reset"],
    Camera$6: function(game, id, x, y, width, height) {
      this.world = this.game.get$world();
      this.id = 0;
      this.view = new R.Rectangle1(x, y, width, height, 0, 0, 0, 0);
      this.screenView = new R.Rectangle1(x, y, width, height, 0, 0, 0, 0);
      this.bounds = new R.Rectangle1(x, y, width, height, 0, 0, 0, 0);
      this.deadzone = null;
      this.visible = true;
      this.atLimit = new R.AtLimit(false, false);
      this.target = null;
      this._edge = 0;
      this.displayObject = null;
      this.scale = null;
    },
    static: {"^": "Camera_FOLLOW_LOCKON<-599,Camera_FOLLOW_PLATFORMER<-599,Camera_FOLLOW_TOPDOWN<-599,Camera_FOLLOW_TOPDOWN_TIGHT<-599", Camera$: [function(game, id, x, y, width, height) {
        var t1 = new R.Camera(game, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Camera$6(game, id, x, y, width, height);
        return t1;
      }, null, null, 12, 0, 246, 214, [], 183, [], 6, [], 7, [], 10, [], 11, [], "new Camera"]}
  },
  "+Camera": [632],
  Signal: {
    "^": "Object;_bindings@-986,_prevParams@-32,memorize@-602,_shouldPropagate@-602,active@-602",
    _validateListener$2: [function(listener, fnName) {
      var t1 = H.checkSubtypeOfRuntimeType(listener, H.getTypeArgumentByIndex(this, 0));
      if (!t1)
        throw H.wrapException(P.Exception_Exception(C.JSString_methods.replaceFirst$2("listener is a required param of {fn}() and should be a Function.", "{fn}", fnName)));
    }, "call$2", "get$_validateListener", 4, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T_String", args: [T, P.String]};
      }, this.$receiver, "Signal");
    }, 936, [], 987, [], "_validateListener"],
    _registerListener$3: [function(listener, isOnce, priority) {
      var prevIndex, binding, t1, t2;
      prevIndex = this._indexOfListener$1(listener);
      if (!J.$eq(prevIndex, -1)) {
        binding = J.$index$asx(this._bindings, prevIndex);
        if (!J.$eq(binding.isOnce$0(), isOnce)) {
          t1 = isOnce === true;
          t2 = "You cannot add" + (t1 ? "" : "Once") + "() then add";
          throw H.wrapException(P.Exception_Exception(t2 + (!t1 ? "" : "Once") + "() the same listener without removing the relationship first."));
        }
      } else {
        binding = new R.SignalBinding(listener, isOnce, priority, this, true, null);
        if (priority == null)
          binding._priority = 0;
        this._addBinding$1(binding);
      }
      if (this.memorize === true && this._prevParams === true)
        binding.execute$1(this._prevParams);
      return binding;
    }, function(listener, isOnce) {
      return this._registerListener$3(listener, isOnce, null);
    }, "_registerListener$2", "call$3", "call$2", "get$_registerListener", 4, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "SignalBinding__T_bool__int", ret: R.SignalBinding, args: [T, P.bool], opt: [P.$int]};
      }, this.$receiver, "Signal");
    }, 32, 936, [], 988, [], 989, [], "_registerListener"],
    _addBinding$1: [function(binding) {
      var n, t1;
      n = J.get$length$asx(this._bindings);
      do {
        n = J.$sub$n(n, 1);
        t1 = J.getInterceptor$n(n);
      } while (t1.$ge(n, 0) && J.$index$asx(this._bindings, n) != null && J.$le$n(binding.get$_priority(), J.$index$asx(this._bindings, n).get$_priority()));
      J.insert$2$ax(this._bindings, t1.$add(n, 1), binding);
    }, "call$1", "get$_addBinding", 2, 0, 990, 991, [], "_addBinding"],
    _indexOfListener$1: [function(listener) {
      var n, t1, n0;
      n = J.get$length$asx(this._bindings);
      for (; t1 = J.getInterceptor$n(n), n0 = t1.$sub(n, 1), !t1.$eq(n, 0); n = n0)
        if (J.$eq(J.$index$asx(this._bindings, n0).get$_listener(), listener))
          return n0;
      return -1;
    }, "call$1", "get$_indexOfListener", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "int__T", ret: P.$int, args: [T]};
      }, this.$receiver, "Signal");
    }, 936, [], "_indexOfListener"],
    has$1: [function(listener) {
      return !J.$eq(this._indexOfListener$1(listener), -1);
    }, "call$1", "get$has", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "bool__T", ret: P.bool, args: [T]};
      }, this.$receiver, "Signal");
    }, 936, [], "has"],
    add$2: [function(_, listener, priority) {
      var t1 = H.checkSubtypeOfRuntimeType(listener, H.getTypeArgumentByIndex(this, 0));
      if (!t1)
        H.throwExpression(P.Exception_Exception(C.JSString_methods.replaceFirst$2("listener is a required param of {fn}() and should be a Function.", "{fn}", "add")));
      return this._registerListener$3(listener, false, priority);
    }, function($receiver, listener) {
      return this.add$2($receiver, listener, null);
    }, "add$1", "call$2", "call$1", "get$add", 2, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "SignalBinding__T__int", ret: R.SignalBinding, args: [T], opt: [P.$int]};
      }, this.$receiver, "Signal");
    }, 32, 936, [], 989, [], "add"],
    addOnce$2: [function(listener, priority) {
      var t1 = H.checkSubtypeOfRuntimeType(listener, H.getTypeArgumentByIndex(this, 0));
      if (!t1)
        H.throwExpression(P.Exception_Exception(C.JSString_methods.replaceFirst$2("listener is a required param of {fn}() and should be a Function.", "{fn}", "addOnce")));
      return this._registerListener$3(listener, true, priority);
    }, function(listener) {
      return this.addOnce$2(listener, null);
    }, "addOnce$1", "call$2", "call$1", "get$addOnce", 2, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "SignalBinding__T__int", ret: R.SignalBinding, args: [T], opt: [P.$int]};
      }, this.$receiver, "Signal");
    }, 32, 936, [], 989, [], "addOnce"],
    remove$1: [function(_, listener) {
      var t1, i;
      t1 = H.checkSubtypeOfRuntimeType(listener, H.getTypeArgumentByIndex(this, 0));
      if (!t1)
        H.throwExpression(P.Exception_Exception(C.JSString_methods.replaceFirst$2("listener is a required param of {fn}() and should be a Function.", "{fn}", "remove")));
      i = this._indexOfListener$1(listener);
      if (!J.$eq(i, -1)) {
        J.$index$asx(this._bindings, i)._destroy$0();
        J.removeAt$1$ax(this._bindings, i);
      }
      return listener;
    }, "call$1", "get$remove", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T__T", ret: T, args: [T]};
      }, this.$receiver, "Signal");
    }, 936, [], "remove"],
    removeAll$0: [function() {
      var n, t1, n0;
      n = J.get$length$asx(this._bindings);
      for (; t1 = J.getInterceptor$n(n), n0 = t1.$sub(n, 1), t1.$gt(n, 0); n = n0)
        J.$index$asx(this._bindings, n0)._destroy$0();
      J.set$length$asx(this._bindings, 0);
    }, "call$0", "get$removeAll", 0, 0, 13, "removeAll"],
    getNumListeners$0: [function() {
      return J.get$length$asx(this._bindings);
    }, "call$0", "get$getNumListeners", 0, 0, 367, "getNumListeners"],
    halt$0: [function() {
      this._shouldPropagate = false;
    }, "call$0", "get$halt", 0, 0, 13, "halt"],
    dispatch$1: [function($arguments) {
      var paramsArr, n, bindings, t1;
      if (this.active !== true)
        return;
      paramsArr = !!J.getInterceptor($arguments).$isList || $arguments == null ? $arguments : [$arguments];
      n = J.get$length$asx(this._bindings);
      if (this.memorize === true)
        this._prevParams = paramsArr;
      if (J.$eq(n, 0))
        return;
      bindings = P.List_List$from(this._bindings, true, null);
      this._shouldPropagate = true;
      do {
        n = J.$sub$n(n, 1);
        if (J.$ge$n(n, 0)) {
          if (n >>> 0 !== n || n >= bindings.length)
            return H.ioore(bindings, n);
          t1 = bindings[n];
          t1 = t1 != null && this._shouldPropagate === true && !J.$eq(t1.execute$1(paramsArr), false);
        } else
          t1 = false;
      } while (t1);
    }, function() {
      return this.dispatch$1(null);
    }, "dispatch$0", "call$1", "call$0", "get$dispatch", 0, 2, 919, 32, 565, [], "dispatch"],
    forget$0: [function() {
      this._prevParams = null;
    }, "call$0", "get$forget", 0, 0, 13, "forget"],
    dispose$0: [function() {
      this.removeAll$0();
      this._bindings = null;
      this._prevParams = null;
    }, "call$0", "get$dispose", 0, 0, 13, "dispose"],
    toString$0: [function(_) {
      return "[Phaser.Signal active:" + ("[Phaser.Signal active:" + this.toString$0(0) + ".active numListeners:" + H.S(J.get$length$asx(this._bindings)) + "]") + ".active numListeners:" + H.S(J.get$length$asx(this._bindings)) + "]";
    }, "call$0", "get$toString", 0, 0, 782, "toString"],
    "<>": [1],
    static: {Signal$: [function($T) {
        return H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [$T]);
      }, null, null, 0, 0, function() {
        return H.computeSignature(function(T) {
          return {func: "Signal_", ret: [R.Signal, T]};
        }, this.$receiver, "Signal");
      }, "new Signal"]}
  },
  "+Signal": [632],
  Filter: {
    "^": "Object;game@-598,type*-599,passes@-992,shaders@-720,dirty@-602,padding*-599,uniforms@-754,fragmentSrc@-820",
    get$width: [function(_) {
      return J.$index$asx(J.$index$asx(J.$index$asx(this.uniforms, "resolution"), "value"), "x");
    }, null, null, 1, 0, 604, "width"],
    set$width: [function(_, value) {
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "resolution"), "value"), "x", value);
    }, null, null, 3, 0, 605, 100, [], "width"],
    get$height: [function(_) {
      return J.$index$asx(J.$index$asx(J.$index$asx(this.uniforms, "resolution"), "value"), "y");
    }, null, null, 1, 0, 604, "height"],
    set$height: [function(_, value) {
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "resolution"), "value"), "y", value);
    }, null, null, 3, 0, 605, 100, [], "height"],
    init$0: [function() {
    }, "call$0", "get$init", 0, 0, 13, "init"],
    setResolution$2: [function(width, height) {
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "resolution"), "value"), "x", width);
      J.$indexSet$ax(J.$index$asx(J.$index$asx(this.uniforms, "resolution"), "value"), "y", height);
    }, "call$2", "get$setResolution", 4, 0, 111, 10, [], 11, [], "setResolution"],
    update$1: [function(pointer) {
      var t1;
      if (pointer != null) {
        t1 = J.getInterceptor$x(pointer);
        if (J.$gt$n(t1.get$x(pointer), 0))
          J.$indexSet$ax(J.$index$asx(this.uniforms, "mouse"), "x", J.toStringAsFixed$1$n(t1.get$x(pointer), 2));
        if (J.$gt$n(t1.get$y(pointer), 0))
          J.$indexSet$ax(J.$index$asx(this.uniforms, "mouse"), "y", J.toStringAsFixed$1$n(t1.get$y(pointer), 2));
      }
      J.$indexSet$ax(J.$index$asx(this.uniforms, "time"), "value", this.game.get$time().totalElapsedSeconds$0());
    }, function() {
      return this.update$1(null);
    }, "update$0", "call$1", "call$0", "get$update", 0, 2, 993, 32, 994, [], "update"],
    destroy$0: [function() {
      this.game = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    Filter$3: function(game, uniforms, fragmentSrc) {
      this.type = 15;
      this.passes = [this];
      this.shaders = [];
      this.dirty = true;
      this.padding = 0;
      this.uniforms = P.LinkedHashMap_LinkedHashMap$_literal(["time", P.LinkedHashMap_LinkedHashMap$_literal(["type", "1f", "value", 0], null, null), "resolution", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 256, "y", 256], null, null)], null, null), "mouse", P.LinkedHashMap_LinkedHashMap$_literal(["type", "2f", "value", P.LinkedHashMap_LinkedHashMap$_literal(["x", 0, "y", 0], null, null)], null, null)], null, null);
      this.fragmentSrc = fragmentSrc;
      if (fragmentSrc == null)
        this.fragmentSrc = [];
    },
    static: {Filter$: [function(game, uniforms, fragmentSrc) {
        var t1 = new R.Filter(game, null, null, null, null, null, null, null);
        t1.Filter$3(game, uniforms, fragmentSrc);
        return t1;
      }, null, null, 2, 4, 247, 32, 32, 214, [], 248, [], 148, [], "new Filter"]}
  },
  "+Filter": [632],
  Game: {
    "^": "Object;width*-601,height*-601,renderer@-809,parent*-639,state*-995,transparent@-602,antialias@-602,physicsConfig@-754,id*-599,config@-754,renderType@-599,isBooted@-602,isRunning@-602,raf@-996,add*-997,make@-998,world@-983,cache@-999,input@-1000,load*-1001,net@-1002,scale*-1003,sound@-1004,plugins@-1005,stage@-1006,time@-1007,physics@-1008,tweens@-1009,rnd@-1010,device@-1011,camera@-1012,canvas*-808,context*-850,debug@-1013,particles@-1014,stepping@-602,pendingStep@-602,stepCount@-601,onPause*-1015,onResume@-1015,onBlur*-1015,onFocus*-1015,_paused@-602,_codePaused@-602,preserveDrawingBuffer@-602,_onBoot@-0",
    add$2: function($receiver, arg0, arg1) {
      return this.add.call$2(arg0, arg1);
    },
    add$1: function($receiver, arg0) {
      return this.add.call$1(arg0);
    },
    add$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.add.call$4(arg0, arg1, arg2, arg3);
    },
    add$3: function($receiver, arg0, arg1, arg2) {
      return this.add.call$3(arg0, arg1, arg2);
    },
    add$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.add.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    load$0: function($receiver) {
      return this.load.call$0();
    },
    load$1: function($receiver, arg0) {
      return this.load.call$1(arg0);
    },
    load$2: function($receiver, arg0, arg1) {
      return this.load.call$2(arg0, arg1);
    },
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    sound$4: function(arg0, arg1, arg2, arg3) {
      return this.sound.call$4(arg0, arg1, arg2, arg3);
    },
    physics$4: function(arg0, arg1, arg2, arg3) {
      return this.physics.call$4(arg0, arg1, arg2, arg3);
    },
    rnd$0: function() {
      return this.rnd.call$0();
    },
    get$paused: [function(_) {
      return this._paused;
    }, null, null, 1, 0, 209, "paused"],
    paused$0: function($receiver) {
      return this.get$paused(this).call$0();
    },
    set$paused: [function(_, value) {
      if (J.$eq(value, true)) {
        if (J.$eq(this._paused, false)) {
          this._paused = true;
          this._codePaused = true;
          this.sound.setMute$0();
          this.time.gamePaused$0();
          this.onPause.dispatch$0();
        }
      } else if (this._paused === true) {
        this._paused = false;
        this._codePaused = false;
        J.reset$0$x(this.input);
        this.sound.unsetMute$0();
        this.time.gameResumed$0();
        this.onResume.dispatch$0();
      }
    }, null, null, 3, 0, 650, 100, [], "paused"],
    parseConfig$1: [function(config) {
      var t1, t2, t3;
      this.config = config;
      t1 = J.getInterceptor$asx(config);
      if (t1.$index(config, "width") != null)
        this.width = R.Utils_parseDimension(t1.$index(config, "width"), 0);
      if (t1.$index(config, "height") != null)
        this.height = R.Utils_parseDimension(t1.$index(config, "height"), 1);
      if (t1.$index(config, "renderer") != null)
        this.renderType = t1.$index(config, "renderer");
      if (t1.$index(config, "parent") != null)
        this.parent = t1.$index(config, "parent");
      if (t1.$index(config, "transparent") != null)
        this.transparent = t1.$index(config, "transparent");
      if (t1.$index(config, "antialias") != null)
        this.antialias = t1.$index(config, "antialias");
      if (t1.$index(config, "preserveDrawingBuffer") != null)
        this.preserveDrawingBuffer = t1.$index(config, "preserveDrawingBuffer");
      if (t1.$index(config, "physicsConfig") != null)
        this.physicsConfig = t1.$index(config, "physicsConfig");
      t2 = Date.now();
      new P.DateTime(t2, false).DateTime$_now$0();
      t3 = $.get$Math_random().call$0();
      if (typeof t3 !== "number")
        return H.iae(t3);
      C.JSNumber_methods.toString$0(t2 * t3);
      if (t1.$index(config, "seed") != null)
        t1.$index(config, "seed");
      this.rnd = new R.RandomDataGenerator(1, 0, 0, 0);
      this.state = R.StateManager$(this, t1.$index(config, "state") != null ? t1.$index(config, "state") : null);
    }, "call$1", "get$parseConfig", 2, 0, 63, 423, [], "parseConfig"],
    boot$0: [function() {
      var t1, t2, t3, t4, t5, t6, t7, t8, target;
      P.print("boot start");
      if (this.isBooted === true)
        return;
      this.onPause = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onResume = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onBlur = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onFocus = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.isBooted = true;
      t1 = new R.Device(this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t1.Device$1(this);
      this.device = t1;
      t1 = this.width;
      t2 = this.height;
      t3 = new R.Point(null, null);
      t3.x = 0;
      t3.y = 0;
      t4 = new Float32Array(9);
      t5 = new M.Point0(null, null);
      t5.x = 0;
      t5.y = 0;
      t6 = new M.Point0(null, null);
      t6.x = 1;
      t6.y = 1;
      t7 = new M.Point0(null, null);
      t7.x = 0;
      t7.y = 0;
      t8 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      t3 = new R.Stage(this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, t3, null, null, null, null, null, null, null, null, null, false, [], null, false, new M.Rectangle0(0, 0, 100000, 100000), 0, [], null, new M.Matrix(1, 0, 0, 1, 0, 0, t4), null, [], false, 0, 0, t5, t6, t7, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t8, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
      t3.Stage$2(0, true);
      t3.Stage$3(this, t1, t2);
      this.stage = t3;
      if (this.device.get$trident() === true)
        this.renderType = 1;
      t1 = J.$index$asx(this.config, "canvasID");
      t2 = this.width;
      t3 = this.height;
      if (t1 != null)
        this.canvas = R.Canvas_create(t2, t3, J.$index$asx(this.config, "canvasID"), false);
      else
        this.canvas = R.Canvas_create(t2, t3, null, false);
      if (this.device.get$cocoonJS() === true) {
        t1 = J.get$dataset$x(this.canvas);
        t1._attributes._element.setAttribute("data-" + t1._toHyphenedName$1("screencanvas"), "true");
      }
      P.print("setUpRenderer 5");
      if (!J.$eq(this.renderType, 3))
        if (!J.$eq(this.renderType, 1))
          t1 = J.$eq(this.renderType, 0) && J.$eq(this.device.get$webGL(), false);
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        if (J.get$canvas$x(this.device) === true) {
          if (J.$eq(this.renderType, 0))
            this.renderType = 1;
          t1 = M.CanvasRenderer$(this.width, this.height, this.canvas, this.transparent, false);
          this.renderer = t1;
          this.context = t1.context;
        } else
          H.throwExpression(P.Exception_Exception("Phaser.Game - cannot create Canvas or WebGL context, aborting."));
      else {
        this.renderType = 2;
        this.renderer = M.WebGLRenderer$(this.width, this.height, this.canvas, this.transparent, this.antialias, this.preserveDrawingBuffer);
        this.context = null;
      }
      if (!J.$eq(this.renderType, 3)) {
        this.stage.set$smoothed(this.antialias);
        t1 = this.canvas;
        target = this.parent;
        if (target != null)
          if (typeof target === "string")
            target = document.getElementById(target);
          else
            target = !!J.getInterceptor(target).$isHtmlElement ? target : null;
        else
          target = null;
        if (target == null)
          target = document.body;
        J.append$1$x(target, t1);
        P.print("setUpRenderer 8");
      }
      this.scale = R.ScaleManager$(this, this.width, this.height);
      this.device.checkFullScreenSupport$0();
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      t2 = new R.Point(null, null);
      t2.x = 0;
      t2.y = 0;
      t3 = new M.Point0(null, null);
      t3.x = 0;
      t3.y = 0;
      t4 = new M.Point0(null, null);
      t4.x = 1;
      t4.y = 1;
      t5 = new M.Point0(null, null);
      t5.x = 0;
      t5.y = 0;
      t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      t1 = new R.World(null, null, null, null, "__world", false, false, 0, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, t1, null, t2, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
      t1.Group$6(this, null, "__world", false, false, 0, null);
      t1.World$1(this);
      this.world = t1;
      t1 = new R.GameObjectFactory(this, null);
      t1.world = this.world;
      this.add = t1;
      t1 = new R.GameObjectCreator(this, null);
      t1.world = this.world;
      this.make = t1;
      t1 = new R.Cache(this, null, null, null, null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), null);
      t1.Cache$1(this);
      this.cache = t1;
      t1 = new R.Loader(this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t1.Loader$1(this);
      this.load = t1;
      t1 = new R.Time(this, 0, 0, 0, 0, false, 0, 1000, 0, 1000, 0, 0, 0, 1000, 0, 0, 0, 0, null, 0, 0, 0, false, [], 0, 0);
      t2 = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      t3 = Date.now();
      new P.DateTime(t3, false).DateTime$_now$0();
      t1.events = new R.Timer(this, true, false, false, 0, [], t2, 0, 1000, false, false, 0, 0, 0, t3, 0, 0, 0, 0, 0);
      this.time = t1;
      t1 = new R.TweenManager(this, [], []);
      t1.TweenManager$1(this);
      this.tweens = t1;
      t1 = Array(11);
      t1.fixed$length = init;
      t1 = new R.Input(this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo(t1, [R.Pointer]), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0);
      t1.Input$1(this);
      this.input = t1;
      t1 = new R.SoundManager(this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t1.SoundManager$1(this);
      this.sound = t1;
      t1 = new R.Physics(null, null, null, null, null, null, null);
      t1.Physics$2(this, this.physicsConfig);
      this.physics = t1;
      t1 = new R.Particles(P.LinkedHashMap_LinkedHashMap$_empty(null, null), this, null);
      t1.emitters = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this.particles = t1;
      t1 = new R.PluginManager(this, null, null, null);
      t1.PluginManager$1(this);
      this.plugins = t1;
      this.net = new R.Net(this);
      this.time.boot$0();
      this.stage.boot$0();
      this.world.boot$0();
      this.input.boot$0();
      this.sound.boot$0();
      this.state.boot$0();
      if (J.$index$asx(this.config, "enableDebug") != null) {
        t1 = new R.Debug(this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Debug$1(this);
        this.debug = t1;
        t1.boot$0();
      }
      this.showDebugHeader$0();
      this.isRunning = true;
      t1 = this.config;
      if (t1 != null && !!J.getInterceptor(J.$index$asx(t1, "forceSetTimeOut")).$isFunction) {
        t1 = R.RequestAnimationFrame$(this, J.$index$asx(this.config, "forceSetTimeOut"));
        this.raf = t1;
      } else {
        t1 = R.RequestAnimationFrame$(this, false);
        this.raf = t1;
      }
      t1.start$0(0);
      P.print("boot end");
    }, "call$0", "get$boot", 0, 0, 13, "boot"],
    showDebugHeader$0: [function() {
      var r, c, a, args, i;
      if (J.$eq(this.renderType, 2)) {
        r = "WebGL";
        c = 2;
      } else {
        r = J.$eq(this.renderType, 3) ? "Headless" : "Canvas";
        c = 1;
      }
      if (this.device.get$webAudio() === true) {
        ++c;
        a = "WebAudio";
      } else
        a = "HTML Audio";
      if (this.device.get$chrome() === true) {
        args = ["%c %c %c Phaser v2.0.5 | Pixi.js v1.6.\uff11 | " + r + " | " + a + "  %c %c  http://phaser.io  %c %c \u2665%c\u2665%c\u2665 ", "background: #0cf300", "background: #00bc17", "color: #ffffff; background: #00711f;", "background: #00bc17", "background: #0cf300", "background: #00bc17"];
        for (i = 0; i < 3; ++i)
          if (i < c)
            args.push("color: #ff2424; background: #fff");
          else
            args.push("color: #959595; background: #fff");
      }
    }, "call$0", "get$showDebugHeader", 0, 0, 13, "showDebugHeader"],
    setUpRenderer$0: [function() {
      var t1, t2, t3, target;
      if (this.device.get$trident() === true)
        this.renderType = 1;
      t1 = J.$index$asx(this.config, "canvasID");
      t2 = this.width;
      t3 = this.height;
      if (t1 != null)
        this.canvas = R.Canvas_create(t2, t3, J.$index$asx(this.config, "canvasID"), false);
      else
        this.canvas = R.Canvas_create(t2, t3, null, false);
      if (this.device.get$cocoonJS() === true) {
        t1 = J.get$dataset$x(this.canvas);
        t1._attributes._element.setAttribute("data-" + t1._toHyphenedName$1("screencanvas"), "true");
      }
      P.print("setUpRenderer 5");
      if (!J.$eq(this.renderType, 3))
        if (!J.$eq(this.renderType, 1))
          t1 = J.$eq(this.renderType, 0) && J.$eq(this.device.get$webGL(), false);
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        if (J.get$canvas$x(this.device) === true) {
          if (J.$eq(this.renderType, 0))
            this.renderType = 1;
          t1 = M.CanvasRenderer$(this.width, this.height, this.canvas, this.transparent, false);
          this.renderer = t1;
          this.context = t1.context;
        } else
          throw H.wrapException(P.Exception_Exception("Phaser.Game - cannot create Canvas or WebGL context, aborting."));
      else {
        this.renderType = 2;
        this.renderer = M.WebGLRenderer$(this.width, this.height, this.canvas, this.transparent, this.antialias, this.preserveDrawingBuffer);
        this.context = null;
      }
      if (!J.$eq(this.renderType, 3)) {
        this.stage.set$smoothed(this.antialias);
        t1 = this.canvas;
        target = this.parent;
        if (target != null)
          if (typeof target === "string")
            target = document.getElementById(target);
          else
            target = !!J.getInterceptor(target).$isHtmlElement ? target : null;
        else
          target = null;
        if (target == null)
          target = document.body;
        J.append$1$x(target, t1);
        P.print("setUpRenderer 8");
      }
    }, "call$0", "get$setUpRenderer", 0, 0, 13, "setUpRenderer"],
    update$1: [function(time) {
      this.time.update$1(time);
      if (this._paused !== true && this.pendingStep !== true) {
        if (this.stepping === true)
          this.pendingStep = true;
        this.debug.preUpdate$0();
        this.physics.preUpdate$0();
        this.state.preUpdate$0();
        this.plugins.preUpdate$0();
        this.stage.preUpdate$0();
        this.state.update$0();
        this.stage.update$0();
        this.tweens.update$0();
        this.sound.update$0();
        this.input.update$0();
        this.physics.update$0();
        this.particles.update$0();
        this.plugins.update$0();
        this.stage.postUpdate$0();
        this.plugins.postUpdate$0();
      } else {
        this.state.pauseUpdate$0();
        this.debug.preUpdate$0();
      }
      if (!J.$eq(this.renderType, 3)) {
        this.state.preRender$0();
        this.renderer.render$1(this.stage);
        this.plugins.render$0();
        this.state.render$0();
        this.plugins.postRender$0();
        if (this.device.get$cocoonJS() === true && J.$eq(this.renderType, 1) && J.$eq(this.stage.get$currentRenderOrderID(), 1))
          J.fillRect$4$x(this.context, 0, 0, 0, 0);
      }
    }, "call$1", "get$update", 2, 0, 1016, 568, [], "update"],
    enableStep$0: [function() {
      this.stepping = true;
      this.pendingStep = false;
      this.stepCount = 0;
    }, "call$0", "get$enableStep", 0, 0, 13, "enableStep"],
    disableStep$0: [function() {
      this.stepping = false;
      this.pendingStep = false;
    }, "call$0", "get$disableStep", 0, 0, 13, "disableStep"],
    step$0: [function(_) {
      this.pendingStep = false;
      this.stepCount = J.$add$ns(this.stepCount, 1);
    }, "call$0", "get$step", 0, 0, 13, "step"],
    destroy$0: [function() {
      J.stop$0$x(this.raf);
      this.input.destroy$0();
      this.state.destroy$0();
      this.physics.destroy$0();
      this.state = null;
      this.cache = null;
      this.input = null;
      this.load = null;
      this.sound = null;
      this.stage = null;
      this.time = null;
      this.world = null;
      this.isBooted = false;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    gamePaused$1: [function($event) {
      if (this._paused !== true) {
        this._paused = true;
        this.time.gamePaused$0();
        this.sound.setMute$0();
        this.onPause.dispatch$0();
      }
    }, "call$1", "get$gamePaused", 2, 0, 63, 815, [], "gamePaused"],
    gameResumed$1: [function($event) {
      if (this._paused === true && this._codePaused !== true) {
        this._paused = false;
        this.time.gameResumed$0();
        J.reset$0$x(this.input);
        this.sound.unsetMute$0();
        this.onResume.dispatch$0();
      }
    }, "call$1", "get$gameResumed", 2, 0, 63, 815, [], "gameResumed"],
    focusLoss$1: [function($event) {
      this.onBlur.dispatch$1($event);
      if (this.stage.get$disableVisibilityChange() !== true)
        this.gamePaused$1($event);
    }, "call$1", "get$focusLoss", 2, 0, 63, 815, [], "focusLoss"],
    focusGain$1: [function($event) {
      this.onFocus.dispatch$1($event);
      if (this.stage.get$disableVisibilityChange() !== true)
        this.gameResumed$1($event);
    }, "call$1", "get$focusGain", 2, 0, 63, 815, [], "focusGain"],
    Game$8: function(width, height, renderer, $parent, state, transparent, antialias, physicsConfig) {
      var t1, t2;
      t1 = $.get$GAMES();
      t1.push(this);
      this.id = t1.length - 1;
      this.config = null;
      this.physicsConfig = this.physicsConfig;
      this.parent = "";
      this.width = J.toInt$0$n(width);
      this.height = J.toInt$0$n(height);
      this.transparent = false;
      this.antialias = true;
      this.preserveDrawingBuffer = false;
      this.renderer = null;
      this.renderType = renderer;
      this.state = null;
      this.isBooted = false;
      this.isRunning = false;
      this.raf = null;
      this.add = null;
      this.make = null;
      this.cache = null;
      this.input = null;
      this.load = null;
      this.net = null;
      this.scale = null;
      this.sound = null;
      this.stage = null;
      this.time = null;
      this.tweens = null;
      this.world = null;
      this.physics = null;
      this.rnd = null;
      this.device = null;
      this.camera = null;
      this.canvas = null;
      this.context = null;
      this.debug = null;
      this.particles = null;
      this.stepping = false;
      this.pendingStep = false;
      this.stepCount = 0;
      this.onPause = null;
      this.onResume = null;
      this.onBlur = null;
      this.onFocus = null;
      this._paused = false;
      this._codePaused = false;
      this.config = P.LinkedHashMap_LinkedHashMap$_literal(["enableDebug", true], null, null);
      if (width != null)
        this.width = width;
      if (height != null)
        this.height = height;
      if (renderer != null)
        this.renderType = renderer;
      t1 = this.parent;
      if (t1 != null)
        this.parent = t1;
      t1 = this.transparent;
      if (t1 != null)
        this.transparent = t1;
      t1 = this.antialias;
      if (t1 != null)
        this.antialias = t1;
      t1 = Date.now();
      new P.DateTime(t1, false).DateTime$_now$0();
      t2 = $.get$Math_random().call$0();
      if (typeof t2 !== "number")
        return H.iae(t2);
      C.JSNumber_methods.toString$0(t1 * t2);
      this.rnd = new R.RandomDataGenerator(1, 0, 0, 0);
      this.state = R.StateManager$(this, state);
      this._onBoot = new R.Game_closure(this);
      t2 = C.EventStreamProvider_load.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t2._target, t2._eventType, W._wrapZone(this._onBoot), t2._useCapture), [H.getTypeArgumentByIndex(t2, 0)])._tryResume$0();
      C.Window_methods.addEventListener$3(window, "load", this._onBoot, false);
      this.boot$0();
    },
    static: {Game$: [function(width, height, renderer, $parent, state, transparent, antialias, physicsConfig) {
        var t1 = new R.Game(null, null, null, $parent, null, transparent, antialias, physicsConfig, null, null, 0, false, false, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Game$8(width, height, renderer, $parent, state, transparent, antialias, physicsConfig);
        return t1;
      }, null, null, 0, 16, 249, 106, 107, 5, 221, 32, 32, 32, 32, 10, [], 11, [], 175, [], 45, [], 250, [], 109, [], 110, [], 251, [], "new Game"]}
  },
  "+Game": [632],
  Game_closure: {
    "^": "Closure:63;_this_0",
    call$1: [function(e) {
      return this._this_0.boot$0();
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  Group: {
    "^": "DisplayObjectContainer;game@-598,name*-639,addToStage@-602,enableBody@-602,physicsBodyType@-601,z*-599,type*-599,alive@-602,exists@-602,_Phaser$_dirty@-602,cursor*-32,cameraOffset@-600,_sortProperty@-639,enableBodyDebug@-602,_cache@-720,creator@-281,renderOrderID@-599,children:Phaser$Group$children*-1017,autoCull@-602,events@-1018,_anchor@-600,_Phaser$_currentBounds@-974,position:Phaser$Group$position*-600,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 281, "parent"],
    enableBody$1: function(arg0) {
      return this.enableBody.call$1(arg0);
    },
    enableBody$4: function(arg0, arg1, arg2, arg3) {
      return this.enableBody.call$4(arg0, arg1, arg2, arg3);
    },
    creator$0: function() {
      return this.creator.call$0();
    },
    get$destroyPhase: [function() {
      return false;
    }, null, null, 1, 0, 209, "destroyPhase"],
    get$anchor: [function() {
      return this._anchor;
    }, null, null, 1, 0, 1019, "anchor"],
    set$anchor: [function(value) {
    }, null, null, 3, 0, 1020, 100, [], "anchor"],
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(this.get$x(this), J.$div$n(this.get$width(this), 2));
      t2 = J.$add$ns(this.get$y(this), J.$div$n(this.get$height(this), 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1019, "center"],
    get$world: [function() {
      var t1, t2;
      t1 = M.DisplayObject.prototype.get$parent.call(this, this) == null || J.$eq(M.DisplayObject.prototype.get$parent.call(this, this), this);
      t2 = this.Phaser$Group$position;
      if (t1)
        return t2;
      else
        return J.$add$ns(t2, M.DisplayObject.prototype.get$parent.call(this, this).get$world());
    }, null, null, 1, 0, 1019, "world"],
    get$total: [function(_) {
      var t1 = J.where$1$ax(this.Phaser$Group$children, new R.Group_total_closure(this));
      return t1.get$length(t1);
    }, null, null, 1, 0, 367, "total"],
    get$length: [function(_) {
      return J.get$length$asx(this.Phaser$Group$children);
    }, null, null, 1, 0, 367, "length"],
    get$angle: [function() {
      return J.$mul$ns(this.rotation, 57.29577951308232);
    }, null, null, 1, 0, 604, "angle"],
    angle$0: function() {
      return this.get$angle().call$0();
    },
    angle$2: function(arg0, arg1) {
      return this.get$angle().call$2(arg0, arg1);
    },
    set$angle: [function(value) {
      this.rotation = J.$mul$ns(value, 0.017453292519943295);
    }, null, null, 3, 0, 605, 100, [], "angle"],
    get$fixedToCamera: [function() {
      return J.$index$asx(this._cache, 7) == null ? false : J.$index$asx(this._cache, 7);
    }, null, null, 1, 0, 209, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.cameraOffset.set$2(this.get$x(this), this.get$y(this));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 650, 100, [], "fixedToCamera"],
    add$2: [function(_, child, silent) {
      var t1 = J.getInterceptor$x(child);
      if (!J.$eq(t1.get$parent(child), this)) {
        if (this.enableBody === true)
          J.enable$2$x(this.get$game().get$physics(), child, this.physicsBodyType);
        this.addChildAt$2(child, J.get$length$asx(this.Phaser$Group$children));
        t1.set$z(child, J.get$length$asx(this.Phaser$Group$children));
        if (silent !== true && child.get$events() != null)
          child.get$events().get$onAddedToGroup().dispatch$1([child, this]);
        if (this.cursor == null)
          this.cursor = child;
      }
      return child;
    }, function($receiver, child) {
      return this.add$2($receiver, child, false);
    }, "add$1", "call$2", "call$1", "get$add", 2, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "T__T__bool", ret: T, args: [T], opt: [P.bool]};
      }, this.$receiver, "Group");
    }, 95, 659, [], 1021, [], "add"],
    addAt$3: [function(child, index, silent) {
      if (!J.$eq(J.get$parent$x(child), this)) {
        if (this.enableBody === true)
          J.enable$2$x(this.get$game().get$physics(), child, this.physicsBodyType);
        this.addChildAt$2(child, index);
        this.updateZ$0();
        if (silent !== true && child.get$events() != null)
          child.get$events().get$onAddedToGroup().dispatch$1([child, this]);
        if (this.cursor == null)
          this.cursor = child;
      }
      return child;
    }, function(child, index) {
      return this.addAt$3(child, index, false);
    }, "addAt$2", "call$3", "call$2", "get$addAt", 4, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "T__T_int__bool", ret: T, args: [T, P.$int], opt: [P.bool]};
      }, this.$receiver, "Group");
    }, 95, 659, [], 243, [], 1021, [], "addAt"],
    getAt$1: [function(index) {
      var t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$ge(index, J.get$length$asx(this.Phaser$Group$children)))
        return;
      else
        return M.DisplayObjectContainer.prototype.getChildAt$1.call(this, index);
    }, "call$1", "get$getAt", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T__int", ret: T, args: [P.$int]};
      }, this.$receiver, "Group");
    }, 243, [], "getAt"],
    create$5: [function(x, y, key, frame, exists) {
      var child, t1;
      child = this.creator$0();
      t1 = J.getInterceptor$x(child);
      t1.set$x(child, x);
      t1.set$y(child, y);
      if (!!t1.$isSprite0)
        child.loadTexture$2(key, frame);
      if (this.enableBody === true)
        J.enable$2$x(this.get$game().get$physics(), child, this.physicsBodyType);
      child.set$exists(exists);
      child.set$visible(exists);
      child.set$alive(exists);
      this.addChildAt$2(child, J.get$length$asx(this.Phaser$Group$children));
      t1.set$z(child, J.get$length$asx(this.Phaser$Group$children));
      if (child.get$events() != null)
        child.get$events().get$onAddedToGroup().dispatch$1([child, this]);
      if (this.cursor == null)
        this.cursor = child;
      return child;
    }, function(x, y, key, frame) {
      return this.create$5(x, y, key, frame, true);
    }, "create$4", function(x) {
      return this.create$5(x, 0, null, 0, true);
    }, "create$1", function() {
      return this.create$5(0, 0, null, 0, true);
    }, "create$0", function(x, y) {
      return this.create$5(x, y, null, 0, true);
    }, "create$2", function(x, y, key) {
      return this.create$5(x, y, key, 0, true);
    }, "create$3", "call$5", "call$4", "call$1", "call$0", "call$2", "call$3", "get$create", 0, 10, function() {
      return H.computeSignature(function(T) {
        return {func: "T___num_num_Object_dynamic_bool", ret: T, opt: [P.num, P.num, P.Object, null, P.bool]};
      }, this.$receiver, "Group");
    }, 5, 5, 32, 5, 39, 6, [], 7, [], 231, [], 178, [], 1022, [], "create"],
    createMultiple$4: [function(quantity, key, frame, exists) {
      var i;
      if (typeof quantity !== "number")
        return H.iae(quantity);
      i = 0;
      for (; i < quantity; ++i)
        this.create$5(0, 0, key, frame, exists);
    }, function(quantity) {
      return this.createMultiple$4(quantity, null, null, false);
    }, "createMultiple$1", function(quantity, key) {
      return this.createMultiple$4(quantity, key, null, false);
    }, "createMultiple$2", function(quantity, key, frame) {
      return this.createMultiple$4(quantity, key, frame, false);
    }, "createMultiple$3", "call$4", "call$1", "call$2", "call$3", "get$createMultiple", 2, 6, 1023, 32, 32, 95, 949, [], 231, [], 178, [], 1022, [], "createMultiple"],
    updateZ$0: [function() {
      var i, t1, i0;
      i = J.get$length$asx(this.Phaser$Group$children);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), !t1.$eq(i, 0); i = i0)
        J.set$z$x(J.$index$asx(this.Phaser$Group$children, i0), i0);
    }, "call$0", "get$updateZ", 0, 0, 13, "updateZ"],
    resetCursor$1: [function(index) {
      var t1;
      if (J.$gt$n(index, J.$sub$n(J.get$length$asx(this.Phaser$Group$children), 1)))
        index = 0;
      if (this.cursor != null) {
        J.$indexSet$ax(this._cache, 8, index);
        t1 = J.$index$asx(this.Phaser$Group$children, J.$index$asx(this._cache, 8));
        this.cursor = t1;
        return t1;
      }
    }, function() {
      return this.resetCursor$1(0);
    }, "resetCursor$0", "call$1", "call$0", "get$resetCursor", 0, 2, 948, 5, 243, [], "resetCursor"],
    next$0: [function() {
      var t1, t2;
      if (this.cursor != null) {
        t1 = J.$ge$n(J.$index$asx(this._cache, 8), J.$sub$n(J.get$length$asx(this.Phaser$Group$children), 1));
        t2 = this._cache;
        if (t1)
          J.$indexSet$ax(t2, 8, 0);
        else {
          t1 = J.getInterceptor$asx(t2);
          t1.$indexSet(t2, 8, J.$add$ns(t1.$index(t2, 8), 1));
        }
        t1 = J.$index$asx(this.Phaser$Group$children, J.$index$asx(this._cache, 8));
        this.cursor = t1;
        return t1;
      }
    }, "call$0", "get$next", 0, 0, 13, "next"],
    previous$0: [function() {
      var t1, t2;
      if (this.cursor != null) {
        t1 = J.$eq(J.$index$asx(this._cache, 8), 0);
        t2 = this._cache;
        if (t1)
          J.$indexSet$ax(t2, 8, J.$sub$n(J.get$length$asx(this.Phaser$Group$children), 1));
        else {
          t1 = J.getInterceptor$asx(t2);
          t1.$indexSet(t2, 8, J.$sub$n(t1.$index(t2, 8), 1));
        }
        t1 = J.$index$asx(this.Phaser$Group$children, J.$index$asx(this._cache, 8));
        this.cursor = t1;
        return t1;
      }
    }, "call$0", "get$previous", 0, 0, 13, "previous"],
    swap$2: [function(child1, child2) {
      var result = this.swapChildren$2(child1, child2);
      if (result)
        this.updateZ$0();
      return result;
    }, "call$2", "get$swap", 4, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T_T", args: [T, T]};
      }, this.$receiver, "Group");
    }, 1024, [], 662, [], "swap"],
    bringToTop$1: [function(child) {
      if (child == null) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
        return H.subtypeOfRuntimeTypeCast(this, H.getRuntimeTypeArgument(this, "Group", 0));
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$Group$children, child), J.get$length$asx(this.Phaser$Group$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Group$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$Group$children));
        }
        return child;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "T___T", ret: T, opt: [T]};
      }, this.$receiver, "Group");
    }, 32, 659, [], "bringToTop"],
    sendToBack$1: [function(child) {
      if (J.$eq(J.get$parent$x(child), this) && J.$gt$n(J.indexOf$1$asx(this.Phaser$Group$children, child), 0)) {
        this.remove$3(0, child, false, true);
        this.addAt$3(child, 0, true);
      }
      return child;
    }, "call$1", "get$sendToBack", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 659, [], "sendToBack"],
    moveUp$1: [function(child) {
      var b;
      if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$Group$children, child), J.$sub$n(J.get$length$asx(this.Phaser$Group$children), 1))) {
        b = this.getAt$1(J.$add$ns(J.indexOf$1$asx(this.Phaser$Group$children, child), 1));
        if (b === true)
          this.swap$2(child, b);
      }
      return child;
    }, "call$1", "get$moveUp", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 659, [], "moveUp"],
    moveDown$1: [function(child) {
      var b;
      if (J.$eq(J.get$parent$x(child), this) && J.$gt$n(J.indexOf$1$asx(this.Phaser$Group$children, child), 0)) {
        b = this.getAt$1(J.$sub$n(J.indexOf$1$asx(this.Phaser$Group$children, child), 1));
        if (b === true)
          this.swap$2(child, b);
      }
      return child;
    }, "call$1", "get$moveDown", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 659, [], "moveDown"],
    xy$3: [function(index, x, y) {
      var t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$gt(index, J.get$length$asx(this.Phaser$Group$children)))
        return -1;
      else {
        J.set$x$x(M.DisplayObjectContainer.prototype.getChildAt$1.call(this, index), x);
        J.set$y$x(M.DisplayObjectContainer.prototype.getChildAt$1.call(this, index), y);
      }
    }, "call$3", "get$xy", 6, 0, 1025, 243, [], 6, [], 7, [], "xy"],
    getChildAt$1: [function(index) {
      return M.DisplayObjectContainer.prototype.getChildAt$1.call(this, index);
    }, "call$1", "get$getChildAt", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T__int", ret: T, args: [P.$int]};
      }, this.$receiver, "Group");
    }, 243, [], "getChildAt"],
    reverse$0: [function() {
      this.Phaser$Group$children = J.toList$0$ax(J.get$reversed$ax(this.Phaser$Group$children));
      this.updateZ$0();
    }, "call$0", "get$reverse", 0, 0, 13, "reverse"],
    getIndex$1: [function(child) {
      return J.indexOf$1$asx(this.Phaser$Group$children, child);
    }, "call$1", "get$getIndex", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "int__T0", ret: P.$int, args: [T]};
      }, this.$receiver, "Group");
    }, 659, [], "getIndex"],
    replace$2: [function(_, oldChild, newChild) {
      var index, t1;
      index = J.indexOf$1$asx(this.Phaser$Group$children, oldChild);
      if (!J.$eq(index, -1)) {
        t1 = J.getInterceptor$x(newChild);
        if (t1.get$parent(newChild) != null) {
          newChild.get$events().get$onRemovedFromGroup().dispatch$1([newChild, this]);
          t1.get$parent(newChild).removeChild$1(newChild);
          if (!!J.getInterceptor(t1.get$parent(newChild)).$isGroup)
            H.interceptedTypeCast(t1.get$parent(newChild), "$isGroup").updateZ$0();
        }
        this.remove$1(0, oldChild);
        this.addAt$2(newChild, index);
        return oldChild;
      }
    }, "call$2", "get$replace", 4, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T_T", args: [T, T]};
      }, this.$receiver, "Group");
    }, 1026, [], 1027, [], "replace"],
    preUpdate$0: [function() {
      var i, t1, i0;
      if (this.exists !== true || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        this.renderOrderID = -1;
        return false;
      }
      i = J.get$length$asx(this.Phaser$Group$children);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this.Phaser$Group$children, i0).preUpdate$0();
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    update$0: [function() {
      var i, t1, i0;
      i = J.get$length$asx(this.Phaser$Group$children);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this.Phaser$Group$children, i0).update$0();
    }, "call$0", "get$update", 0, 0, 13, "update"],
    postUpdate$0: [function() {
      var i, t1, i0;
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        this.set$x(0, J.$add$ns(J.get$x$x(J.get$view$x(this.get$game().get$camera())), J.get$x$x(this.cameraOffset)));
        this.set$y(0, J.$add$ns(J.get$y$x(J.get$view$x(this.get$game().get$camera())), J.get$y$x(this.cameraOffset)));
      }
      i = J.get$length$asx(this.Phaser$Group$children);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this.Phaser$Group$children, i0).postUpdate$0();
    }, "call$0", "get$postUpdate", 0, 0, 13, "postUpdate"],
    forEach$2: [function(_, callback, checkExists) {
      var len, t1, i;
      len = J.get$length$asx(this.Phaser$Group$children);
      if (typeof len !== "number")
        return H.iae(len);
      t1 = J.getInterceptor(checkExists);
      i = 0;
      for (; i < len; ++i)
        if (t1.$eq(checkExists, false))
          callback.call$1(J.$index$asx(this.Phaser$Group$children, i));
        else if (J.$index$asx(this.Phaser$Group$children, i).get$exists() === true)
          callback.call$1(J.$index$asx(this.Phaser$Group$children, i));
    }, function($receiver, callback) {
      return this.forEach$2($receiver, callback, false);
    }, "forEach$1", "call$2", "call$1", "get$forEach", 2, 2, 1028, 95, 272, [], 1029, [], "forEach"],
    forEachExists$1: [function(callback) {
      J.where$1$ax(this.Phaser$Group$children, new R.Group_forEachExists_closure(this)).forEach$1(0, callback);
    }, "call$1", "get$forEachExists", 2, 0, 1030, 272, [], "forEachExists"],
    forEachAlive$1: [function(callback) {
      J.where$1$ax(this.Phaser$Group$children, new R.Group_forEachAlive_closure(this)).forEach$1(0, callback);
    }, "call$1", "get$forEachAlive", 2, 0, 1030, 272, [], "forEachAlive"],
    forEachDead$1: [function(callback) {
      J.where$1$ax(this.Phaser$Group$children, new R.Group_forEachDead_closure(this)).forEach$1(0, callback);
    }, "call$1", "get$forEachDead", 2, 0, 1030, 272, [], "forEachDead"],
    sort$2: [function(_, index, order) {
      var t1, t2;
      if (J.$lt$n(J.get$length$asx(this.Phaser$Group$children), 2))
        return;
      if (index == null)
        index = "z";
      if (order == null)
        order = $.Group_SORT_ASCENDING;
      this._sortProperty = index;
      t1 = J.$eq(order, $.Group_SORT_ASCENDING);
      t2 = this.Phaser$Group$children;
      if (t1)
        J.sort$1$ax(t2, this.get$ascendingSortHandler());
      else
        J.sort$1$ax(t2, this.get$descendingSortHandler());
      this.updateZ$0();
    }, function($receiver, index) {
      return this.sort$2($receiver, index, null);
    }, "sort$1", function($receiver) {
      return this.sort$2($receiver, null, null);
    }, "sort$0", "call$2", "call$1", "call$0", "get$sort", 0, 4, 1031, 32, 32, 243, [], 1032, [], "sort"],
    customSort$1: [function(sortHandler) {
      if (J.$lt$n(J.get$length$asx(this.Phaser$Group$children), 2))
        return;
      J.sort$1$ax(this.Phaser$Group$children, sortHandler);
      this.updateZ$0();
    }, "call$1", "get$customSort", 2, 0, 1030, 1033, [], "customSort"],
    ascendingSortHandler$2: [function(a, b) {
      var t1, t2;
      t1 = J.getInterceptor$asx(a);
      t2 = J.getInterceptor$asx(b);
      if (J.$lt$n(t1.$index(a, this._sortProperty), t2.$index(b, this._sortProperty)))
        return -1;
      else if (J.$gt$n(t1.$index(a, this._sortProperty), t2.$index(b, this._sortProperty)))
        return 1;
      else if (J.$lt$n(t1.get$z(a), t2.get$z(b)))
        return -1;
      else
        return 1;
    }, "call$2", "get$ascendingSortHandler", 4, 0, 1034, 304, [], 305, [], "ascendingSortHandler"],
    descendingSortHandler$2: [function(a, b) {
      var t1, t2;
      t1 = J.getInterceptor$asx(a);
      t2 = J.getInterceptor$asx(b);
      if (J.$lt$n(t1.$index(a, this._sortProperty), t2.$index(b, this._sortProperty)))
        return 1;
      else if (J.$gt$n(t1.$index(a, this._sortProperty), t2.$index(b, this._sortProperty)))
        return -1;
      else
        return 0;
    }, "call$2", "get$descendingSortHandler", 4, 0, 1034, 304, [], 305, [], "descendingSortHandler"],
    getFirst$1: [function(where) {
      return J.firstWhere$2$orElse$ax(this.Phaser$Group$children, where, new R.Group_getFirst_closure());
    }, function() {
      return this.getFirst$1(null);
    }, "getFirst$0", "call$1", "call$0", "get$getFirst", 0, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "T___SelectWhere", ret: T, opt: [{func: "bool__dynamic", ret: P.bool, args: [null]}]};
      }, this.$receiver, "Group");
    }, 32, 1035, [], "getFirst"],
    getFirstExists$1: [function(state) {
      return J.firstWhere$2$orElse$ax(this.Phaser$Group$children, new R.Group_getFirstExists_closure(this, state), new R.Group_getFirstExists_closure0());
    }, function() {
      return this.getFirstExists$1(true);
    }, "getFirstExists$0", "call$1", "call$0", "get$getFirstExists", 0, 2, function() {
      return H.computeSignature(function(T) {
        return {func: "T___bool", ret: T, opt: [P.bool]};
      }, this.$receiver, "Group");
    }, 39, 250, [], "getFirstExists"],
    getFirstAlive$0: [function() {
      return J.firstWhere$2$orElse$ax(this.Phaser$Group$children, new R.Group_getFirstAlive_closure(this), new R.Group_getFirstAlive_closure0());
    }, "call$0", "get$getFirstAlive", 0, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T_", ret: T};
      }, this.$receiver, "Group");
    }, "getFirstAlive"],
    getFirstDead$0: [function() {
      return J.firstWhere$2$orElse$ax(this.Phaser$Group$children, new R.Group_getFirstDead_closure(this), new R.Group_getFirstDead_closure0());
    }, "call$0", "get$getFirstDead", 0, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T_", ret: T};
      }, this.$receiver, "Group");
    }, "getFirstDead"],
    getTop$0: [function() {
      var t1, t2;
      if (J.$gt$n(J.get$length$asx(this.Phaser$Group$children), 0)) {
        t1 = this.Phaser$Group$children;
        t2 = J.getInterceptor$asx(t1);
        return t2.$index(t1, J.$sub$n(t2.get$length(t1), 1));
      }
      return;
    }, "call$0", "get$getTop", 0, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T_", ret: T};
      }, this.$receiver, "Group");
    }, "getTop"],
    getBottom$0: [function() {
      if (J.$gt$n(J.get$length$asx(this.Phaser$Group$children), 0))
        return J.$index$asx(this.Phaser$Group$children, 0);
      return;
    }, "call$0", "get$getBottom", 0, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T_", ret: T};
      }, this.$receiver, "Group");
    }, "getBottom"],
    countLiving$0: [function() {
      var t1 = J.where$1$ax(this.Phaser$Group$children, new R.Group_countLiving_closure(this));
      return t1.get$length(t1);
    }, "call$0", "get$countLiving", 0, 0, 367, "countLiving"],
    countDead$0: [function() {
      var t1 = J.where$1$ax(this.Phaser$Group$children, new R.Group_countDead_closure(this));
      return t1.get$length(t1);
    }, "call$0", "get$countDead", 0, 0, 367, "countDead"],
    getRandom$2: [function(startIndex, $length) {
      if (J.$eq(J.get$length$asx(this.Phaser$Group$children), 0))
        return;
      if ($length == null)
        $length = J.get$length$asx(this.Phaser$Group$children);
      return R.Math_getRandom(this.Phaser$Group$children, startIndex, $length);
    }, function() {
      return this.getRandom$2(0, null);
    }, "getRandom$0", function(startIndex) {
      return this.getRandom$2(startIndex, null);
    }, "getRandom$1", "call$2", "call$0", "call$1", "get$getRandom", 0, 4, function() {
      return H.computeSignature(function(T) {
        return {func: "T___int_int", ret: T, opt: [P.$int, P.$int]};
      }, this.$receiver, "Group");
    }, 5, 32, 387, [], 388, [], "getRandom"],
    remove$3: [function(_, child, destroy, silent) {
      var removed;
      if (J.$eq(J.get$length$asx(this.Phaser$Group$children), 0) || J.$eq(J.indexOf$1$asx(this.Phaser$Group$children, child), -1))
        return false;
      if (silent !== true && child.get$events() != null && !child.get$destroyPhase())
        child.get$events().get$onRemovedFromGroup().dispatch$1([child, this]);
      removed = this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Group$children, child));
      this.updateZ$0();
      if (J.$eq(this.cursor, child))
        this.next$0();
      if (destroy === true && removed != null)
        removed.destroy$1(true);
      return true;
    }, function($receiver, child) {
      return this.remove$3($receiver, child, false, false);
    }, "remove$1", function($receiver, child, destroy) {
      return this.remove$3($receiver, child, destroy, false);
    }, "remove$2", "call$3", "call$1", "call$2", "get$remove", 2, 4, function() {
      return H.computeSignature(function(T) {
        return {func: "bool__T__bool_bool", ret: P.bool, args: [T], opt: [P.bool, P.bool]};
      }, this.$receiver, "Group");
    }, 95, 95, 659, [], 1036, [], 1021, [], "remove"],
    removeAll$2: [function(destroy, silent) {
      var t1, t2, t3, removed;
      if (J.$eq(J.get$length$asx(this.Phaser$Group$children), 0))
        return;
      t1 = destroy === true;
      t2 = silent !== true;
      do {
        if (t2 && J.$index$asx(this.Phaser$Group$children, 0).get$events() != null)
          J.$index$asx(this.Phaser$Group$children, 0).get$events().get$onRemovedFromGroup().dispatch$1([J.$index$asx(this.Phaser$Group$children, 0), this]);
        t3 = J.$index$asx(this.Phaser$Group$children, 0);
        removed = this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Group$children, t3));
        if (t1 && removed != null)
          removed.destroy$1(true);
      } while (J.$gt$n(J.get$length$asx(this.Phaser$Group$children), 0));
      this.cursor = null;
    }, function() {
      return this.removeAll$2(false, false);
    }, "removeAll$0", function(destroy) {
      return this.removeAll$2(destroy, false);
    }, "removeAll$1", "call$2", "call$0", "call$1", "get$removeAll", 0, 4, 945, 95, 95, 1036, [], 1021, [], "removeAll"],
    removeBetween$4: [function(startIndex, endIndex, destroy, silent) {
      var t1, t2, i, t3, t4, removed;
      if (endIndex == null)
        endIndex = J.get$length$asx(this.Phaser$Group$children);
      if (J.$eq(J.get$length$asx(this.Phaser$Group$children), 0))
        return;
      t1 = J.getInterceptor$n(startIndex);
      if (t1.$gt(startIndex, endIndex) || t1.$lt(startIndex, 0) || J.$gt$n(endIndex, J.get$length$asx(this.Phaser$Group$children)))
        return;
      for (t1 = destroy === true, t2 = silent !== true, i = endIndex; t3 = J.getInterceptor$n(i), t3.$ge(i, startIndex);) {
        if (t2 && J.$index$asx(this.Phaser$Group$children, i).get$events() != null)
          J.$index$asx(this.Phaser$Group$children, i).get$events().get$onRemovedFromGroup().dispatch$1([J.$index$asx(this.Phaser$Group$children, i), this]);
        t4 = J.$index$asx(this.Phaser$Group$children, i);
        removed = this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Group$children, t4));
        if (t1 && removed != null)
          removed.destroy$1(true);
        if (J.$eq(this.cursor, J.$index$asx(this.Phaser$Group$children, i)))
          this.cursor = null;
        i = t3.$sub(i, 1);
      }
      this.updateZ$0();
    }, function(startIndex) {
      return this.removeBetween$4(startIndex, null, false, false);
    }, "removeBetween$1", function(startIndex, endIndex) {
      return this.removeBetween$4(startIndex, endIndex, false, false);
    }, "removeBetween$2", function(startIndex, endIndex, destroy) {
      return this.removeBetween$4(startIndex, endIndex, destroy, false);
    }, "removeBetween$3", "call$4", "call$1", "call$2", "call$3", "get$removeBetween", 2, 6, 1037, 32, 95, 95, 387, [], 1038, [], 1036, [], 1021, [], "removeBetween"],
    destroy$2: [function(destroyChildren, soft) {
      if (this.get$game() == null)
        return;
      this.removeAll$1(destroyChildren);
      this.cursor = null;
      this.set$filters(null);
      if (soft !== true) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).removeChild$1(this);
        this.set$game(null);
        this.exists = false;
      }
    }, function() {
      return this.destroy$2(true, false);
    }, "destroy$0", function(destroyChildren) {
      return this.destroy$2(destroyChildren, false);
    }, "destroy$1", "call$2", "call$0", "call$1", "get$destroy", 0, 4, 945, 39, 95, 1039, [], 1040, [], "destroy"],
    getBounds$1: [function(matrix) {
      return new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.DisplayObjectContainer.prototype.getBounds$1.call(this, null));
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 1041, 32, 537, [], "getBounds"],
    Group$6: function(game, $parent, $name, addToStage, enableBody, physicsBodyType, $T) {
      var t1;
      this.set$game(game);
      if (this.addToStage === true)
        this.get$game().get$stage().addChild$1(this);
      else if ($parent != null)
        J.add$1$ax($parent, this);
      else if (this.get$game().get$world() != null)
        this.get$game().get$world().addChild$1(this);
      this.z = 0;
      this.type = 7;
      this.alive = true;
      this.exists = true;
      this.creator = new R.Group_closure(this);
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this.scale = t1;
      this.cursor = null;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.cameraOffset = t1;
      this.enableBody = this.enableBody;
      this.enableBodyDebug = false;
      this.physicsBodyType = this.physicsBodyType;
      this._sortProperty = "z";
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0, 0];
    },
    $isGroup: true,
    $isGameObject: true,
    "<>": [3],
    static: {"^": "Group_RETURN_NONE@-599,Group_RETURN_TOTAL@-599,Group_RETURN_CHILD@-599,Group_SORT_ASCENDING@-599,Group_SORT_DESCENDING@-599", Group$: [function(game, $parent, $name, addToStage, enableBody, physicsBodyType, $T) {
        var t1, t2, t3, t4, t5, t6;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new R.Point(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = H.setRuntimeTypeInfo(new R.Group(null, $name, addToStage, enableBody, physicsBodyType, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, t1, null, t2, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0), [$T]);
        t1.Group$6(game, $parent, $name, addToStage, enableBody, physicsBodyType, $T);
        return t1;
      }, null, null, 2, 10, 252, 32, 253, 95, 95, 5, 214, [], 45, [], 44, [], 254, [], 255, [], 256, [], "new Group"]}
  },
  "+Group": [678, 2],
  Group_closure: {
    "^": "Closure:13;this_0",
    call$0: [function() {
      return R.Sprite$(this.this_0.get$game(), 0, 0, null, 0);
    }, "call$0", null, 0, 0, 13, "call"],
    $isFunction: true
  },
  Group_total_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$exists();
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 659, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_forEachExists_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$exists();
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 659, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_forEachAlive_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$alive();
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 659, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_forEachDead_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$alive() !== true;
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 659, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_getFirst_closure: {
    "^": "Closure:13;",
    call$0: [function() {
      return;
    }, "call$0", null, 0, 0, 13, "call"],
    $isFunction: true
  },
  Group_getFirstExists_closure: {
    "^": "Closure;this_0,state_1",
    call$1: [function(child) {
      return J.$eq(child.get$exists(), this.state_1);
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 659, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_getFirstExists_closure0: {
    "^": "Closure:13;",
    call$0: [function() {
      return;
    }, "call$0", null, 0, 0, 13, "call"],
    $isFunction: true
  },
  Group_getFirstAlive_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$alive();
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 659, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_getFirstAlive_closure0: {
    "^": "Closure:13;",
    call$0: [function() {
      return;
    }, "call$0", null, 0, 0, 13, "call"],
    $isFunction: true
  },
  Group_getFirstDead_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$alive() !== true;
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 659, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_getFirstDead_closure0: {
    "^": "Closure:13;",
    call$0: [function() {
      return;
    }, "call$0", null, 0, 0, 13, "call"],
    $isFunction: true
  },
  Group_countLiving_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$alive();
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 659, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Group_countDead_closure: {
    "^": "Closure;this_0",
    call$1: [function(child) {
      return child.get$alive() !== true;
    }, "call$1", null, 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.$receiver, "Group");
    }, 659, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Group");
    }
  },
  Plugin: {
    "^": "Object;game@-598,parent*-1005,active@-602,visible@-602,hasPreUpdate@-602,hasUpdate@-602,hasPostUpdate@-602,hasRender@-602,hasPostRender@-602",
    preUpdate$0: [function() {
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 13, "update"],
    render$0: [function() {
    }, "call$0", "get$render", 0, 0, 13, "render"],
    postRender$0: [function() {
    }, "call$0", "get$postRender", 0, 0, 13, "postRender"],
    postUpdate$0: [function() {
    }, "call$0", "get$postUpdate", 0, 0, 13, "postUpdate"],
    destroy$0: [function() {
      this.game = null;
      this.parent = null;
      this.active = false;
      this.visible = false;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    Plugin$2: function(game, $parent) {
      this.active = false;
      this.visible = false;
      this.hasPreUpdate = false;
      this.hasUpdate = false;
      this.hasPostUpdate = false;
      this.hasRender = false;
      this.hasPostRender = false;
    },
    static: {Plugin$: [function(game, $parent) {
        var t1 = new R.Plugin(game, $parent, null, null, null, null, null, null, null);
        t1.Plugin$2(game, $parent);
        return t1;
      }, null, null, 4, 0, 257, 214, [], 45, [], "new Plugin"]}
  },
  "+Plugin": [632],
  PluginManager: {
    "^": "Object;game@-598,plugins@-1042,_len@-599,_i@-599",
    add$2: [function(_, plugin, args) {
      plugin.set$game(this.game);
      J.set$parent$x(plugin, this);
      if (plugin.get$hasPreUpdate() === true || plugin.get$hasUpdate() === true || plugin.get$hasPostUpdate() === true)
        plugin.set$active(true);
      if (plugin.get$hasRender() === true || plugin.get$hasPostRender() === true)
        plugin.set$visible(true);
      J.add$1$ax(this.plugins, plugin);
      this._len = J.get$length$asx(this.plugins);
      return plugin;
    }, function($receiver, plugin) {
      return this.add$2($receiver, plugin, null);
    }, "add$1", "call$2", "call$1", "get$add", 2, 2, 1043, 32, 1044, [], 338, [], "add"],
    remove$1: [function(_, plugin) {
      var t1, t2;
      this._i = this._len;
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$eq(J.$index$asx(this.plugins, this._i), plugin)) {
          plugin.destroy$0();
          J.removeAt$1$ax(this.plugins, this._i);
          this._len = J.$sub$n(this._len, 1);
          return;
        }
    }, "call$1", "get$remove", 2, 0, 1045, 1044, [], "remove"],
    removeAll$0: [function() {
      var t1, t2;
      this._i = this._len;
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        J.$index$asx(this.plugins, this._i).destroy$0();
      J.clear$0$ax(this.plugins);
      this._len = 0;
    }, "call$0", "get$removeAll", 0, 0, 13, "removeAll"],
    preUpdate$0: [function() {
      var t1, t2;
      this._i = this._len;
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$index$asx(this.plugins, this._i).get$active() === true && J.$index$asx(this.plugins, this._i).get$hasPreUpdate() === true)
          J.$index$asx(this.plugins, this._i).preUpdate$0();
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    update$0: [function() {
      var t1, t2;
      this._i = this._len;
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$index$asx(this.plugins, this._i).get$active() === true && J.$index$asx(this.plugins, this._i).get$hasUpdate() === true)
          J.$index$asx(this.plugins, this._i).update$0();
    }, "call$0", "get$update", 0, 0, 13, "update"],
    postUpdate$0: [function() {
      var t1, t2;
      this._i = this._len;
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$index$asx(this.plugins, this._i).get$active() === true && J.$index$asx(this.plugins, this._i).get$hasPostUpdate() === true)
          J.$index$asx(this.plugins, this._i).postUpdate$0();
    }, "call$0", "get$postUpdate", 0, 0, 13, "postUpdate"],
    render$0: [function() {
      var t1, t2;
      this._i = this._len;
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$index$asx(this.plugins, this._i).get$visible() === true && J.$index$asx(this.plugins, this._i).get$hasRender() === true)
          J.$index$asx(this.plugins, this._i).render$0();
    }, "call$0", "get$render", 0, 0, 13, "render"],
    postRender$0: [function() {
      var t1, t2;
      this._i = this._len;
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$index$asx(this.plugins, this._i).get$visible() === true && J.$index$asx(this.plugins, this._i).get$hasPostRender() === true)
          J.$index$asx(this.plugins, this._i).postRender$0();
    }, "call$0", "get$postRender", 0, 0, 13, "postRender"],
    destroy$0: [function() {
      this.removeAll$0();
      this.game = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    PluginManager$1: function(game) {
      this.plugins = [];
      this._len = 0;
      this._i = 0;
    },
    static: {PluginManager$: [function(game) {
        var t1 = new R.PluginManager(game, null, null, null);
        t1.PluginManager$1(game);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new PluginManager"]}
  },
  "+PluginManager": [632],
  ScaleManager: {
    "^": "Object;game@-598,width*-601,height*-601,minWidth*-601,maxWidth*-601,minHeight*-601,maxHeight*-601,forceLandscape@-602,forcePortrait@-602,incorrectOrientation@-602,pageAlignHorizontally@-602,pageAlignVertically@-602,maxIterations@-599,orientationSprite@-643,enterLandscape@-1046,enterPortrait@-1046,enterIncorrectOrientation@-1015,leaveIncorrectOrientation@-1015,hasResized@-1047,fullScreenTarget@-1048,enterFullScreen@-1046,leaveFullScreen@-1046,orientation*-599,scaleFactor@-600,scaleFactorInversed@-600,margin*-600,bounds@-974,aspectRatio*-629,sourceAspectRatio@-629,event@-32,scaleMode@-599,fullScreenScaleMode@-599,_startHeight@-601,_Phaser$_width@-601,_Phaser$_height@-601,_check@-1049,isFullScreen@-602,_iterations@-599,isLandscape@-602",
    fullScreenChange$1: [function($event) {
      this.event = $event;
      if (this.isFullScreen === true) {
        if (J.$eq(this.fullScreenScaleMode, 0)) {
          J.set$width$x(J.get$style$x(this.fullScreenTarget), "100%");
          J.set$height$x(J.get$style$x(this.fullScreenTarget), "100%");
          this.width = window.outerWidth;
          this.height = window.outerHeight;
          J.get$scale$x(this.game.get$input()).setTo$2(J.$div$n(J.get$width$x(this.game), this.width), J.$div$n(J.get$height$x(this.game), this.height));
          this.aspectRatio = J.$div$n(this.width, this.height);
          J.set$x$x(this.scaleFactor, J.$div$n(J.get$width$x(this.game), this.width));
          J.set$y$x(this.scaleFactor, J.$div$n(J.get$height$x(this.game), this.height));
          this.checkResize$0();
        } else if (J.$eq(this.fullScreenScaleMode, 2)) {
          this.setShowAll$0();
          this.refresh$0();
        }
        this.enterFullScreen.dispatch$1([this.width, this.height]);
      } else {
        J.set$width$x(J.get$style$x(this.fullScreenTarget), J.$add$ns(J.toString$0(J.get$width$x(this.game)), "px"));
        J.set$height$x(J.get$style$x(this.fullScreenTarget), J.$add$ns(J.toString$0(J.get$height$x(this.game)), "px"));
        this.width = this._Phaser$_width;
        this.height = this._Phaser$_height;
        J.get$scale$x(this.game.get$input()).setTo$2(J.$div$n(J.get$width$x(this.game), this.width), J.$div$n(J.get$height$x(this.game), this.height));
        this.aspectRatio = J.$div$n(this.width, this.height);
        J.set$x$x(this.scaleFactor, J.$div$n(J.get$width$x(this.game), this.width));
        J.set$y$x(this.scaleFactor, J.$div$n(J.get$height$x(this.game), this.height));
        this.leaveFullScreen.dispatch$1([this.width, this.height]);
      }
    }, "call$1", "get$fullScreenChange", 2, 0, 63, 815, [], "fullScreenChange"],
    forceOrientation$3: [function(forceLandscape, forcePortrait, orientationImage) {
      var t1, t2;
      if (forcePortrait == null)
        forcePortrait = false;
      this.forceLandscape = forceLandscape;
      this.forcePortrait = forcePortrait;
      if (orientationImage != null) {
        if (!this.game.get$cache().checkImageKey$1(orientationImage))
          orientationImage = "__default";
        t1 = this.game;
        t1 = R.Image$(t1, J.$tdiv$n(J.get$width$x(t1), 2), J.$tdiv$n(J.get$height$x(this.game), 2), J.$index$asx($.get$TextureCache(), orientationImage), null);
        this.orientationSprite = t1;
        t1.Phaser$Image$anchor.set$1(0.5);
        this.checkOrientationState$0();
        t1 = this.incorrectOrientation;
        t2 = this.orientationSprite;
        if (t1 === true) {
          t2.set$visible(true);
          this.game.get$world().set$visible(false);
        } else {
          t2.set$visible(false);
          this.game.get$world().set$visible(true);
        }
        this.game.get$stage().addChild$1(this.orientationSprite);
      }
    }, function(forceLandscape) {
      return this.forceOrientation$3(forceLandscape, false, "");
    }, "forceOrientation$1", function(forceLandscape, forcePortrait) {
      return this.forceOrientation$3(forceLandscape, forcePortrait, "");
    }, "forceOrientation$2", "call$3", "call$1", "call$2", "get$forceOrientation", 2, 4, 1050, 95, 221, 1051, [], 1052, [], 1053, [], "forceOrientation"],
    checkOrientationState$0: [function() {
      var t1, t2;
      if (this.incorrectOrientation === true) {
        if (this.forceLandscape === true) {
          t1 = window.innerWidth;
          t2 = window.innerHeight;
          if (typeof t1 !== "number")
            return t1.$gt();
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = t1 > t2;
          t1 = t2;
        } else
          t1 = false;
        if (!t1)
          if (this.forcePortrait === true) {
            t1 = window.innerHeight;
            t2 = window.innerWidth;
            if (typeof t1 !== "number")
              return t1.$gt();
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = t1 > t2;
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = true;
        if (t1) {
          this.incorrectOrientation = false;
          this.leaveIncorrectOrientation.dispatch$0();
          t1 = this.orientationSprite;
          if (t1 != null) {
            t1.set$visible(false);
            this.game.get$world().set$visible(true);
          }
          if (!J.$eq(this.scaleMode, 1))
            this.refresh$0();
        }
      } else {
        if (this.forceLandscape === true) {
          t1 = window.innerWidth;
          t2 = window.innerHeight;
          if (typeof t1 !== "number")
            return t1.$lt();
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = t1 < t2;
          t1 = t2;
        } else
          t1 = false;
        if (!t1)
          if (this.forcePortrait === true) {
            t1 = window.innerHeight;
            t2 = window.innerWidth;
            if (typeof t1 !== "number")
              return t1.$lt();
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = t1 < t2;
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = true;
        if (t1) {
          this.incorrectOrientation = true;
          this.enterIncorrectOrientation.dispatch$0();
          t1 = this.orientationSprite;
          if (t1 != null && J.$eq(t1.get$visible(), false)) {
            this.orientationSprite.set$visible(true);
            this.game.get$world().set$visible(false);
          }
          if (!J.$eq(this.scaleMode, 1))
            this.refresh$0();
        }
      }
    }, "call$0", "get$checkOrientationState", 0, 0, 13, "checkOrientationState"],
    checkOrientation$1: [function($event) {
      var t1;
      this.event = $event;
      t1 = window.orientation;
      this.orientation = t1;
      if (this.isLandscape === true)
        this.enterLandscape.dispatch$1([t1, true, false]);
      else
        this.enterPortrait.dispatch$1([t1, false, true]);
      if (!J.$eq(this.scaleMode, 1))
        this.refresh$0();
    }, "call$1", "get$checkOrientation", 2, 0, 63, 815, [], "checkOrientation"],
    checkResize$1: [function($event) {
      var t1, t2;
      this.event = $event;
      t1 = this.isLandscape;
      t2 = this.orientation;
      if (t1 === true)
        this.enterLandscape.dispatch$1([t2, true, false]);
      else
        this.enterPortrait.dispatch$1([t2, false, true]);
      if (!J.$eq(this.scaleMode, 1))
        this.refresh$0();
      this.checkOrientationState$0();
    }, function() {
      return this.checkResize$1(null);
    }, "checkResize$0", "call$1", "call$0", "get$checkResize", 0, 2, 919, 32, 815, [], "checkResize"],
    refresh$0: [function() {
      if (this.game.get$device().get$iPad() !== true && this.game.get$device().get$webApp() !== true && this.game.get$device().get$desktop() !== true)
        if (this.game.get$device().get$android() === true && this.game.get$device().get$chrome() !== true)
          C.Window_methods.scrollTo$2(window, 0, 1);
        else
          C.Window_methods.scrollTo$2(window, 0, 0);
      if (this._check == null && J.$gt$n(this.maxIterations, 0)) {
        this._iterations = this.maxIterations;
        this._check = P.Timer_Timer$periodic(C.Duration_10000, new R.ScaleManager_refresh_closure(this));
        this.setScreenSize$0();
      }
    }, "call$0", "get$refresh", 0, 0, 13, "refresh"],
    setScreenSize$1: [function(force) {
      var t1, t2, t3;
      if (this.game.get$device().get$iPad() !== true && this.game.get$device().get$webApp() !== true && this.game.get$device().get$desktop() !== true)
        if (this.game.get$device().get$android() === true && this.game.get$device().get$chrome() !== true)
          C.Window_methods.scrollTo$2(window, 0, 1);
        else
          C.Window_methods.scrollTo$2(window, 0, 0);
      t1 = J.$sub$n(this._iterations, 1);
      this._iterations = t1;
      if (force !== true) {
        t2 = window.innerHeight;
        t3 = this._startHeight;
        if (typeof t2 !== "number")
          return t2.$gt();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t1 = t2 > t3 || J.$lt$n(t1, 0);
      } else
        t1 = true;
      if (t1) {
        J.set$minHeight$x(document.documentElement.style, J.toString$0(window.innerHeight) + "px");
        if (this.incorrectOrientation === true) {
          this.width = window.innerWidth;
          this.height = window.innerHeight;
        } else if (this.isFullScreen !== true) {
          if (J.$eq(this.scaleMode, 0))
            this.setExactFit$0();
          else if (J.$eq(this.scaleMode, 2))
            this.setShowAll$0();
        } else if (J.$eq(this.fullScreenScaleMode, 0))
          this.setExactFit$0();
        else if (J.$eq(this.fullScreenScaleMode, 2))
          this.setShowAll$0();
        if (this.incorrectOrientation !== true) {
          t1 = this.maxWidth;
          if (t1 != null && J.$gt$n(this.width, t1))
            this.width = this.maxWidth;
          t1 = this.maxHeight;
          if (t1 != null && J.$gt$n(this.height, t1))
            this.height = this.maxHeight;
          t1 = this.minWidth;
          if (t1 != null && J.$lt$n(this.width, t1))
            this.width = this.minWidth;
          t1 = this.minHeight;
          if (t1 != null && J.$lt$n(this.height, t1))
            this.height = this.minHeight;
        }
        J.set$width$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(this.width), "px"));
        J.set$height$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(this.height), "px"));
        J.get$scale$x(this.game.get$input()).setTo$2(J.$div$n(J.get$width$x(this.game), this.width), J.$div$n(J.get$height$x(this.game), this.height));
        if (this.pageAlignHorizontally === true) {
          t1 = J.$lt$n(this.width, window.innerWidth) && this.incorrectOrientation !== true;
          t2 = this.margin;
          if (t1) {
            t1 = window.innerWidth;
            t3 = this.width;
            if (typeof t1 !== "number")
              return t1.$sub();
            if (typeof t3 !== "number")
              return H.iae(t3);
            J.set$x$x(t2, C.JSNumber_methods.round$0((t1 - t3) / 2));
            J.set$marginLeft$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(J.get$x$x(this.margin)), "px"));
          } else {
            J.set$x$x(t2, 0);
            J.set$marginLeft$x(J.get$style$x(J.get$canvas$x(this.game)), "0px");
          }
        }
        if (this.pageAlignVertically === true) {
          t1 = J.$lt$n(this.height, window.innerHeight) && this.incorrectOrientation !== true;
          t2 = this.margin;
          if (t1) {
            t1 = window.innerHeight;
            t3 = this.height;
            if (typeof t1 !== "number")
              return t1.$sub();
            if (typeof t3 !== "number")
              return H.iae(t3);
            J.set$y$x(t2, C.JSNumber_methods.round$0((t1 - t3) / 2));
            J.set$marginTop$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(J.get$y$x(this.margin)), "px"));
          } else {
            J.set$y$x(t2, 0);
            J.set$marginTop$x(J.get$style$x(J.get$canvas$x(this.game)), "0px");
          }
        }
        R.Canvas_getOffset(J.get$canvas$x(this.game), J.get$offset$x(this.game.get$stage()));
        this.bounds.setTo$4(J.get$x$x(J.get$offset$x(this.game.get$stage())), J.get$y$x(J.get$offset$x(this.game.get$stage())), this.width, this.height);
        this.aspectRatio = J.$div$n(this.width, this.height);
        J.set$x$x(this.scaleFactor, J.$div$n(J.get$width$x(this.game), this.width));
        J.set$y$x(this.scaleFactor, J.$div$n(J.get$height$x(this.game), this.height));
        J.set$x$x(this.scaleFactorInversed, J.$div$n(this.width, J.get$width$x(this.game)));
        J.set$y$x(this.scaleFactorInversed, J.$div$n(this.height, J.get$height$x(this.game)));
        this.hasResized.dispatch$1([this.width, this.height]);
        this.checkOrientationState$0();
        t1 = this._check;
        if (t1 != null) {
          t1.cancel$0();
          this._check = null;
        }
      }
    }, function() {
      return this.setScreenSize$1(false);
    }, "setScreenSize$0", "call$1", "call$0", "get$setScreenSize", 0, 2, 932, 95, 1054, [], "setScreenSize"],
    setSize$0: [function() {
      var t1, t2, t3;
      if (this.incorrectOrientation !== true) {
        t1 = this.maxWidth;
        if (t1 != null && J.$gt$n(this.width, t1))
          this.width = this.maxWidth;
        t1 = this.maxHeight;
        if (t1 != null && J.$gt$n(this.height, t1))
          this.height = this.maxHeight;
        t1 = this.minWidth;
        if (t1 != null && J.$lt$n(this.width, t1))
          this.width = this.minWidth;
        t1 = this.minHeight;
        if (t1 != null && J.$lt$n(this.height, t1))
          this.height = this.minHeight;
      }
      J.set$width$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(this.width), "px"));
      J.set$height$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(this.height), "px"));
      J.get$scale$x(this.game.get$input()).setTo$2(J.$div$n(J.get$width$x(this.game), this.width), J.$div$n(J.get$height$x(this.game), this.height));
      if (this.pageAlignHorizontally === true) {
        t1 = J.$lt$n(this.width, window.innerWidth) && this.incorrectOrientation !== true;
        t2 = this.margin;
        if (t1) {
          t1 = window.innerWidth;
          t3 = this.width;
          if (typeof t1 !== "number")
            return t1.$sub();
          if (typeof t3 !== "number")
            return H.iae(t3);
          J.set$x$x(t2, C.JSNumber_methods.round$0((t1 - t3) / 2));
          J.set$marginLeft$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(J.get$x$x(this.margin)), "px"));
        } else {
          J.set$x$x(t2, 0);
          J.set$marginLeft$x(J.get$style$x(J.get$canvas$x(this.game)), "0px");
        }
      }
      if (this.pageAlignVertically === true) {
        t1 = J.$lt$n(this.height, window.innerHeight) && this.incorrectOrientation !== true;
        t2 = this.margin;
        if (t1) {
          t1 = window.innerHeight;
          t3 = this.height;
          if (typeof t1 !== "number")
            return t1.$sub();
          if (typeof t3 !== "number")
            return H.iae(t3);
          J.set$y$x(t2, C.JSNumber_methods.round$0((t1 - t3) / 2));
          J.set$marginTop$x(J.get$style$x(J.get$canvas$x(this.game)), J.$add$ns(J.toString$0(J.get$y$x(this.margin)), "px"));
        } else {
          J.set$y$x(t2, 0);
          J.set$marginTop$x(J.get$style$x(J.get$canvas$x(this.game)), "0px");
        }
      }
      R.Canvas_getOffset(J.get$canvas$x(this.game), J.get$offset$x(this.game.get$stage()));
      this.bounds.setTo$4(J.get$x$x(J.get$offset$x(this.game.get$stage())), J.get$y$x(J.get$offset$x(this.game.get$stage())), this.width, this.height);
      this.aspectRatio = J.$div$n(this.width, this.height);
      J.set$x$x(this.scaleFactor, J.$div$n(J.get$width$x(this.game), this.width));
      J.set$y$x(this.scaleFactor, J.$div$n(J.get$height$x(this.game), this.height));
      J.set$x$x(this.scaleFactorInversed, J.$div$n(this.width, J.get$width$x(this.game)));
      J.set$y$x(this.scaleFactorInversed, J.$div$n(this.height, J.get$height$x(this.game)));
      this.hasResized.dispatch$1([this.width, this.height]);
      this.checkOrientationState$0();
    }, "call$0", "get$setSize", 0, 0, 13, "setSize"],
    setMaximum$0: [function() {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
    }, "call$0", "get$setMaximum", 0, 0, 13, "setMaximum"],
    setShowAll$0: [function() {
      var t1, t2, t3, t4, multiplier;
      t1 = window.innerHeight;
      t2 = J.get$height$x(this.game);
      if (typeof t1 !== "number")
        return t1.$div();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = window.innerWidth;
      t4 = J.get$width$x(this.game);
      if (typeof t3 !== "number")
        return t3.$div();
      if (typeof t4 !== "number")
        return H.iae(t4);
      multiplier = P.min(t1 / t2, t3 / t4);
      this.width = J.round$0$n(J.$mul$ns(J.get$width$x(this.game), multiplier));
      this.height = J.round$0$n(J.$mul$ns(J.get$height$x(this.game), multiplier));
    }, "call$0", "get$setShowAll", 0, 0, 13, "setShowAll"],
    setExactFit$0: [function() {
      var availableWidth, availableHeight, t1, t2;
      availableWidth = window.innerWidth;
      availableHeight = window.innerHeight;
      t1 = this.maxWidth;
      if (t1 != null) {
        if (typeof availableWidth !== "number")
          return availableWidth.$gt();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = availableWidth > t1;
      } else
        t2 = false;
      if (t2)
        this.width = t1;
      else
        this.width = availableWidth;
      t1 = this.maxHeight;
      if (t1 != null) {
        if (typeof availableHeight !== "number")
          return availableHeight.$gt();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = availableHeight > t1;
      } else
        t2 = false;
      if (t2)
        this.height = t1;
      else
        this.height = availableHeight;
    }, "call$0", "get$setExactFit", 0, 0, 13, "setExactFit"],
    ScaleManager$3: function(game, width, height) {
      var _this, t1, exception;
      this.game = game;
      this.width = width;
      this.height = height;
      this.minWidth = null;
      this.maxWidth = null;
      this.minHeight = null;
      this.maxHeight = null;
      this.forceLandscape = false;
      this.forcePortrait = false;
      this.incorrectOrientation = false;
      this.pageAlignHorizontally = false;
      this.pageAlignVertically = false;
      this.maxIterations = 5;
      this.orientationSprite = null;
      this.enterLandscape = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.enterPortrait = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.enterIncorrectOrientation = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.leaveIncorrectOrientation = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.hasResized = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.fullScreenTarget = J.get$canvas$x(this.game);
      this.enterFullScreen = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.leaveFullScreen = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.orientation = 0;
      this.orientation = window.orientation;
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this.scaleFactor = t1;
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this.scaleFactorInversed = t1;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.margin = t1;
      this.bounds = new R.Rectangle1(0, 0, width, height, 0, 0, 0, 0);
      this.aspectRatio = 0;
      this.sourceAspectRatio = J.$div$n(width, height);
      this.event = null;
      this.scaleMode = 1;
      this.fullScreenScaleMode = 1;
      this._startHeight = 0;
      this._Phaser$_width = 0;
      this._Phaser$_height = 0;
      this._check = null;
      _this = this;
      C.Window_methods.addEventListener$2(window, "orientationchange", _this.get$checkOrientation());
      try {
        t1 = C.EventStreamProvider_resize.forTarget$1(window);
        H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(_this.get$checkResize()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      } catch (exception) {
        H.unwrapException(exception);
      }

      t1 = C.EventStreamProvider_webkitfullscreenchange.forTarget$1(document);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(_this.get$fullScreenChange()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    },
    static: {"^": "ScaleManager_EXACT_FIT<-599,ScaleManager_NO_SCALE<-599,ScaleManager_SHOW_ALL<-599", ScaleManager$: [function(game, width, height) {
        var t1 = new R.ScaleManager(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, 1, 1, null, null, null, null, null, 0, false);
        t1.ScaleManager$3(game, width, height);
        return t1;
      }, null, null, 6, 0, 259, 214, [], 10, [], 11, [], "new ScaleManager"]}
  },
  "+ScaleManager": [632],
  ScaleManager_refresh_closure: {
    "^": "Closure:63;_this_0",
    call$1: [function(t) {
      return this._this_0.setScreenSize$0();
    }, "call$1", null, 2, 0, 63, 380, [], "call"],
    $isFunction: true
  },
  SignalBinding: {
    "^": "Object;_listener@-0,_isOnce@-602,_priority@-599,_signal@-1055,active@-602,params@-720",
    _listener$0: function() {
      return this._listener.call$0();
    },
    execute$1: [function(params) {
      var t1, handlerReturn;
      if (this.active === true && this._listener != null) {
        t1 = this.params;
        if (t1 == null)
          this.params = params;
        else
          J.addAll$1$ax(t1, params);
        handlerReturn = params != null && !J.$eq(J.get$length$asx(params), 0) ? H.Primitives_applyFunction(this._listener, params, P.Function__toMangledNames(null)) : this._listener$0();
        if (this._isOnce === true)
          if (this.isBound$0())
            J.remove$1$ax(this._signal, this._listener);
      } else
        handlerReturn = null;
      return handlerReturn;
    }, "call$1", "get$execute", 2, 0, 14, 1056, [], "execute"],
    detach$0: [function() {
      return this.isBound$0() ? J.remove$1$ax(this._signal, this._listener) : null;
    }, "call$0", "get$detach", 0, 0, 13, "detach"],
    isBound$0: [function() {
      return this._signal != null && this._listener != null;
    }, "call$0", "get$isBound", 0, 0, 13, "isBound"],
    isOnce$0: [function() {
      return this._isOnce;
    }, "call$0", "get$isOnce", 0, 0, 13, "isOnce"],
    getListener$0: [function() {
      return this._listener;
    }, "call$0", "get$getListener", 0, 0, 13, "getListener"],
    getSignal$0: [function() {
      return this._signal;
    }, "call$0", "get$getSignal", 0, 0, 13, "getSignal"],
    _destroy$0: [function() {
      this._signal = null;
      this._listener = null;
    }, "call$0", "get$_destroy", 0, 0, 13, "_destroy"],
    toString$0: [function(_) {
      return "[Phaser.SignalBinding isOnce: " + H.S(this._isOnce) + ", isBound:" + this.isBound$0() + ", active:" + H.S(this.active) + "]";
    }, "call$0", "get$toString", 0, 0, 782, "toString"],
    $isSignalBinding: true,
    static: {SignalBinding$_: [function(_signal, _listener, _isOnce, _priority) {
        var t1 = new R.SignalBinding(_listener, _isOnce, _priority, _signal, true, null);
        if (_priority == null)
          t1._priority = 0;
        return t1;
      }, null, null, 4, 4, 260, 95, 5, 261, [], 262, [], 263, [], 264, [], "new SignalBinding$_"]}
  },
  "+SignalBinding": [632],
  Stage: {
    "^": "Stage0;game@-598,offset*-600,bounds@-974,name*-639,disableVisibilityChange@-602,checkOffsetInterval@-601,exists@-602,currentRenderOrderID@-601,_hiddenVar@-639,_nextOffsetCheck@-601,_backgroundColor@-599,_onChange@-0,scaleModel@-865,fullScreenScaleMode@-602,scaleMode@-865,parent*-2,z*-599,fixedToCamera@-602,anchor@-600,world@-600,_Phaser$_currentBounds@-974,type*-599,_cache@-720,events@-1018,classType@-1057,renderOrderID@-599,cameraOffset@-600,autoCull@-602,alive@-602,_Phaser$_dirty@-602,children:Phaser$Stage$children*-1058,PIXI$Stage0$_dirty-602,_interactiveEventsAdded-602,PIXI$Stage0$hitArea-641,backgroundColor-599,backgroundColorSplit-681,backgroundColorString-639,PIXI$Stage0$_worldTransform-640,interactionManager-682,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(J.get$x$x(this.position), J.$div$n(J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.getLocalBounds$0())), 2));
      t2 = J.$add$ns(J.get$y$x(this.position), J.$div$n(J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.getLocalBounds$0())), 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1019, "center"],
    destroy$1: [function(destroyChildren) {
      throw H.wrapException(P.Exception_Exception("Not implement yet!"));
    }, function() {
      return this.destroy$1(true);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 932, 39, 1039, [], "destroy"],
    get$destroyPhase: [function() {
      return false;
    }, null, null, 1, 0, 209, "destroyPhase"],
    bringToTop$1: [function(child) {
      var t1;
      if (child == null) {
        t1 = this.parent;
        if (t1 != null)
          t1.bringToTop$1(this);
        return this;
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$Stage$children, child), J.get$length$asx(this.Phaser$Stage$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Stage$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$Stage$children));
        }
        return child;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1059, 32, 659, [], "bringToTop"],
    get$backgroundColor: [function(_) {
      return this._backgroundColor;
    }, null, null, 1, 0, 367, "backgroundColor"],
    set$backgroundColor: [function(_, value) {
      if (this.game.get$transparent() !== true)
        this.setBackgroundColor$1(value);
    }, null, null, 3, 0, 60, 100, [], "backgroundColor"],
    get$smoothed: [function() {
      return true;
    }, null, null, 1, 0, 209, "smoothed"],
    set$smoothed: [function(value) {
    }, null, null, 3, 0, 650, 100, [], "smoothed"],
    preUpdate$0: [function() {
      var len, i;
      this.currentRenderOrderID = 0;
      len = J.get$length$asx(this.Phaser$Stage$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Stage$children, i).preUpdate$0();
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    update$0: [function() {
      var i, t1, i0;
      i = J.get$length$asx(this.Phaser$Stage$children);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this.Phaser$Stage$children, i0).update$0();
    }, "call$0", "get$update", 0, 0, 13, "update"],
    postUpdate$0: [function() {
      var t1, t2, i, i0;
      t1 = J.get$target$x(this.game.get$world().get$camera());
      t2 = this.game;
      if (t1 != null) {
        J.get$target$x(t2.get$world().get$camera()).postUpdate$0();
        this.game.get$world().get$camera().update$0();
        i = J.get$length$asx(this.Phaser$Stage$children);
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          if (!J.$eq(J.$index$asx(this.Phaser$Stage$children, i0), J.get$target$x(this.game.get$world().get$camera())))
            J.$index$asx(this.Phaser$Stage$children, i0).postUpdate$0();
      } else {
        t2.get$world().get$camera().update$0();
        i = J.get$length$asx(this.Phaser$Stage$children);
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          J.$index$asx(this.Phaser$Stage$children, i0).postUpdate$0();
      }
      if (!J.$eq(this.checkOffsetInterval, false))
        if (J.$gt$n(this.game.get$time().get$now(), this._nextOffsetCheck)) {
          R.Canvas_getOffset(J.get$canvas$x(this.game), this.offset);
          J.set$x$x(this.bounds, J.get$x$x(this.offset));
          J.set$y$x(this.bounds, J.get$y$x(this.offset));
          this._nextOffsetCheck = J.$add$ns(this.game.get$time().get$now(), this.checkOffsetInterval);
        }
    }, "call$0", "get$postUpdate", 0, 0, 13, "postUpdate"],
    parseConfig$1: [function(config) {
      var t1 = J.getInterceptor$x(config);
      if (t1.containsKey$1(config, "checkOffsetInterval") === true)
        this.checkOffsetInterval = t1.$index(config, "checkOffsetInterval");
      if (t1.containsKey$1(config, "disableVisibilityChange") === true)
        this.disableVisibilityChange = t1.$index(config, "disableVisibilityChange");
      if (t1.containsKey$1(config, "fullScreenScaleMode") === true)
        this.fullScreenScaleMode = t1.$index(config, "fullScreenScaleMode");
      if (t1.containsKey$1(config, "scaleMode") === true)
        this.scaleMode = t1.$index(config, "scaleMode");
      if (t1.containsKey$1(config, "backgroundColor") === true) {
        t1 = t1.$index(config, "backgroundColor");
        if (this.game.get$transparent() !== true)
          this.setBackgroundColor$1(t1);
      }
    }, "call$1", "get$parseConfig", 2, 0, 771, 423, [], "parseConfig"],
    boot$0: [function() {
      var t1, t2;
      R.Canvas_getOffset(J.get$canvas$x(this.game), this.offset);
      this.bounds.setTo$4(J.get$x$x(this.offset), J.get$y$x(this.offset), J.get$width$x(this.game), J.get$height$x(this.game));
      this._onChange = new R.Stage_boot_closure(this);
      t1 = J.get$canvas$x(this.game);
      t2 = J.getInterceptor$x(t1);
      J.set$userSelect$x(t2.get$style(t1), "none");
      J.set$tapHighlightColor$x(t2.get$style(t1), "rgba(0, 0, 0, 0)");
      this._hiddenVar = "visibilitychange";
      C.HtmlDocument_methods.addEventListener$3(document, "visibilitychange", this._onChange, false);
      t1 = C.EventStreamProvider_pagehide.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = C.EventStreamProvider_pageshow.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = C.EventStreamProvider_blur.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = C.EventStreamProvider_focus.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    }, "call$0", "get$boot", 0, 0, 13, "boot"],
    checkVisibility$0: [function() {
      this._hiddenVar = "visibilitychange";
      C.HtmlDocument_methods.addEventListener$3(document, "visibilitychange", this._onChange, false);
      var t1 = C.EventStreamProvider_pagehide.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = C.EventStreamProvider_pageshow.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = C.EventStreamProvider_blur.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = C.EventStreamProvider_focus.forTarget$1(window);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this._onChange), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    }, "call$0", "get$checkVisibility", 0, 0, 13, "checkVisibility"],
    visibilityChange$1: [function($event) {
      var t1, t2;
      t1 = J.getInterceptor$x($event);
      if (J.$eq(t1.get$type($event), "pagehide") || J.$eq(t1.get$type($event), "blur") || J.$eq(t1.get$type($event), "pageshow") || J.$eq(t1.get$type($event), "focus")) {
        if (J.$eq(t1.get$type($event), "pagehide") || J.$eq(t1.get$type($event), "blur"))
          this.game.focusLoss$1($event);
        else if (J.$eq(t1.get$type($event), "pageshow") || J.$eq(t1.get$type($event), "focus"))
          this.game.focusGain$1($event);
        return;
      }
      if (this.disableVisibilityChange === true)
        return;
      t1 = document.webkitHidden;
      t2 = this.game;
      if (t1 === true)
        t2.gamePaused$1($event);
      else
        t2.gameResumed$1($event);
    }, "call$1", "get$visibilityChange", 2, 0, 63, 815, [], "visibilityChange"],
    setBackgroundColor$1: [function(backgroundColor) {
      var rgb, t1, t2, t3;
      if (typeof backgroundColor === "string") {
        rgb = R.Color_hexToColor(backgroundColor, null);
        t1 = J.get$r$x(rgb);
        t2 = rgb.get$g();
        t3 = rgb.get$b();
        t1 = J.$shl$n(t1, 16);
        t2 = J.$shl$n(t2, 8);
        if (typeof t3 !== "number")
          return H.iae(t3);
        this._backgroundColor = (t1 | t2 | t3) >>> 0;
      } else {
        rgb = R.Color_getRGB(backgroundColor);
        this._backgroundColor = backgroundColor;
      }
      t1 = J.getInterceptor$x(rgb);
      this.backgroundColorSplit = [J.$div$n(t1.get$r(rgb), 255), J.$div$n(rgb.get$g(), 255), J.$div$n(rgb.get$b(), 255)];
      this.backgroundColorString = R.Color_RGBtoString(t1.get$r(rgb), rgb.get$g(), rgb.get$b(), 255, "#");
    }, "call$1", "get$setBackgroundColor", 2, 0, 63, 40, [], "setBackgroundColor"],
    Stage$3: function(game, width, height) {
      var t1, t2;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.offset = t1;
      this.bounds = new R.Rectangle1(0, 0, width, height, 0, 0, 0, 0);
      this.name = "_stage_root";
      this.set$interactive(false);
      this.disableVisibilityChange = false;
      this.checkOffsetInterval = 2500;
      this.exists = true;
      this.currentRenderOrderID = 0;
      this._hiddenVar = "hidden";
      this._nextOffsetCheck = 0;
      this._backgroundColor = 0;
      if (this.game.get$config() != null) {
        t1 = this.game.get$config();
        t2 = J.getInterceptor$x(t1);
        if (t2.containsKey$1(t1, "checkOffsetInterval") === true)
          this.checkOffsetInterval = t2.$index(t1, "checkOffsetInterval");
        if (t2.containsKey$1(t1, "disableVisibilityChange") === true)
          this.disableVisibilityChange = t2.$index(t1, "disableVisibilityChange");
        if (t2.containsKey$1(t1, "fullScreenScaleMode") === true)
          this.fullScreenScaleMode = t2.$index(t1, "fullScreenScaleMode");
        if (t2.containsKey$1(t1, "scaleMode") === true)
          this.scaleMode = t2.$index(t1, "scaleMode");
        if (t2.containsKey$1(t1, "backgroundColor") === true) {
          t1 = t2.$index(t1, "backgroundColor");
          if (this.game.get$transparent() !== true)
            this.setBackgroundColor$1(t1);
        }
      }
    },
    $isGameObject: true,
    static: {Stage$0: [function(game, width, height) {
        var t1, t2, t3, t4, t5, t6;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new Float32Array(9);
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new R.Stage(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, t1, null, null, null, null, null, null, null, null, null, false, [], null, false, new M.Rectangle0(0, 0, 100000, 100000), 0, [], null, new M.Matrix(1, 0, 0, 1, 0, 0, t2), null, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.Stage$2(0, true);
        t1.Stage$3(game, width, height);
        return t1;
      }, null, null, 6, 0, 259, 214, [], 10, [], 11, [], "new Stage"]}
  },
  "+Stage": [638, 2],
  Stage_boot_closure: {
    "^": "Closure:63;_this_0",
    call$1: [function($event) {
      return this._this_0.visibilityChange$1($event);
    }, "call$1", null, 2, 0, 63, 815, [], "call"],
    $isFunction: true
  },
  State: {
    "^": "Object;game@-598,add*-997,make@-998,camera@-1012,cache@-999,input@-1000,math@-1060,load*-1001,sound@-1004,scale*-1003,stage@-1006,time@-1007,tweens@-1009,world@-983,particles@-1014,physics@-1008,rnd@-1010,state*-995",
    add$2: function($receiver, arg0, arg1) {
      return this.add.call$2(arg0, arg1);
    },
    add$1: function($receiver, arg0) {
      return this.add.call$1(arg0);
    },
    add$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.add.call$4(arg0, arg1, arg2, arg3);
    },
    add$3: function($receiver, arg0, arg1, arg2) {
      return this.add.call$3(arg0, arg1, arg2);
    },
    add$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.add.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    load$0: function($receiver) {
      return this.load.call$0();
    },
    load$1: function($receiver, arg0) {
      return this.load.call$1(arg0);
    },
    load$2: function($receiver, arg0, arg1) {
      return this.load.call$2(arg0, arg1);
    },
    sound$4: function(arg0, arg1, arg2, arg3) {
      return this.sound.call$4(arg0, arg1, arg2, arg3);
    },
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    physics$4: function(arg0, arg1, arg2, arg3) {
      return this.physics.call$4(arg0, arg1, arg2, arg3);
    },
    rnd$0: function() {
      return this.rnd.call$0();
    },
    preload$0: [function(_) {
    }, "call$0", "get$preload", 0, 0, 13, "preload"],
    loadUpdate$0: [function() {
    }, "call$0", "get$loadUpdate", 0, 0, 13, "loadUpdate"],
    loadRender$0: [function() {
    }, "call$0", "get$loadRender", 0, 0, 13, "loadRender"],
    create$0: [function() {
    }, "call$0", "get$create", 0, 0, 13, "create"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 13, "update"],
    render$0: [function() {
    }, "call$0", "get$render", 0, 0, 13, "render"],
    paused$0: [function(_) {
    }, "call$0", "get$paused", 0, 0, 13, "paused"],
    pauseUpdate$0: [function() {
    }, "call$0", "get$pauseUpdate", 0, 0, 13, "pauseUpdate"],
    shutdown$0: [function() {
    }, "call$0", "get$shutdown", 0, 0, 13, "shutdown"],
    preRender$0: [function() {
    }, "call$0", "get$preRender", 0, 0, 13, "preRender"],
    resumed$0: [function() {
    }, "call$0", "get$resumed", 0, 0, 13, "resumed"],
    init$1: [function(args) {
    }, function() {
      return this.init$1(null);
    }, "init$0", "call$1", "call$0", "get$init", 0, 2, 919, 32, 338, [], "init"],
    State$0: function() {
      this.game = null;
      this.add = null;
      this.make = null;
      this.camera = null;
      this.cache = null;
      this.input = null;
      this.load = null;
      this.math = null;
      this.sound = null;
      this.scale = null;
      this.stage = null;
      this.time = null;
      this.tweens = null;
      this.world = null;
      this.particles = null;
      this.physics = null;
      this.set$rnd(null);
    },
    static: {State$: [function() {
        var t1 = new R.State(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.State$0();
        return t1;
      }, null, null, 0, 0, 13, "new State"]}
  },
  "+State": [632],
  StateManager: {
    "^": "Object;game@-598,states@-1061,_clearWorld@-602,_clearCache@-602,_created*-602,_args@-720,_pendingStateKey@-639,_pendingState@-1062,current@-1062,onInitCallback@-0,onPreloadCallback@-0,onCreateCallback@-0,onUpdateCallback@-0,onRenderCallback@-0,onPreRenderCallback@-0,onLoadUpdateCallback@-0,onLoadRenderCallback@-0,onPausedCallback@-0,onResumedCallback@-0,onPauseUpdateCallback@-0,onShutDownCallback@-0",
    onInitCallback$1: function(arg0) {
      return this.onInitCallback.call$1(arg0);
    },
    onPreloadCallback$0: function() {
      return this.onPreloadCallback.call$0();
    },
    onCreateCallback$0: function() {
      return this.onCreateCallback.call$0();
    },
    onUpdateCallback$0: function() {
      return this.onUpdateCallback.call$0();
    },
    onUpdateCallback$2: function(arg0, arg1) {
      return this.onUpdateCallback.call$2(arg0, arg1);
    },
    onRenderCallback$0: function() {
      return this.onRenderCallback.call$0();
    },
    onPreRenderCallback$0: function() {
      return this.onPreRenderCallback.call$0();
    },
    onLoadUpdateCallback$0: function() {
      return this.onLoadUpdateCallback.call$0();
    },
    onLoadRenderCallback$0: function() {
      return this.onLoadRenderCallback.call$0();
    },
    onPausedCallback$0: function() {
      return this.onPausedCallback.call$0();
    },
    onResumedCallback$0: function() {
      return this.onResumedCallback.call$0();
    },
    onPauseUpdateCallback$0: function() {
      return this.onPauseUpdateCallback.call$0();
    },
    onShutDownCallback$0: function() {
      return this.onShutDownCallback.call$0();
    },
    boot$0: [function() {
      J.add$1$ax(J.get$onPause$x(this.game), this.get$pause(this));
      J.add$1$ax(this.game.get$onResume(), this.get$resume());
      J.add$1$ax(J.get$load$x(this.game).get$onLoadComplete(), this.get$loadComplete());
      var t1 = this._pendingState;
      if (t1 != null)
        this.add$3(0, "default", t1, true);
    }, "call$0", "get$boot", 0, 0, 13, "boot"],
    add$3: [function(_, key, state, autoStart) {
      J.$indexSet$ax(this.states, key, state);
      if (autoStart === true)
        if (this.game.get$isBooted() === true)
          this.start$1(0, key);
        else
          this._pendingState = state;
      return state;
    }, function($receiver, key, state) {
      return this.add$3($receiver, key, state, false);
    }, "add$2", "call$3", "call$2", "get$add", 4, 2, 1063, 95, 231, [], 250, [], 1064, [], "add"],
    remove$1: [function(_, key) {
      if (J.$eq(this.current, J.$index$asx(this.states, key))) {
        this.onInitCallback = null;
        this.onShutDownCallback = null;
        this.onPreloadCallback = null;
        this.onLoadRenderCallback = null;
        this.onLoadUpdateCallback = null;
        this.onCreateCallback = null;
        this.onUpdateCallback = null;
        this.onRenderCallback = null;
        this.onPausedCallback = null;
        this.onResumedCallback = null;
        this.onPauseUpdateCallback = null;
      }
      J.remove$1$ax(this.states, key);
    }, "call$1", "get$remove", 2, 0, 52, 231, [], "remove"],
    start$4: [function(_, key, clearWorld, clearCache, args) {
      if (this.checkState$1(key)) {
        this._pendingStateKey = key;
        this._pendingState = J.$index$asx(this.states, key);
        this._clearWorld = clearWorld;
        this._clearCache = clearCache;
        this._args = args;
      }
    }, function($receiver, key) {
      return this.start$4($receiver, key, true, false, null);
    }, "start$1", function($receiver, key, clearWorld, clearCache) {
      return this.start$4($receiver, key, clearWorld, clearCache, null);
    }, "start$3", function($receiver, key, clearWorld) {
      return this.start$4($receiver, key, clearWorld, false, null);
    }, "start$2", "call$4", "call$1", "call$3", "call$2", "get$start", 2, 6, 1065, 39, 95, 32, 231, [], 1066, [], 1067, [], 338, [], "start"],
    restart$3: [function(clearWorld, clearCache, args) {
      this._pendingState = this.current;
      this._clearWorld = clearWorld;
      this._clearCache = clearCache;
      this._args = args;
    }, function() {
      return this.restart$3(true, false, null);
    }, "restart$0", function(clearWorld) {
      return this.restart$3(clearWorld, false, null);
    }, "restart$1", function(clearWorld, clearCache) {
      return this.restart$3(clearWorld, clearCache, null);
    }, "restart$2", "call$3", "call$0", "call$1", "call$2", "get$restart", 0, 6, 1068, 39, 95, 32, 1066, [], 1067, [], 338, [], "restart"],
    preUpdate$0: [function() {
      if (this._pendingState != null && this.game.get$isBooted() === true) {
        if (this.current != null) {
          this.onShutDownCallback$0();
          this.game.get$tweens().removeAll$0();
          J.reset$0$x(this.game.get$camera());
          J.reset$1$x(this.game.get$input(), true);
          J.clear$0$ax(this.game.get$physics());
          this.game.get$time().removeAll$0();
          if (this._clearWorld === true) {
            this.game.get$world().shutdown$0();
            if (J.$eq(this._clearCache, true))
              this.game.get$cache().destroy$0();
          }
        }
        var t1 = this._pendingStateKey;
        J.$index$asx(this.states, t1).set$game(this.game);
        J.set$add$ax(J.$index$asx(this.states, t1), J.get$add$ax(this.game));
        J.$index$asx(this.states, t1).set$make(this.game.get$make());
        J.$index$asx(this.states, t1).set$camera(this.game.get$camera());
        J.$index$asx(this.states, t1).set$cache(this.game.get$cache());
        J.$index$asx(this.states, t1).set$input(this.game.get$input());
        J.set$load$x(J.$index$asx(this.states, t1), J.get$load$x(this.game));
        J.$index$asx(this.states, t1).set$sound(this.game.get$sound());
        J.set$scale$x(J.$index$asx(this.states, t1), J.get$scale$x(this.game));
        J.set$state$x(J.$index$asx(this.states, t1), this);
        J.$index$asx(this.states, t1).set$stage(this.game.get$stage());
        J.$index$asx(this.states, t1).set$time(this.game.get$time());
        J.$index$asx(this.states, t1).set$tweens(this.game.get$tweens());
        J.$index$asx(this.states, t1).set$world(this.game.get$world());
        J.$index$asx(this.states, t1).set$particles(this.game.get$particles());
        J.$index$asx(this.states, t1).set$rnd(this.game.get$rnd());
        J.$index$asx(this.states, t1).set$physics(this.game.get$physics());
        this.onInitCallback = J.$index$asx(this.states, t1).get$init();
        this.onPreloadCallback = J.get$preload$x(J.$index$asx(this.states, t1));
        this.onLoadRenderCallback = J.$index$asx(this.states, t1).get$loadRender();
        this.onLoadUpdateCallback = J.$index$asx(this.states, t1).get$loadUpdate();
        this.onCreateCallback = J.$index$asx(this.states, t1).get$create();
        this.onUpdateCallback = J.$index$asx(this.states, t1).get$update();
        this.onPreRenderCallback = J.$index$asx(this.states, t1).get$preRender();
        this.onRenderCallback = J.$index$asx(this.states, t1).get$render();
        this.onPausedCallback = J.get$paused$x(J.$index$asx(this.states, t1));
        this.onResumedCallback = J.$index$asx(this.states, t1).get$resumed();
        this.onPauseUpdateCallback = J.$index$asx(this.states, t1).get$pauseUpdate();
        this.onShutDownCallback = J.$index$asx(this.states, t1).get$shutdown();
        this.current = J.$index$asx(this.states, t1);
        this._created = false;
        this.onInitCallback$1(this._args);
        this._args = [];
        if (this.onPreloadCallback != null) {
          J.reset$0$x(J.get$load$x(this.game));
          this.onPreloadCallback$0();
          if (J.get$load$x(this.game).totalQueuedFiles$0() === 0 && J.get$load$x(this.game).totalQueuedPacks$0() === 0)
            this.loadComplete$0();
          else
            J.start$0$x(J.get$load$x(this.game));
        } else
          this.loadComplete$0();
        if (J.$eq(this.current, this._pendingState))
          this._pendingState = null;
      }
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    checkState$1: [function(key) {
      var t1;
      if (J.$index$asx(this.states, key) != null)
        return true;
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.StateManager - No state found with the key: ", key);
        if (typeof console != "undefined")
          console.warn(t1);
        return false;
      }
    }, "call$1", "get$checkState", 2, 0, 52, 231, [], "checkState"],
    link$1: [function(key) {
      J.$index$asx(this.states, key).set$game(this.game);
      J.set$add$ax(J.$index$asx(this.states, key), J.get$add$ax(this.game));
      J.$index$asx(this.states, key).set$make(this.game.get$make());
      J.$index$asx(this.states, key).set$camera(this.game.get$camera());
      J.$index$asx(this.states, key).set$cache(this.game.get$cache());
      J.$index$asx(this.states, key).set$input(this.game.get$input());
      J.set$load$x(J.$index$asx(this.states, key), J.get$load$x(this.game));
      J.$index$asx(this.states, key).set$sound(this.game.get$sound());
      J.set$scale$x(J.$index$asx(this.states, key), J.get$scale$x(this.game));
      J.set$state$x(J.$index$asx(this.states, key), this);
      J.$index$asx(this.states, key).set$stage(this.game.get$stage());
      J.$index$asx(this.states, key).set$time(this.game.get$time());
      J.$index$asx(this.states, key).set$tweens(this.game.get$tweens());
      J.$index$asx(this.states, key).set$world(this.game.get$world());
      J.$index$asx(this.states, key).set$particles(this.game.get$particles());
      J.$index$asx(this.states, key).set$rnd(this.game.get$rnd());
      J.$index$asx(this.states, key).set$physics(this.game.get$physics());
    }, "call$1", "get$link", 2, 0, 52, 231, [], "link"],
    setCurrentState$1: [function(key) {
      J.$index$asx(this.states, key).set$game(this.game);
      J.set$add$ax(J.$index$asx(this.states, key), J.get$add$ax(this.game));
      J.$index$asx(this.states, key).set$make(this.game.get$make());
      J.$index$asx(this.states, key).set$camera(this.game.get$camera());
      J.$index$asx(this.states, key).set$cache(this.game.get$cache());
      J.$index$asx(this.states, key).set$input(this.game.get$input());
      J.set$load$x(J.$index$asx(this.states, key), J.get$load$x(this.game));
      J.$index$asx(this.states, key).set$sound(this.game.get$sound());
      J.set$scale$x(J.$index$asx(this.states, key), J.get$scale$x(this.game));
      J.set$state$x(J.$index$asx(this.states, key), this);
      J.$index$asx(this.states, key).set$stage(this.game.get$stage());
      J.$index$asx(this.states, key).set$time(this.game.get$time());
      J.$index$asx(this.states, key).set$tweens(this.game.get$tweens());
      J.$index$asx(this.states, key).set$world(this.game.get$world());
      J.$index$asx(this.states, key).set$particles(this.game.get$particles());
      J.$index$asx(this.states, key).set$rnd(this.game.get$rnd());
      J.$index$asx(this.states, key).set$physics(this.game.get$physics());
      this.onInitCallback = J.$index$asx(this.states, key).get$init();
      this.onPreloadCallback = J.get$preload$x(J.$index$asx(this.states, key));
      this.onLoadRenderCallback = J.$index$asx(this.states, key).get$loadRender();
      this.onLoadUpdateCallback = J.$index$asx(this.states, key).get$loadUpdate();
      this.onCreateCallback = J.$index$asx(this.states, key).get$create();
      this.onUpdateCallback = J.$index$asx(this.states, key).get$update();
      this.onPreRenderCallback = J.$index$asx(this.states, key).get$preRender();
      this.onRenderCallback = J.$index$asx(this.states, key).get$render();
      this.onPausedCallback = J.get$paused$x(J.$index$asx(this.states, key));
      this.onResumedCallback = J.$index$asx(this.states, key).get$resumed();
      this.onPauseUpdateCallback = J.$index$asx(this.states, key).get$pauseUpdate();
      this.onShutDownCallback = J.$index$asx(this.states, key).get$shutdown();
      this.current = J.$index$asx(this.states, key);
      this._created = false;
      this.onInitCallback$1(this._args);
      this._args = [];
    }, "call$1", "get$setCurrentState", 2, 0, 52, 231, [], "setCurrentState"],
    getCurrentState$0: [function() {
      return this.current;
    }, "call$0", "get$getCurrentState", 0, 0, 13, "getCurrentState"],
    loadComplete$0: [function() {
      if (J.$eq(this._created, false) && this.onCreateCallback != null) {
        this._created = true;
        this.onCreateCallback$0();
      } else
        this._created = true;
    }, "call$0", "get$loadComplete", 0, 0, 13, "loadComplete"],
    pause$0: [function(_) {
      if (this._created === true && this.onPausedCallback != null)
        this.onPausedCallback$0();
    }, "call$0", "get$pause", 0, 0, 13, "pause"],
    resume$0: [function() {
      if (this._created === true && this.onResumedCallback != null)
        this.onResumedCallback$0();
    }, "call$0", "get$resume", 0, 0, 13, "resume"],
    update$0: [function() {
      if (this._created === true && this.onUpdateCallback != null)
        this.onUpdateCallback$0();
      else if (this.onLoadUpdateCallback != null)
        this.onLoadUpdateCallback$0();
    }, "call$0", "get$update", 0, 0, 13, "update"],
    pauseUpdate$0: [function() {
      if (this._created === true && this.onPauseUpdateCallback != null)
        this.onPauseUpdateCallback$0();
      else if (this.onLoadUpdateCallback != null)
        this.onLoadUpdateCallback$0();
    }, "call$0", "get$pauseUpdate", 0, 0, 13, "pauseUpdate"],
    preRender$0: [function() {
      if (this.onPreRenderCallback != null)
        this.onPreRenderCallback$0();
    }, "call$0", "get$preRender", 0, 0, 13, "preRender"],
    render$0: [function() {
      if (this._created === true && this.onRenderCallback != null) {
        if (J.$eq(this.game.get$renderType(), 1)) {
          J.save$0$x(J.get$context$x(this.game));
          J.setTransform$6$x(J.get$context$x(this.game), 1, 0, 0, 1, 0, 0);
        }
        this.onRenderCallback$0();
        if (J.$eq(this.game.get$renderType(), 1))
          J.restore$0$x(J.get$context$x(this.game));
      } else if (this.onLoadRenderCallback != null)
        this.onLoadRenderCallback$0();
    }, "call$0", "get$render", 0, 0, 13, "render"],
    destroy$0: [function() {
      this.onInitCallback = null;
      this.onShutDownCallback = null;
      this.onPreloadCallback = null;
      this.onLoadRenderCallback = null;
      this.onLoadUpdateCallback = null;
      this.onCreateCallback = null;
      this.onUpdateCallback = null;
      this.onRenderCallback = null;
      this.onPausedCallback = null;
      this.onResumedCallback = null;
      this.onPauseUpdateCallback = null;
      this.game = null;
      this.states = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._pendingState = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    StateManager$2: function(game, pendingState) {
      this.states = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._pendingState = pendingState;
      this._clearWorld = false;
      this._clearCache = false;
      this._created = false;
      this._args = [];
      this.current = null;
      this.onInitCallback = null;
      this.onPreloadCallback = null;
      this.onCreateCallback = null;
      this.onUpdateCallback = null;
      this.onRenderCallback = null;
      this.onPreRenderCallback = null;
      this.onLoadUpdateCallback = null;
      this.onLoadRenderCallback = null;
      this.onPausedCallback = null;
      this.onResumedCallback = null;
      this.onPauseUpdateCallback = null;
      this.onShutDownCallback = null;
    },
    static: {StateManager$: [function(game, pendingState) {
        var t1 = new R.StateManager(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.StateManager$2(game, pendingState);
        return t1;
      }, null, null, 2, 2, 265, 32, 214, [], 266, [], "new StateManager"]}
  },
  "+StateManager": [632],
  World: {
    "^": "Group;game:Phaser$World$game@-598,bounds@-974,camera@-1012,game-598,name-639,addToStage-602,enableBody-602,physicsBodyType-601,z-599,type-599,alive-602,exists-602,_Phaser$_dirty-602,cursor-32,cameraOffset-600,_sortProperty-639,enableBodyDebug-602,_cache-720,creator-281,renderOrderID-599,Phaser$Group$children-1017,autoCull-602,events-1018,_anchor-600,_Phaser$_currentBounds-974,Phaser$Group$position-600,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    get$width: [function(_) {
      return J.get$width$x(this.bounds);
    }, null, null, 1, 0, 604, "width"],
    set$width: [function(_, value) {
      J.set$width$x(this.bounds, value);
    }, null, null, 3, 0, 605, 100, [], "width"],
    get$height: [function(_) {
      return J.get$height$x(this.bounds);
    }, null, null, 1, 0, 604, "height"],
    set$height: [function(_, value) {
      J.set$height$x(this.bounds, value);
    }, null, null, 3, 0, 605, 100, [], "height"],
    get$centerX: [function() {
      return this.bounds.get$halfWidth();
    }, null, null, 1, 0, 604, "centerX"],
    get$centerY: [function() {
      return this.bounds.get$halfHeight();
    }, null, null, 1, 0, 604, "centerY"],
    get$randomX: [function() {
      var t1, t2;
      t1 = J.$lt$n(J.get$x$x(this.bounds), 0);
      t2 = this.Phaser$World$game;
      if (t1)
        return t2.get$rnd().integerInRange$2(J.get$x$x(this.bounds), J.$sub$n(J.get$width$x(this.bounds), J.abs$0$n(J.get$x$x(this.bounds))));
      else
        return t2.get$rnd().integerInRange$2(J.get$x$x(this.bounds), J.get$width$x(this.bounds));
    }, null, null, 1, 0, 604, "randomX"],
    get$randomY: [function() {
      var t1, t2;
      t1 = J.$lt$n(J.get$y$x(this.bounds), 0);
      t2 = this.Phaser$World$game;
      if (t1)
        return t2.get$rnd().integerInRange$2(J.get$y$x(this.bounds), J.$sub$n(J.get$height$x(this.bounds), J.abs$0$n(J.get$y$x(this.bounds))));
      else
        return t2.get$rnd().integerInRange$2(J.get$y$x(this.bounds), J.get$height$x(this.bounds));
    }, null, null, 1, 0, 604, "randomY"],
    boot$0: [function() {
      var t1, t2;
      t1 = this.Phaser$World$game;
      t2 = new R.Camera(t1, null, null, null, null, null, null, null, null, null, null, null, null);
      t2.Camera$6(t1, 0, 0, 0, J.get$width$x(t1), J.get$height$x(this.Phaser$World$game));
      this.camera = t2;
      t2.displayObject = this;
      J.set$scale$x(this.camera, this.scale);
      this.Phaser$World$game.set$camera(this.camera);
      this.Phaser$World$game.get$stage().addChild$1(this);
    }, "call$0", "get$boot", 0, 0, 13, "boot"],
    setBounds$4: [function(x, y, width, height) {
      if (J.$lt$n(width, J.get$width$x(this.Phaser$World$game)))
        width = J.get$width$x(this.Phaser$World$game);
      if (J.$lt$n(height, J.get$height$x(this.Phaser$World$game)))
        height = J.get$height$x(this.Phaser$World$game);
      this.bounds.setTo$4(x, y, width, height);
      if (this.camera.get$bounds() != null)
        this.camera.get$bounds().setTo$4(x, y, width, height);
      this.Phaser$World$game.get$physics().setBoundsToWorld$0();
    }, "call$4", "get$setBounds", 8, 0, 306, 6, [], 7, [], 10, [], 11, [], "setBounds"],
    shutdown$0: [function() {
      this.destroy$2(true, true);
    }, "call$0", "get$shutdown", 0, 0, 13, "shutdown"],
    wrap$5: [function(_, sprite, padding, useBounds, horizontal, vertical) {
      var t1;
      if (useBounds !== true) {
        t1 = horizontal === true;
        if (t1 && J.$lt$n(J.$add$ns(J.get$x$x(sprite), padding), J.get$x$x(this.bounds)))
          J.set$x$x(sprite, J.$add$ns(J.get$right$x(this.bounds), padding));
        else if (t1 && J.$gt$n(J.$sub$n(J.get$x$x(sprite), padding), J.get$right$x(this.bounds)))
          J.set$x$x(sprite, J.$sub$n(J.get$left$x(this.bounds), padding));
        t1 = vertical === true;
        if (t1 && J.$lt$n(J.$add$ns(J.get$y$x(sprite), padding), J.get$top$x(this.bounds)))
          J.set$y$x(sprite, J.$add$ns(J.get$bottom$x(this.bounds), padding));
        else if (t1 && J.$gt$n(J.$sub$n(J.get$y$x(sprite), padding), J.get$bottom$x(this.bounds)))
          J.set$y$x(sprite, J.$sub$n(J.get$top$x(this.bounds), padding));
      } else {
        sprite.getBounds$0();
        t1 = horizontal === true;
        if (t1 && J.$lt$n(J.get$right$x(sprite.get$_Phaser$_currentBounds()), J.get$x$x(this.bounds)))
          J.set$x$x(sprite, J.get$right$x(this.bounds));
        else if (t1 && J.$gt$n(J.get$x$x(sprite.get$_Phaser$_currentBounds()), J.get$right$x(this.bounds)))
          J.set$x$x(sprite, J.get$left$x(this.bounds));
        t1 = vertical === true;
        if (t1 && J.$lt$n(J.get$bottom$x(sprite.get$_Phaser$_currentBounds()), J.get$top$x(this.bounds)))
          J.set$y$x(sprite, J.get$bottom$x(this.bounds));
        else if (t1 && J.$gt$n(J.get$top$x(sprite.get$_Phaser$_currentBounds()), J.get$bottom$x(this.bounds)))
          J.set$y$x(sprite, J.get$top$x(this.bounds));
      }
    }, function($receiver, sprite) {
      return this.wrap$5($receiver, sprite, 0, false, true, true);
    }, "wrap$1", function($receiver, sprite, padding) {
      return this.wrap$5($receiver, sprite, padding, false, true, true);
    }, "wrap$2", function($receiver, sprite, padding, useBounds) {
      return this.wrap$5($receiver, sprite, padding, useBounds, true, true);
    }, "wrap$3", function($receiver, sprite, padding, useBounds, horizontal) {
      return this.wrap$5($receiver, sprite, padding, useBounds, horizontal, true);
    }, "wrap$4", "call$5", "call$1", "call$2", "call$3", "call$4", "get$wrap", 2, 8, 1069, 5, 95, 39, 39, 113, [], 1070, [], 1071, [], 1072, [], 1073, [], "wrap"],
    World$1: function(game) {
      var t1;
      this.Phaser$World$game = game;
      t1 = J.getInterceptor$x(game);
      this.bounds = new R.Rectangle1(0, 0, t1.get$width(game), t1.get$height(game), 0, 0, 0, 0);
      this.camera = null;
    },
    $asGroup: function() {
      return [null];
    },
    $asGroup: function() {
      return [null];
    },
    "<>": [],
    static: {World$: [function(game) {
        var t1, t2, t3, t4, t5, t6;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new R.Point(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new R.World(null, null, null, null, "__world", false, false, 0, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, t1, null, t2, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.Group$6(game, null, "__world", false, false, 0, null);
        t1.World$1(game);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new World"]}
  },
  "+World": [1074],
  BitmapData: {
    "^": "Object;game@-598,key*-639,width*-599,height*-599,canvas*-808,context*-850,ctx@-850,imageData@-1075,data*-715,pixels@-1076,baseTexture@-826,texture@-670,textureFrame@-939,type*-599,disableTextureUpload@-602,dirty@-602,_tempR@-599,_tempG@-599,_tempB@-599,cls@-0,update@-0",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    cls$0: function() {
      return this.cls.call$0();
    },
    update$1: function(arg0) {
      return this.update.call$1(arg0);
    },
    update$0: function() {
      return this.update.call$0();
    },
    add$1: [function(_, object) {
      var t1, i, t2;
      t1 = J.getInterceptor(object);
      if (!!t1.$isList) {
        i = 0;
        while (true) {
          t2 = t1.get$length(object);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          t1.$index(object, i).loadTexture$1(this);
          ++i;
        }
      } else
        object.loadTexture$1(this);
    }, "call$1", "get$add", 2, 0, 63, 541, [], "add"],
    load$1: [function(_, source) {
      var t1;
      if (typeof source === "string")
        source = this.game.get$cache().getImage$1(source);
      t1 = J.getInterceptor$x(source);
      this.resize$2(0, t1.get$width(source), t1.get$height(source));
      this.cls$0();
      if (!!t1.$isImage || !!t1.$isSprite0)
        this.draw$3(source, 0, 0);
      else
        this.draw$3(source, 0, 0);
      this.update$0();
    }, "call$1", "get$load", 2, 0, 63, 170, [], "load"],
    clear$0: [function(_) {
      J.clearRect$4$x(this.context, 0, 0, this.width, this.height);
      this.dirty = true;
    }, "call$0", "get$clear", 0, 0, 13, "clear"],
    fill$4: [function(_, r, g, b, a) {
      if (a == null)
        a = 1;
      J.set$fillStyle$x(this.context, "rgba(" + H.S(r) + "," + H.S(g) + "," + H.S(b) + "," + H.S(a) + ")");
      J.fillRect$4$x(this.context, 0, 0, this.width, this.height);
      this.dirty = true;
    }, function($receiver, r, g, b) {
      return this.fill$4($receiver, r, g, b, 1);
    }, "fill$3", "call$4", "call$3", "get$fill", 6, 2, 1077, 390, 302, [], 493, [], 305, [], 304, [], "fill"],
    resize$2: [function(_, width, height) {
      width = J.toInt$0$n(width);
      height = J.toInt$0$n(height);
      if (width !== this.width || height !== this.height) {
        this.width = width;
        this.height = height;
        J.set$width$x(this.canvas, width);
        J.set$height$x(this.canvas, height);
        J.set$width$x(this.baseTexture, width);
        J.set$height$x(this.baseTexture, height);
        J.set$width$x(this.textureFrame, width);
        J.set$height$x(this.textureFrame, height);
        J.set$width$x(this.texture, width);
        J.set$height$x(this.texture, height);
        this.refreshBuffer$0();
        this.dirty = true;
      }
    }, "call$2", "get$resize", 4, 0, 111, 10, [], 11, [], "resize"],
    refreshBuffer$4: [function(x, y, width, height) {
      var t1, index, i, index0, t2, t3, t4, t5;
      if (x == null)
        x = 0;
      if (y == null)
        y = 0;
      if (width == null)
        width = this.width;
      if (height == null)
        height = this.height;
      t1 = J.getImageData$4$x(this.context, x, y, width, height);
      this.imageData = t1;
      t1 = J.get$data$x(t1);
      this.data = t1;
      t1 = C.JSInt_methods._tdivFast$1(t1.length, 4);
      this.pixels = new Uint32Array(t1);
      index = 0;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.data);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        t1 = this.pixels;
        index0 = index + 1;
        t2 = J.$shl$n(J.$index$asx(this.data, i), 24);
        t3 = J.$shl$n(J.$index$asx(this.data, i + 1), 16);
        t4 = J.$shl$n(J.$index$asx(this.data, i + 2), 8);
        t5 = J.$index$asx(this.data, i + 3);
        if (typeof t5 !== "number")
          return H.iae(t5);
        J.$indexSet$ax(t1, index, t2 + t3 + t4 + t5);
        i += 4;
        index = index0;
      }
    }, function() {
      return this.refreshBuffer$4(0, 0, null, null);
    }, "refreshBuffer$0", function(x) {
      return this.refreshBuffer$4(x, 0, null, null);
    }, "refreshBuffer$1", function(x, y) {
      return this.refreshBuffer$4(x, y, null, null);
    }, "refreshBuffer$2", function(x, y, width) {
      return this.refreshBuffer$4(x, y, width, null);
    }, "refreshBuffer$3", "call$4", "call$0", "call$1", "call$2", "call$3", "get$refreshBuffer", 0, 8, 1078, 5, 5, 32, 32, 6, [], 7, [], 10, [], 11, [], "refreshBuffer"],
    processPixelRGB$5: [function(callback, x, y, width, height) {
      var w, h, pixel, result, ty, dirty, t1, tx, t2, t3;
      if (x == null)
        x = 0;
      if (y == null)
        y = 0;
      if (width == null)
        width = this.width;
      if (height == null)
        height = this.height;
      w = J.$add$ns(x, width);
      h = J.$add$ns(y, height);
      pixel = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
      result = P.LinkedHashMap_LinkedHashMap$_literal(["r", 0, "g", 0, "b", 0, "a", 0], null, null);
      for (ty = y, dirty = false; t1 = J.getInterceptor$n(ty), t1.$lt(ty, h); ty = t1.$add(ty, 1))
        for (tx = x; t2 = J.getInterceptor$n(tx), t2.$lt(tx, w); tx = t2.$add(tx, 1)) {
          R.Color_unpackPixel(this.getPixel32$2(tx, ty), pixel, false, false);
          result = callback.call$3(pixel, tx, ty);
          t3 = J.getInterceptor(result);
          if (!t3.$eq(result, false) && result != null) {
            this.setPixel32$7(tx, ty, t3.$index(result, "r"), t3.$index(result, "g"), t3.$index(result, "b"), t3.$index(result, "a"), false);
            dirty = true;
          }
        }
      if (dirty) {
        J.putImageData$3$x(this.context, this.imageData, 0, 0);
        this.dirty = true;
      }
    }, function(callback) {
      return this.processPixelRGB$5(callback, 0, 0, null, null);
    }, "processPixelRGB$1", function(callback, x) {
      return this.processPixelRGB$5(callback, x, 0, null, null);
    }, "processPixelRGB$2", function(callback, x, y) {
      return this.processPixelRGB$5(callback, x, y, null, null);
    }, "processPixelRGB$3", function(callback, x, y, width) {
      return this.processPixelRGB$5(callback, x, y, width, null);
    }, "processPixelRGB$4", "call$5", "call$1", "call$2", "call$3", "call$4", "get$processPixelRGB", 2, 8, 1079, 5, 5, 32, 32, 272, [], 6, [], 7, [], 10, [], 11, [], "processPixelRGB"],
    processPixel$5: [function(callback, x, y, width, height) {
      var w, h, ty, pixel, result, dirty, t1, tx, t2;
      if (x == null)
        x = 0;
      if (y == null)
        y = 0;
      if (width == null)
        width = this.width;
      if (height == null)
        height = this.height;
      w = J.$add$ns(x, width);
      h = J.$add$ns(y, height);
      for (ty = y, pixel = 0, result = 0, dirty = false; t1 = J.getInterceptor$n(ty), t1.$lt(ty, h); ty = t1.$add(ty, 1))
        for (tx = x; t2 = J.getInterceptor$n(tx), t2.$lt(tx, w); tx = t2.$add(tx, 1)) {
          pixel = this.getPixel32$2(tx, ty);
          result = callback.call$3(pixel, tx, ty);
          if (!J.$eq(result, pixel)) {
            J.$indexSet$ax(this.pixels, J.$add$ns(t1.$mul(ty, this.width), tx), result);
            dirty = true;
          }
        }
      if (dirty) {
        J.putImageData$3$x(this.context, this.imageData, 0, 0);
        this.dirty = true;
      }
    }, "call$5", "get$processPixel", 10, 0, 1080, 272, [], 6, [], 7, [], 10, [], 11, [], "processPixel"],
    replaceRGB$9: [function(r1, g1, b1, a1, r2, g2, b2, a2, region) {
      var w, h, source, t1, sx, sy, t2, y, x;
      w = this.width;
      h = this.height;
      source = R.Color_packPixel(r1, g1, b1, a1);
      if (region != null && !!J.getInterceptor(region).$isRectangle1) {
        t1 = J.getInterceptor$x(region);
        sx = t1.get$x(region);
        sy = t1.get$y(region);
        w = t1.get$width(region);
        h = t1.get$height(region);
      } else {
        sx = 0;
        sy = 0;
      }
      if (typeof h !== "number")
        return H.iae(h);
      t1 = J.getInterceptor$ns(sx);
      t2 = J.getInterceptor$ns(sy);
      y = 0;
      for (; y < h; ++y) {
        if (typeof w !== "number")
          return H.iae(w);
        x = 0;
        for (; x < w; ++x)
          if (J.$eq(this.getPixel32$2(t1.$add(sx, x), t2.$add(sy, y)), source))
            this.setPixel32$7(t1.$add(sx, x), t2.$add(sy, y), r2, g2, b2, a2, false);
      }
      J.putImageData$3$x(this.context, this.imageData, 0, 0);
      this.dirty = true;
    }, function(r1, g1, b1, a1, r2, g2, b2, a2) {
      return this.replaceRGB$9(r1, g1, b1, a1, r2, g2, b2, a2, null);
    }, "replaceRGB$8", "call$9", "call$8", "get$replaceRGB", 16, 2, 1081, 32, 527, [], 528, [], 404, [], 402, [], 529, [], 530, [], 405, [], 403, [], 1082, [], "replaceRGB"],
    setHSL$4: [function(h, s, l, region) {
      var t1, pixel, t2, y, t3, t4, t5, x, t6;
      t1 = h == null;
      if (t1 && s == null && l == null)
        return;
      if (region == null)
        region = new R.Rectangle1(0, 0, this.width, this.height, 0, 0, 0, 0);
      pixel = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
      for (t2 = J.getInterceptor$x(region), y = t2.get$y(region), t3 = l != null, t4 = s != null, t1 = !t1; t5 = J.getInterceptor$n(y), t5.$lt(y, t2.get$bottom(region)); y = t5.$add(y, 1))
        for (x = t2.get$x(region); t6 = J.getInterceptor$n(x), t6.$lt(x, t2.get$right(region)); x = t6.$add(x, 1)) {
          R.Color_unpackPixel(this.getPixel32$2(x, y), pixel, true, false);
          if (t1)
            pixel.h = h;
          if (t4)
            pixel.s = s;
          if (t3)
            pixel.l = l;
          R.Color_HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel);
          this.setPixel32$7(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false);
        }
      J.putImageData$3$x(this.context, this.imageData, 0, 0);
      this.dirty = true;
    }, function() {
      return this.setHSL$4(null, null, null, null);
    }, "setHSL$0", function(h) {
      return this.setHSL$4(h, null, null, null);
    }, "setHSL$1", function(h, s) {
      return this.setHSL$4(h, s, null, null);
    }, "setHSL$2", function(h, s, l) {
      return this.setHSL$4(h, s, l, null);
    }, "setHSL$3", "call$4", "call$0", "call$1", "call$2", "call$3", "get$setHSL", 0, 8, 1083, 32, 32, 32, 32, 501, [], 502, [], 503, [], 1082, [], "setHSL"],
    shiftHSL$4: [function(h, s, l, region) {
      var t1, pixel, t2, y, t3, t4, t5, x, t6, t7, t8;
      t1 = h == null;
      if (t1 && s == null && l == null)
        return;
      if (region == null)
        region = new R.Rectangle1(0, 0, this.width, this.height, 0, 0, 0, 0);
      pixel = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
      for (t2 = J.getInterceptor$x(region), y = t2.get$y(region), t3 = l != null, t4 = s != null, t1 = !t1; t5 = J.getInterceptor$n(y), t5.$lt(y, t2.get$bottom(region)); y = t5.$add(y, 1))
        for (x = t2.get$x(region); t6 = J.getInterceptor$n(x), t6.$lt(x, t2.get$right(region)); x = t6.$add(x, 1)) {
          R.Color_unpackPixel(this.getPixel32$2(x, y), pixel, true, false);
          if (t1)
            pixel.h = R.Math_wrap(J.$add$ns(pixel.h, h), 0, 1);
          if (t4) {
            t7 = J.$add$ns(pixel.s, s);
            t8 = J.getInterceptor$n(t7);
            if (t8.$lt(t7, 0))
              t7 = 0;
            else if (t8.$gt(t7, 1))
              t7 = 1;
            pixel.s = t7;
          }
          if (t3) {
            t7 = J.$add$ns(pixel.l, l);
            t8 = J.getInterceptor$n(t7);
            if (t8.$lt(t7, 0))
              t7 = 0;
            else if (t8.$gt(t7, 1))
              t7 = 1;
            pixel.l = t7;
          }
          R.Color_HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel);
          this.setPixel32$7(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false);
        }
      J.putImageData$3$x(this.context, this.imageData, 0, 0);
      this.dirty = true;
    }, function() {
      return this.shiftHSL$4(null, null, null, null);
    }, "shiftHSL$0", function(h) {
      return this.shiftHSL$4(h, null, null, null);
    }, "shiftHSL$1", function(h, s) {
      return this.shiftHSL$4(h, s, null, null);
    }, "shiftHSL$2", function(h, s, l) {
      return this.shiftHSL$4(h, s, l, null);
    }, "shiftHSL$3", "call$4", "call$0", "call$1", "call$2", "call$3", "get$shiftHSL", 0, 8, 1083, 32, 32, 32, 32, 501, [], 502, [], 503, [], 1082, [], "shiftHSL"],
    setPixel32$7: [function(x, y, red, green, blue, alpha, immediate) {
      var t1, index, t2, t3, t4, i, i0;
      t1 = J.getInterceptor$ns(y);
      index = J.$add$ns(t1.$mul(y, this.width), x);
      t2 = J.getInterceptor$n(x);
      if (t2.$ge(x, 0) && t2.$le(x, this.width) && t1.$ge(y, 0) && t1.$le(y, this.height)) {
        t1 = $.Device_LITTLE_ENDIAN;
        t2 = J.getInterceptor$n(blue);
        t3 = this.pixels;
        t4 = J.getInterceptor$n(green);
        if (t1 === true) {
          t1 = J.$shl$n(alpha, 24);
          t2 = t2.$shl(blue, 16);
          t4 = t4.$shl(green, 8);
          if (typeof red !== "number")
            return H.iae(red);
          J.$indexSet$ax(t3, index, (t1 | t2 | t4 | red) >>> 0);
        } else {
          t1 = J.$shl$n(red, 24);
          t4 = t4.$shl(green, 16);
          t2 = t2.$shl(blue, 8);
          if (typeof alpha !== "number")
            return H.iae(alpha);
          J.$indexSet$ax(t3, index, (t1 | t4 | t2 | alpha) >>> 0);
        }
        i = J.$mul$ns(index, 4);
        t1 = J.get$data$x(this.imageData);
        i0 = J.$add$ns(i, 1);
        J.$indexSet$ax(t1, i, red);
        t1 = J.get$data$x(this.imageData);
        i = J.$add$ns(i0, 1);
        J.$indexSet$ax(t1, i0, green);
        t1 = J.get$data$x(this.imageData);
        i0 = J.$add$ns(i, 1);
        J.$indexSet$ax(t1, i, blue);
        J.$indexSet$ax(J.get$data$x(this.imageData), i0, alpha);
        if (immediate === true) {
          J.putImageData$3$x(this.context, this.imageData, 0, 0);
          this.dirty = true;
        }
      }
    }, function(x, y, red, green, blue, alpha) {
      return this.setPixel32$7(x, y, red, green, blue, alpha, true);
    }, "setPixel32$6", "call$7", "call$6", "get$setPixel32", 12, 2, 1084, 39, 6, [], 7, [], 1085, [], 1086, [], 1087, [], 524, [], 1088, [], "setPixel32"],
    setPixel$6: [function(x, y, red, green, blue, immediate) {
      this.setPixel32$7(x, y, red, green, blue, 255, immediate);
    }, function(x, y, red, green, blue) {
      return this.setPixel$6(x, y, red, green, blue, true);
    }, "setPixel$5", "call$6", "call$5", "get$setPixel", 10, 2, 1089, 39, 6, [], 7, [], 1085, [], 1086, [], 1087, [], 1088, [], "setPixel"],
    getPixel$3: [function(x, y, out) {
      var index, t1;
      if (out == null)
        out = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
      index = (~J.$not$i(J.$add$ns(x, J.$mul$ns(y, this.width))) >>> 0) * 4;
      t1 = J.getInterceptor$x(out);
      t1.set$r(out, J.$index$asx(this.data, index));
      ++index;
      out.set$g(J.$index$asx(this.data, index));
      ++index;
      out.set$b(J.$index$asx(this.data, index));
      t1.set$a(out, J.$index$asx(this.data, index + 1));
      return out;
    }, "call$3", "get$getPixel", 6, 0, 1090, 6, [], 7, [], 317, [], "getPixel"],
    getPixel32$2: [function(x, y) {
      var t1 = J.getInterceptor$n(x);
      if (t1.$ge(x, 0))
        if (t1.$le(x, this.width)) {
          t1 = J.getInterceptor$n(y);
          t1 = t1.$ge(y, 0) && t1.$le(y, this.height);
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        return J.$index$asx(this.pixels, J.$add$ns(J.$mul$ns(y, this.width), x));
      return;
    }, "call$2", "get$getPixel32", 4, 0, 1091, 6, [], 7, [], "getPixel32"],
    getPixelRGB$5: [function(x, y, out, hsl, hsv) {
      return R.Color_unpackPixel(this.getPixel32$2(x, y), out, hsl, hsv);
    }, function(x, y) {
      return this.getPixelRGB$5(x, y, null, false, false);
    }, "getPixelRGB$2", function(x, y, out) {
      return this.getPixelRGB$5(x, y, out, false, false);
    }, "getPixelRGB$3", function(x, y, out, hsl) {
      return this.getPixelRGB$5(x, y, out, hsl, false);
    }, "getPixelRGB$4", "call$5", "call$2", "call$3", "call$4", "get$getPixelRGB", 4, 6, 1092, 32, 95, 95, 6, [], 7, [], 317, [], 496, [], 497, [], "getPixelRGB"],
    getPixels$1: [function(rect) {
      var t1 = J.getInterceptor$x(rect);
      return J.getImageData$4$x(this.context, t1.get$x(rect), t1.get$y(rect), t1.get$width(rect), t1.get$height(rect));
    }, "call$1", "get$getPixels", 2, 0, 1093, 1094, [], "getPixels"],
    addToWorld$2: [function(x, y) {
      return J.get$add$ax(this.game).image$3(x, y, this);
    }, function() {
      return this.addToWorld$2(0, 0);
    }, "addToWorld$0", function(x) {
      return this.addToWorld$2(x, 0);
    }, "addToWorld$1", "call$2", "call$0", "call$1", "get$addToWorld", 0, 4, 1095, 5, 5, 6, [], 7, [], "addToWorld"],
    copyPixels$4: [function(source, area, x, y) {
      var t1, src, frame, sx, sy;
      if (typeof source === "string")
        source = this.game.get$cache().getImage$1(source);
      t1 = J.getInterceptor(source);
      if (!!t1.$isImage || !!t1.$isSprite0) {
        src = J.get$source$x(source.get$texture().get$baseTexture());
        frame = source.get$texture().get$frame();
        t1 = J.getInterceptor$x(frame);
        sx = t1.get$x(frame);
        sy = t1.get$y(frame);
      } else {
        src = !!t1.$isBitmapData ? source.canvas : source;
        sx = 0;
        sy = 0;
      }
      t1 = J.getInterceptor$x(area);
      J.drawImageScaledFromSource$9$x(this.context, src, J.$add$ns(sx, t1.get$x(area)), J.$add$ns(sy, t1.get$y(area)), t1.get$width(area), t1.get$height(area), x, y, t1.get$width(area), t1.get$height(area));
      this.dirty = true;
    }, "call$4", "get$copyPixels", 8, 0, 1096, 170, [], 1097, [], 6, [], 7, [], "copyPixels"],
    draw$5: [function(source, x, y, width, height) {
      var t1, src, frame, sx, sy, sw, sh;
      if (x == null)
        x = 0;
      if (y == null)
        y = 0;
      if (typeof source === "string")
        source = this.game.get$cache().getImage$1(source);
      t1 = J.getInterceptor(source);
      if (!!t1.$isImage || !!t1.$isSprite0) {
        src = J.get$source$x(source.get$texture().get$baseTexture());
        frame = source.get$texture().get$frame();
        t1 = J.getInterceptor$x(frame);
        sx = t1.get$x(frame);
        sy = t1.get$y(frame);
        sw = t1.get$width(frame);
        sh = t1.get$height(frame);
      } else {
        src = !!t1.$isBitmapData ? source.canvas : source;
        sw = t1.get$width(source);
        sh = t1.get$height(source);
        sx = 0;
        sy = 0;
      }
      if (width == null)
        width = sw;
      if (height == null)
        height = sh;
      J.drawImageScaledFromSource$9$x(this.context, src, sx, sy, sw, sh, x, y, width, height);
      this.dirty = true;
    }, function(source, x, y) {
      return this.draw$5(source, x, y, null, null);
    }, "draw$3", function(source, x, y, width) {
      return this.draw$5(source, x, y, width, null);
    }, "draw$4", function(source) {
      return this.draw$5(source, 0, 0, null, null);
    }, "draw$1", function(source, x) {
      return this.draw$5(source, x, 0, null, null);
    }, "draw$2", "call$5", "call$3", "call$4", "call$1", "call$2", "get$draw", 2, 8, 1098, 5, 5, 32, 32, 170, [], 6, [], 7, [], 10, [], 11, [], "draw"],
    drawSprite$3: [function(sprite, x, y) {
      if (x == null)
        x = 0;
      this.draw$3(sprite, x, y == null ? 0 : y);
    }, function(sprite) {
      return this.drawSprite$3(sprite, null, null);
    }, "drawSprite$1", function(sprite, x) {
      return this.drawSprite$3(sprite, x, null);
    }, "drawSprite$2", "call$3", "call$1", "call$2", "get$drawSprite", 2, 4, 1099, 32, 32, 113, [], 6, [], 7, [], "drawSprite"],
    alphaMask$4: [function(source, mask, sourceRect, maskRect) {
      var temp, t1;
      if (mask == null)
        mask = this;
      temp = J.get$globalCompositeOperation$x(this.context);
      if (maskRect == null || false)
        this.draw$1(mask);
      else {
        t1 = J.getInterceptor$x(maskRect);
        this.draw$5(mask, t1.get$x(maskRect), t1.get$y(maskRect), t1.get$width(maskRect), t1.get$height(maskRect));
      }
      J.set$globalCompositeOperation$x(this.context, "source-atop");
      if (sourceRect == null || false)
        this.draw$1(source);
      else {
        t1 = J.getInterceptor$x(sourceRect);
        this.draw$5(source, t1.get$x(sourceRect), t1.get$y(sourceRect), t1.get$width(sourceRect), t1.get$height(sourceRect));
      }
      J.set$globalCompositeOperation$x(this.context, temp);
      this.update$0();
      this.dirty = true;
    }, function(source, mask) {
      return this.alphaMask$4(source, mask, null, null);
    }, "alphaMask$2", function(source, mask, sourceRect) {
      return this.alphaMask$4(source, mask, sourceRect, null);
    }, "alphaMask$3", "call$4", "call$2", "call$3", "get$alphaMask", 4, 4, 1100, 32, 32, 170, [], 1101, [], 1102, [], 1103, [], "alphaMask"],
    extract$9: [function(destination, r, g, b, a, resize, r2, g2, b2) {
      var t1 = {};
      t1.a_0 = a;
      t1.r2_1 = r2;
      t1.g2_2 = g2;
      t1.b2_3 = b2;
      if (a == null)
        t1.a_0 = 255;
      if (resize == null)
        resize = false;
      if (r2 == null)
        t1.r2_1 = r;
      if (g2 == null)
        t1.g2_2 = g;
      if (b2 == null)
        t1.b2_3 = b;
      if (resize === true)
        J.resize$2$x(destination, this.width, this.height);
      this.processPixelRGB$1(new R.BitmapData_extract_closure(t1, destination, r, g, b));
      J.putImageData$3$x(J.get$context$x(destination), destination.get$imageData(), 0, 0);
      destination.set$dirty(true);
      return destination;
    }, function(destination, r, g, b) {
      return this.extract$9(destination, r, g, b, 255, null, null, null, null);
    }, "extract$4", function(destination, r, g, b, a, resize) {
      return this.extract$9(destination, r, g, b, a, resize, null, null, null);
    }, "extract$6", function(destination, r, g, b, a) {
      return this.extract$9(destination, r, g, b, a, null, null, null, null);
    }, "extract$5", function(destination, r, g, b, a, resize, r2) {
      return this.extract$9(destination, r, g, b, a, resize, r2, null, null);
    }, "extract$7", function(destination, r, g, b, a, resize, r2, g2) {
      return this.extract$9(destination, r, g, b, a, resize, r2, g2, null);
    }, "extract$8", "call$9", "call$4", "call$6", "call$5", "call$7", "call$8", "get$extract", 8, 10, 1104, 508, 32, 32, 32, 32, 1105, [], 302, [], 493, [], 305, [], 304, [], 1106, [], 529, [], 530, [], 405, [], "extract"],
    rect$5: [function(_, x, y, width, height, fillStyle) {
      if (fillStyle != null)
        J.set$fillStyle$x(this.context, fillStyle);
      J.fillRect$4$x(this.context, x, y, width, height);
    }, function($receiver, x, y, width, height) {
      return this.rect$5($receiver, x, y, width, height, null);
    }, "rect$4", "call$5", "call$4", "get$rect", 8, 2, 1107, 32, 6, [], 7, [], 10, [], 11, [], 1108, [], "rect"],
    circle$4: [function(x, y, radius, fillStyle) {
      if (fillStyle != null)
        J.set$fillStyle$x(this.context, fillStyle);
      J.beginPath$0$x(this.context);
      J.arc$6$x(this.context, x, y, radius, 0, 6.283185307179586, false);
      J.closePath$0$x(this.context);
      J.fill$0$x(this.context);
    }, function(x, y, radius) {
      return this.circle$4(x, y, radius, null);
    }, "circle$3", "call$4", "call$3", "get$circle", 6, 2, 1109, 32, 6, [], 7, [], 8, [], 1108, [], "circle"],
    render$0: [function() {
      if (this.disableTextureUpload !== true && J.$eq(this.game.get$renderType(), 2) && this.dirty === true) {
        M.updateWebGLTexture(this.baseTexture, this.game.get$renderer().get$gl());
        this.dirty = false;
      }
    }, "call$0", "get$render", 0, 0, 13, "render"],
    BitmapData$4: function(game, key, width, height) {
      var t1, index, i, index0, t2, t3, t4, t5;
      t1 = R.Canvas_create(this.width, this.height, "", true);
      this.canvas = t1;
      t1 = J.getContext$1$x(t1, "2d");
      this.context = t1;
      this.ctx = t1;
      t1 = J.getImageData$4$x(t1, 0, 0, this.width, this.height);
      this.imageData = t1;
      this.data = J.get$data$x(t1);
      this.pixels = null;
      t1 = J.$tdiv$n(J.get$length$asx(J.get$data$x(this.imageData)), 4);
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.pixels = new Uint32Array(t1);
      index = 0;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(J.get$data$x(this.imageData));
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        t1 = this.pixels;
        index0 = index + 1;
        t2 = J.$shl$n(J.$index$asx(J.get$data$x(this.imageData), i), 24);
        t3 = J.$shl$n(J.$index$asx(J.get$data$x(this.imageData), i + 1), 16);
        t4 = J.$shl$n(J.$index$asx(J.get$data$x(this.imageData), i + 2), 8);
        t5 = J.$index$asx(J.get$data$x(this.imageData), i + 3);
        if (typeof t5 !== "number")
          return H.iae(t5);
        J.$indexSet$ax(t1, index, t2 + t3 + t4 + t5);
        i += 4;
        index = index0;
      }
      t1 = M.BaseTexture$(this.canvas, C.scaleModes_0);
      this.baseTexture = t1;
      this.texture = M.Texture$(t1, null);
      t1 = R.Frame$(0, 0, 0, this.width, this.height, "bitmapData", this.game.get$rnd().uuid$0());
      this.textureFrame = t1;
      this.texture.set$frame(t1);
      this.type = 13;
      this.disableTextureUpload = false;
      this.dirty = false;
      this.cls = this.get$clear(this);
      this.update = this.get$refreshBuffer();
      this._tempR = 0;
      this._tempG = 0;
      this._tempB = 0;
    },
    $isBitmapData: true,
    static: {BitmapData$: [function(game, key, width, height) {
        var t1 = new R.BitmapData(game, key, width, height, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.BitmapData$4(game, key, width, height);
        return t1;
      }, null, null, 8, 0, 267, 214, [], 231, [], 10, [], 11, [], "new BitmapData"]}
  },
  "+BitmapData": [632],
  BitmapData_extract_closure: {
    "^": "Closure:117;box_0,destination_1,r_2,g_3,b_4",
    call$3: [function(pixel, x, y) {
      var t1;
      if (J.$eq(J.get$r$x(pixel), this.r_2) && J.$eq(pixel.get$g(), this.g_3) && J.$eq(pixel.get$b(), this.b_4)) {
        t1 = this.box_0;
        this.destination_1.setPixel32$7(x, y, t1.r2_1, t1.g2_2, t1.b2_3, t1.a_0, false);
      }
      return false;
    }, "call$3", null, 6, 0, 117, 1110, [], 6, [], 7, [], "call"],
    $isFunction: true
  },
  BitmapText0: {
    "^": "BitmapText;game@-598,exists@-602,name*-639,type*-599,z*-599,world@-600,_text@-639,_font@-639,_fontSize@-599,_align@-639,_tint@-599,_Phaser$_dirty@-602,events@-1018,input@-1111,cameraOffset@-600,_cache@-720,renderOrderID@-599,autoCull@-602,alive@-602,anchor@-600,children:Phaser$BitmapText0$children*-1058,_Phaser$_currentBounds@-974,text-639,_style-910,_pool-720,PIXI$BitmapText$_dirty-602,tint-599,fontName-639,fontSize-601,_textWidth-601,_textHeight-601,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    get$x: [function(_) {
      return J.get$x$x(this.position);
    }, null, null, 1, 0, 604, "x"],
    set$x: [function(_, value) {
      J.set$x$x(this.position, value);
    }, null, null, 3, 0, 605, 100, [], "x"],
    get$y: [function(_) {
      return J.get$y$x(this.position);
    }, null, null, 1, 0, 604, "y"],
    set$y: [function(_, value) {
      J.set$y$x(this.position, value);
    }, null, null, 3, 0, 605, 100, [], "y"],
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(J.get$x$x(this.position), J.$div$n(J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.getLocalBounds$0())), 2));
      t2 = J.$add$ns(J.get$y$x(this.position), J.$div$n(J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.getLocalBounds$0())), 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1019, "center"],
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 281, "parent"],
    bringToTop$1: [function(child) {
      if (child == null) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
        return this;
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$BitmapText0$children, child), J.get$length$asx(this.Phaser$BitmapText0$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$BitmapText0$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$BitmapText0$children));
        }
        return this;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1059, 32, 659, [], "bringToTop"],
    get$align: [function() {
      return this._align;
    }, null, null, 1, 0, 782, "align"],
    set$align: [function(value) {
      if (!J.$eq(value, this._align)) {
        this._align = value;
        this.setStyle$0();
      }
    }, null, null, 3, 0, 52, 100, [], "align"],
    get$tint: [function() {
      return this._tint;
    }, null, null, 1, 0, 604, "tint"],
    set$tint: [function(value) {
      if (!J.$eq(value, this._tint)) {
        this._tint = value;
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 605, 100, [], "tint"],
    get$angle: [function() {
      return J.$mul$ns(this.rotation, 57.29577951308232);
    }, null, null, 1, 0, 604, "angle"],
    angle$0: function() {
      return this.get$angle().call$0();
    },
    angle$2: function(arg0, arg1) {
      return this.get$angle().call$2(arg0, arg1);
    },
    set$angle: [function(value) {
      this.rotation = J.$mul$ns(value, 0.017453292519943295);
    }, null, null, 3, 0, 605, 100, [], "angle"],
    get$font: [function(_) {
      return this._font;
    }, null, null, 1, 0, 782, "font"],
    set$font: [function(_, value) {
      var t1 = J.getInterceptor(value);
      if (!t1.$eq(value, this._font)) {
        this._font = t1.trim$0(value);
        J.set$font$x(this._style, J.$add$ns(J.$add$ns(J.$add$ns(J.toString$0(this._fontSize), "px '"), this._font), "'"));
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 52, 100, [], "font"],
    get$fontSize: [function(_) {
      return this._fontSize;
    }, null, null, 1, 0, 367, "fontSize"],
    set$fontSize: [function(_, value) {
      if (!J.$eq(value, this._fontSize)) {
        this._fontSize = value;
        J.set$font$x(this._style, J.$add$ns(J.$add$ns(J.$add$ns(J.toString$0(value), "px '"), J.toString$0(this._font)), "'"));
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 60, 100, [], "fontSize"],
    get$text: [function(_) {
      return this._text;
    }, null, null, 1, 0, 782, "text"],
    text$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.get$text(this).call$4(arg0, arg1, arg2, arg3);
    },
    text$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.get$text(this).call$5(arg0, arg1, arg2, arg3, arg4);
    },
    text$3: function($receiver, arg0, arg1, arg2) {
      return this.get$text(this).call$3(arg0, arg1, arg2);
    },
    set$text: [function(_, value) {
      if (!J.$eq(value, this._text)) {
        this._text = value;
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 52, 100, [], "text"],
    get$inputEnabled: [function() {
      var t1 = this.input;
      return t1 != null && t1.get$enabled() === true;
    }, null, null, 1, 0, 209, "inputEnabled"],
    set$inputEnabled: [function(value) {
      var t1;
      if (value === true) {
        t1 = this.input;
        if (t1 == null) {
          t1 = R.InputHandler$(this);
          this.input = t1;
          t1.start$0(0);
        } else if (t1.get$enabled() !== true)
          J.start$0$x(this.input);
      } else {
        t1 = this.input;
        if (t1 != null && t1.get$enabled() === true)
          J.stop$0$x(this.input);
      }
    }, null, null, 3, 0, 650, 100, [], "inputEnabled"],
    get$fixedToCamera: [function() {
      return J.$eq(J.$index$asx(this._cache, 7), 1);
    }, null, null, 1, 0, 209, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.cameraOffset.set$2(J.get$x$x(this.position), J.get$y$x(this.position));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 650, 100, [], "fixedToCamera"],
    get$destroyPhase: [function() {
      return J.$eq(J.$index$asx(this._cache, 8), 1);
    }, null, null, 1, 0, 209, "destroyPhase"],
    setStyle$1: [function(style) {
      M.BitmapText.prototype.setStyle$1.call(this, style);
      this._style.set$align(this._align);
      this._font = this.fontName;
      this._fontSize = this._fontSize;
    }, function() {
      return this.setStyle$1(null);
    }, "setStyle$0", "call$1", "call$0", "get$setStyle", 0, 2, 1112, 32, 156, [], "setStyle"],
    preUpdate$0: [function() {
      var t1, t2, t3;
      J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
      J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
      J.$indexSet$ax(this._cache, 2, this.rotation);
      if (this.exists !== true || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        this.renderOrderID = -1;
        return false;
      }
      if (J.$eq(this.autoCull, true))
        this.renderable = J.intersects$1$x(this.game.get$world().get$camera().get$screenView(), this.getBounds$0());
      this.world.setTo$2(J.$add$ns(J.get$x$x(this.game.get$camera()), J.$index$asx(this._worldTransform, 2)), J.$add$ns(J.get$y$x(this.game.get$camera()), J.$index$asx(this._worldTransform, 5)));
      if (this.visible === true) {
        t1 = this._cache;
        t2 = this.game.get$stage();
        t3 = t2.get$currentRenderOrderID();
        t2.set$currentRenderOrderID(J.$add$ns(t3, 1));
        J.$indexSet$ax(t1, 3, t3);
      }
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 13, "update"],
    postUpdate$0: [function() {
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.position, J.$div$n(J.$add$ns(J.get$x$x(J.get$view$x(this.game.get$camera())), J.get$x$x(this.cameraOffset)), J.get$x$x(J.get$scale$x(this.game.get$camera()))));
        J.set$y$x(this.position, J.$div$n(J.$add$ns(J.get$y$x(J.get$view$x(this.game.get$camera())), J.get$y$x(this.cameraOffset)), J.get$y$x(J.get$scale$x(this.game.get$camera()))));
      }
    }, "call$0", "get$postUpdate", 0, 0, 13, "postUpdate"],
    destroy$1: [function(destroyChildren) {
      var i, t1, i0;
      if (this.game == null || J.$eq(J.$index$asx(this._cache, 8), 1))
        return;
      if (destroyChildren == null)
        destroyChildren = true;
      J.$indexSet$ax(this._cache, 8, 1);
      if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
        if (!!J.getInterceptor(M.DisplayObject.prototype.get$parent.call(this, this)).$isGroup)
          H.interceptedTypeCast(M.DisplayObject.prototype.get$parent.call(this, this), "$isGroup").remove$1(0, this);
        else
          M.DisplayObject.prototype.get$parent.call(this, this).removeChild$1(this);
      i = J.get$length$asx(this.Phaser$BitmapText0$children);
      if (destroyChildren === true) {
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          if (!!J.getInterceptor(J.$index$asx(this.Phaser$BitmapText0$children, i0)).$isGameObject)
            J.$index$asx(this.Phaser$BitmapText0$children, i0).destroy$1(destroyChildren);
      } else
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0) {
          t1 = J.$index$asx(this.Phaser$BitmapText0$children, i0);
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$BitmapText0$children, t1));
        }
      this.exists = false;
      this.visible = false;
      this.set$filters(null);
      this.set$mask(0, null);
      this.game = null;
      J.$indexSet$ax(this._cache, 8, 0);
    }, "call$1", "get$destroy", 2, 0, 63, 1039, [], "destroy"],
    BitmapText$6: function(game, x, y, font, text, size) {
      var t1;
      this.game = game;
      this.exists = true;
      this.name = "";
      this.type = 6;
      this.z = 0;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.world = t1;
      this._text = text;
      this._align = "left";
      this._tint = 16777215;
      this.events = R.Events$(this);
      this.input = null;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.cameraOffset = t1;
      this.position.set$2(x, y);
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
    },
    $isGameObject: true,
    static: {BitmapText$: [function(game, x, y, font, text, size) {
        var t1, t2, t3, t4, t5;
        t1 = M.TextStyle$0("left", "black", "bold 20pt Arial", "black", 0, 16777215);
        t1.font = font;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 1;
        t3.y = 1;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t2 = new R.BitmapText0(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, null, null, null, 16777215, null, null, null, null, [], false, 0, 0, t2, t3, t4, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t5, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t2.BitmapText$2(text, t1);
        t2.BitmapText$6(game, x, y, font, text, size);
        return t2;
      }, null, null, 2, 10, 268, 32, 32, 32, 221, 269, 214, [], 6, [], 7, [], 163, [], 85, [], 270, [], "new BitmapText"]}
  },
  "+BitmapText": [1113, 2],
  Button: {
    "^": "Image;_onOverFrameName@-639,_onOutFrameName@-639,_onDownFrameName@-639,_onUpFrameName@-639,_onOverFrameID@-599,_onOutFrameID@-599,_onDownFrameID@-599,_onUpFrameID@-599,onOverMouseOnly@-602,onOverSound@-1114,onOutSound@-1114,onDownSound@-1114,onUpSound@-1114,onOverSoundMarker@-639,onOutSoundMarker@-639,onDownSoundMarker@-639,onUpSoundMarker@-639,onInputOver@-1115,onInputOut@-1115,onInputDown@-1115,onInputUp@-1116,freezeFrames@-602,forceOut@-602,game-598,exists-602,name-639,type-599,z-599,events-1018,key-32,world-600,autoCull-602,input-1111,body-1117,cameraOffset-600,Phaser$Image$anchor-600,cropRect-974,_cache-720,_crop-974,_frame-599,_Phaser$_bounds-974,_Phaser$_dirty-602,_frameName-639,alive-602,Phaser$Image$children-1058,_Phaser$_currentBounds-974,anchor-634,texture-670,updateFrame-602,PIXI$Sprite$_width-601,PIXI$Sprite$_height-601,_uvs-671,tintedTexture-672,buffer-673,tint-599,cachedTint-599,blendMode-674,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    clearFrames$0: [function() {
      this._onOverFrameName = null;
      this._onOverFrameID = null;
      this._onOutFrameName = null;
      this._onOutFrameID = null;
      this._onDownFrameName = null;
      this._onDownFrameID = null;
      this._onUpFrameName = null;
      this._onUpFrameID = null;
    }, "call$0", "get$clearFrames", 0, 0, 13, "clearFrames"],
    setFrames$4: [function(overFrame, outFrame, downFrame, upFrame) {
      this._onOverFrameName = null;
      this._onOverFrameID = null;
      this._onOutFrameName = null;
      this._onOutFrameID = null;
      this._onDownFrameName = null;
      this._onDownFrameID = null;
      this._onUpFrameName = null;
      this._onUpFrameID = null;
      if (overFrame != null)
        if (typeof overFrame === "string") {
          this._onOverFrameName = overFrame;
          if (this.input.pointerOver$0() === true)
            this.set$frameName(overFrame);
        } else {
          this._onOverFrameID = overFrame;
          if (this.input.pointerOver$0() === true)
            this.set$frame(overFrame);
        }
      if (outFrame != null)
        if (typeof outFrame === "string") {
          this._onOutFrameName = outFrame;
          if (J.$eq(this.input.pointerOver$0(), false))
            this.set$frameName(outFrame);
        } else {
          this._onOutFrameID = outFrame;
          if (J.$eq(this.input.pointerOver$0(), false))
            this.set$frame(outFrame);
        }
      if (downFrame != null)
        if (typeof downFrame === "string") {
          this._onDownFrameName = downFrame;
          if (this.input.pointerDown$0() === true)
            this.set$frameName(downFrame);
        } else {
          this._onDownFrameID = downFrame;
          if (this.input.pointerDown$0() === true)
            this.set$frame(downFrame);
        }
      if (upFrame != null)
        if (typeof upFrame === "string") {
          this._onUpFrameName = upFrame;
          if (this.input.pointerUp$0() === true)
            this.set$frameName(upFrame);
        } else {
          this._onUpFrameID = upFrame;
          if (this.input.pointerUp$0() === true)
            this.set$frame(upFrame);
        }
    }, "call$4", "get$setFrames", 8, 0, 1118, 273, [], 274, [], 275, [], 276, [], "setFrames"],
    setSounds$8: [function(overSound, overMarker, downSound, downMarker, outSound, outMarker, upSound, upMarker) {
      this.onOverSound = overSound;
      this.onOverSoundMarker = overMarker;
      this.onOutSound = outSound;
      this.onOutSoundMarker = outMarker;
      this.onDownSound = downSound;
      this.onDownSoundMarker = downMarker;
      this.onUpSound = upSound;
      this.onUpSoundMarker = upMarker;
    }, function() {
      return this.setSounds$8(null, null, null, null, null, null, null, null);
    }, "setSounds$0", function(overSound) {
      return this.setSounds$8(overSound, null, null, null, null, null, null, null);
    }, "setSounds$1", function(overSound, overMarker) {
      return this.setSounds$8(overSound, overMarker, null, null, null, null, null, null);
    }, "setSounds$2", function(overSound, overMarker, downSound) {
      return this.setSounds$8(overSound, overMarker, downSound, null, null, null, null, null);
    }, "setSounds$3", function(overSound, overMarker, downSound, downMarker) {
      return this.setSounds$8(overSound, overMarker, downSound, downMarker, null, null, null, null);
    }, "setSounds$4", function(overSound, overMarker, downSound, downMarker, outSound, outMarker) {
      return this.setSounds$8(overSound, overMarker, downSound, downMarker, outSound, outMarker, null, null);
    }, "setSounds$6", function(overSound, overMarker, downSound, downMarker, outSound) {
      return this.setSounds$8(overSound, overMarker, downSound, downMarker, outSound, null, null, null);
    }, "setSounds$5", function(overSound, overMarker, downSound, downMarker, outSound, outMarker, upSound) {
      return this.setSounds$8(overSound, overMarker, downSound, downMarker, outSound, outMarker, upSound, null);
    }, "setSounds$7", "call$8", "call$0", "call$1", "call$2", "call$3", "call$4", "call$6", "call$5", "call$7", "get$setSounds", 0, 16, 1119, 32, 32, 32, 32, 32, 32, 32, 32, 1120, [], 1121, [], 1122, [], 1123, [], 1124, [], 1125, [], 1126, [], 1127, [], "setSounds"],
    setOverSound$2: [function(sound, marker) {
      this.onOverSound = sound;
      this.onOverSoundMarker = marker;
    }, function() {
      return this.setOverSound$2(null, "");
    }, "setOverSound$0", function(sound) {
      return this.setOverSound$2(sound, "");
    }, "setOverSound$1", "call$2", "call$0", "call$1", "get$setOverSound", 0, 4, 1128, 32, 221, 1129, [], 1130, [], "setOverSound"],
    setOutSound$2: [function(sound, marker) {
      this.onOutSound = sound;
      this.onOutSoundMarker = marker;
    }, function() {
      return this.setOutSound$2(null, "");
    }, "setOutSound$0", function(sound) {
      return this.setOutSound$2(sound, "");
    }, "setOutSound$1", "call$2", "call$0", "call$1", "get$setOutSound", 0, 4, 1128, 32, 221, 1129, [], 1130, [], "setOutSound"],
    setDownSound$2: [function(sound, marker) {
      this.onDownSound = sound;
      this.onDownSoundMarker = marker;
    }, function() {
      return this.setDownSound$2(null, "");
    }, "setDownSound$0", function(sound) {
      return this.setDownSound$2(sound, "");
    }, "setDownSound$1", "call$2", "call$0", "call$1", "get$setDownSound", 0, 4, 1128, 32, 221, 1129, [], 1130, [], "setDownSound"],
    setUpSound$2: [function(sound, marker) {
      this.onUpSound = sound;
      this.onUpSoundMarker = marker;
    }, function() {
      return this.setUpSound$2(null, "");
    }, "setUpSound$0", function(sound) {
      return this.setUpSound$2(sound, "");
    }, "setUpSound$1", "call$2", "call$0", "call$1", "get$setUpSound", 0, 4, 1128, 32, 221, 1129, [], 1130, [], "setUpSound"],
    onInputOverHandler$2: [function(sprite, pointer) {
      var t1;
      if (J.$eq(this.freezeFrames, false))
        this.setState$1(1);
      if (this.onOverMouseOnly != null && pointer.get$isMouse() !== true)
        return;
      t1 = this.onOverSound;
      if (t1 != null)
        J.play$1$x(t1, this.onOverSoundMarker);
      t1 = this.onInputOver;
      if (t1 != null)
        t1.dispatch$1([this, pointer]);
    }, "call$2", "get$onInputOverHandler", 4, 0, 1131, 113, [], 994, [], "onInputOverHandler"],
    onInputOutHandler$2: [function(sprite, pointer) {
      var t1;
      if (J.$eq(this.freezeFrames, false))
        this.setState$1(2);
      t1 = this.onOutSound;
      if (t1 != null)
        J.play$1$x(t1, this.onOutSoundMarker);
      t1 = this.onInputOut;
      if (t1 != null)
        t1.dispatch$1([this, pointer]);
    }, "call$2", "get$onInputOutHandler", 4, 0, 1131, 113, [], 994, [], "onInputOutHandler"],
    onInputDownHandler$2: [function(sprite, pointer) {
      var t1;
      if (J.$eq(this.freezeFrames, false))
        this.setState$1(3);
      t1 = this.onDownSound;
      if (t1 != null)
        J.play$1$x(t1, this.onDownSoundMarker);
      t1 = this.onInputDown;
      if (t1 != null)
        t1.dispatch$1([this, pointer]);
    }, "call$2", "get$onInputDownHandler", 4, 0, 1131, 113, [], 994, [], "onInputDownHandler"],
    onInputUpHandler$3: [function(sprite, pointer, isOver) {
      var t1 = this.onUpSound;
      if (t1 != null)
        J.play$1$x(t1, this.onUpSoundMarker);
      t1 = this.onInputUp;
      if (t1 != null)
        t1.dispatch$1([this, pointer, isOver]);
      if (this.freezeFrames === true)
        return;
      if (this.forceOut === true)
        this.setState$1(2);
      else if (this._onUpFrameName != null || this._onUpFrameID != null)
        this.setState$1(4);
      else if (isOver === true)
        this.setState$1(1);
      else
        this.setState$1(2);
    }, "call$3", "get$onInputUpHandler", 6, 0, 1132, 113, [], 994, [], 1133, [], "onInputUpHandler"],
    setState$1: [function(newState) {
      var t1 = J.getInterceptor(newState);
      if (t1.$eq(newState, 1)) {
        t1 = this._onOverFrameName;
        if (t1 != null)
          this.set$frameName(t1);
        else {
          t1 = this._onOverFrameID;
          if (t1 != null)
            this.set$frame(t1);
        }
      } else if (t1.$eq(newState, 2)) {
        t1 = this._onOutFrameName;
        if (t1 != null)
          this.set$frameName(t1);
        else {
          t1 = this._onOutFrameID;
          if (t1 != null)
            this.set$frame(t1);
        }
      } else if (t1.$eq(newState, 3)) {
        t1 = this._onDownFrameName;
        if (t1 != null)
          this.set$frameName(t1);
        else {
          t1 = this._onDownFrameID;
          if (t1 != null)
            this.set$frame(t1);
        }
      } else if (t1.$eq(newState, 4)) {
        t1 = this._onUpFrameName;
        if (t1 != null)
          this.set$frameName(t1);
        else {
          t1 = this._onUpFrameID;
          if (t1 != null)
            this.set$frame(t1);
        }
      }
    }, "call$1", "get$setState", 2, 0, 60, 1134, [], "setState"],
    Button$9: function(game, x, y, key, callback, overFrame, outFrame, downFrame, upFrame) {
      var t1;
      this.type = 1;
      this._onOverFrameName = null;
      this._onOutFrameName = null;
      this._onDownFrameName = null;
      this._onUpFrameName = null;
      this._onOverFrameID = null;
      this._onOutFrameID = null;
      this._onDownFrameID = null;
      this._onUpFrameID = null;
      this.onOverMouseOnly = false;
      this.onOverSound = null;
      this.onOutSound = null;
      this.onDownSound = null;
      this.onUpSound = null;
      this.onOverSoundMarker = "";
      this.onOutSoundMarker = "";
      this.onDownSoundMarker = "";
      this.onUpSoundMarker = "";
      this.onInputOver = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onInputOut = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onInputDown = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onInputUp = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.freezeFrames = false;
      this.forceOut = false;
      t1 = this.input;
      if (t1 == null) {
        t1 = R.InputHandler$(this);
        this.input = t1;
        t1.start$0(0);
      } else if (t1.get$enabled() !== true)
        J.start$0$x(this.input);
      J.start$2$x(this.input, 0, true);
      this._onOverFrameName = null;
      this._onOverFrameID = null;
      this._onOutFrameName = null;
      this._onOutFrameID = null;
      this._onDownFrameName = null;
      this._onDownFrameID = null;
      this._onUpFrameName = null;
      this._onUpFrameID = null;
      if (overFrame != null)
        if (typeof overFrame === "string") {
          this._onOverFrameName = overFrame;
          if (this.input.pointerOver$0() === true)
            this.set$frameName(overFrame);
        } else {
          this._onOverFrameID = overFrame;
          if (this.input.pointerOver$0() === true)
            this.set$frame(overFrame);
        }
      if (outFrame != null)
        if (typeof outFrame === "string") {
          this._onOutFrameName = outFrame;
          if (J.$eq(this.input.pointerOver$0(), false))
            this.set$frameName(outFrame);
        } else {
          this._onOutFrameID = outFrame;
          if (J.$eq(this.input.pointerOver$0(), false))
            this.set$frame(outFrame);
        }
      if (downFrame != null)
        if (typeof downFrame === "string") {
          this._onDownFrameName = downFrame;
          if (this.input.pointerDown$0() === true)
            this.set$frameName(downFrame);
        } else {
          this._onDownFrameID = downFrame;
          if (this.input.pointerDown$0() === true)
            this.set$frame(downFrame);
        }
      if (upFrame != null)
        if (typeof upFrame === "string") {
          this._onUpFrameName = upFrame;
          if (this.input.pointerUp$0() === true)
            this.set$frameName(upFrame);
        } else {
          this._onUpFrameID = upFrame;
          if (this.input.pointerUp$0() === true)
            this.set$frame(upFrame);
        }
      if (callback != null)
        J.add$1$ax(this.onInputUp, callback);
      J.add$1$ax(this.events.get$onInputOver(), this.get$onInputOverHandler());
      J.add$1$ax(this.events.get$onInputOut(), this.get$onInputOutHandler());
      J.add$1$ax(this.events.get$onInputDown(), this.get$onInputDownHandler());
      J.add$1$ax(this.events.get$onInputUp(), this.get$onInputUpHandler());
    },
    static: {Button$: [function(game, x, y, key, callback, overFrame, outFrame, downFrame, upFrame) {
        var t1, t2, t3, t4, t5, t6;
        t1 = J.$index$asx($.get$TextureCache(), "__default");
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t2 = new R.Button(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, [], null, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t2.texture = t1;
        t2._setupTexture$0();
        t2.Image$5(game, x, y, key, outFrame);
        t2.Button$9(game, x, y, key, callback, overFrame, outFrame, downFrame, upFrame);
        return t2;
      }, null, null, 2, 16, 271, 5, 5, 32, 32, 32, 32, 32, 32, 214, [], 6, [], 7, [], 231, [], 272, [], 273, [], 274, [], 275, [], 276, [], "new Button"]}
  },
  "+Button": [1135],
  Events: {
    "^": "Object;onAddedToGroup@-1136,onRemovedFromGroup@-1136,onKilled@-1137,onRevived@-1137,onOutOfBounds@-1137,onEnterBounds@-1137,onInputOver@-1115,onInputOut@-1115,onInputDown@-1115,onInputUp@-1116,onDragStart*-1115,onDragStop@-1115,onAnimationStart*-940,onAnimationComplete@-940,onAnimationLoop@-940,sprite@-2,parent*-2",
    sprite$3: function(arg0, arg1, arg2) {
      return this.sprite.call$3(arg0, arg1, arg2);
    },
    sprite$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.sprite.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    sprite$4: function(arg0, arg1, arg2, arg3) {
      return this.sprite.call$4(arg0, arg1, arg2, arg3);
    },
    destroy$0: [function() {
      this.parent = null;
      this.onAddedToGroup.dispose$0();
      this.onRemovedFromGroup.dispose$0();
      this.onKilled.dispose$0();
      this.onRevived.dispose$0();
      this.onOutOfBounds.dispose$0();
      var t1 = this.onInputOver;
      if (t1 != null) {
        t1.dispose$0();
        this.onInputOut.dispose$0();
        this.onInputDown.dispose$0();
        this.onInputUp.dispose$0();
        this.onDragStart.dispose$0();
        this.onDragStop.dispose$0();
      }
      t1 = this.onAnimationStart;
      if (t1 != null) {
        t1.dispose$0();
        this.onAnimationComplete.dispose$0();
        this.onAnimationLoop.dispose$0();
      }
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    Events$1: function(sprite) {
      this.parent = J.get$parent$x(this.sprite);
      this.onAddedToGroup = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onRemovedFromGroup = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onKilled = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onRevived = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onOutOfBounds = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onEnterBounds = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onInputOver = null;
      this.onInputOut = null;
      this.onInputDown = null;
      this.onInputUp = null;
      this.onDragStart = null;
      this.onDragStop = null;
      this.onAnimationStart = null;
      this.onAnimationComplete = null;
      this.onAnimationLoop = null;
    },
    static: {Events$: [function(sprite) {
        var t1 = new R.Events(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, sprite, null);
        t1.Events$1(sprite);
        return t1;
      }, null, null, 2, 0, 277, 113, [], "new Events"]}
  },
  "+Events": [632],
  CoreInterfact: {
    "^": "Object;game@-598,events@-1018,visible@-602",
    static: {CoreInterfact$: [function() {
        return new R.CoreInterfact(null, null, null);
      }, null, null, 0, 0, 278, "new CoreInterfact"]}
  },
  "+CoreInterfact": [632],
  SpriteInterface: {
    "^": "Object;texture@-670,body*-1117,anchor@-600",
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.body.call$3(arg0, arg1, arg2);
    },
    $isSpriteInterface: true,
    static: {SpriteInterface$: [function() {
        return new R.SpriteInterface(null, null, null);
      }, null, null, 0, 0, 279, "new SpriteInterface"]}
  },
  "+SpriteInterface": [632, 1138],
  AnimationInterface: {
    "^": "Object;__tilePattern@-794",
    $isSpriteInterface: true,
    static: {AnimationInterface$: [function() {
        return new R.AnimationInterface(null);
      }, null, null, 0, 0, 280, "new AnimationInterface"]}
  },
  "+AnimationInterface": [632, 1139],
  GameObject: {
    "^": "Object;exists@-602,alive@-602,type*-599,name*-639,_Phaser$_currentBounds@-974,scale*-600,_cache@-681,_Phaser$_dirty@-602,anchor@-600,position*-600,x*-601,y*-601,z*-599,alpha*-601,rotation@-601,fixedToCamera@-602,cameraOffset@-600,width*-601,height*-601,autoCull@-602,children*-1058",
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    $isGameObject: true,
    static: {GameObject$: [function() {
        return new R.GameObject(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      }, null, null, 0, 0, 281, "new GameObject"]}
  },
  "+GameObject": [632, 1138, 635],
  GameObjectCreator: {
    "^": "Object;game@-598,world@-983",
    image$4: [function(x, y, key, frame) {
      return R.Image$(this.game, x, y, key, frame);
    }, function(x, y, key) {
      return this.image$4(x, y, key, null);
    }, "image$3", "call$4", "call$3", "get$image", 6, 2, 1140, 32, 6, [], 7, [], 231, [], 178, [], "image"],
    sprite$4: [function(x, y, key, frame) {
      return R.Sprite$(this.game, x, y, key, frame);
    }, function(x, y, key) {
      return this.sprite$4(x, y, key, null);
    }, "sprite$3", function(x, y) {
      return this.sprite$4(x, y, null, null);
    }, "sprite$2", "call$4", "call$3", "call$2", "get$sprite", 4, 4, 1141, 32, 32, 6, [], 7, [], 231, [], 178, [], "sprite"],
    tween$1: [function(obj) {
      var t1, t2, t3, t4;
      t1 = this.game;
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      t3 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      t4 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      $.get$Easing_Linear().toString;
      return new R.Tween(obj, t1, null, t2, t3, t4, 1000, 0, false, false, 0, null, $.get$Linear_INOUT().compute, R.Math_linearInterpolation$closure(), [], false, null, null, false, 0, false, false, H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), false, null, null);
    }, "call$1", "get$tween", 2, 0, 1142, 617, [], "tween"],
    group$4: [function($name, addToStage, enableBody, physicsBodyType) {
      return R.Group$(this.game, null, $name, addToStage, enableBody, physicsBodyType, null);
    }, function() {
      return this.group$4(null, false, false, 0);
    }, "group$0", function(name) {
      return this.group$4(name, false, false, 0);
    }, "group$1", function(name, addToStage) {
      return this.group$4(name, addToStage, false, 0);
    }, "group$2", function(name, addToStage, enableBody) {
      return this.group$4(name, addToStage, enableBody, 0);
    }, "group$3", "call$4", "call$0", "call$1", "call$2", "call$3", "get$group", 0, 8, 1143, 32, 95, 95, 5, 44, [], 254, [], 255, [], 256, [], "group"],
    spriteBatch$3: [function($parent, $name, addToStage) {
      if ($name == null)
        $name = "group";
      if (addToStage == null)
        addToStage = false;
      return R.SpriteBatch$(this.game, $parent, $name, addToStage);
    }, function(parent) {
      return this.spriteBatch$3(parent, null, null);
    }, "spriteBatch$1", function(parent, name) {
      return this.spriteBatch$3(parent, name, null);
    }, "spriteBatch$2", "call$3", "call$1", "call$2", "get$spriteBatch", 2, 4, 1144, 32, 32, 45, [], 44, [], 254, [], "spriteBatch"],
    audio$4: [function(_, key, volume, loop, connect) {
      return J.add$4$ax(this.game.get$sound(), key, volume, loop, connect);
    }, function($receiver, key, volume, loop) {
      return this.audio$4($receiver, key, volume, loop, true);
    }, "audio$3", function($receiver, key) {
      return this.audio$4($receiver, key, null, false, true);
    }, "audio$1", function($receiver, key, volume) {
      return this.audio$4($receiver, key, volume, false, true);
    }, "audio$2", "call$4", "call$3", "call$1", "call$2", "get$audio", 2, 6, 1145, 32, 95, 39, 231, [], 426, [], 219, [], 427, [], "audio"],
    sound$4: [function(key, volume, loop, connect) {
      return J.add$4$ax(this.game.get$sound(), key, volume, loop, connect);
    }, function(key) {
      return this.sound$4(key, null, false, true);
    }, "sound$1", function(key, volume) {
      return this.sound$4(key, volume, false, true);
    }, "sound$2", function(key, volume, loop) {
      return this.sound$4(key, volume, loop, true);
    }, "sound$3", "call$4", "call$1", "call$2", "call$3", "get$sound", 2, 6, 1145, 32, 95, 39, 231, [], 426, [], 219, [], 427, [], "sound"],
    tileSprite$6: [function(x, y, width, height, key, frame) {
      return R.TileSprite$(this.game, x, y, width, height, key, frame);
    }, "call$6", "get$tileSprite", 12, 0, 1146, 6, [], 7, [], 10, [], 11, [], 231, [], 178, [], "tileSprite"],
    text$4: [function(_, x, y, text, style) {
      return R.Text$(this.game, x, y, text, style);
    }, "call$4", "get$text", 8, 0, 1147, 6, [], 7, [], 85, [], 156, [], "text"],
    button$8: [function(_, x, y, key, callback, overFrame, outFrame, downFrame, upFrame) {
      return R.Button$(this.game, x, y, key, callback, overFrame, outFrame, downFrame, upFrame);
    }, function($receiver, x, y, key, callback, overFrame) {
      return this.button$8($receiver, x, y, key, callback, overFrame, null, null, null);
    }, "button$5", function($receiver) {
      return this.button$8($receiver, 0, 0, null, null, null, null, null, null);
    }, "button$0", function($receiver, x) {
      return this.button$8($receiver, x, 0, null, null, null, null, null, null);
    }, "button$1", function($receiver, x, y) {
      return this.button$8($receiver, x, y, null, null, null, null, null, null);
    }, "button$2", function($receiver, x, y, key) {
      return this.button$8($receiver, x, y, key, null, null, null, null, null);
    }, "button$3", function($receiver, x, y, key, callback) {
      return this.button$8($receiver, x, y, key, callback, null, null, null, null);
    }, "button$4", function($receiver, x, y, key, callback, overFrame, outFrame) {
      return this.button$8($receiver, x, y, key, callback, overFrame, outFrame, null, null);
    }, "button$6", function($receiver, x, y, key, callback, overFrame, outFrame, downFrame) {
      return this.button$8($receiver, x, y, key, callback, overFrame, outFrame, downFrame, null);
    }, "button$7", "call$8", "call$5", "call$0", "call$1", "call$2", "call$3", "call$4", "call$6", "call$7", "get$button", 0, 16, 1148, 5, 5, 32, 32, 32, 32, 32, 32, 6, [], 7, [], 231, [], 272, [], 273, [], 274, [], 275, [], 276, [], "button"],
    graphics$2: [function(x, y) {
      return R.Graphics$(this.game, x, y);
    }, function() {
      return this.graphics$2(0, 0);
    }, "graphics$0", function(x) {
      return this.graphics$2(x, 0);
    }, "graphics$1", "call$2", "call$0", "call$1", "get$graphics", 0, 4, 1149, 5, 5, 6, [], 7, [], "graphics"],
    emitter$3: [function(x, y, maxParticles) {
      return R.Emitter$(this.game, x, y, maxParticles);
    }, function() {
      return this.emitter$3(null, null, 50);
    }, "emitter$0", function(x) {
      return this.emitter$3(x, null, 50);
    }, "emitter$1", function(x, y) {
      return this.emitter$3(x, y, 50);
    }, "emitter$2", "call$3", "call$0", "call$1", "call$2", "get$emitter", 0, 6, 1150, 32, 32, 361, 6, [], 7, [], 415, [], "emitter"],
    retroFont$9: [function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
      return R.RetroFont$(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);
    }, function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, 0, 0, 0);
    }, "retroFont$6", function(font, characterWidth, characterHeight, chars, charsPerRow) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, 0, 0, 0, 0);
    }, "retroFont$5", function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, 0, 0);
    }, "retroFont$7", function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, 0);
    }, "retroFont$8", "call$9", "call$6", "call$5", "call$7", "call$8", "get$retroFont", 10, 8, 1151, 5, 5, 5, 5, 163, [], 287, [], 288, [], 289, [], 290, [], 291, [], 292, [], 293, [], 294, [], "retroFont"],
    bitmapText$5: [function(x, y, font, text, size) {
      return R.BitmapText$(this.game, x, y, font, text, size);
    }, function(x, y, font) {
      return this.bitmapText$5(x, y, font, null, null);
    }, "bitmapText$3", function(x, y, font, text) {
      return this.bitmapText$5(x, y, font, text, null);
    }, "bitmapText$4", "call$5", "call$3", "call$4", "get$bitmapText", 6, 4, 1152, 32, 32, 6, [], 7, [], 163, [], 85, [], 270, [], "bitmapText"],
    tilemap$5: [function(key, tileWidth, tileHeight, width, height) {
      return R.Tilemap$(this.game, key, tileWidth, tileHeight, width, height);
    }, function(key, tileWidth, tileHeight, width) {
      return this.tilemap$5(key, tileWidth, tileHeight, width, 10);
    }, "tilemap$4", function(key) {
      return this.tilemap$5(key, 32, 32, 10, 10);
    }, "tilemap$1", function(key, tileWidth) {
      return this.tilemap$5(key, tileWidth, 32, 10, 10);
    }, "tilemap$2", function(key, tileWidth, tileHeight) {
      return this.tilemap$5(key, tileWidth, tileHeight, 10, 10);
    }, "tilemap$3", "call$5", "call$4", "call$1", "call$2", "call$3", "get$tilemap", 2, 8, 1153, 269, 269, 348, 348, 231, [], 455, [], 456, [], 10, [], 11, [], "tilemap"],
    renderTexture$4: [function(width, height, key, addToCache) {
      var texture;
      if (key == null)
        key = this.game.get$rnd().uuid$0();
      texture = R.RenderTexture$(this.game, width, height, key, null);
      if (addToCache === true)
        this.game.get$cache().addRenderTexture$2(key, texture);
      return texture;
    }, function() {
      return this.renderTexture$4(100, 100, null, false);
    }, "renderTexture$0", function(width) {
      return this.renderTexture$4(width, 100, null, false);
    }, "renderTexture$1", function(width, height) {
      return this.renderTexture$4(width, height, null, false);
    }, "renderTexture$2", function(width, height, key) {
      return this.renderTexture$4(width, height, key, false);
    }, "renderTexture$3", "call$4", "call$0", "call$1", "call$2", "call$3", "get$renderTexture", 0, 8, 1154, 90, 90, 32, 95, 10, [], 11, [], 231, [], 1155, [], "renderTexture"],
    bitmapData$4: [function(width, height, key, addToCache) {
      var texture;
      if (key == null)
        key = this.game.get$rnd().uuid$0();
      texture = R.BitmapData$(this.game, key, width, height);
      if (addToCache === true)
        this.game.get$cache().addBitmapData$2(key, texture);
      return texture;
    }, function() {
      return this.bitmapData$4(100, 100, null, false);
    }, "bitmapData$0", function(width) {
      return this.bitmapData$4(width, 100, null, false);
    }, "bitmapData$1", function(width, height) {
      return this.bitmapData$4(width, height, null, false);
    }, "bitmapData$2", function(width, height, key) {
      return this.bitmapData$4(width, height, key, false);
    }, "bitmapData$3", "call$4", "call$0", "call$1", "call$2", "call$3", "get$bitmapData", 0, 8, 1156, 90, 90, 32, 95, 10, [], 11, [], 231, [], 1155, [], "bitmapData"],
    filter$1: [function(_, filter) {
      return filter;
    }, "call$1", "get$filter", 2, 0, 1157, 886, [], "filter"],
    static: {GameObjectCreator$: [function(game) {
        var t1 = new R.GameObjectCreator(game, null);
        t1.world = game.get$world();
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new GameObjectCreator"]}
  },
  "+GameObjectCreator": [632],
  GameObjectFactory: {
    "^": "Object;game@-598,world@-983",
    existing$1: [function(object) {
      return J.add$1$ax(this.world, object);
    }, "call$1", "get$existing", 2, 0, 63, 541, [], "existing"],
    image$5: [function(x, y, key, frame, group) {
      if (group == null)
        group = this.world;
      return J.add$1$ax(group, R.Image$(this.game, x, y, key, frame));
    }, function(x, y, key, frame) {
      return this.image$5(x, y, key, frame, null);
    }, "image$4", function(x, y, key) {
      return this.image$5(x, y, key, null, null);
    }, "image$3", "call$5", "call$4", "call$3", "get$image", 6, 4, 1158, 32, 32, 6, [], 7, [], 231, [], 178, [], 253, [], "image"],
    sprite$5: [function(x, y, key, frame, group) {
      return (group == null ? this.world : group).create$4(x, y, key, frame);
    }, function(x, y, key) {
      return this.sprite$5(x, y, key, null, null);
    }, "sprite$3", function(x, y, key, frame) {
      return this.sprite$5(x, y, key, frame, null);
    }, "sprite$4", function(x, y) {
      return this.sprite$5(x, y, null, null, null);
    }, "sprite$2", "call$5", "call$3", "call$4", "call$2", "get$sprite", 4, 6, 1159, 32, 32, 32, 6, [], 7, [], 231, [], 178, [], 253, [], "sprite"],
    tween$1: [function(obj) {
      return this.game.get$tweens().create$1(obj);
    }, "call$1", "get$tween", 2, 0, 1160, 617, [], "tween"],
    group$5: [function($parent, $name, addToStage, enableBody, physicsBodyType) {
      return R.Group$(this.game, $parent, $name, addToStage, enableBody, physicsBodyType, null);
    }, function(parent, name, addToStage, enableBody) {
      return this.group$5(parent, name, addToStage, enableBody, 0);
    }, "group$4", function() {
      return this.group$5(null, null, false, false, 0);
    }, "group$0", function(parent) {
      return this.group$5(parent, null, false, false, 0);
    }, "group$1", function(parent, name) {
      return this.group$5(parent, name, false, false, 0);
    }, "group$2", function(parent, name, addToStage) {
      return this.group$5(parent, name, addToStage, false, 0);
    }, "group$3", "call$5", "call$4", "call$0", "call$1", "call$2", "call$3", "get$group", 0, 10, 1161, 32, 32, 95, 95, 5, 45, [], 44, [], 254, [], 255, [], 256, [], "group"],
    physicsGroup$4: [function(physicsBodyType, $parent, $name, addToStage) {
      return R.Group$(this.game, $parent, $name, addToStage, true, physicsBodyType, null);
    }, function() {
      return this.physicsGroup$4(0, null, "group", false);
    }, "physicsGroup$0", function(physicsBodyType) {
      return this.physicsGroup$4(physicsBodyType, null, "group", false);
    }, "physicsGroup$1", function(physicsBodyType, parent) {
      return this.physicsGroup$4(physicsBodyType, parent, "group", false);
    }, "physicsGroup$2", function(physicsBodyType, parent, name) {
      return this.physicsGroup$4(physicsBodyType, parent, name, false);
    }, "physicsGroup$3", "call$4", "call$0", "call$1", "call$2", "call$3", "get$physicsGroup", 0, 8, 1162, 5, 32, 253, 95, 256, [], 45, [], 44, [], 254, [], "physicsGroup"],
    spriteBatch$3: [function($parent, $name, addToStage) {
      if ($parent == null)
        $parent = null;
      if ($name == null)
        $name = "group";
      if (addToStage == null)
        addToStage = false;
      return R.SpriteBatch$(this.game, $parent, $name, addToStage);
    }, function() {
      return this.spriteBatch$3(null, null, false);
    }, "spriteBatch$0", function(parent) {
      return this.spriteBatch$3(parent, null, false);
    }, "spriteBatch$1", function(parent, name) {
      return this.spriteBatch$3(parent, name, false);
    }, "spriteBatch$2", "call$3", "call$0", "call$1", "call$2", "get$spriteBatch", 0, 6, 1163, 32, 32, 95, 45, [], 44, [], 254, [], "spriteBatch"],
    audio$4: [function(_, key, volume, loop, connect) {
      return J.add$4$ax(this.game.get$sound(), key, volume, loop, connect);
    }, function($receiver, key, volume, loop) {
      return this.audio$4($receiver, key, volume, loop, true);
    }, "audio$3", function($receiver, key) {
      return this.audio$4($receiver, key, 1, false, true);
    }, "audio$1", function($receiver, key, volume) {
      return this.audio$4($receiver, key, volume, false, true);
    }, "audio$2", "call$4", "call$3", "call$1", "call$2", "get$audio", 2, 6, 1164, 390, 95, 39, 231, [], 426, [], 219, [], 427, [], "audio"],
    sound$4: [function(key, volume, loop, connect) {
      return J.add$4$ax(this.game.get$sound(), key, volume, loop, connect);
    }, function(key) {
      return this.sound$4(key, 1, false, true);
    }, "sound$1", function(key, volume) {
      return this.sound$4(key, volume, false, true);
    }, "sound$2", function(key, volume, loop) {
      return this.sound$4(key, volume, loop, true);
    }, "sound$3", "call$4", "call$1", "call$2", "call$3", "get$sound", 2, 6, 1164, 390, 95, 39, 231, [], 426, [], 219, [], 427, [], "sound"],
    tileSprite$7: [function(x, y, width, height, key, frame, group) {
      if (group == null)
        group = this.world;
      return J.add$1$ax(group, R.TileSprite$(this.game, x, y, width, height, key, frame));
    }, function(x, y, width, height, key, frame) {
      return this.tileSprite$7(x, y, width, height, key, frame, null);
    }, "tileSprite$6", function(x, y, width, height, key) {
      return this.tileSprite$7(x, y, width, height, key, 0, null);
    }, "tileSprite$5", "call$7", "call$6", "call$5", "get$tileSprite", 10, 4, 1165, 5, 32, 6, [], 7, [], 10, [], 11, [], 231, [], 178, [], 253, [], "tileSprite"],
    text$5: [function(_, x, y, text, style, group) {
      if (group == null)
        group = this.world;
      return J.add$1$ax(group, R.Text$(this.game, x, y, text, style));
    }, function($receiver, x, y, text, style) {
      return this.text$5($receiver, x, y, text, style, null);
    }, "text$4", "call$5", "call$4", "get$text", 8, 2, 1166, 32, 6, [], 7, [], 85, [], 156, [], 253, [], "text"],
    button$9: [function(_, x, y, key, callback, overFrame, outFrame, downFrame, upFrame, group) {
      if (group == null)
        group = this.world;
      return J.add$1$ax(group, R.Button$(this.game, x, y, key, callback, overFrame, outFrame, downFrame, upFrame));
    }, function($receiver, x, y, key, callback, overFrame) {
      return this.button$9($receiver, x, y, key, callback, overFrame, null, null, null, null);
    }, "button$5", function($receiver, x, y, key, callback, overFrame, outFrame, downFrame, upFrame) {
      return this.button$9($receiver, x, y, key, callback, overFrame, outFrame, downFrame, upFrame, null);
    }, "button$8", function($receiver) {
      return this.button$9($receiver, null, null, null, null, null, null, null, null, null);
    }, "button$0", function($receiver, x) {
      return this.button$9($receiver, x, null, null, null, null, null, null, null, null);
    }, "button$1", function($receiver, x, y) {
      return this.button$9($receiver, x, y, null, null, null, null, null, null, null);
    }, "button$2", function($receiver, x, y, key) {
      return this.button$9($receiver, x, y, key, null, null, null, null, null, null);
    }, "button$3", function($receiver, x, y, key, callback) {
      return this.button$9($receiver, x, y, key, callback, null, null, null, null, null);
    }, "button$4", function($receiver, x, y, key, callback, overFrame, outFrame) {
      return this.button$9($receiver, x, y, key, callback, overFrame, outFrame, null, null, null);
    }, "button$6", function($receiver, x, y, key, callback, overFrame, outFrame, downFrame) {
      return this.button$9($receiver, x, y, key, callback, overFrame, outFrame, downFrame, null, null);
    }, "button$7", "call$9", "call$5", "call$8", "call$0", "call$1", "call$2", "call$3", "call$4", "call$6", "call$7", "get$button", 0, 18, 1167, 32, 32, 32, 32, 32, 32, 32, 32, 32, 6, [], 7, [], 231, [], 272, [], 273, [], 274, [], 275, [], 276, [], 253, [], "button"],
    graphics$3: [function(x, y, group) {
      if (group == null)
        group = this.world;
      return J.add$1$ax(group, R.Graphics$(this.game, x, y));
    }, function(x, y) {
      return this.graphics$3(x, y, null);
    }, "graphics$2", function() {
      return this.graphics$3(0, 0, null);
    }, "graphics$0", function(x) {
      return this.graphics$3(x, 0, null);
    }, "graphics$1", "call$3", "call$2", "call$0", "call$1", "get$graphics", 0, 6, 1168, 5, 5, 32, 6, [], 7, [], 253, [], "graphics"],
    emitter$3: [function(x, y, maxParticles) {
      return J.add$1$ax(this.game.get$particles(), R.Emitter$(this.game, x, y, maxParticles));
    }, function() {
      return this.emitter$3(null, null, 50);
    }, "emitter$0", function(x) {
      return this.emitter$3(x, null, 50);
    }, "emitter$1", function(x, y) {
      return this.emitter$3(x, y, 50);
    }, "emitter$2", "call$3", "call$0", "call$1", "call$2", "get$emitter", 0, 6, 1169, 32, 32, 361, 6, [], 7, [], 415, [], "emitter"],
    retroFont$9: [function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
      return R.RetroFont$(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);
    }, function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, 0, 0, 0);
    }, "retroFont$6", function(font, characterWidth, characterHeight, chars, charsPerRow) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, 0, 0, 0, 0);
    }, "retroFont$5", function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, 0, 0);
    }, "retroFont$7", function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset) {
      return this.retroFont$9(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, 0);
    }, "retroFont$8", "call$9", "call$6", "call$5", "call$7", "call$8", "get$retroFont", 10, 8, 1170, 5, 5, 5, 5, 163, [], 287, [], 288, [], 289, [], 290, [], 291, [], 292, [], 293, [], 294, [], "retroFont"],
    bitmapText$6: [function(x, y, font, text, size, group) {
      if (group == null)
        group = this.world;
      return J.add$1$ax(group, R.BitmapText$(this.game, x, y, font, text, size));
    }, function(x, y, font, text, size) {
      return this.bitmapText$6(x, y, font, text, size, null);
    }, "bitmapText$5", function(x, y, font) {
      return this.bitmapText$6(x, y, font, null, null, null);
    }, "bitmapText$3", function(x, y, font, text) {
      return this.bitmapText$6(x, y, font, text, null, null);
    }, "bitmapText$4", "call$6", "call$5", "call$3", "call$4", "get$bitmapText", 6, 6, 1171, 32, 32, 32, 6, [], 7, [], 163, [], 85, [], 270, [], 253, [], "bitmapText"],
    tilemap$5: [function(key, tileWidth, tileHeight, width, height) {
      return R.Tilemap$(this.game, key, tileWidth, tileHeight, width, height);
    }, function(key, tileWidth, tileHeight, width) {
      return this.tilemap$5(key, tileWidth, tileHeight, width, 10);
    }, "tilemap$4", function() {
      return this.tilemap$5(null, 32, 32, 10, 10);
    }, "tilemap$0", function(key) {
      return this.tilemap$5(key, 32, 32, 10, 10);
    }, "tilemap$1", function(key, tileWidth) {
      return this.tilemap$5(key, tileWidth, 32, 10, 10);
    }, "tilemap$2", function(key, tileWidth, tileHeight) {
      return this.tilemap$5(key, tileWidth, tileHeight, 10, 10);
    }, "tilemap$3", "call$5", "call$4", "call$0", "call$1", "call$2", "call$3", "get$tilemap", 0, 10, 1172, 32, 269, 269, 348, 348, 231, [], 455, [], 456, [], 10, [], 11, [], "tilemap"],
    renderTexture$4: [function(width, height, key, addToCache) {
      var texture;
      if (key == null)
        key = this.game.get$rnd().uuid$0();
      texture = R.RenderTexture$(this.game, width, height, key, null);
      if (addToCache === true)
        this.game.get$cache().addRenderTexture$2(key, texture);
      return texture;
    }, function() {
      return this.renderTexture$4(null, null, null, false);
    }, "renderTexture$0", function(width) {
      return this.renderTexture$4(width, null, null, false);
    }, "renderTexture$1", function(width, height) {
      return this.renderTexture$4(width, height, null, false);
    }, "renderTexture$2", function(width, height, key) {
      return this.renderTexture$4(width, height, key, false);
    }, "renderTexture$3", "call$4", "call$0", "call$1", "call$2", "call$3", "get$renderTexture", 0, 8, 1154, 32, 32, 32, 95, 10, [], 11, [], 231, [], 1155, [], "renderTexture"],
    bitmapData$4: [function(width, height, key, addToCache) {
      var texture;
      if (key == null)
        key = this.game.get$rnd().uuid$0();
      texture = R.BitmapData$(this.game, key, width, height);
      if (addToCache === true)
        this.game.get$cache().addBitmapData$2(key, texture);
      return texture;
    }, function() {
      return this.bitmapData$4(null, null, null, false);
    }, "bitmapData$0", function(width) {
      return this.bitmapData$4(width, null, null, false);
    }, "bitmapData$1", function(width, height) {
      return this.bitmapData$4(width, height, null, false);
    }, "bitmapData$2", function(width, height, key) {
      return this.bitmapData$4(width, height, key, false);
    }, "bitmapData$3", "call$4", "call$0", "call$1", "call$2", "call$3", "get$bitmapData", 0, 8, 1156, 32, 32, 32, 95, 10, [], 11, [], 231, [], 1155, [], "bitmapData"],
    filter$2: [function(_, filterType, args) {
      var filter;
      J.insert$2$ax(args, 0, this.game);
      filter = P.reflectClass(filterType).newInstance$2(null, args).reflectee;
      filter.init$0();
      return filter;
    }, function($receiver, filterType) {
      return this.filter$2($receiver, filterType, null);
    }, "filter$1", "call$2", "call$1", "get$filter", 2, 2, 1173, 32, 1174, [], 338, [], "filter"],
    plugin$1: [function(plugin) {
      return J.add$1$ax(this.game.get$plugins(), plugin);
    }, "call$1", "get$plugin", 2, 0, 1175, 1044, [], "plugin"],
    static: {GameObjectFactory$: [function(game) {
        var t1 = new R.GameObjectFactory(game, null);
        t1.world = game.get$world();
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new GameObjectFactory"]}
  },
  "+GameObjectFactory": [632],
  Graphics: {
    "^": "Graphics0;game@-598,position:Phaser$Graphics$position*-600,world@-600,cameraOffset@-600,_cache@-720,children:Phaser$Graphics$children*-1058,exists@-602,alive@-602,autoCull@-602,_Phaser$_dirty@-602,events@-1018,type*-599,name*-639,_Phaser$_currentBounds@-974,anchor@-600,z*-599,fillAlpha-601,lineWidth-601,lineColor-601,fillColor-601,filling-602,lineAlpha-601,_graphicsData-829,tint-599,blendMode-674,_currentPath-830,_webGL-831,_isMask-602,bounds-641,boundsPadding-599,clearDirty-602,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 281, "parent"],
    get$renderOrderID: [function() {
      return J.$index$asx(this._cache, 3);
    }, null, null, 1, 0, 367, "renderOrderID"],
    set$renderOrderID: [function(value) {
      J.$indexSet$ax(this._cache, 3, value);
    }, null, null, 3, 0, 60, 100, [], "renderOrderID"],
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(J.get$x$x(this.Phaser$Graphics$position), J.$div$n(J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.getLocalBounds$0())), 2));
      t2 = J.$add$ns(J.get$y$x(this.Phaser$Graphics$position), J.$div$n(J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.getLocalBounds$0())), 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1019, "center"],
    bringToTop$1: [function(child) {
      if (child == null) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
        return this;
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$Graphics$children, child), J.get$length$asx(this.Phaser$Graphics$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Graphics$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$Graphics$children));
        }
        return this;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1059, 32, 659, [], "bringToTop"],
    get$angle: [function() {
      return J.$mul$ns(this.rotation, 57.29577951308232);
    }, null, null, 1, 0, 604, "angle"],
    angle$0: function() {
      return this.get$angle().call$0();
    },
    angle$2: function(arg0, arg1) {
      return this.get$angle().call$2(arg0, arg1);
    },
    set$angle: [function(value) {
      this.rotation = J.$mul$ns(value, 0.017453292519943295);
    }, null, null, 3, 0, 605, 100, [], "angle"],
    get$fixedToCamera: [function() {
      return J.$eq(J.$index$asx(this._cache, 7), 1);
    }, null, null, 1, 0, 209, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.cameraOffset.set$2(J.get$x$x(this.Phaser$Graphics$position), J.get$y$x(this.Phaser$Graphics$position));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 650, 100, [], "fixedToCamera"],
    get$destroyPhase: [function() {
      return J.$eq(J.$index$asx(this._cache, 8), 1);
    }, null, null, 1, 0, 209, "destroyPhase"],
    preUpdate$0: [function() {
      var t1, t2, t3;
      J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
      J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
      J.$indexSet$ax(this._cache, 2, this.rotation);
      if (this.exists !== true || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        J.$indexSet$ax(this._cache, 3, -1);
        return false;
      }
      if (this.autoCull === true)
        this.renderable = J.intersects$1$x(this.game.get$world().get$camera().get$screenView(), new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.Graphics0.prototype.getBounds$1.call(this, null)));
      this.world.setTo$2(J.$add$ns(J.get$x$x(this.game.get$camera()), J.$index$asx(this._worldTransform, 2)), J.$add$ns(J.get$y$x(this.game.get$camera()), J.$index$asx(this._worldTransform, 5)));
      if (this.visible === true) {
        t1 = this._cache;
        t2 = this.game.get$stage();
        t3 = t2.get$currentRenderOrderID();
        t2.set$currentRenderOrderID(J.$add$ns(t3, 1));
        J.$indexSet$ax(t1, 3, t3);
      }
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 13, "update"],
    postUpdate$0: [function() {
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.Phaser$Graphics$position, J.$div$n(J.$add$ns(J.get$x$x(J.get$view$x(this.game.get$camera())), J.get$x$x(this.cameraOffset)), J.get$x$x(J.get$scale$x(this.game.get$camera()))));
        J.set$y$x(this.Phaser$Graphics$position, J.$div$n(J.$add$ns(J.get$y$x(J.get$view$x(this.game.get$camera())), J.get$y$x(this.cameraOffset)), J.get$y$x(J.get$scale$x(this.game.get$camera()))));
      }
    }, "call$0", "get$postUpdate", 0, 0, 13, "postUpdate"],
    destroy$1: [function(destroyChildren) {
      var i, t1, i0;
      if (this.game == null || J.$eq(J.$index$asx(this._cache, 8), 1))
        return;
      if (destroyChildren == null)
        destroyChildren = true;
      J.$indexSet$ax(this._cache, 8, 1);
      this.clear$0(0);
      if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
        if (!!J.getInterceptor(M.DisplayObject.prototype.get$parent.call(this, this)).$isGroup)
          H.interceptedTypeCast(M.DisplayObject.prototype.get$parent.call(this, this), "$isGroup").remove$1(0, this);
        else
          M.DisplayObject.prototype.get$parent.call(this, this).removeChild$1(this);
      i = J.get$length$asx(this.Phaser$Graphics$children);
      if (destroyChildren === true)
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          J.$index$asx(this.Phaser$Graphics$children, i0).destroy$1(destroyChildren);
      else
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0) {
          t1 = J.$index$asx(this.Phaser$Graphics$children, i0);
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Graphics$children, t1));
        }
      this.exists = false;
      this.visible = false;
      this.game = null;
      J.$indexSet$ax(this._cache, 8, 0);
    }, function() {
      return this.destroy$1(true);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 932, 39, 1039, [], "destroy"],
    drawPolygon$1: [function(poly) {
      var t1, i, t2, t3;
      t1 = J.getInterceptor$x(poly);
      this.moveTo$2(0, J.get$x$x(J.$index$asx(t1.get$points(poly), 0)), J.get$y$x(J.$index$asx(t1.get$points(poly), 0)));
      i = 1;
      while (true) {
        t2 = J.get$length$asx(t1.get$points(poly));
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        t2 = J.get$x$x(J.$index$asx(t1.get$points(poly), i));
        t3 = J.get$y$x(J.$index$asx(t1.get$points(poly), i));
        J.addAll$1$ax(J.get$points$x(this._currentPath), [t2, t3]);
        this._dirty = true;
        ++i;
      }
      this.lineTo$2(0, J.get$x$x(J.$index$asx(t1.get$points(poly), 0)), J.get$y$x(J.$index$asx(t1.get$points(poly), 0)));
    }, "call$1", "get$drawPolygon", 2, 0, 1176, 1177, [], "drawPolygon"],
    drawTriangle$2: [function(points, cull) {
      var triangle, t1, t2, t3, cameraToFace, t4, t5, ab, t6, cb, faceNormal;
      if (cull == null)
        cull = false;
      triangle = new R.Polygon0(points, null);
      triangle.type = 12;
      if (cull === true) {
        t1 = J.getInterceptor$asx(points);
        t2 = J.$sub$n(J.get$x$x(this.game.get$camera()), J.get$x$x(t1.$index(points, 0)));
        t3 = J.$sub$n(J.get$y$x(this.game.get$camera()), J.get$y$x(t1.$index(points, 0)));
        cameraToFace = new R.Point(null, null);
        cameraToFace.x = t2;
        cameraToFace.y = t3;
        t4 = J.$sub$n(J.get$x$x(t1.$index(points, 1)), J.get$x$x(t1.$index(points, 0)));
        t5 = J.$sub$n(J.get$y$x(t1.$index(points, 1)), J.get$y$x(t1.$index(points, 0)));
        ab = new R.Point(null, null);
        ab.x = t4;
        ab.y = t5;
        t6 = J.$sub$n(J.get$x$x(t1.$index(points, 1)), J.get$x$x(t1.$index(points, 2)));
        t1 = J.$sub$n(J.get$y$x(t1.$index(points, 1)), J.get$y$x(t1.$index(points, 2)));
        cb = new R.Point(null, null);
        cb.x = t6;
        cb.y = t1;
        faceNormal = J.$sub$n(J.$mul$ns(t6, t5), J.$mul$ns(t1, t4));
        t1 = J.getInterceptor$x(faceNormal);
        if (J.$gt$n(J.$add$ns(J.$mul$ns(t2, t1.get$x(faceNormal)), J.$mul$ns(t3, t1.get$y(faceNormal))), 0))
          this.drawPolygon$1(triangle);
      } else
        this.drawPolygon$1(triangle);
    }, function(points) {
      return this.drawTriangle$2(points, false);
    }, "drawTriangle$1", "call$2", "call$1", "get$drawTriangle", 2, 2, 1178, 95, 17, [], 1179, [], "drawTriangle"],
    drawTriangles$3: [function(vertices, indices, cull) {
      var point1, point2, point3, points, t1, i, t2, t3;
      if (cull == null)
        cull = false;
      point1 = new R.Point(null, null);
      point1.x = 0;
      point1.y = 0;
      point2 = new R.Point(null, null);
      point2.x = 0;
      point2.y = 0;
      point3 = new R.Point(null, null);
      point3.x = 0;
      point3.y = 0;
      points = [];
      if (indices == null) {
        t1 = J.getInterceptor$asx(vertices);
        if (!!J.getInterceptor(t1.$index(vertices, 0)).$isPoint) {
          i = 0;
          while (true) {
            t2 = J.$div$n(t1.get$length(vertices), 3);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            t2 = i * 3;
            this.drawTriangle$2([t1.$index(vertices, t2), t1.$index(vertices, t2 + 1), t1.$index(vertices, t2 + 2)], cull);
            ++i;
          }
        } else {
          i = 0;
          while (true) {
            t2 = J.$div$n(t1.get$length(vertices), 6);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            t2 = i * 6;
            point1.x = t1.$index(vertices, t2);
            point1.y = t1.$index(vertices, t2 + 1);
            point2.x = t1.$index(vertices, t2 + 2);
            point2.y = t1.$index(vertices, t2 + 3);
            point3.x = t1.$index(vertices, t2 + 4);
            point3.y = t1.$index(vertices, t2 + 5);
            this.drawTriangle$2([point1, point2, point3], cull);
            ++i;
          }
        }
      } else {
        t1 = J.getInterceptor$asx(vertices);
        if (!!J.getInterceptor(t1.$index(vertices, 0)).$isPoint) {
          t2 = J.getInterceptor$asx(indices);
          i = 0;
          while (true) {
            t3 = J.$div$n(t2.get$length(indices), 3);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(i < t3))
              break;
            t3 = i * 3;
            points.push(t1.$index(vertices, t2.$index(indices, t3)));
            points.push(t1.$index(vertices, t2.$index(indices, t3 + 1)));
            points.push(t1.$index(vertices, t2.$index(indices, t3 + 2)));
            if (points.length === 3) {
              this.drawTriangle$2(points, cull);
              points = [];
            }
            ++i;
          }
        } else {
          t2 = J.getInterceptor$asx(indices);
          i = 0;
          while (true) {
            t3 = t2.get$length(indices);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(i < t3))
              break;
            point1.x = t1.$index(vertices, J.$mul$ns(t2.$index(indices, i), 2));
            point1.y = t1.$index(vertices, J.$add$ns(J.$mul$ns(t2.$index(indices, i), 2), 1));
            t3 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
            t3.set$x(0, point1.x);
            t3.set$y(0, point1.y);
            points.push(t3);
            if (points.length === 3) {
              this.drawTriangle$2(points, cull);
              points = [];
            }
            ++i;
          }
        }
      }
    }, function(vertices) {
      return this.drawTriangles$3(vertices, null, false);
    }, "drawTriangles$1", function(vertices, indices) {
      return this.drawTriangles$3(vertices, indices, false);
    }, "drawTriangles$2", "call$3", "call$1", "call$2", "get$drawTriangles", 2, 4, 1180, 32, 95, 753, [], 1181, [], 1179, [], "drawTriangles"],
    getBounds$1: [function(matrix) {
      return new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.Graphics0.prototype.getBounds$1.call(this, matrix));
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 1041, 32, 537, [], "getBounds"],
    Graphics$3: function(game, x, y) {
      var t1;
      J.set$x$x(this.Phaser$Graphics$position, x);
      J.set$y$x(this.Phaser$Graphics$position, y);
      this.exists = true;
      this.name = "";
      this.type = 3;
      this.z = 0;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.world = t1;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.cameraOffset = t1;
      this.Phaser$Graphics$position.set$2(x, y);
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
    },
    $isGameObject: true,
    static: {Graphics$: [function(game, x, y) {
        var t1, t2, t3, t4, t5, t6, t7, t8;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new R.Point(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = $.Graphics_POLY;
        t4 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = new M.Point0(null, null);
        t6.x = 1;
        t6.y = 1;
        t7 = new M.Point0(null, null);
        t7.x = 0;
        t7.y = 0;
        t8 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new R.Graphics(game, t1, null, null, null, [], null, null, false, false, null, null, null, null, t2, null, 1, 1, 0, 0, false, 1, [], 16777215, null, new M.GraphicsData([], 1, 0, null, 1, 1, 0, t3), t4, false, null, 0, false, [], false, 0, 0, t5, t6, t7, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t8, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.Graphics$0();
        t1.Graphics$3(game, x, y);
        return t1;
      }, null, null, 2, 4, 282, 5, 5, 214, [], 6, [], 7, [], "new Graphics"]}
  },
  "+Graphics": [642, 2],
  Image: {
    "^": "Sprite;game@-598,exists@-602,name*-639,type*-599,z*-599,events@-1018,key*-32,world@-600,autoCull@-602,input@-1111,body*-1117,cameraOffset@-600,anchor:Phaser$Image$anchor@-600,cropRect@-974,_cache@-720,_crop@-974,_frame@-599,_Phaser$_bounds@-974,_Phaser$_dirty@-602,_frameName@-639,alive@-602,children:Phaser$Image$children*-1058,_Phaser$_currentBounds@-974,anchor-634,texture-670,updateFrame-602,PIXI$Sprite$_width-601,PIXI$Sprite$_height-601,_uvs-671,tintedTexture-672,buffer-673,tint-599,cachedTint-599,blendMode-674,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.body.call$3(arg0, arg1, arg2);
    },
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(J.get$x$x(this.position), J.$div$n(J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.get$texture().get$frame())), 2));
      t2 = J.$add$ns(J.get$y$x(this.position), J.$div$n(J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.get$texture().get$frame())), 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1019, "center"],
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 281, "parent"],
    bringToTop$1: [function(child) {
      if (child == null) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
        return this;
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$Image$children, child), J.get$length$asx(this.Phaser$Image$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Image$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$Image$children));
        }
        return this;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1059, 32, 659, [], "bringToTop"],
    destroy$1: [function(destroyChildren) {
    }, "call$1", "get$destroy", 2, 0, 63, 1039, [], "destroy"],
    get$angle: [function() {
      return R.Math_wrapAngle(J.$mul$ns(this.rotation, 57.29577951308232), false);
    }, null, null, 1, 0, 604, "angle"],
    angle$0: function() {
      return this.get$angle().call$0();
    },
    angle$2: function(arg0, arg1) {
      return this.get$angle().call$2(arg0, arg1);
    },
    set$angle: [function(value) {
      this.rotation = R.Math_wrapAngle(value, false) * 0.017453292519943295;
    }, null, null, 3, 0, 605, 100, [], "angle"],
    get$deltaX: [function(_) {
      return J.$sub$n(J.get$x$x(this.world), J.$index$asx(this._cache, 0));
    }, null, null, 1, 0, 604, "deltaX"],
    deltaX$0: function($receiver) {
      return this.get$deltaX(this).call$0();
    },
    get$deltaZ: [function(_) {
      return J.$sub$n(J.get$x$x(this.world), J.$index$asx(this._cache, 2));
    }, null, null, 1, 0, 604, "deltaZ"],
    get$inWorld: [function() {
      var t1, t2;
      t1 = this.get$game().get$world().get$bounds();
      t2 = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      t2.copyFrom$1(this.getBounds$0());
      return J.intersects$1$x(t1, t2);
    }, null, null, 1, 0, 209, "inWorld"],
    get$inCamera: [function() {
      var t1, t2;
      t1 = this.get$game().get$world().get$camera().get$screenView();
      t2 = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      t2.copyFrom$1(this.getBounds$0());
      return J.intersects$1$x(t1, t2);
    }, null, null, 1, 0, 209, "inCamera"],
    get$frame: [function() {
      return this._frame;
    }, null, null, 1, 0, 367, "frame"],
    set$frame: [function(value) {
      var t1, frameData;
      t1 = J.getInterceptor(value);
      if (!t1.$eq(value, this._frame) && this.get$game().get$cache().isSpriteSheet$1(this.key) === true) {
        frameData = this.get$game().get$cache().getFrameData$1(this.key);
        if (frameData != null && t1.$lt(value, J.get$total$x(frameData)) && frameData.getFrame$1(value) != null) {
          this.set$texture(J.$index$asx($.get$TextureCache(), frameData.getFrame$1(value).get$uuid()));
          this.cachedTint = 16777215;
          this._frame = value;
        }
      }
    }, null, null, 3, 0, 60, 100, [], "frame"],
    get$frameName: [function() {
      return this._frameName;
    }, null, null, 1, 0, 782, "frameName"],
    set$frameName: [function(value) {
      var frameData;
      if (!J.$eq(value, this._frameName) && this.get$game().get$cache().isSpriteSheet$1(this.key) === true) {
        frameData = this.get$game().get$cache().getFrameData$1(this.key);
        if (frameData != null && frameData.getFrameByName$1(value) != null) {
          this.set$texture(J.$index$asx($.get$TextureCache(), frameData.getFrameByName$1(value).get$uuid()));
          this.cachedTint = 16777215;
          this._frameName = value;
        }
      }
    }, null, null, 3, 0, 52, 100, [], "frameName"],
    get$renderOrderID: [function() {
      return J.$index$asx(this._cache, 3);
    }, null, null, 1, 0, 367, "renderOrderID"],
    get$inputEnabled: [function() {
      var t1 = this.input;
      return t1 != null && t1.get$enabled() === true;
    }, null, null, 1, 0, 209, "inputEnabled"],
    set$inputEnabled: [function(value) {
      var t1;
      if (value === true) {
        t1 = this.input;
        if (t1 == null) {
          t1 = R.InputHandler$(this);
          this.input = t1;
          t1.start$0(0);
        } else if (t1.get$enabled() !== true)
          J.start$0$x(this.input);
      } else {
        t1 = this.input;
        if (t1 != null && t1.get$enabled() === true)
          J.stop$0$x(this.input);
      }
    }, null, null, 3, 0, 650, 100, [], "inputEnabled"],
    get$fixedToCamera: [function() {
      return J.$eq(J.$index$asx(this._cache, 7), 1);
    }, null, null, 1, 0, 209, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.get$cameraOffset().set$2(J.get$x$x(this.position), J.get$y$x(this.position));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 650, 100, [], "fixedToCamera"],
    get$smoothed: [function() {
      return J.$eq(this.get$texture().get$baseTexture().get$scaleMode(), 0);
    }, null, null, 1, 0, 209, "smoothed"],
    set$smoothed: [function(value) {
      if (value === true) {
        if (this.get$texture() != null)
          this.get$texture().get$baseTexture().set$scaleMode(C.scaleModes_0);
      } else if (this.get$texture() != null)
        this.get$texture().get$baseTexture().set$scaleMode(C.scaleModes_1);
    }, null, null, 3, 0, 650, 100, [], "smoothed"],
    get$destroyPhase: [function() {
      return J.$eq(J.$index$asx(this._cache, 8), 1);
    }, null, null, 1, 0, 209, "destroyPhase"],
    preUpdate$0: [function() {
      var t1, t2, t3, len, i;
      J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
      J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
      J.$indexSet$ax(this._cache, 2, this.rotation);
      if (this.exists !== true || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        J.$indexSet$ax(this._cache, 3, -1);
        return false;
      }
      if (this.autoCull === true)
        this.renderable = J.intersects$1$x(this.get$game().get$world().get$camera().get$screenView(), this.getBounds$0());
      this.world.setTo$2(J.$add$ns(J.get$x$x(this.get$game().get$camera()), J.$index$asx(this._worldTransform, 2)), J.$add$ns(J.get$y$x(this.get$game().get$camera()), J.$index$asx(this._worldTransform, 5)));
      if (this.visible === true) {
        t1 = this._cache;
        t2 = this.get$game().get$stage();
        t3 = t2.get$currentRenderOrderID();
        t2.set$currentRenderOrderID(J.$add$ns(t3, 1));
        J.$indexSet$ax(t1, 3, t3);
      }
      len = J.get$length$asx(this.Phaser$Image$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Image$children, i).preUpdate$0();
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 13, "update"],
    postUpdate$0: [function() {
      var t1, len, i;
      t1 = this.key;
      if (!!J.getInterceptor(t1).$isBitmapData)
        H.interceptedTypeCast(t1, "$isBitmapData").render$0();
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.position, J.$div$n(J.$add$ns(J.get$x$x(J.get$view$x(this.get$game().get$camera())), J.get$x$x(this.get$cameraOffset())), J.get$x$x(J.get$scale$x(this.get$game().get$camera()))));
        J.set$y$x(this.position, J.$div$n(J.$add$ns(J.get$y$x(J.get$view$x(this.get$game().get$camera())), J.get$y$x(this.get$cameraOffset())), J.get$y$x(J.get$scale$x(this.get$game().get$camera()))));
      }
      len = J.get$length$asx(this.Phaser$Image$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Image$children, i).postUpdate$0();
    }, "call$0", "get$postUpdate", 0, 0, 13, "postUpdate"],
    loadTexture$2: [function(key, frame) {
      var t1, frameData;
      this.key = key;
      t1 = J.getInterceptor(key);
      if (!!t1.$isRenderTexture) {
        this.key = key.key;
        this.set$texture(key);
        this.cachedTint = 16777215;
      } else if (!!t1.$isBitmapData) {
        this.key = key;
        this.set$texture(key.texture);
        this.cachedTint = 16777215;
      } else if (!!t1.$isTexture) {
        this.key = key;
        this.set$texture(key);
        this.cachedTint = 16777215;
      } else if (key == null) {
        this.key = "__default";
        this.set$texture(J.$index$asx($.get$TextureCache(), "__default"));
        this.cachedTint = 16777215;
      } else if (typeof key === "string" && !this.get$game().get$cache().checkImageKey$1(key)) {
        window;
        t1 = C.JSString_methods.$add("Texture with key '", key) + "' not found.";
        if (typeof console != "undefined")
          console.warn(t1);
        this.key = "__missing";
        this.set$texture(J.$index$asx($.get$TextureCache(), "__missing"));
        this.cachedTint = 16777215;
      } else if (this.get$game().get$cache().isSpriteSheet$1(key) === true) {
        frameData = this.get$game().get$cache().getFrameData$1(key);
        if (typeof frame === "string") {
          this._frame = 0;
          this._frameName = frame;
          this.key = key;
          this.set$texture(M.Texture$(J.$index$asx($.get$BaseTextureCache(), key), frameData.getFrameByName$1(frame)));
          this.cachedTint = 16777215;
        } else {
          this._frame = frame;
          this._frameName = "";
          this.key = key;
          this.set$texture(M.Texture$(J.$index$asx($.get$BaseTextureCache(), key), frameData.getFrame$1(frame)));
          this.cachedTint = 16777215;
        }
      } else {
        this.key = key;
        this.set$texture(M.Texture$(J.$index$asx($.get$BaseTextureCache(), key), null));
        this.cachedTint = 16777215;
      }
    }, function(key) {
      return this.loadTexture$2(key, 0);
    }, "loadTexture$1", "call$2", "call$1", "get$loadTexture", 2, 2, 862, 5, 231, [], 178, [], "loadTexture"],
    revive$0: [function() {
      this.alive = true;
      this.exists = true;
      this.visible = true;
      var t1 = this.events;
      if (t1 != null)
        t1.get$onRevived().dispatch$1(this);
      return this;
    }, "call$0", "get$revive", 0, 0, 13, "revive"],
    reset$2: [function(_, x, y) {
      this.world.setTo$2(x, y);
      J.set$x$x(this.position, x);
      J.set$y$x(this.position, y);
      this.alive = true;
      this.exists = true;
      this.visible = true;
      this.renderable = true;
      return this;
    }, "call$2", "get$reset", 4, 0, 935, 6, [], 7, [], "reset"],
    Image$5: function(game, x, y, key, frame) {
      var t1;
      this.set$game(this.get$game());
      this.exists = true;
      this.set$name(0, "");
      this.set$type(0, 2);
      this.z = 0;
      this.events = R.Events$(this);
      this.key = key;
      this.position.set$2(x, y);
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.world = t1;
      this.autoCull = false;
      this.input = null;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.set$cameraOffset(t1);
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.Phaser$Image$anchor = t1;
      this.cropRect = null;
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
      this._crop = null;
      this._frame = null;
      this._Phaser$_bounds = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      this._frameName = "";
      this.loadTexture$2(key, frame);
    },
    $isImage: true,
    $isSpriteInterface: true,
    $isGameObject: true,
    static: {Image$: [function(game, x, y, key, frame) {
        var t1, t2, t3, t4, t5, t6;
        t1 = J.$index$asx($.get$TextureCache(), "__default");
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t2 = new R.Image(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, [], null, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t2.texture = t1;
        t2._setupTexture$0();
        t2.Image$5(game, x, y, key, frame);
        return t2;
      }, null, null, 2, 8, 283, 5, 5, 32, 32, 214, [], 6, [], 7, [], 231, [], 178, [], "new Image"]}
  },
  "+Image": [643, 1139, 2],
  Particle: {
    "^": "Sprite0;autoScale@-602,scaleData@-1182,_s@-599,autoAlpha@-602,alphaData@-1182,_a@-599,game-598,key-32,name-639,type-601,z-601,events-1018,animations-1183,_frameName-639,world-600,autoCull-602,input-1111,body-1117,alive-602,health-601,checkWorldBounds-602,outOfBoundsKill-602,debug-602,cameraOffset-600,cropRect-974,_cache-681,_crop-974,_frame-974,_Phaser$_bounds-974,lifespan-601,_Phaser$_dirty-602,__tilePattern-794,tilingTexture-670,camerOffset-600,Phaser$Sprite0$children-1058,_Phaser$_currentBounds-974,Phaser$Sprite0$anchor-600,Phaser$Sprite0$position-600,_outOfBoundsFired-602,anchor-634,texture-670,updateFrame-602,PIXI$Sprite$_width-601,PIXI$Sprite$_height-601,_uvs-671,tintedTexture-672,buffer-673,tint-599,cachedTint-599,blendMode-674,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    update$0: [function() {
      if (this.autoScale === true) {
        var t1 = J.$sub$n(this._s, 1);
        this._s = t1;
        if (J.$ge$n(t1, 0))
          this.scale.set$2(J.$index$asx(J.$index$asx(this.scaleData, this._s), "x"), J.$index$asx(J.$index$asx(this.scaleData, this._s), "y"));
        else
          this.autoScale = false;
      }
      if (this.autoAlpha === true) {
        t1 = J.$sub$n(this._a, 1);
        this._a = t1;
        if (J.$ge$n(t1, 0))
          this.alpha = J.$index$asx(J.$index$asx(this.alphaData, this._a), "v");
        else
          this.autoAlpha = false;
      }
    }, "call$0", "get$update", 0, 0, 13, "update"],
    onEmit$0: [function() {
    }, "call$0", "get$onEmit", 0, 0, 13, "onEmit"],
    setAlphaData$1: [function(data) {
      var t1;
      this.alphaData = data;
      t1 = J.$sub$n(J.get$length$asx(data), 1);
      this._a = t1;
      this.alpha = J.$index$asx(J.$index$asx(this.alphaData, t1), "v");
      this.autoAlpha = true;
    }, "call$1", "get$setAlphaData", 2, 0, 1184, 48, [], "setAlphaData"],
    setScaleData$1: [function(data) {
      var t1;
      this.scaleData = data;
      t1 = J.$sub$n(J.get$length$asx(data), 1);
      this._s = t1;
      this.scale.set$2(J.$index$asx(J.$index$asx(this.scaleData, t1), "x"), J.$index$asx(J.$index$asx(this.scaleData, this._s), "y"));
      this.autoScale = true;
    }, "call$1", "get$setScaleData", 2, 0, 1184, 48, [], "setScaleData"],
    reset$3: [function(_, x, y, health) {
      var t1;
      if (health == null)
        health = 1;
      this.world.setTo$2(x, y);
      J.set$x$x(this.Phaser$Sprite0$position, x);
      J.set$y$x(this.Phaser$Sprite0$position, y);
      this.alive = true;
      this.set$exists(true);
      this.visible = true;
      this.renderable = true;
      this._outOfBoundsFired = false;
      this.health = health;
      t1 = this.body;
      if (t1 != null)
        J.reset$4$x(t1, x, y, false, false);
      J.$indexSet$ax(this._cache, 4, 1);
      this.alpha = 1;
      this.scale.set$1(1);
      this.autoScale = false;
      this.autoAlpha = false;
      return this;
    }, function($receiver, x, y) {
      return this.reset$3($receiver, x, y, 1);
    }, "reset$2", "call$3", "call$2", "get$reset", 4, 2, 1185, 390, 6, [], 7, [], 1186, [], "reset"],
    Particle$5: function(game, x, y, key, frame) {
      this.autoScale = false;
      this.scaleData = null;
      this._s = 0;
      this.autoAlpha = false;
      this.alphaData = null;
      this._a = 0;
    },
    static: {Particle$: [function(game, x, y, key, frame) {
        var t1, t2, t3, t4, t5, t6, t7, t8;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new R.Point(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = J.$index$asx($.get$TextureCache(), "__default");
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = new M.Point0(null, null);
        t6.x = 1;
        t6.y = 1;
        t7 = new M.Point0(null, null);
        t7.x = 0;
        t7.y = 0;
        t8 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new R.Particle(null, null, null, null, null, null, game, null, null, null, null, null, null, null, null, null, null, null, null, null, false, false, false, null, null, null, null, null, null, null, false, null, null, null, [], null, t1, t2, false, t4, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t5, t6, t7, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t8, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.texture = t3;
        t1._setupTexture$0();
        t1.Sprite$5(game, x, y, key, frame);
        t1.Particle$5(game, x, y, key, frame);
        return t1;
      }, null, null, 10, 0, 284, 214, [], 6, [], 7, [], 231, [], 178, [], "new Particle"]}
  },
  "+Particle": [937],
  RenderTexture: {
    "^": "RenderTexture0;key*-639,type*-599,_temp@-600,game@-598,renderer-809,PIXI$RenderTexture0$width-599,PIXI$RenderTexture0$height-599,PIXI$RenderTexture0$frame-641,PIXI$RenderTexture0$scaleMode-865,PIXI$RenderTexture0$baseTexture-826,textureBuffer-32,projection-634,render-925,PIXI$RenderTexture0$valid-602,noFrame-602,updateFrame-602,frame-641,trim-641,scope-826,_uvs-671,valid-602,baseTexture-826,PIXI$Texture$width-601,PIXI$Texture$height-601,sourceWidth-601,sourceHeight-601,tintCache-754,needsUpdate-602,isTiling-602,canvasBuffer-673,crop-641,id-599,width-601,height-601,scaleMode-865,_hasLoaded-602,source-32,_glTextures-922,imageUrl-639,_powerOf2-602,onLoaded-923,premultipliedAlpha-602,_dirty-754,listeners-821",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    renderXY$4: [function(displayObject, x, y, clear) {
      this._temp.set$2(x, y);
      this.render$3(displayObject, this._temp, clear);
    }, "call$4", "get$renderXY", 8, 0, 1187, 805, [], 6, [], 7, [], 930, [], "renderXY"],
    RenderTexture$5: function(game, width, height, key, scaleMode) {
      var t1;
      this.game = game;
      if (key == null)
        key = "";
      if (scaleMode == null)
        ;
      this.game = game;
      this.key = key;
      this.type = 8;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this._temp = t1;
    },
    $isRenderTexture: true,
    static: {RenderTexture$: [function(game, width, height, key, scaleMode) {
        var t1, t2, t3;
        t1 = game.get$renderer();
        t2 = M.BaseTexture$(null, C.scaleModes_0);
        t3 = $.BaseTextureCacheIdGenerator;
        $.BaseTextureCacheIdGenerator = J.$add$ns(t3, 1);
        t3 = new R.RenderTexture(null, null, null, null, t1, width, height, null, scaleMode, t2, null, null, null, null, false, false, null, null, null, null, false, null, 0, 0, 0, 0, null, true, null, null, null, t3, 100, 100, C.scaleModes_0, false, null, P.LinkedHashMap_LinkedHashMap(null, null, null, P.RenderingContext, null), null, false, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t3.BaseTexture$2(null, C.scaleModes_0);
        t3.scope = t3;
        t3.RenderTexture$4(width, height, t1, scaleMode);
        t3.RenderTexture$5(game, width, height, key, scaleMode);
        return t3;
      }, null, null, 6, 4, 285, 32, 32, 214, [], 10, [], 11, [], 231, [], 35, [], "new RenderTexture"]}
  },
  "+RenderTexture": [679],
  RetroFont: {
    "^": "RenderTexture;characterWidth@-601,characterHeight@-601,characterSpacingX@-601,characterSpacingY@-601,characterPerRow@-601,offsetX@-601,offsetY@-601,align@-639,multiLine@-602,autoUpperCase@-602,customSpacingX@-601,customSpacingY@-601,fixedWidth@-601,fontSet@-1188,stamp@-1135,_text@-639,grabData@-720,key-639,type-599,_temp-600,game-598,renderer-809,PIXI$RenderTexture0$width-599,PIXI$RenderTexture0$height-599,PIXI$RenderTexture0$frame-641,PIXI$RenderTexture0$scaleMode-865,PIXI$RenderTexture0$baseTexture-826,textureBuffer-32,projection-634,render-925,PIXI$RenderTexture0$valid-602,noFrame-602,updateFrame-602,frame-641,trim-641,scope-826,_uvs-671,valid-602,baseTexture-826,PIXI$Texture$width-601,PIXI$Texture$height-601,sourceWidth-601,sourceHeight-601,tintCache-754,needsUpdate-602,isTiling-602,canvasBuffer-673,crop-641,id-599,width-601,height-601,scaleMode-865,_hasLoaded-602,source-32,_glTextures-922,imageUrl-639,_powerOf2-602,onLoaded-923,premultipliedAlpha-602,_dirty-754,listeners-821",
    get$text: [function(_) {
      return this._text;
    }, null, null, 1, 0, 782, "text"],
    text$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.get$text(this).call$4(arg0, arg1, arg2, arg3);
    },
    text$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.get$text(this).call$5(arg0, arg1, arg2, arg3, arg4);
    },
    text$3: function($receiver, arg0, arg1, arg2) {
      return this.get$text(this).call$3(arg0, arg1, arg2);
    },
    set$text: [function(_, value) {
      var newText = this.autoUpperCase === true ? J.toUpperCase$0$s(value) : value;
      if (!J.$eq(newText, this._text)) {
        this._text = newText;
        this.removeUnsupportedCharacters$1(this.multiLine);
        this.buildRetroFontText$0();
      }
    }, null, null, 3, 0, 52, 100, [], "text"],
    get$smoothed: [function() {
      return this.stamp.get$smoothed();
    }, null, null, 1, 0, 209, "smoothed"],
    set$smoothed: [function(value) {
      this.stamp.set$smoothed(value);
      this.buildRetroFontText$0();
    }, null, null, 3, 0, 650, 100, [], "smoothed"],
    setFixedWidth$2: [function(width, lineAlignment) {
      if (lineAlignment == null)
        lineAlignment = "left";
      this.fixedWidth = width;
      this.align = lineAlignment;
    }, function(width) {
      return this.setFixedWidth$2(width, "left");
    }, "setFixedWidth$1", "call$2", "call$1", "get$setFixedWidth", 2, 2, 1189, 160, 10, [], 1190, [], "setFixedWidth"],
    setText$6: [function($content, multiLine, characterSpacing, lineSpacing, lineAlignment, allowLowerCase) {
      if (allowLowerCase === true)
        this.autoUpperCase = false;
      else
        this.autoUpperCase = true;
      if (J.$gt$n(J.get$length$asx($content), 0))
        this.set$text(0, $content);
    }, function(content) {
      return this.setText$6(content, false, 0, 0, "left", false);
    }, "setText$1", function(content, multiLine) {
      return this.setText$6(content, multiLine, 0, 0, "left", false);
    }, "setText$2", function(content, multiLine, characterSpacing) {
      return this.setText$6(content, multiLine, characterSpacing, 0, "left", false);
    }, "setText$3", function(content, multiLine, characterSpacing, lineSpacing) {
      return this.setText$6(content, multiLine, characterSpacing, lineSpacing, "left", false);
    }, "setText$4", function(content, multiLine, characterSpacing, lineSpacing, lineAlignment) {
      return this.setText$6(content, multiLine, characterSpacing, lineSpacing, lineAlignment, false);
    }, "setText$5", "call$6", "call$1", "call$2", "call$3", "call$4", "call$5", "get$setText", 2, 10, 1191, 95, 5, 5, 160, 95, 188, [], 1192, [], 1193, [], 1194, [], 1190, [], 1195, [], "setText"],
    buildRetroFontText$0: [function() {
      var lines, t1, t2, t3, t4, cx, cy, i;
      this.clear$0(0);
      if (this.multiLine === true) {
        lines = J.split$1$s(this._text, "\n");
        if (J.$gt$n(this.fixedWidth, 0)) {
          t1 = this.fixedWidth;
          t2 = lines.length;
          t3 = J.$add$ns(this.characterHeight, this.customSpacingY);
          if (typeof t3 !== "number")
            return H.iae(t3);
          t4 = this.customSpacingY;
          if (typeof t4 !== "number")
            return H.iae(t4);
          this.resize$3(0, t1, t2 * t3 - t4, true);
        } else {
          t1 = J.$mul$ns(this.getLongestLine$0(), J.$add$ns(this.characterWidth, this.customSpacingX));
          t2 = lines.length;
          t3 = J.$add$ns(this.characterHeight, this.customSpacingY);
          if (typeof t3 !== "number")
            return H.iae(t3);
          t4 = this.customSpacingY;
          if (typeof t4 !== "number")
            return H.iae(t4);
          this.resize$3(0, t1, t2 * t3 - t4, true);
        }
        for (cx = 0, cy = 0, i = 0; i < lines.length; ++i) {
          switch (this.align) {
            case "left":
              cx = 0;
              break;
            case "right":
              cx = J.$sub$n(this.PIXI$RenderTexture0$width, J.$mul$ns(J.get$length$asx(lines[i]), J.$add$ns(this.characterWidth, this.customSpacingX)));
              break;
            case "center":
              t1 = J.$div$n(this.PIXI$RenderTexture0$width, 2);
              if (i >= lines.length)
                return H.ioore(lines, i);
              cx = J.$add$ns(J.$sub$n(t1, J.$div$n(J.$mul$ns(J.get$length$asx(lines[i]), J.$add$ns(this.characterWidth, this.customSpacingX)), 2)), J.$div$n(this.customSpacingX, 2));
              break;
          }
          if (J.$lt$n(cx, 0))
            cx = 0;
          if (i >= lines.length)
            return H.ioore(lines, i);
          this.pasteLine$4(lines[i], cx, cy, this.customSpacingX);
          t1 = J.$add$ns(this.characterHeight, this.customSpacingY);
          if (typeof t1 !== "number")
            return H.iae(t1);
          cy += t1;
        }
      } else {
        if (J.$gt$n(this.fixedWidth, 0))
          this.resize$3(0, this.fixedWidth, this.characterHeight, true);
        else
          this.resize$3(0, J.$mul$ns(J.get$length$asx(this._text), J.$add$ns(this.characterWidth, this.customSpacingX)), this.characterHeight, true);
        switch (this.align) {
          case "left":
            cx = 0;
            break;
          case "right":
            cx = J.$sub$n(this.PIXI$RenderTexture0$width, J.$mul$ns(J.get$length$asx(this._text), J.$add$ns(this.characterWidth, this.customSpacingX)));
            break;
          case "center":
            cx = J.$add$ns(J.$sub$n(J.$div$n(this.PIXI$RenderTexture0$width, 2), J.$div$n(J.$mul$ns(J.get$length$asx(this._text), J.$add$ns(this.characterWidth, this.customSpacingX)), 2)), J.$div$n(this.customSpacingX, 2));
            break;
          default:
            cx = 0;
        }
        J.clear$0$ax(this.textureBuffer);
        this.pasteLine$4(this._text, cx, 0, this.customSpacingX);
      }
    }, "call$0", "get$buildRetroFontText", 0, 0, 13, "buildRetroFontText"],
    pasteLine$4: [function(line, x, y, customSpacingX) {
      var p, t1, t2, c, t3;
      p = new R.Point(null, null);
      p.x = 0;
      p.y = 0;
      t1 = J.getInterceptor$asx(line);
      t2 = y == null;
      c = 0;
      while (true) {
        t3 = t1.get$length(line);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(c < t3))
          break;
        if (J.$eq(t1.$index(line, c), " "))
          x = J.$add$ns(x, J.$add$ns(this.characterWidth, customSpacingX));
        else if (J.$ge$n(J.$index$asx(this.grabData, t1.codeUnitAt$1(line, c)), 0)) {
          this.stamp.set$frame(J.$index$asx(this.grabData, t1.codeUnitAt$1(line, c)));
          p.x = x;
          p.y = t2 ? x : y;
          this.render$3(this.stamp, p, false);
          x = J.$add$ns(x, J.$add$ns(this.characterWidth, customSpacingX));
          if (J.$gt$n(x, this.PIXI$RenderTexture0$width))
            break;
        }
        ++c;
      }
    }, "call$4", "get$pasteLine", 8, 0, 1196, 1197, [], 6, [], 7, [], 1198, [], "pasteLine"],
    getLongestLine$0: [function() {
      var lines, longestLine, i;
      if (J.$gt$n(J.get$length$asx(this._text), 0)) {
        lines = J.split$1$s(this._text, "\n");
        for (longestLine = 0, i = 0; i < lines.length; ++i)
          if (J.$gt$n(J.get$length$asx(lines[i]), longestLine)) {
            if (i >= lines.length)
              return H.ioore(lines, i);
            longestLine = J.get$length$asx(lines[i]);
          }
      } else
        longestLine = 0;
      return longestLine;
    }, "call$0", "get$getLongestLine", 0, 0, 604, "getLongestLine"],
    removeUnsupportedCharacters$1: [function(stripCR) {
      var t1, newString, c, t2, aChar, code;
      t1 = stripCR !== true;
      newString = "";
      c = 0;
      while (true) {
        t2 = J.get$length$asx(this._text);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(c < t2))
          break;
        aChar = J.$index$asx(this._text, c);
        t2 = J.getInterceptor$s(aChar);
        code = t2.codeUnitAt$1(aChar, 0);
        if (!J.$ge$n(J.$index$asx(this.grabData, code), 0))
          t2 = t1 && t2.$eq(aChar, "\n");
        else
          t2 = true;
        if (t2)
          newString = C.JSString_methods.$add(newString, aChar);
        ++c;
      }
      return newString;
    }, "call$1", "get$removeUnsupportedCharacters", 2, 0, 1199, 1200, [], "removeUnsupportedCharacters"],
    updateOffset$2: [function(x, y) {
      var diffX, diffY, $frames, t1, i, i0, t2, t3;
      if (J.$eq(this.offsetX, x) && J.$eq(this.offsetY, y))
        return;
      diffX = J.$sub$n(x, this.offsetX);
      diffY = J.$sub$n(y, this.offsetY);
      $frames = this.game.get$cache().getFrameData$1(J.get$key$x(this.stamp)).getFrames$0();
      t1 = J.getInterceptor$asx($frames);
      i = t1.get$length($frames);
      for (; i0 = J.$sub$n(i, 1), i === true; i = i0) {
        t2 = t1.$index($frames, i0);
        t3 = J.getInterceptor$x(t2);
        t3.set$x(t2, J.$add$ns(t3.get$x(t2), diffX));
        t2 = t1.$index($frames, i0);
        t3 = J.getInterceptor$x(t2);
        t3.set$y(t2, J.$add$ns(t3.get$y(t2), diffY));
        J.set$x$x(J.$index$asx($.get$TextureCache(), t1.$index($frames, i0).get$uuid()).get$frame(), J.get$x$x(t1.$index($frames, i0)));
        J.set$y$x(J.$index$asx($.get$TextureCache(), t1.$index($frames, i0).get$uuid()).get$frame(), J.get$y$x(t1.$index($frames, i0)));
      }
      this.buildRetroFontText$0();
    }, function() {
      return this.updateOffset$2(0, 0);
    }, "updateOffset$0", function(x) {
      return this.updateOffset$2(x, 0);
    }, "updateOffset$1", "call$2", "call$0", "call$1", "get$updateOffset", 0, 4, 16, 5, 5, 6, [], 7, [], "updateOffset"],
    RetroFont$10: function(game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
      var currentX, currentY, data, t1, r, c, t2, uuid, t3, t4, frame;
      if (!game.get$cache().checkImageKey$1(key))
        throw H.wrapException(P.Exception_Exception("error!"));
      if (charsPerRow == null || false)
        charsPerRow = J.$div$n(J.get$width$x(game.get$cache().getImage$1(key)), characterWidth);
      this.characterWidth = characterWidth;
      this.characterHeight = characterHeight;
      this.characterSpacingX = xSpacing;
      this.characterSpacingY = ySpacing;
      this.characterPerRow = charsPerRow;
      this.offsetX = xOffset;
      this.offsetY = yOffset;
      this.align = "left";
      this.multiLine = false;
      this.autoUpperCase = true;
      this.customSpacingX = 0;
      this.customSpacingY = 0;
      this.fixedWidth = 0;
      this.fontSet = game.get$cache().getImage$1(key);
      this._text = "";
      this.grabData = [];
      currentX = this.offsetX;
      currentY = this.offsetY;
      data = new R.FrameData([], P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      t1 = J.getInterceptor$asx(chars);
      r = 0;
      c = 0;
      while (true) {
        t2 = t1.get$length(chars);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(c < t2))
          break;
        uuid = game.get$rnd().uuid$0();
        t2 = this.characterWidth;
        t3 = this.characterHeight;
        t4 = new R.Frame(c, currentX, currentY, t2, t3, "", uuid, null, null, null, false, "cw", false, null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        t4.centerX = J.floor$0$n(J.$div$n(t2, 2));
        t4.centerY = J.floor$0$n(J.$div$n(t3, 2));
        t4.sourceSizeW = t2;
        t4.sourceSizeH = t3;
        frame = data.addFrame$1(t4);
        J.$indexSet$ax(this.grabData, t1.codeUnitAt$1(chars, c), J.get$index$x(frame));
        t4 = $.get$TextureCache();
        t3 = J.$index$asx($.get$BaseTextureCache(), key);
        t2 = new M.Rectangle0(0, 0, 0, 0);
        t2.x = currentX;
        t2.y = currentY;
        t2.width = this.characterWidth;
        t2.height = this.characterHeight;
        J.$indexSet$ax(t4, uuid, M.Texture$(t3, t2));
        ++r;
        if (r === this.characterPerRow) {
          currentX = this.offsetX;
          currentY = J.$add$ns(currentY, J.$add$ns(this.characterHeight, this.characterSpacingY));
          r = 0;
        } else
          currentX = J.$add$ns(currentX, J.$add$ns(this.characterWidth, this.characterSpacingX));
        ++c;
      }
      game.get$cache().updateFrameData$2(key, data);
      this.stamp = R.Image$(game, 0, 0, key, 0);
      this.type = 17;
    },
    static: {"^": "RetroFont_ALIGN_LEFT<-639,RetroFont_ALIGN_RIGHT<-639,RetroFont_ALIGN_CENTER<-639,RetroFont_TEXT_SET1<-639,RetroFont_TEXT_SET2<-639,RetroFont_TEXT_SET3<-639,RetroFont_TEXT_SET4<-639,RetroFont_TEXT_SET5<-639,RetroFont_TEXT_SET6<-639,RetroFont_TEXT_SET7<-639,RetroFont_TEXT_SET8<-639,RetroFont_TEXT_SET9<-639,RetroFont_TEXT_SET10<-639,RetroFont_TEXT_SET11<-639", RetroFont$: [function(game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
        var t1, t2, t3;
        t1 = game.get$renderer();
        t2 = M.BaseTexture$(null, C.scaleModes_0);
        t3 = $.BaseTextureCacheIdGenerator;
        $.BaseTextureCacheIdGenerator = J.$add$ns(t3, 1);
        t3 = new R.RetroFont(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, t1, 100, 100, null, C.scaleModes_2, t2, null, null, null, null, false, false, null, null, null, null, false, null, 0, 0, 0, 0, null, true, null, null, null, t3, 100, 100, C.scaleModes_0, false, null, P.LinkedHashMap_LinkedHashMap(null, null, null, P.RenderingContext, null), null, false, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t3.BaseTexture$2(null, C.scaleModes_0);
        t3.scope = t3;
        t3.RenderTexture$4(100, 100, t1, C.scaleModes_2);
        t3.RenderTexture$5(game, 100, 100, "", C.scaleModes_2);
        t3.RetroFont$10(game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);
        return t3;
      }, null, null, 10, 10, 286, 32, 32, 32, 32, 32, 214, [], 231, [], 287, [], 288, [], 289, [], 290, [], 291, [], 292, [], 293, [], 294, [], "new RetroFont"]}
  },
  "+RetroFont": [1201],
  Sprite0: {
    "^": "Sprite;game@-598,key*-32,name*-639,type*-601,z*-601,events@-1018,animations@-1183,_frameName@-639,world@-600,autoCull@-602,input@-1111,body*-1117,alive@-602,health@-601,checkWorldBounds@-602,outOfBoundsKill@-602,debug@-602,cameraOffset@-600,cropRect@-974,_cache@-681,_crop@-974,_frame@-974,_Phaser$_bounds@-974,lifespan@-601,_Phaser$_dirty@-602,__tilePattern@-794,tilingTexture@-670,camerOffset@-600,children:Phaser$Sprite0$children*-1058,_Phaser$_currentBounds@-974,anchor:Phaser$Sprite0$anchor@-600,position:Phaser$Sprite0$position*-600,_outOfBoundsFired@-602,anchor-634,texture-670,updateFrame-602,PIXI$Sprite$_width-601,PIXI$Sprite$_height-601,_uvs-671,tintedTexture-672,buffer-673,tint-599,cachedTint-599,blendMode-674,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.body.call$3(arg0, arg1, arg2);
    },
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 281, "parent"],
    get$angle: [function() {
      return R.Math_wrapAngle(J.$mul$ns(this.rotation, 57.29577951308232), false);
    }, null, null, 1, 0, 604, "angle"],
    angle$0: function() {
      return this.get$angle().call$0();
    },
    angle$2: function(arg0, arg1) {
      return this.get$angle().call$2(arg0, arg1);
    },
    set$angle: [function(value) {
      this.rotation = R.Math_wrapAngle(value, false) * 0.017453292519943295;
    }, null, null, 3, 0, 605, 100, [], "angle"],
    get$deltaX: [function(_) {
      return J.$sub$n(J.get$x$x(this.world), J.$index$asx(this._cache, 0));
    }, null, null, 1, 0, 604, "deltaX"],
    deltaX$0: function($receiver) {
      return this.get$deltaX(this).call$0();
    },
    get$deltaY: [function(_) {
      return J.$sub$n(J.get$y$x(this.world), J.$index$asx(this._cache, 1));
    }, null, null, 1, 0, 604, "deltaY"],
    deltaY$0: function($receiver) {
      return this.get$deltaY(this).call$0();
    },
    get$deltaZ: [function(_) {
      return J.$sub$n(this.rotation, J.$index$asx(this._cache, 2));
    }, null, null, 1, 0, 604, "deltaZ"],
    get$inWorld: [function() {
      var t1, t2;
      t1 = this.game.get$world().get$bounds();
      t2 = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      t2.copyFrom$1(new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.Sprite.prototype.getBounds$1.call(this, null)));
      return J.intersects$1$x(t1, t2);
    }, null, null, 1, 0, 209, "inWorld"],
    get$inCamera: [function() {
      var t1, t2;
      t1 = this.game.get$world().get$camera().get$screenView();
      t2 = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      t2.copyFrom$1(new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.Sprite.prototype.getBounds$1.call(this, null)));
      return J.intersects$1$x(t1, t2);
    }, null, null, 1, 0, 209, "inCamera"],
    get$frame: [function() {
      return this.animations.get$frame();
    }, null, null, 1, 0, 367, "frame"],
    set$frame: [function(value) {
      this.animations.set$frame(value);
    }, null, null, 3, 0, 60, 100, [], "frame"],
    get$frameName: [function() {
      return this.animations.get$frameName();
    }, null, null, 1, 0, 782, "frameName"],
    set$frameName: [function(value) {
      this.animations.set$frameName(value);
    }, null, null, 3, 0, 52, 100, [], "frameName"],
    get$renderOrderID: [function() {
      return J.$index$asx(this._cache, 3);
    }, null, null, 1, 0, 604, "renderOrderID"],
    get$inputEnabled: [function() {
      var t1 = this.input;
      return t1 != null && t1.get$enabled() === true;
    }, null, null, 1, 0, 209, "inputEnabled"],
    set$inputEnabled: [function(value) {
      var t1;
      if (value === true) {
        t1 = this.input;
        if (t1 == null) {
          t1 = R.InputHandler$(this);
          this.input = t1;
          t1.start$0(0);
        } else if (t1.get$enabled() !== true)
          J.start$0$x(this.input);
      } else {
        t1 = this.input;
        if (t1 != null && t1.get$enabled() === true)
          J.stop$0$x(this.input);
      }
    }, null, null, 3, 0, 650, 100, [], "inputEnabled"],
    get$exists: [function() {
      return J.$eq(J.$index$asx(this._cache, 6), 1);
    }, null, null, 1, 0, 209, "exists"],
    set$exists: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 6, 1);
        t1 = this.body;
        if (t1 != null && J.$eq(J.get$type$x(t1), 1))
          this.body.addToWorld$0();
        this.visible = true;
      } else {
        J.$indexSet$ax(t1, 6, 0);
        t1 = this.body;
        if (t1 != null && J.$eq(J.get$type$x(t1), 1))
          this.body.removeFromWorld$0();
        this.visible = false;
      }
    }, null, null, 3, 0, 650, 100, [], "exists"],
    get$fixedToCamera: [function() {
      return J.$eq(J.$index$asx(this._cache, 7), 1);
    }, null, null, 1, 0, 209, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.cameraOffset.set$2(J.get$x$x(this.Phaser$Sprite0$position), J.get$y$x(this.Phaser$Sprite0$position));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 650, 100, [], "fixedToCamera"],
    get$smoothed: [function() {
      return J.$eq(this.texture.get$baseTexture().get$scaleMode(), C.scaleModes_0);
    }, null, null, 1, 0, 209, "smoothed"],
    set$smoothed: [function(value) {
      var t1;
      if (value === true) {
        t1 = this.texture;
        if (t1 != null)
          t1.get$baseTexture().set$scaleMode(C.scaleModes_0);
      } else {
        t1 = this.texture;
        if (t1 != null)
          t1.get$baseTexture().set$scaleMode(C.scaleModes_1);
      }
    }, null, null, 3, 0, 650, 100, [], "smoothed"],
    get$x: [function(_) {
      return J.get$x$x(this.Phaser$Sprite0$position);
    }, null, null, 1, 0, 604, "x"],
    set$x: [function(_, value) {
      var t1;
      J.set$x$x(this.Phaser$Sprite0$position, value);
      t1 = this.body;
      if (t1 != null && J.$eq(J.get$type$x(t1), 0) && J.$eq(this.body.get$phase(), 2))
        this.body.set$_reset(true);
    }, null, null, 3, 0, 605, 100, [], "x"],
    get$y: [function(_) {
      return J.get$y$x(this.Phaser$Sprite0$position);
    }, null, null, 1, 0, 604, "y"],
    set$y: [function(_, value) {
      var t1;
      J.set$y$x(this.Phaser$Sprite0$position, value);
      t1 = this.body;
      if (t1 != null && J.$eq(J.get$type$x(t1), 0) && J.$eq(this.body.get$phase(), 2))
        this.body.set$_reset(true);
    }, null, null, 3, 0, 605, 100, [], "y"],
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(J.get$x$x(this.Phaser$Sprite0$position), J.$div$n(J.$mul$ns(J.get$x$x(this.scale), J.get$width$x(this.texture.get$frame())), 2));
      t2 = J.$add$ns(J.get$y$x(this.Phaser$Sprite0$position), J.$div$n(J.$mul$ns(J.get$y$x(this.scale), J.get$height$x(this.texture.get$frame())), 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1019, "center"],
    get$destroyPhase: [function() {
      return J.$eq(J.$index$asx(this._cache, 8), 1);
    }, null, null, 1, 0, 209, "destroyPhase"],
    get$fresh: [function() {
      return J.$eq(J.$index$asx(this._cache, 4), 1);
    }, null, null, 1, 0, 209, "fresh"],
    preUpdate$0: [function() {
      var t1, t2, t3, len, i;
      if (J.$eq(J.$index$asx(this._cache, 4), 1) && J.$eq(J.$index$asx(this._cache, 6), 1)) {
        this.world.setTo$2(J.$add$ns(J.get$x$x(J.get$position$x(M.DisplayObject.prototype.get$parent.call(this, this))), J.get$x$x(this.Phaser$Sprite0$position)), J.$add$ns(J.get$y$x(J.get$position$x(M.DisplayObject.prototype.get$parent.call(this, this))), J.get$y$x(this.Phaser$Sprite0$position)));
        this._worldTransform.set$tx(J.toDouble$0$n(J.get$x$x(this.world)));
        this._worldTransform.set$ty(J.toDouble$0$n(J.get$y$x(this.world)));
        J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
        J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
        J.$indexSet$ax(this._cache, 2, this.rotation);
        t1 = this.body;
        if (t1 != null)
          t1.preUpdate$0();
        J.$indexSet$ax(this._cache, 4, 0);
        return false;
      }
      J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
      J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
      J.$indexSet$ax(this._cache, 2, this.rotation);
      if (!J.$eq(J.$index$asx(this._cache, 6), 1) || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        J.$indexSet$ax(this._cache, 3, -1);
        return false;
      }
      if (J.$gt$n(this.lifespan, 0)) {
        t1 = J.$sub$n(this.lifespan, this.game.get$time().get$elapsed());
        this.lifespan = t1;
        if (J.$le$n(t1, 0)) {
          this.kill$0();
          return false;
        }
      }
      if (this.autoCull === true || this.checkWorldBounds === true)
        this._Phaser$_bounds.copyFrom$1(new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.Sprite.prototype.getBounds$1.call(this, null)));
      if (this.autoCull === true)
        this.renderable = J.intersects$1$x(this.game.get$world().get$camera().get$screenView(), this._Phaser$_bounds);
      if (this.checkWorldBounds === true)
        if (J.$eq(J.$index$asx(this._cache, 5), 1) && J.intersects$1$x(this.game.get$world().get$bounds(), this._Phaser$_bounds) === true) {
          J.$indexSet$ax(this._cache, 5, 0);
          this.events.get$onEnterBounds().dispatch$1(this);
        } else if (J.$eq(J.$index$asx(this._cache, 5), 0) && J.intersects$1$x(this.game.get$world().get$bounds(), this._Phaser$_bounds) !== true) {
          J.$indexSet$ax(this._cache, 5, 1);
          this.events.get$onOutOfBounds().dispatch$1(this);
          if (this.outOfBoundsKill === true) {
            this.kill$0();
            return false;
          }
        }
      this.world.setTo$2(J.$add$ns(J.get$x$x(this.game.get$camera()), this._worldTransform.get$tx()), J.$add$ns(J.get$y$x(this.game.get$camera()), this._worldTransform.get$ty()));
      if (this.visible === true) {
        t1 = this._cache;
        t2 = this.game.get$stage();
        t3 = t2.get$currentRenderOrderID();
        t2.set$currentRenderOrderID(J.$add$ns(t3, 1));
        J.$indexSet$ax(t1, 3, t3);
      }
      this.animations.update$0();
      t1 = this.body;
      if (t1 != null)
        t1.preUpdate$0();
      len = J.get$length$asx(this.Phaser$Sprite0$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Sprite0$children, i).preUpdate$0();
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 13, "update"],
    postUpdate$0: [function() {
      var t1, len, i;
      t1 = this.key;
      if (!!J.getInterceptor(t1).$isBitmapData)
        H.interceptedTypeCast(t1, "$isBitmapData").render$0();
      if (J.$eq(J.$index$asx(this._cache, 6), 1) && this.body != null)
        this.body.postUpdate$0();
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.Phaser$Sprite0$position, J.$div$n(J.$add$ns(J.get$x$x(J.get$view$x(this.game.get$camera())), J.get$x$x(this.cameraOffset)), J.get$x$x(J.get$scale$x(this.game.get$camera()))));
        J.set$y$x(this.Phaser$Sprite0$position, J.$div$n(J.$add$ns(J.get$y$x(J.get$view$x(this.game.get$camera())), J.get$y$x(this.cameraOffset)), J.get$y$x(J.get$scale$x(this.game.get$camera()))));
      }
      len = J.get$length$asx(this.Phaser$Sprite0$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Sprite0$children, i).postUpdate$0();
    }, "call$0", "get$postUpdate", 0, 0, 13, "postUpdate"],
    loadTexture$3: [function(key, frame, stopAnimation) {
      var smoothed, t1, setFrame;
      if (J.$eq(stopAnimation, true))
        J.stop$0$x(this.animations);
      this.key = key;
      smoothed = J.$eq(this.texture.get$baseTexture().get$scaleMode(), C.scaleModes_0);
      t1 = J.getInterceptor(key);
      if (!!t1.$isRenderTexture) {
        this.key = key.key;
        this.texture = key;
        this.cachedTint = 16777215;
        setFrame = true;
      } else if (!!t1.$isBitmapData) {
        this.texture = key.texture;
        this.cachedTint = 16777215;
        setFrame = true;
      } else if (!!t1.$isTexture) {
        this.texture = key;
        this.cachedTint = 16777215;
        setFrame = true;
      } else if (key == null) {
        this.key = "__default";
        this.texture = J.$index$asx($.get$TextureCache(), "__default");
        this.cachedTint = 16777215;
        setFrame = true;
      } else if (typeof key === "string" && !this.game.get$cache().checkImageKey$1(key)) {
        window;
        t1 = C.JSString_methods.$add("Texture with key '", key) + "' not found.";
        if (typeof console != "undefined")
          console.warn(t1);
        this.key = "__missing";
        this.texture = J.$index$asx($.get$TextureCache(), "__missing");
        this.cachedTint = 16777215;
        setFrame = true;
      } else {
        this.texture = M.Texture$(J.$index$asx($.get$BaseTextureCache(), key), null);
        this.cachedTint = 16777215;
        setFrame = !this.animations.loadFrameData$2(this.game.get$cache().getFrameData$1(key), frame);
      }
      if (setFrame)
        this._frame = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(this.texture.get$frame());
      if (!smoothed)
        this.set$smoothed(false);
    }, function(key, frame) {
      return this.loadTexture$3(key, frame, true);
    }, "loadTexture$2", function(key) {
      return this.loadTexture$3(key, 0, true);
    }, "loadTexture$1", "call$3", "call$2", "call$1", "get$loadTexture", 2, 4, 1202, 5, 39, 231, [], 178, [], 1203, [], "loadTexture"],
    setFrame$1: [function(frame) {
      var t1, t2;
      this._frame = frame;
      t1 = J.getInterceptor$x(frame);
      J.set$x$x(this.texture.get$frame(), t1.get$x(frame));
      J.set$y$x(this.texture.get$frame(), t1.get$y(frame));
      J.set$width$x(this.texture.get$frame(), t1.get$width(frame));
      J.set$height$x(this.texture.get$frame(), t1.get$height(frame));
      J.set$x$x(this.texture.get$crop(), t1.get$x(frame));
      J.set$y$x(this.texture.get$crop(), t1.get$y(frame));
      J.set$width$x(this.texture.get$crop(), t1.get$width(frame));
      J.set$height$x(this.texture.get$crop(), t1.get$height(frame));
      if (frame.get$trimmed() === true) {
        t1 = J.get$trim$s(this.texture);
        t2 = this.texture;
        if (t1 != null) {
          J.set$x$x(J.get$trim$s(t2), frame.get$spriteSourceSizeX());
          J.set$y$x(J.get$trim$s(this.texture), frame.get$spriteSourceSizeY());
          J.set$width$x(J.get$trim$s(this.texture), frame.get$sourceSizeW());
          J.set$height$x(J.get$trim$s(this.texture), frame.get$sourceSizeH());
        } else
          J.set$trim$s(t2, new R.Rectangle1(frame.get$spriteSourceSizeX(), frame.get$spriteSourceSizeY(), frame.get$sourceSizeW(), frame.get$sourceSizeH(), 0, 0, 0, 0));
        J.set$width$x(this.texture, frame.get$sourceSizeW());
        J.set$height$x(this.texture, frame.get$sourceSizeH());
        J.set$width$x(this.texture.get$frame(), frame.get$sourceSizeW());
        J.set$height$x(this.texture.get$frame(), frame.get$sourceSizeH());
      }
      if (this.cropRect != null)
        this.updateCrop$0();
      else if (J.$eq(this.game.get$renderType(), 2))
        this.texture._updateWebGLuvs$0();
    }, "call$1", "get$setFrame", 2, 0, 1204, 178, [], "setFrame"],
    resetFrame$0: [function() {
      var t1 = this._frame;
      if (t1 != null)
        this.setFrame$1(t1);
    }, "call$0", "get$resetFrame", 0, 0, 13, "resetFrame"],
    crop$2: [function(rect, copy) {
      var t1;
      if (rect != null) {
        t1 = copy === true;
        if (t1 && this.cropRect != null) {
          t1 = J.getInterceptor$x(rect);
          this.cropRect.setTo$4(t1.get$x(rect), t1.get$y(rect), t1.get$width(rect), t1.get$height(rect));
        } else if (t1 && this.cropRect == null) {
          t1 = J.getInterceptor$x(rect);
          this.cropRect = new R.Rectangle1(t1.get$x(rect), t1.get$y(rect), t1.get$width(rect), t1.get$height(rect), 0, 0, 0, 0);
        } else
          this.cropRect = rect;
        this.updateCrop$0();
      } else {
        this._crop = null;
        this.cropRect = null;
        t1 = this._frame;
        if (t1 != null)
          this.setFrame$1(t1);
      }
    }, function(rect) {
      return this.crop$2(rect, false);
    }, "crop$1", function() {
      return this.crop$2(null, false);
    }, "crop$0", "call$2", "call$1", "call$0", "get$crop", 0, 4, 1205, 32, 95, 1094, [], 1206, [], "crop"],
    updateCrop$0: [function() {
      var t1, t2, cx, cy, cw, ch;
      t1 = this.cropRect;
      if (t1 == null)
        return;
      t1 = J.clone$0$x(t1);
      this._crop = t1;
      t2 = J.getInterceptor$x(t1);
      t2.set$x(t1, J.$add$ns(t2.get$x(t1), J.get$x$x(this._frame)));
      t1 = this._crop;
      t2 = J.getInterceptor$x(t1);
      t2.set$y(t1, J.$add$ns(t2.get$y(t1), J.get$y$x(this._frame)));
      cx = P.max(J.get$x$x(this._frame), J.get$x$x(this._crop));
      cy = P.max(J.get$y$x(this._frame), J.get$y$x(this._crop));
      cw = P.min(J.get$right$x(this._frame), J.get$right$x(this._crop)) - cx;
      ch = P.min(J.get$bottom$x(this._frame), J.get$bottom$x(this._crop)) - cy;
      J.set$x$x(this.texture.get$crop(), cx);
      J.set$y$x(this.texture.get$crop(), cy);
      J.set$width$x(this.texture.get$crop(), cw);
      J.set$height$x(this.texture.get$crop(), ch);
      J.set$width$x(this.texture.get$frame(), P.min(cw, J.get$width$x(this.cropRect)));
      J.set$height$x(this.texture.get$frame(), P.min(ch, J.get$height$x(this.cropRect)));
      t1 = this.texture;
      J.set$width$x(t1, J.get$width$x(t1.get$frame()));
      t1 = this.texture;
      J.set$height$x(t1, J.get$height$x(t1.get$frame()));
      if (J.$eq(this.game.get$renderType(), 2))
        this.texture._updateWebGLuvs$0();
    }, "call$0", "get$updateCrop", 0, 0, 13, "updateCrop"],
    revive$1: [function(health) {
      var t1;
      if (health == null)
        health = 1;
      this.alive = true;
      this.set$exists(true);
      this.visible = true;
      this.health = health;
      t1 = this.events;
      if (t1 != null)
        t1.get$onRevived().dispatch$1(this);
      return this;
    }, function() {
      return this.revive$1(null);
    }, "revive$0", "call$1", "call$0", "get$revive", 0, 2, 919, 32, 1186, [], "revive"],
    kill$0: [function() {
      this.alive = false;
      this.set$exists(false);
      this.visible = false;
      var t1 = this.events;
      if (t1 != null)
        t1.get$onKilled().dispatch$1(this);
      return this;
    }, "call$0", "get$kill", 0, 0, 13, "kill"],
    destroy$1: [function(destroyChildren) {
      var t1, i, i0;
      if (this.game == null || J.$eq(J.$index$asx(this._cache, 8), 1))
        return;
      if (destroyChildren == null)
        destroyChildren = true;
      J.$indexSet$ax(this._cache, 8, 1);
      if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
        if (!!J.getInterceptor(M.DisplayObject.prototype.get$parent.call(this, this)).$isGroup)
          H.interceptedTypeCast(M.DisplayObject.prototype.get$parent.call(this, this), "$isGroup").remove$1(0, this);
        else
          M.DisplayObject.prototype.get$parent.call(this, this).removeChild$1(this);
      t1 = this.input;
      if (t1 != null)
        t1.destroy$0();
      t1 = this.animations;
      if (t1 != null)
        t1.destroy$0();
      t1 = this.body;
      if (t1 != null)
        t1.destroy$0();
      t1 = this.events;
      if (t1 != null)
        t1.destroy$0();
      i = J.get$length$asx(this.Phaser$Sprite0$children);
      if (destroyChildren === true)
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          J.$index$asx(this.Phaser$Sprite0$children, i0).destroy$1(destroyChildren);
      else
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0) {
          t1 = J.$index$asx(this.Phaser$Sprite0$children, i0);
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Sprite0$children, t1));
        }
      this.alive = false;
      this.set$exists(false);
      this.visible = false;
      this.set$filters(null);
      this.set$mask(0, null);
      this.game = null;
      J.$indexSet$ax(this._cache, 8, 0);
    }, function() {
      return this.destroy$1(true);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 932, 39, 1039, [], "destroy"],
    damage$1: [function(amount) {
      var t1;
      if (this.alive === true) {
        t1 = J.$sub$n(this.health, amount);
        this.health = t1;
        if (J.$le$n(t1, 0))
          this.kill$0();
      }
      return this;
    }, "call$1", "get$damage", 2, 0, 63, 366, [], "damage"],
    reset$3: [function(_, x, y, health) {
      var t1;
      this.world.setTo$2(x, y);
      J.set$x$x(this.Phaser$Sprite0$position, x);
      J.set$y$x(this.Phaser$Sprite0$position, y);
      this.alive = true;
      this.set$exists(true);
      this.visible = true;
      this.renderable = true;
      this._outOfBoundsFired = false;
      this.health = health;
      t1 = this.body;
      if (t1 != null)
        J.reset$4$x(t1, x, y, false, false);
      J.$indexSet$ax(this._cache, 4, 1);
      return this;
    }, function($receiver, x, y) {
      return this.reset$3($receiver, x, y, 1);
    }, "reset$2", "call$3", "call$2", "get$reset", 4, 2, 1207, 390, 6, [], 7, [], 1186, [], "reset"],
    bringToTop$1: [function(child) {
      if (child == null) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
        return this;
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$Sprite0$children, child), J.get$length$asx(this.Phaser$Sprite0$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Sprite0$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$Sprite0$children));
        }
        return this;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1059, 32, 659, [], "bringToTop"],
    play$4: [function(_, $name, frameRate, loop, killOnComplete) {
      var t1 = this.animations;
      if (t1 != null)
        return J.play$4$x(t1, $name, frameRate, loop, killOnComplete);
    }, function($receiver, name) {
      return this.play$4($receiver, name, 60, true, false);
    }, "play$1", function($receiver, name, frameRate, loop) {
      return this.play$4($receiver, name, frameRate, loop, false);
    }, "play$3", function($receiver, name, frameRate) {
      return this.play$4($receiver, name, frameRate, true, false);
    }, "play$2", "call$4", "call$1", "call$3", "call$2", "get$play", 2, 6, 1208, 213, 39, 95, 44, [], 218, [], 219, [], 942, [], "play"],
    overlap$1: [function(displayObject) {
      return new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.Sprite.prototype.getBounds$1.call(this, null)).intersects$1(0, displayObject.getBounds$0());
    }, "call$1", "get$overlap", 2, 0, 1209, 805, [], "overlap"],
    getBounds$1: [function(matrix) {
      return new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(M.Sprite.prototype.getBounds$1.call(this, null));
    }, function() {
      return this.getBounds$1(null);
    }, "getBounds$0", "call$1", "call$0", "get$getBounds", 0, 2, 1041, 32, 537, [], "getBounds"],
    Sprite$5: function(game, x, y, key, frame) {
      var t1;
      this.set$x(0, x);
      this.set$y(0, y);
      this.key = key;
      this.name = "";
      this.type = 0;
      this.z = 0;
      this.events = R.Events$(this);
      t1 = new R.AnimationManager(this, null, null, null, true, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), [], 0, null, null);
      t1.game = this.game;
      this.animations = t1;
      this._frameName = "";
      this.loadTexture$2(key, frame);
      this.Phaser$Sprite0$position.set$2(x, y);
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.world = t1;
      this.autoCull = false;
      this.input = null;
      this.body = null;
      this.health = 1;
      this.lifespan = 0;
      this.checkWorldBounds = false;
      this.outOfBoundsKill = false;
      this.debug = false;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.cameraOffset = t1;
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
      this._Phaser$_bounds = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
    },
    $isSprite0: true,
    $isSpriteInterface: true,
    $isGameObject: true,
    static: {Sprite$: [function(game, x, y, key, frame) {
        var t1, t2, t3, t4, t5, t6, t7, t8;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new R.Point(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = J.$index$asx($.get$TextureCache(), "__default");
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = new M.Point0(null, null);
        t6.x = 1;
        t6.y = 1;
        t7 = new M.Point0(null, null);
        t7.x = 0;
        t7.y = 0;
        t8 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new R.Sprite0(game, null, null, null, null, null, null, null, null, null, null, null, null, null, false, false, false, null, null, null, null, null, null, null, false, null, null, null, [], null, t1, t2, false, t4, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t5, t6, t7, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t8, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.texture = t3;
        t1._setupTexture$0();
        t1.Sprite$5(game, x, y, key, frame);
        return t1;
      }, null, null, 2, 8, 283, 5, 5, 32, 5, 214, [], 6, [], 7, [], 231, [], 178, [], "new Sprite"]}
  },
  "+Sprite": [643, 952, 2],
  SpriteBatch: {
    "^": "Group;game-598,name-639,addToStage-602,enableBody-602,physicsBodyType-601,z-599,type-599,alive-602,exists-602,_Phaser$_dirty-602,cursor-32,cameraOffset-600,_sortProperty-639,enableBodyDebug-602,_cache-720,creator-281,renderOrderID-599,Phaser$Group$children-1017,autoCull-602,events-1018,_anchor-600,_Phaser$_currentBounds-974,Phaser$Group$position-600,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    SpriteBatch$4: function(game, $parent, $name, addToStage) {
      if ($parent == null)
        game.get$world();
      this.type = 17;
    },
    $asGroup: function() {
      return [null];
    },
    $asGroup: function() {
      return [null];
    },
    "<>": [],
    static: {SpriteBatch$: [function(game, $parent, $name, addToStage) {
        var t1, t2, t3, t4, t5, t6;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new R.Point(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new R.SpriteBatch(null, "group", false, false, 0, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, t1, null, t2, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.Group$6(game, null, "group", false, false, 0, null);
        t1.SpriteBatch$4(game, $parent, $name, addToStage);
        return t1;
      }, null, null, 8, 0, 295, 214, [], 45, [], 44, [], 254, [], "new SpriteBatch"]}
  },
  "+SpriteBatch": [1074],
  TextStyle0: {
    "^": "TextStyle;shadowOffsetX*-601,shadowOffsetY*-601,shadowColor*-639,shadowBlur*-601,fill-639,font-639,align-639,stroke-639,strokeThickness-601,wordWrap-602,wordWrapWidth-601,dropShadow-602,dropShadowAngle-601,dropShadowDistance-601,dropShadowColor-639,tint-601",
    TextStyle$6$align$fill$font$stroke$strokeThickness$tint: function(align, fill, font, stroke, strokeThickness, tint) {
      this.fill = fill;
      this.font = font;
      this.align = align;
      this.stroke = stroke;
      this.strokeThickness = strokeThickness;
      this.tint = tint;
    },
    static: {TextStyle$: [function(align, fill, font, stroke, strokeThickness, tint) {
        var t1 = new R.TextStyle0(0, 0, "rgba(0,0,0,0)", 0, "black", "bold 20pt Arial", "left", "black", 0, false, 100, false, 0.5235987755982988, 4, "black", 16777215);
        t1.TextStyle$6$align$fill$font$stroke$strokeThickness$tint("left", "black", "bold 20pt Arial", "black", 0, 16777215);
        t1.TextStyle$6$align$fill$font$stroke$strokeThickness$tint(align, fill, font, stroke, strokeThickness, tint);
        return t1;
      }, null, null, 0, 13, 157, 158, 159, 160, 158, 5, 161, 162, [], 163, [], 164, [], 165, [], 166, [], 167, [], "new TextStyle"]}
  },
  "+TextStyle": [910],
  Text0: {
    "^": "Text;game@-598,name*-639,style*-1210,exists@-602,type*-599,z*-599,world@-600,_text@-639,_font@-639,_fontSize@-599,_fontWeight@-639,_lineSpacing@-599,input@-1111,cameraOffset@-600,renderOrderID@-599,autoCull@-602,_cache@-720,children:Phaser$Text0$children*-1058,events@-1018,alive@-602,_Phaser$_dirty@-602,__tilePattern@-794,anchor:Phaser$Text0$anchor@-600,_Phaser$_currentBounds@-974,_PIXI$_text-639,_style-910,_canvas-808,_context-850,PIXI$Text$_dirty-602,_requiresUpdate-602,anchor-634,texture-670,updateFrame-602,PIXI$Sprite$_width-601,PIXI$Sprite$_height-601,_uvs-671,tintedTexture-672,buffer-673,tint-599,cachedTint-599,blendMode-674,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 281, "parent"],
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(J.get$x$x(this.position), J.$div$n(this.get$width(this), 2));
      t2 = J.$add$ns(J.get$y$x(this.position), J.$div$n(this.get$height(this), 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1019, "center"],
    bringToTop$1: [function(child) {
      if (child == null) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
        return this;
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$Text0$children, child), J.get$length$asx(this.Phaser$Text0$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Text0$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$Text0$children));
        }
        return this;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1059, 32, 659, [], "bringToTop"],
    preUpdate$0: [function() {
      var t1, t2, t3, len, i;
      J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
      J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
      J.$indexSet$ax(this._cache, 2, this.rotation);
      if (this.exists !== true || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        this.renderOrderID = -1;
        return false;
      }
      if (this.autoCull === true)
        this.renderable = J.intersects$1$x(this.game.get$world().get$camera().get$screenView(), this.getBounds$0());
      this.world.setTo$2(J.$add$ns(J.get$x$x(this.game.get$camera()), this._worldTransform.get$tx()), J.$add$ns(J.get$y$x(this.game.get$camera()), this._worldTransform.get$ty()));
      if (this.visible === true) {
        t1 = this._cache;
        t2 = this.game.get$stage();
        t3 = t2.get$currentRenderOrderID();
        t2.set$currentRenderOrderID(J.$add$ns(t3, 1));
        J.$indexSet$ax(t1, 3, t3);
      }
      len = J.get$length$asx(this.Phaser$Text0$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Text0$children, i).preUpdate$0();
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 13, "update"],
    postUpdate$0: [function() {
      var len, i;
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.position, J.$div$n(J.$add$ns(J.get$x$x(J.get$view$x(this.game.get$camera())), J.get$x$x(this.cameraOffset)), J.get$x$x(J.get$scale$x(this.game.get$camera()))));
        J.set$y$x(this.position, J.$div$n(J.$add$ns(J.get$y$x(J.get$view$x(this.game.get$camera())), J.get$y$x(this.cameraOffset)), J.get$y$x(J.get$scale$x(this.game.get$camera()))));
      }
      len = J.get$length$asx(this.Phaser$Text0$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$Text0$children, i).postUpdate$0();
    }, "call$0", "get$postUpdate", 0, 0, 13, "postUpdate"],
    destroy$1: [function(destroyChildren) {
      var i, t1, i0;
      if (this.game == null || J.$eq(J.$index$asx(this._cache, 8), 1))
        return;
      if (destroyChildren == null)
        destroyChildren = true;
      J.$indexSet$ax(this._cache, 8, 1);
      if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
        if (!!J.getInterceptor(M.DisplayObject.prototype.get$parent.call(this, this)).$isGroup)
          H.interceptedTypeCast(M.DisplayObject.prototype.get$parent.call(this, this), "$isGroup").remove$1(0, this);
        else
          M.DisplayObject.prototype.get$parent.call(this, this).removeChild$1(this);
      this.texture.destroy$0();
      if (J.get$parentNode$x(this._canvas) != null)
        J.remove$0$ax(this._canvas);
      else
        M.Text.prototype.destroy$1.call(this, null);
      i = J.get$length$asx(this.Phaser$Text0$children);
      if (destroyChildren === true)
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          J.$index$asx(this.Phaser$Text0$children, i0).destroy$1(destroyChildren);
      else
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0) {
          t1 = J.$index$asx(this.Phaser$Text0$children, i0);
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$Text0$children, t1));
        }
      this.exists = false;
      this.visible = false;
      this.set$filters(null);
      this.set$mask(0, null);
      this.game = null;
      J.$indexSet$ax(this._cache, 8, 0);
    }, function() {
      return this.destroy$1(null);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 932, 32, 1039, [], "destroy"],
    setShadow$4: [function(x, y, color, $blur) {
      J.set$shadowOffsetX$x(this.style, x);
      J.set$shadowOffsetY$x(this.style, y);
      J.set$shadowColor$x(this.style, color);
      J.set$shadowBlur$x(this.style, $blur);
      this._Phaser$_dirty = true;
    }, function() {
      return this.setShadow$4(0, 0, "rgba(0,0,0,0)", 0);
    }, "setShadow$0", function(x) {
      return this.setShadow$4(x, 0, "rgba(0,0,0,0)", 0);
    }, "setShadow$1", function(x, y) {
      return this.setShadow$4(x, y, "rgba(0,0,0,0)", 0);
    }, "setShadow$2", function(x, y, color) {
      return this.setShadow$4(x, y, color, 0);
    }, "setShadow$3", "call$4", "call$0", "call$1", "call$2", "call$3", "get$setShadow", 0, 8, 1211, 5, 5, 1212, 5, 6, [], 7, [], 114, [], 1213, [], "setShadow"],
    setStyle$1: [function(style) {
      this.style = style;
      this._Phaser$_dirty = true;
    }, "call$1", "get$setStyle", 2, 0, 1214, 156, [], "setStyle"],
    updateText$0: [function() {
      var outputText, lines, t1, lineWidths, maxLineWidth, i, lineWidth, t2, t3, lineHeight, linePosition, t4;
      J.set$font$x(this._context, J.get$font$x(this.style));
      outputText = this._text;
      if (J.get$wordWrap$x(this.style) === true)
        outputText = this.runWordWrap$1(this._text);
      lines = J.split$1$s(outputText, $.get$Text_linesReg());
      t1 = lines.length;
      lineWidths = Array(t1);
      for (maxLineWidth = 0, i = 0; i < lines.length; ++i) {
        lineWidth = J.measureText$1$x(this._context, lines[i]).width;
        if (i >= t1)
          return H.ioore(lineWidths, i);
        lineWidths[i] = lineWidth;
        maxLineWidth = C.JSNumber_methods.floor$0(P.max(maxLineWidth, lineWidth));
      }
      t2 = this._canvas;
      t3 = this.style.get$strokeThickness();
      if (typeof t3 !== "number")
        return H.iae(t3);
      J.set$width$x(t2, maxLineWidth + t3);
      lineHeight = J.$add$ns(J.$add$ns(J.$add$ns(this.determineFontHeight$1(C.JSString_methods.$add("font: ", J.get$font$x(this.style)) + ";"), this.style.get$strokeThickness()), this._lineSpacing), J.get$shadowOffsetY$x(this.style));
      J.set$height$x(this._canvas, J.$mul$ns(lineHeight, lines.length));
      if (this.game.get$device().get$cocoonJS() === true)
        J.clearRect$4$x(this._context, 0, 0, J.get$width$x(this._canvas), J.get$height$x(this._canvas));
      J.set$fillStyle$x(this._context, J.get$fill$x(this.style));
      J.set$font$x(this._context, J.get$font$x(this.style));
      J.set$strokeStyle$x(this._context, J.get$stroke$x(this.style));
      J.set$lineWidth$x(this._context, this.style.get$strokeThickness());
      J.set$shadowOffsetX$x(this._context, J.get$shadowOffsetX$x(this.style));
      J.set$shadowOffsetY$x(this._context, J.get$shadowOffsetY$x(this.style));
      J.set$shadowColor$x(this._context, J.get$shadowColor$x(this.style));
      J.set$shadowBlur$x(this._context, J.get$shadowBlur$x(this.style));
      J.set$textBaseline$x(this._context, "top");
      J.set$lineCap$x(this._context, "round");
      J.set$lineJoin$x(this._context, "round");
      for (i = 0; i < lines.length; ++i) {
        t2 = J.$div$n(this.style.get$strokeThickness(), 2);
        t3 = J.$div$n(this.style.get$strokeThickness(), 2);
        if (typeof lineHeight !== "number")
          return H.iae(lineHeight);
        t3 = J.$add$ns(t3, i * lineHeight);
        linePosition = new R.Point(null, null);
        linePosition.x = t2;
        linePosition.y = t3;
        if (J.$eq(this.style.get$align(), "right")) {
          if (i >= t1)
            return H.ioore(lineWidths, i);
          t4 = lineWidths[i];
          if (typeof t4 !== "number")
            return H.iae(t4);
          t4 = J.$add$ns(t2, maxLineWidth - t4);
          linePosition.x = t4;
          t2 = t4;
        } else if (J.$eq(this.style.get$align(), "center")) {
          if (i >= t1)
            return H.ioore(lineWidths, i);
          t4 = lineWidths[i];
          if (typeof t4 !== "number")
            return H.iae(t4);
          t4 = J.$add$ns(t2, (maxLineWidth - t4) / 2);
          linePosition.x = t4;
          t2 = t4;
        }
        t3 = J.$add$ns(t3, this._lineSpacing);
        linePosition.y = t3;
        if (J.get$stroke$x(this.style) != null && !J.$eq(this.style.get$strokeThickness(), 0)) {
          t4 = this._context;
          if (i >= lines.length)
            return H.ioore(lines, i);
          J.strokeText$3$x(t4, lines[i], t2, t3);
        }
        if (J.get$fill$x(this.style) != null) {
          t4 = this._context;
          if (i >= lines.length)
            return H.ioore(lines, i);
          J.fillText$3$x(t4, lines[i], t2, t3);
        }
      }
      this.updateTexture$0();
    }, "call$0", "get$updateText", 0, 0, 13, "updateText"],
    runWordWrap$1: [function(text) {
      var lines, result, i, spaceLeft, words, j, wordWidth, t1, wordWidthWithSpace;
      lines = J.split$1$s(text, "\n");
      for (result = "", i = 0; i < lines.length; ++i) {
        spaceLeft = this.style.get$wordWrapWidth();
        if (i >= lines.length)
          return H.ioore(lines, i);
        words = J.split$1$s(lines[i], " ");
        for (j = 0; j < words.length; ++j) {
          wordWidth = J.measureText$1$x(this._context, words[j]).width;
          t1 = J.measureText$1$x(this._context, " ").width;
          if (typeof wordWidth !== "number")
            return wordWidth.$add();
          if (typeof t1 !== "number")
            return H.iae(t1);
          wordWidthWithSpace = wordWidth + t1;
          if (typeof spaceLeft !== "number")
            return H.iae(spaceLeft);
          if (wordWidthWithSpace > spaceLeft) {
            if (j > 0)
              result += "\n";
            if (j >= words.length)
              return H.ioore(words, j);
            result = C.JSString_methods.$add(result, J.$add$ns(words[j], " "));
            spaceLeft = J.$sub$n(this.style.get$wordWrapWidth(), wordWidth);
          } else {
            spaceLeft -= wordWidthWithSpace;
            if (j >= words.length)
              return H.ioore(words, j);
            result = C.JSString_methods.$add(result, J.$add$ns(words[j], " "));
          }
        }
        if (i < lines.length - 1)
          result += "\n";
      }
      return result;
    }, "call$1", "get$runWordWrap", 2, 0, 52, 85, [], "runWordWrap"],
    get$angle: [function() {
      return J.$mul$ns(this.rotation, 57.29577951308232);
    }, null, null, 1, 0, 604, "angle"],
    angle$0: function() {
      return this.get$angle().call$0();
    },
    angle$2: function(arg0, arg1) {
      return this.get$angle().call$2(arg0, arg1);
    },
    set$angle: [function(value) {
      this.rotation = J.$mul$ns(value, 0.017453292519943295);
    }, null, null, 3, 0, 605, 100, [], "angle"],
    get$text: [function(_) {
      return this._text;
    }, null, null, 1, 0, 782, "text"],
    text$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.get$text(this).call$4(arg0, arg1, arg2, arg3);
    },
    text$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.get$text(this).call$5(arg0, arg1, arg2, arg3, arg4);
    },
    text$3: function($receiver, arg0, arg1, arg2) {
      return this.get$text(this).call$3(arg0, arg1, arg2);
    },
    set$text: [function(_, value) {
      if (!J.$eq(value, this._text)) {
        this._text = value;
        this._Phaser$_dirty = true;
        this.updateTransform$0();
      }
    }, null, null, 3, 0, 52, 100, [], "text"],
    get$font: [function(_) {
      return this._font;
    }, null, null, 1, 0, 782, "font"],
    set$font: [function(_, value) {
      var t1 = J.getInterceptor(value);
      if (!t1.$eq(value, this._font)) {
        this._font = t1.trim$0(value);
        J.set$font$x(this.style, J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(this._fontWeight, " "), J.toString$0(this._fontSize)), "px '"), this._font), "'"));
        this._Phaser$_dirty = true;
        this.updateTransform$0();
      }
    }, null, null, 3, 0, 52, 100, [], "font"],
    get$fontSize: [function(_) {
      return this._fontSize;
    }, null, null, 1, 0, 604, "fontSize"],
    set$fontSize: [function(_, value) {
      if (!J.$eq(value, this._fontSize)) {
        this._fontSize = value;
        J.set$font$x(this.style, J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(this._fontWeight, " "), J.toString$0(this._fontSize)), "px '"), this._font), "'"));
        this._Phaser$_dirty = true;
        this.updateTransform$0();
      }
    }, null, null, 3, 0, 605, 100, [], "fontSize"],
    get$fontWeight: [function(_) {
      return this._fontWeight;
    }, null, null, 1, 0, 782, "fontWeight"],
    set$fontWeight: [function(_, value) {
      if (!J.$eq(value, this._fontWeight)) {
        this._fontWeight = value;
        J.set$font$x(this.style, J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(value, " "), J.toString$0(this._fontSize)), "px '"), this._font), "'"));
        this._Phaser$_dirty = true;
        this.updateTransform$0();
      }
    }, null, null, 3, 0, 52, 100, [], "fontWeight"],
    get$fill: [function(_) {
      return J.get$fill$x(this.style);
    }, null, null, 1, 0, 782, "fill"],
    fill$0: function($receiver) {
      return this.get$fill(this).call$0();
    },
    fill$6: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5) {
      return this.get$fill(this).call$6(arg0, arg1, arg2, arg3, arg4, arg5);
    },
    fill$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.get$fill(this).call$4(arg0, arg1, arg2, arg3);
    },
    set$fill: [function(_, value) {
      if (!J.$eq(value, J.get$fill$x(this.style))) {
        J.set$fill$x(this.style, value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 52, 100, [], "fill"],
    get$align: [function() {
      return this.style.get$align();
    }, null, null, 1, 0, 782, "align"],
    set$align: [function(value) {
      if (!J.$eq(value, this.style.get$align())) {
        this.style.set$align(value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 52, 100, [], "align"],
    get$stroke: [function(_) {
      return J.get$stroke$x(this.style);
    }, null, null, 1, 0, 782, "stroke"],
    stroke$0: function($receiver) {
      return this.get$stroke(this).call$0();
    },
    set$stroke: [function(_, value) {
      if (!J.$eq(value, J.get$stroke$x(this.style))) {
        J.set$stroke$x(this.style, value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 52, 100, [], "stroke"],
    get$strokeThickness: [function() {
      return this.style.get$strokeThickness();
    }, null, null, 1, 0, 604, "strokeThickness"],
    set$strokeThickness: [function(value) {
      if (!J.$eq(value, this.style.get$strokeThickness())) {
        this.style.set$strokeThickness(value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 605, 100, [], "strokeThickness"],
    get$isWordWrap: [function() {
      return J.get$wordWrap$x(this.style);
    }, null, null, 1, 0, 209, "isWordWrap"],
    set$isWordWrap: [function(value) {
      if (!J.$eq(value, J.get$wordWrap$x(this.style))) {
        J.set$wordWrap$x(this.style, value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 650, 100, [], "isWordWrap"],
    get$wordWrapWidth: [function() {
      return this.style.get$wordWrapWidth();
    }, null, null, 1, 0, 604, "wordWrapWidth"],
    set$wordWrapWidth: [function(value) {
      if (!J.$eq(value, this.style.get$wordWrapWidth())) {
        this.style.set$wordWrapWidth(value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 605, 100, [], "wordWrapWidth"],
    get$lineSpacing: [function() {
      return this._lineSpacing;
    }, null, null, 1, 0, 604, "lineSpacing"],
    set$lineSpacing: [function(value) {
      if (!J.$eq(value, this._lineSpacing)) {
        this._lineSpacing = value;
        this._Phaser$_dirty = true;
        this.updateTransform$0();
      }
    }, null, null, 3, 0, 605, 100, [], "lineSpacing"],
    get$shadowOffsetX: [function(_) {
      return J.get$shadowOffsetX$x(this.style);
    }, null, null, 1, 0, 604, "shadowOffsetX"],
    set$shadowOffsetX: [function(_, value) {
      if (!J.$eq(value, J.get$shadowOffsetX$x(this.style))) {
        J.set$shadowOffsetX$x(this.style, value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 605, 100, [], "shadowOffsetX"],
    get$shadowOffsetY: [function(_) {
      return J.get$shadowOffsetY$x(this.style);
    }, null, null, 1, 0, 13, "shadowOffsetY"],
    set$shadowOffsetY: [function(_, value) {
      if (!J.$eq(value, J.get$shadowOffsetY$x(this.style))) {
        J.set$shadowOffsetY$x(this.style, value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 605, 100, [], "shadowOffsetY"],
    get$shadowColor: [function(_) {
      return J.get$shadowColor$x(this.style);
    }, null, null, 1, 0, 782, "shadowColor"],
    set$shadowColor: [function(_, value) {
      if (!J.$eq(value, J.get$shadowColor$x(this.style))) {
        J.set$shadowColor$x(this.style, value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 52, 100, [], "shadowColor"],
    get$shadowBlur: [function(_) {
      return J.get$shadowBlur$x(this.style);
    }, null, null, 1, 0, 604, "shadowBlur"],
    set$shadowBlur: [function(_, value) {
      if (!J.$eq(value, J.get$shadowBlur$x(this.style))) {
        J.set$shadowBlur$x(this.style, value);
        this._Phaser$_dirty = true;
      }
    }, null, null, 3, 0, 605, 100, [], "shadowBlur"],
    get$inputEnabled: [function() {
      var t1 = this.input;
      return t1 != null && t1.get$enabled() === true;
    }, null, null, 1, 0, 209, "inputEnabled"],
    set$inputEnabled: [function(value) {
      var t1;
      if (value === true) {
        t1 = this.input;
        if (t1 == null) {
          t1 = R.InputHandler$(this);
          this.input = t1;
          t1.start$0(0);
        } else if (t1.get$enabled() !== true)
          J.start$0$x(this.input);
      } else {
        t1 = this.input;
        if (t1 != null && t1.get$enabled() === true)
          J.stop$0$x(this.input);
      }
    }, null, null, 3, 0, 650, 100, [], "inputEnabled"],
    get$fixedToCamera: [function() {
      return J.$eq(J.$index$asx(this._cache, 7), 1);
    }, null, null, 1, 0, 209, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.cameraOffset.set$2(J.get$x$x(this.position), J.get$y$x(this.position));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 650, 100, [], "fixedToCamera"],
    get$destroyPhase: [function() {
      return J.$eq(J.$index$asx(this._cache, 8), 1);
    }, null, null, 1, 0, 209, "destroyPhase"],
    Text$5: function(game, x, y, text, style) {
      var t1;
      J.set$x$x(this.position, x);
      J.set$y$x(this.position, y);
      this.style = style;
      if (style == null)
        this.style = M.TextStyle$0("left", "black", "bold 20pt Arial", "black", 0, 16777215);
      this._text = text;
      this.exists = true;
      this.name = "";
      this.type = 4;
      this.z = 0;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.world = t1;
      this._font = "";
      this._fontSize = 32;
      this._fontWeight = "normal";
      this._lineSpacing = 0;
      this.events = R.Events$(this);
      this.input = null;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.cameraOffset = t1;
      this.style = style;
      this._Phaser$_dirty = true;
      this.position.set$2(x, y);
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
    },
    $isGameObject: true,
    static: {"^": "Text_linesReg@-785", Text$: [function(game, x, y, text, style) {
        var t1, t2, t3, t4, t5, t6;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new R.Text0(game, null, null, null, null, null, null, "", null, null, null, null, null, null, null, false, null, [], null, null, false, null, t1, null, null, null, null, null, null, null, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.renderable = true;
        t1.Text$2(text, style);
        t1.Text$5(game, x, y, text, style);
        return t1;
      }, null, null, 2, 8, 296, 32, 32, 221, 32, 214, [], 6, [], 7, [], 85, [], 156, [], "new Text"]}
  },
  "+Text": [1215, 2],
  TileSprite: {
    "^": "TilingSprite;game@-598,name*-639,type*-601,events@-1018,alive@-602,body*-1117,input@-1111,animations@-1183,key*-32,z*-601,_cache@-681,_Phaser$_currentBounds@-974,_frame@-32,_frameName@-639,world@-600,_scroll@-600,_Phaser$_dirty@-602,children:Phaser$TileSprite$children*-1058,_Phaser$_bounds@-974,checkWorldBounds@-602,_outOfBoundsFired@-602,autoCull@-602,cameraOffset@-600,__tilePattern@-794,PIXI$TilingSprite$_width-601,PIXI$TilingSprite$_height-601,tileScale-634,tilePosition-634,_PIXI$__tilePattern-794,tilingTexture-670,refreshTexture-602,tileScaleOffset-634,anchor-634,texture-670,updateFrame-602,PIXI$Sprite$_width-601,PIXI$Sprite$_height-601,_uvs-671,tintedTexture-672,buffer-673,tint-599,cachedTint-599,blendMode-674,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    get$parent: [function(_) {
      return M.DisplayObject.prototype.get$parent.call(this, this);
    }, null, null, 1, 0, 281, "parent"],
    body$3: function($receiver, arg0, arg1, arg2) {
      return this.body.call$3(arg0, arg1, arg2);
    },
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    get$center: [function() {
      var t1, t2, t3;
      t1 = J.$add$ns(J.get$x$x(this.position), J.$div$n(this.PIXI$TilingSprite$_width, 2));
      t2 = J.$add$ns(J.get$y$x(this.position), J.$div$n(this.PIXI$TilingSprite$_height, 2));
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1019, "center"],
    bringToTop$1: [function(child) {
      if (child == null) {
        if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
          M.DisplayObject.prototype.get$parent.call(this, this).bringToTop$1(this);
        return this;
      } else {
        if (J.$eq(J.get$parent$x(child), this) && J.$lt$n(J.indexOf$1$asx(this.Phaser$TileSprite$children, child), J.get$length$asx(this.Phaser$TileSprite$children))) {
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$TileSprite$children, child));
          this.addChildAt$2(child, J.get$length$asx(this.Phaser$TileSprite$children));
        }
        return this;
      }
    }, function() {
      return this.bringToTop$1(null);
    }, "bringToTop$0", "call$1", "call$0", "get$bringToTop", 0, 2, 1059, 32, 659, [], "bringToTop"],
    get$renderOrderID: [function() {
      return J.$index$asx(this._cache, 3);
    }, null, null, 1, 0, 604, "renderOrderID"],
    get$angle: [function() {
      return R.Math_wrapAngle(J.$mul$ns(this.rotation, 57.29577951308232), false);
    }, null, null, 1, 0, 13, "angle"],
    angle$0: function() {
      return this.get$angle().call$0();
    },
    angle$2: function(arg0, arg1) {
      return this.get$angle().call$2(arg0, arg1);
    },
    set$angle: [function(value) {
      this.rotation = R.Math_wrapAngle(value, false) * 0.017453292519943295;
    }, null, null, 3, 0, 63, 100, [], "angle"],
    get$frame: [function() {
      return this.animations.get$frame();
    }, null, null, 1, 0, 13, "frame"],
    set$frame: [function(value) {
      if (!J.$eq(value, this.animations.get$frame()))
        this.animations.set$frame(value);
    }, null, null, 3, 0, 63, 100, [], "frame"],
    get$frameName: [function() {
      return this.animations.get$frameName();
    }, null, null, 1, 0, 782, "frameName"],
    set$frameName: [function(value) {
      if (!J.$eq(value, this.animations.get$frameName()))
        this.animations.set$frameName(value);
    }, null, null, 3, 0, 52, 100, [], "frameName"],
    get$fixedToCamera: [function() {
      return J.$eq(J.$index$asx(this._cache, 7), 1);
    }, null, null, 1, 0, 209, "fixedToCamera"],
    set$fixedToCamera: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 7, 1);
        this.cameraOffset.set$2(J.get$x$x(this.position), J.get$y$x(this.position));
      } else
        J.$indexSet$ax(t1, 7, 0);
    }, null, null, 3, 0, 650, 100, [], "fixedToCamera"],
    get$exists: [function() {
      return J.$eq(J.$index$asx(this._cache, 6), 1);
    }, null, null, 1, 0, 209, "exists"],
    set$exists: [function(value) {
      var t1 = this._cache;
      if (value === true) {
        J.$indexSet$ax(t1, 6, 1);
        t1 = this.body;
        if (t1 != null && J.$eq(J.get$type$x(t1), 1))
          H.interceptedTypeCast(this.body, "$isBody1").addToWorld$0();
        this.visible = true;
      } else {
        J.$indexSet$ax(t1, 6, 0);
        t1 = this.body;
        if (t1 != null && J.$eq(J.get$type$x(t1), 1))
          this.body.set$safeRemove(true);
        this.visible = false;
      }
    }, null, null, 3, 0, 650, 100, [], "exists"],
    get$inputEnabled: [function() {
      var t1 = this.input;
      return t1 != null && t1.get$enabled() === true;
    }, null, null, 1, 0, 209, "inputEnabled"],
    set$inputEnabled: [function(value) {
      var t1;
      if (value === true) {
        t1 = this.input;
        if (t1 == null) {
          t1 = R.InputHandler$(this);
          this.input = t1;
          t1.start$0(0);
        } else if (t1.get$enabled() !== true)
          J.start$0$x(this.input);
      } else {
        t1 = this.input;
        if (t1 != null && t1.get$enabled() === true)
          J.stop$0$x(this.input);
      }
    }, null, null, 3, 0, 650, 100, [], "inputEnabled"],
    get$x: [function(_) {
      return J.get$x$x(this.position);
    }, null, null, 1, 0, 13, "x"],
    set$x: [function(_, value) {
      var t1;
      J.set$x$x(this.position, value);
      t1 = this.body;
      if (t1 != null && J.$eq(J.get$type$x(t1), 0) && J.$eq(this.body.get$phase(), 2))
        this.body.set$_reset(true);
    }, null, null, 3, 0, 63, 100, [], "x"],
    get$y: [function(_) {
      return J.get$y$x(this.position);
    }, null, null, 1, 0, 13, "y"],
    set$y: [function(_, value) {
      var t1;
      J.set$y$x(this.position, value);
      t1 = this.body;
      if (t1 != null && J.$eq(J.get$type$x(t1), 0) && J.$eq(this.body.get$phase(), 2))
        this.body.set$_reset(true);
    }, null, null, 3, 0, 63, 100, [], "y"],
    get$destroyPhase: [function() {
      return J.$eq(J.$index$asx(this._cache, 8), 1);
    }, null, null, 1, 0, 209, "destroyPhase"],
    preUpdate$0: [function() {
      var t1, t2, t3, len, i;
      if (J.$eq(J.$index$asx(this._cache, 4), 1) && J.$eq(J.$index$asx(this._cache, 6), 1)) {
        this.world.setTo$2(J.$add$ns(J.get$x$x(J.get$position$x(M.DisplayObject.prototype.get$parent.call(this, this))), J.get$x$x(this.position)), J.$add$ns(J.get$y$x(J.get$position$x(M.DisplayObject.prototype.get$parent.call(this, this))), J.get$y$x(this.position)));
        this._worldTransform.set$tx(J.toDouble$0$n(J.get$x$x(this.world)));
        this._worldTransform.set$ty(J.toDouble$0$n(J.get$y$x(this.world)));
        J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
        J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
        J.$indexSet$ax(this._cache, 2, this.rotation);
        t1 = this.body;
        if (t1 != null)
          t1.preUpdate$0();
        J.$indexSet$ax(this._cache, 4, 0);
        return false;
      }
      J.$indexSet$ax(this._cache, 0, J.get$x$x(this.world));
      J.$indexSet$ax(this._cache, 1, J.get$y$x(this.world));
      J.$indexSet$ax(this._cache, 2, this.rotation);
      if (!J.$eq(J.$index$asx(this._cache, 6), 1) || M.DisplayObject.prototype.get$parent.call(this, this).get$exists() !== true) {
        J.$indexSet$ax(this._cache, 3, -1);
        return false;
      }
      if (this.autoCull === true || this.checkWorldBounds === true)
        this._Phaser$_bounds.copyFrom$1(this.getBounds$0());
      if (this.autoCull === true)
        this.renderable = J.intersects$1$x(this.game.get$world().get$camera().get$screenView(), this._Phaser$_bounds);
      if (this.checkWorldBounds === true)
        if (J.$eq(J.$index$asx(this._cache, 5), 1) && J.intersects$1$x(this.game.get$world().get$bounds(), this._Phaser$_bounds) === true) {
          J.$indexSet$ax(this._cache, 5, 0);
          this.events.get$onEnterBounds().dispatch$1(this);
        } else if (J.$eq(J.$index$asx(this._cache, 5), 0) && J.intersects$1$x(this.game.get$world().get$bounds(), this._Phaser$_bounds) !== true) {
          J.$indexSet$ax(this._cache, 5, 1);
          this.events.get$onOutOfBounds().dispatch$1(this);
        }
      this.world.setTo$2(J.$add$ns(J.get$x$x(this.game.get$camera()), this._worldTransform.get$tx()), J.$add$ns(J.get$y$x(this.game.get$camera()), this._worldTransform.get$ty()));
      if (this.visible === true) {
        t1 = this._cache;
        t2 = this.game.get$stage();
        t3 = t2.get$currentRenderOrderID();
        t2.set$currentRenderOrderID(J.$add$ns(t3, 1));
        J.$indexSet$ax(t1, 3, t3);
      }
      this.animations.update$0();
      if (!J.$eq(J.get$x$x(this._scroll), 0)) {
        t1 = this.tilePosition;
        t2 = J.getInterceptor$x(t1);
        t2.set$x(t1, J.$add$ns(t2.get$x(t1), J.$mul$ns(J.get$x$x(this._scroll), this.game.get$time().get$physicsElapsed())));
      }
      if (!J.$eq(J.get$y$x(this._scroll), 0)) {
        t1 = this.tilePosition;
        t2 = J.getInterceptor$x(t1);
        t2.set$y(t1, J.$add$ns(t2.get$y(t1), J.$mul$ns(J.get$y$x(this._scroll), this.game.get$time().get$physicsElapsed())));
      }
      t1 = this.body;
      if (t1 != null)
        t1.preUpdate$0();
      len = J.get$length$asx(this.Phaser$TileSprite$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$TileSprite$children, i).preUpdate$0();
      return true;
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    update$0: [function() {
    }, "call$0", "get$update", 0, 0, 13, "update"],
    postUpdate$0: [function() {
      var len, i;
      if (J.$eq(J.$index$asx(this._cache, 6), 1) && this.body != null)
        this.body.postUpdate$0();
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.position, J.$add$ns(J.get$x$x(J.get$view$x(this.game.get$camera())), J.get$x$x(this.cameraOffset)));
        J.set$y$x(this.position, J.$add$ns(J.get$y$x(J.get$view$x(this.game.get$camera())), J.get$y$x(this.cameraOffset)));
      }
      len = J.get$length$asx(this.Phaser$TileSprite$children);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(this.Phaser$TileSprite$children, i).postUpdate$0();
    }, "call$0", "get$postUpdate", 0, 0, 13, "postUpdate"],
    autoScroll$2: [function(x, y) {
      this._scroll.set$2(x, y);
    }, "call$2", "get$autoScroll", 4, 0, 111, 6, [], 7, [], "autoScroll"],
    stopScroll$0: [function() {
      this._scroll.set$2(0, 0);
    }, "call$0", "get$stopScroll", 0, 0, 13, "stopScroll"],
    loadTexture$2: [function(key, frame) {
      var t1, setFrame;
      this.key = key;
      t1 = J.getInterceptor(key);
      if (!!t1.$isRenderTexture) {
        this.key = key.key;
        this.setTexture$1(key);
        setFrame = true;
      } else if (!!t1.$isBitmapData) {
        this.setTexture$1(key.texture);
        setFrame = true;
      } else if (!!t1.$isTexture) {
        this.setTexture$1(key);
        setFrame = true;
      } else if (key == null) {
        this.key = "__default";
        this.setTexture$1(J.$index$asx($.get$TextureCache(), "__default"));
        setFrame = true;
      } else if (typeof key === "string" && !this.game.get$cache().checkImageKey$1(key)) {
        window;
        t1 = C.JSString_methods.$add("Texture with key '", key) + "' not found.";
        if (typeof console != "undefined")
          console.warn(t1);
        this.key = "__missing";
        this.setTexture$1(J.$index$asx($.get$TextureCache(), "__missing"));
        setFrame = true;
      } else {
        this.setTexture$1(M.Texture$(J.$index$asx($.get$BaseTextureCache(), key), null));
        setFrame = !this.animations.loadFrameData$2(this.game.get$cache().getFrameData$1(key), frame);
      }
      if (setFrame)
        this._frame = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(this.texture.get$frame());
    }, "call$2", "get$loadTexture", 4, 0, 935, 231, [], 178, [], "loadTexture"],
    setFrame$1: [function(frame) {
      var t1, t2;
      t1 = J.getInterceptor$x(frame);
      J.set$x$x(this.texture.get$frame(), t1.get$x(frame));
      J.set$y$x(this.texture.get$frame(), t1.get$y(frame));
      J.set$width$x(this.texture.get$frame(), t1.get$width(frame));
      J.set$height$x(this.texture.get$frame(), t1.get$height(frame));
      J.set$x$x(this.texture.get$crop(), t1.get$x(frame));
      J.set$y$x(this.texture.get$crop(), t1.get$y(frame));
      J.set$width$x(this.texture.get$crop(), t1.get$width(frame));
      J.set$height$x(this.texture.get$crop(), t1.get$height(frame));
      if (frame.get$trimmed() === true) {
        t1 = J.get$trim$s(this.texture);
        t2 = this.texture;
        if (t1 != null) {
          J.set$x$x(J.get$trim$s(t2), frame.get$spriteSourceSizeX());
          J.set$y$x(J.get$trim$s(this.texture), frame.get$spriteSourceSizeY());
          J.set$width$x(J.get$trim$s(this.texture), frame.get$sourceSizeW());
          J.set$height$x(J.get$trim$s(this.texture), frame.get$sourceSizeH());
        } else {
          t1 = new M.Rectangle0(0, 0, 0, 0);
          t1.x = frame.get$spriteSourceSizeX();
          t1.y = frame.get$spriteSourceSizeY();
          t1.width = frame.get$sourceSizeW();
          t1.height = frame.get$sourceSizeH();
          J.set$trim$s(t2, t1);
        }
        J.set$width$x(this.texture, frame.get$sourceSizeW());
        J.set$height$x(this.texture, frame.get$sourceSizeH());
        J.set$width$x(this.texture.get$frame(), frame.get$sourceSizeW());
        J.set$height$x(this.texture.get$frame(), frame.get$sourceSizeH());
      }
      if (J.$eq(this.game.get$renderType(), 2))
        this.texture._updateWebGLuvs$0();
    }, "call$1", "get$setFrame", 2, 0, 1204, 178, [], "setFrame"],
    destroy$1: [function(destroyChildren) {
      var i, t1, i0;
      if (this.game == null || J.$eq(J.$index$asx(this._cache, 8), 1))
        return;
      if (destroyChildren == null)
        destroyChildren = true;
      J.$indexSet$ax(this._cache, 8, 1);
      if (this._filters != null)
        this.set$filters(null);
      if (M.DisplayObject.prototype.get$parent.call(this, this) != null)
        if (!!J.getInterceptor(M.DisplayObject.prototype.get$parent.call(this, this)).$isGroup)
          H.interceptedTypeCast(M.DisplayObject.prototype.get$parent.call(this, this), "$isGroup").remove$1(0, this);
        else
          M.DisplayObject.prototype.get$parent.call(this, this).removeChild$1(this);
      this.animations.destroy$0();
      this.events.destroy$0();
      i = J.get$length$asx(this.Phaser$TileSprite$children);
      if (destroyChildren === true)
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
          J.$index$asx(this.Phaser$TileSprite$children, i0).destroy$1(destroyChildren);
      else
        for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0) {
          t1 = J.$index$asx(this.Phaser$TileSprite$children, i0);
          this.removeChildAt$1(J.indexOf$1$asx(this.Phaser$TileSprite$children, t1));
        }
      this.set$exists(false);
      this.visible = false;
      this.set$filters(null);
      this.set$mask(0, null);
      this.game = null;
      J.$indexSet$ax(this._cache, 8, 0);
    }, function() {
      return this.destroy$1(true);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 932, 39, 1039, [], "destroy"],
    play$4: [function(_, $name, frameRate, loop, killOnComplete) {
      return J.play$4$x(this.animations, $name, frameRate, loop, killOnComplete);
    }, function($receiver, name, frameRate, loop) {
      return this.play$4($receiver, name, frameRate, loop, null);
    }, "play$3", function($receiver, name, frameRate) {
      return this.play$4($receiver, name, frameRate, null, null);
    }, "play$2", "call$4", "call$3", "call$2", "get$play", 4, 4, 1216, 32, 32, 44, [], 218, [], 219, [], 942, [], "play"],
    reset$2: [function(_, x, y) {
      var t1;
      this.world.setTo$2(x, y);
      J.set$x$x(this.position, x);
      J.set$y$x(this.position, y);
      this.alive = true;
      this.set$exists(true);
      this.visible = true;
      this.renderable = true;
      this._outOfBoundsFired = false;
      J.set$x$x(this.tilePosition, 0);
      J.set$y$x(this.tilePosition, 0);
      t1 = this.body;
      if (t1 != null)
        J.reset$4$x(t1, x, y, false, false);
      J.$indexSet$ax(this._cache, 4, 1);
      return this;
    }, "call$2", "get$reset", 4, 0, 111, 6, [], 7, [], "reset"],
    TileSprite$7: function(game, x, y, width, height, key, frame) {
      var t1, setFrame;
      this.set$x(0, J.toInt$0$n(x));
      this.set$y(0, J.toInt$0$n(y));
      this.PIXI$TilingSprite$_width = J.toInt$0$n(width);
      this.PIXI$TilingSprite$_height = J.toInt$0$n(height);
      this.game = this.game;
      this.name = "";
      this.type = 5;
      this.z = 0;
      this.events = R.Events$(this);
      t1 = new R.AnimationManager(this, null, null, null, true, false, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), [], 0, null, null);
      t1.game = this.game;
      this.animations = t1;
      this.key = key;
      this._frame = 0;
      this._frameName = "";
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this._scroll = t1;
      this.position.set$2(x, y);
      this.input = null;
      t1 = new R.Point(null, null);
      t1.x = x;
      t1.y = y;
      this.world = t1;
      this.autoCull = false;
      this.checkWorldBounds = false;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.cameraOffset = t1;
      this.body = null;
      this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
      this.key = key;
      t1 = J.getInterceptor(key);
      if (!!t1.$isRenderTexture) {
        this.key = key.key;
        this.setTexture$1(key);
        setFrame = true;
      } else if (!!t1.$isBitmapData) {
        this.setTexture$1(key.texture);
        setFrame = true;
      } else if (!!t1.$isTexture) {
        this.setTexture$1(key);
        setFrame = true;
      } else if (key == null) {
        this.key = "__default";
        this.setTexture$1(J.$index$asx($.get$TextureCache(), "__default"));
        setFrame = true;
      } else if (typeof key === "string" && !this.game.get$cache().checkImageKey$1(key)) {
        window;
        t1 = C.JSString_methods.$add("Texture with key '", key) + "' not found.";
        if (typeof console != "undefined")
          console.warn(t1);
        this.key = "__missing";
        this.setTexture$1(J.$index$asx($.get$TextureCache(), "__missing"));
        setFrame = true;
      } else {
        this.setTexture$1(M.Texture$(J.$index$asx($.get$BaseTextureCache(), key), null));
        setFrame = !this.animations.loadFrameData$2(this.game.get$cache().getFrameData$1(key), frame);
      }
      if (setFrame)
        this._frame = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0).copyFrom$1(this.texture.get$frame());
    },
    $isTileSprite: true,
    $isSpriteInterface: true,
    $isGameObject: true,
    static: {TileSprite$: [function(game, x, y, width, height, key, frame) {
        var t1, t2, t3, t4, t5, t6, t7;
        t1 = J.$index$asx($.get$TextureCache(), "__default");
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 0;
        t4.y = 0;
        t5 = new M.Point0(null, null);
        t5.x = 1;
        t5.y = 1;
        t6 = new M.Point0(null, null);
        t6.x = 0;
        t6.y = 0;
        t7 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t2 = new R.TileSprite(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false, [], null, null, null, null, null, null, null, null, null, null, null, null, false, t2, t3, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t4, t5, t6, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t7, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t2.texture = t1;
        t2._setupTexture$0();
        t2.TilingSprite$3(t1, width, height);
        t2.TileSprite$7(game, x, y, width, height, key, frame);
        return t2;
      }, null, null, 2, 12, 297, 5, 5, 298, 298, 32, 32, 214, [], 6, [], 7, [], 10, [], 11, [], 231, [], 178, [], "new TileSprite"]}
  },
  "+TileSprite": [1217, 952, 2],
  Circle0: {
    "^": "Circle;x:Phaser$Circle0$x*-601,y:Phaser$Circle0$y*-601,_diameter@-601,_radius@-601,x-601,y-601,radius-601",
    get$diameter: [function() {
      return this._diameter;
    }, null, null, 1, 0, 604, "diameter"],
    set$diameter: [function(value) {
      var t1 = J.getInterceptor$n(value);
      if (t1.$gt(value, 0)) {
        this._diameter = value;
        this._radius = t1.$mul(value, 0.5);
      }
    }, null, null, 3, 0, 605, 100, [], "diameter"],
    get$radius: [function() {
      return this._radius;
    }, null, null, 1, 0, 604, "radius"],
    set$radius: [function(value) {
      var t1 = J.getInterceptor$n(value);
      if (t1.$gt(value, 0)) {
        this._radius = value;
        this._diameter = t1.$mul(value, 2);
      }
    }, null, null, 3, 0, 605, 100, [], "radius"],
    get$left: [function(_) {
      return J.$sub$n(this.Phaser$Circle0$x, this._radius);
    }, null, null, 1, 0, 604, "left"],
    set$left: [function(_, value) {
      if (J.$gt$n(value, this.Phaser$Circle0$x)) {
        this._radius = 0;
        this._diameter = 0;
      } else
        this.set$radius(J.$sub$n(this.Phaser$Circle0$x, value));
    }, null, null, 3, 0, 605, 100, [], "left"],
    get$right: [function(_) {
      return J.$sub$n(this.Phaser$Circle0$x, this._radius);
    }, null, null, 1, 0, 604, "right"],
    set$right: [function(_, value) {
      var t1 = J.getInterceptor$n(value);
      if (t1.$lt(value, this.Phaser$Circle0$x)) {
        this._radius = 0;
        this._diameter = 0;
      } else
        this.set$radius(t1.$sub(value, this.Phaser$Circle0$x));
    }, null, null, 3, 0, 605, 100, [], "right"],
    get$top: [function(_) {
      return J.$sub$n(this.Phaser$Circle0$y, this._radius);
    }, null, null, 1, 0, 604, "top"],
    set$top: [function(_, value) {
      if (J.$gt$n(value, this.Phaser$Circle0$y)) {
        this._radius = 0;
        this._diameter = 0;
      } else
        this.set$radius(J.$sub$n(this.Phaser$Circle0$y, value));
    }, null, null, 3, 0, 605, 100, [], "top"],
    get$bottom: [function(_) {
      return J.$sub$n(this.Phaser$Circle0$y, this._radius);
    }, null, null, 1, 0, 604, "bottom"],
    set$bottom: [function(_, value) {
      var t1 = J.getInterceptor$n(value);
      if (t1.$lt(value, this.Phaser$Circle0$y)) {
        this._radius = 0;
        this._diameter = 0;
      } else
        this.set$radius(t1.$sub(value, this.Phaser$Circle0$y));
    }, null, null, 3, 0, 605, 100, [], "bottom"],
    get$area: [function() {
      if (J.$gt$n(this._radius, 0)) {
        var t1 = this._radius;
        if (typeof t1 !== "number")
          return H.iae(t1);
        return 3.141592653589793 * t1 * t1;
      } else
        return 0;
    }, null, null, 1, 0, 604, "area"],
    get$empty: [function() {
      return J.$eq(this._diameter, 0);
    }, null, null, 1, 0, 209, "empty"],
    set$1: [function(value) {
      if (J.$eq(value, true))
        this.setTo$3(0, 0, 0);
    }, "call$1", "get$set", 2, 0, 650, 100, [], "set"],
    circumference$0: [function() {
      var t1 = this._radius;
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 2 * (3.141592653589793 * t1);
    }, "call$0", "get$circumference", 0, 0, 604, "circumference"],
    setTo$3: [function(x, y, diameter) {
      this.Phaser$Circle0$x = x;
      this.Phaser$Circle0$y = y;
      this._diameter = diameter;
      this._radius = J.$mul$ns(diameter, 0.5);
      return this;
    }, "call$3", "get$setTo", 6, 0, 1218, 6, [], 7, [], 1219, [], "setTo"],
    copyFromfunction$1: [function(source) {
      var t1 = J.getInterceptor$x(source);
      return this.setTo$3(t1.get$x(source), t1.get$y(source), source.get$_diameter());
    }, "call$1", "get$copyFromfunction", 2, 0, 1220, 170, [], "copyFromfunction"],
    copyTo$1: [function(dest) {
      var t1 = J.getInterceptor$x(dest);
      t1.set$x(dest, this.Phaser$Circle0$x);
      t1.set$y(dest, this.Phaser$Circle0$y);
      dest.set$diameter(this._diameter);
      return dest;
    }, "call$1", "get$copyTo", 2, 0, 1220, 1221, [], "copyTo"],
    distance$2: [function(dest, round) {
      var t1, t2, t3;
      t1 = J.getInterceptor$x(dest);
      t2 = this.Phaser$Circle0$x;
      t3 = this.Phaser$Circle0$y;
      if (round === true)
        return C.JSNumber_methods.toInt$0(C.JSDouble_methods.roundToDouble$0(R.Math_distance(t2, t3, t1.get$x(dest), t1.get$y(dest))));
      else
        return R.Math_distance(t2, t3, t1.get$x(dest), t1.get$y(dest));
    }, function(dest) {
      return this.distance$2(dest, false);
    }, "distance$1", "call$2", "call$1", "get$distance", 2, 2, 943, 95, 1221, [], 1222, [], "distance"],
    clone$1: [function(_, out) {
      var t1, t2, t3;
      t1 = this.Phaser$Circle0$x;
      t2 = this.Phaser$Circle0$y;
      t3 = this._diameter;
      if (out == null)
        out = R.Circle$(t1, t2, t3);
      else
        out.setTo$3(t1, t2, t3);
      return out;
    }, function($receiver) {
      return this.clone$1($receiver, null);
    }, "clone$0", "call$1", "call$0", "get$clone", 0, 2, 1223, 32, 317, [], "clone"],
    contains$2: [function(_, x, y) {
      var t1, t2;
      if (J.$gt$n(this._radius, 0)) {
        t1 = J.getInterceptor$n(x);
        if (t1.$ge(x, J.$sub$n(this.Phaser$Circle0$x, this._radius)))
          if (t1.$le(x, J.$sub$n(this.Phaser$Circle0$x, this._radius))) {
            t1 = J.getInterceptor$n(y);
            t1 = t1.$ge(y, J.$sub$n(this.Phaser$Circle0$y, this._radius)) && t1.$le(y, J.$sub$n(this.Phaser$Circle0$y, this._radius));
          } else
            t1 = false;
        else
          t1 = false;
      } else
        t1 = false;
      if (t1) {
        t1 = J.getInterceptor$n(x);
        t2 = J.getInterceptor$n(y);
        t2 = J.$add$ns(J.$mul$ns(t1.$sub(x, x), t1.$sub(x, x)), J.$mul$ns(t2.$sub(y, y), t2.$sub(y, y)));
        t1 = this._radius;
        return J.$le$n(t2, J.$mul$ns(t1, t1));
      } else
        return false;
    }, "call$2", "get$contains", 4, 0, 625, 6, [], 7, [], "contains"],
    circumferencePoint$3: [function(angle, asDegrees, out) {
      var t1, t2, t3, t4;
      if (out == null) {
        out = new R.Point(null, null);
        out.x = 0;
        out.y = 0;
      }
      if (J.$eq(asDegrees, true))
        angle = J.$mul$ns(angle, 0.017453292519943295);
      t1 = this.Phaser$Circle0$x;
      t2 = this._radius;
      t3 = typeof angle !== "number";
      if (t3)
        H.throwExpression(P.ArgumentError$(angle));
      t4 = J.getInterceptor$x(out);
      t4.set$x(out, J.$add$ns(t1, J.$mul$ns(t2, Math.cos(angle))));
      t2 = this.Phaser$Circle0$y;
      t1 = this._radius;
      if (t3)
        H.throwExpression(P.ArgumentError$(angle));
      t4.set$y(out, J.$add$ns(t2, J.$mul$ns(t1, Math.sin(angle))));
      return out;
    }, function(angle) {
      return this.circumferencePoint$3(angle, false, null);
    }, "circumferencePoint$1", function(angle, asDegrees) {
      return this.circumferencePoint$3(angle, asDegrees, null);
    }, "circumferencePoint$2", "call$3", "call$1", "call$2", "get$circumferencePoint", 2, 4, 1224, 95, 32, 373, [], 1225, [], 317, [], "circumferencePoint"],
    intersects$2: [function(_, a, b) {
      var t1, t2;
      t1 = J.getInterceptor$x(a);
      t2 = J.getInterceptor$x(b);
      t2 = R.Math_distance(t1.get$x(a), t1.get$y(a), t2.get$x(b), t2.get$y(b));
      t1 = J.$add$ns(a.get$radius(), b.get$radius());
      if (typeof t1 !== "number")
        return H.iae(t1);
      return t2 <= t1;
    }, "call$2", "get$intersects", 4, 0, 303, 304, [], 305, [], "intersects"],
    offset$2: [function(_, dx, dy) {
      this.Phaser$Circle0$x = J.$add$ns(this.Phaser$Circle0$x, dx);
      this.Phaser$Circle0$y = J.$add$ns(this.Phaser$Circle0$y, dy);
      return this;
    }, "call$2", "get$offset", 4, 0, 1226, 1227, [], 1228, [], "offset"],
    offsetPoint$1: [function(point) {
      var t1, t2;
      t1 = J.getInterceptor$x(point);
      t2 = t1.get$x(point);
      t1 = t1.get$y(point);
      this.Phaser$Circle0$x = J.$add$ns(this.Phaser$Circle0$x, t2);
      this.Phaser$Circle0$y = J.$add$ns(this.Phaser$Circle0$y, t1);
      return this;
    }, "call$1", "get$offsetPoint", 2, 0, 1229, 433, [], "offsetPoint"],
    toString$0: [function(_) {
      return "[{Phaser.Circle (x=" + H.S(this.Phaser$Circle0$x) + " + " + H.S(this.Phaser$Circle0$y) + "=" + H.S(this.Phaser$Circle0$y) + " " + H.S(this._diameter) + "=" + H.S(this._diameter) + " + " + H.S(this._radius) + "=" + H.S(this._radius) + ")}]";
    }, "call$0", "get$toString", 0, 0, 782, "toString"],
    Circle$3: function(x, y, _diameter) {
      if (J.$gt$n(this._diameter, 0))
        this._radius = J.$mul$ns(this._diameter, 0.5);
      else
        this._radius = 0;
    },
    $isCircle0: true,
    static: {Circle$: [function(x, y, _diameter) {
        var t1 = new R.Circle0(x, y, _diameter, null, 0, 0, 0);
        t1.Circle$3(x, y, _diameter);
        return t1;
      }, null, null, 0, 6, 4, 5, 5, 5, 6, [], 7, [], 299, [], "new Circle"], Circle_intersectsRectangle: [function(c, r) {
        var t1, t2, cx, t3, cy, xCornerDist, yCornerDist, xCornerDistSq, yCornerDistSq, maxCornerDistSq;
        t1 = J.getInterceptor$x(c);
        t2 = J.getInterceptor$x(r);
        cx = J.abs$0$n(J.$sub$n(J.$sub$n(t1.get$x(c), t2.get$x(r)), r.get$halfWidth()));
        t3 = J.getInterceptor$n(cx);
        if (t3.$gt(cx, J.$add$ns(r.get$halfWidth(), c.get$radius())))
          return false;
        cy = J.abs$0$n(J.$sub$n(J.$sub$n(t1.get$y(c), t2.get$y(r)), r.get$halfHeight()));
        t1 = J.getInterceptor$n(cy);
        if (t1.$gt(cy, J.$add$ns(r.get$halfHeight(), c.get$radius())))
          return false;
        if (t3.$le(cx, r.get$halfWidth()) || t1.$le(cy, r.get$halfHeight()))
          return true;
        xCornerDist = t3.$sub(cx, r.get$halfWidth());
        yCornerDist = t1.$sub(cy, r.get$halfHeight());
        xCornerDistSq = J.$mul$ns(xCornerDist, xCornerDist);
        yCornerDistSq = J.$mul$ns(yCornerDist, yCornerDist);
        maxCornerDistSq = J.$mul$ns(c.get$radius(), c.get$radius());
        return J.$le$n(J.$add$ns(xCornerDistSq, yCornerDistSq), maxCornerDistSq);
      }, "call$2", "Circle_intersectsRectangle$closure", 4, 0, 300, 301, [], 302, [], "intersectsRectangle"], Circle_equals: [function(a, b) {
        var t1, t2;
        t1 = J.getInterceptor$x(a);
        t2 = J.getInterceptor$x(b);
        return J.$eq(t1.get$x(a), t2.get$x(b)) && J.$eq(t1.get$y(a), t2.get$y(b)) && J.$eq(a.get$diameter(), b.get$diameter());
      }, "call$2", "Circle_equals$closure", 4, 0, 303, 304, [], 305, [], "equals"]}
  },
  "+Circle": [1230],
  Ellipse0: {
    "^": "Ellipse;type*-599,x:Phaser$Ellipse0$x*-601,y:Phaser$Ellipse0$y*-601,width:Phaser$Ellipse0$width*-601,height:Phaser$Ellipse0$height*-601,x-601,y-601,width-601,height-601",
    get$left: [function(_) {
      return this.Phaser$Ellipse0$x;
    }, null, null, 1, 0, 604, "left"],
    set$left: [function(_, value) {
      this.Phaser$Ellipse0$x = value;
    }, null, null, 3, 0, 605, 100, [], "left"],
    get$right: [function(_) {
      return J.$add$ns(this.Phaser$Ellipse0$x, this.Phaser$Ellipse0$width);
    }, null, null, 1, 0, 604, "right"],
    set$right: [function(_, value) {
      if (J.$lt$n(value, this.Phaser$Ellipse0$x))
        this.Phaser$Ellipse0$width = 0;
      else
        this.Phaser$Ellipse0$width = J.$add$ns(this.Phaser$Ellipse0$x, value);
    }, null, null, 3, 0, 605, 100, [], "right"],
    get$top: [function(_) {
      return this.Phaser$Ellipse0$y;
    }, null, null, 1, 0, 604, "top"],
    set$top: [function(_, value) {
      this.Phaser$Ellipse0$y = value;
    }, null, null, 3, 0, 605, 100, [], "top"],
    get$bottom: [function(_) {
      return J.$add$ns(this.Phaser$Ellipse0$y, this.Phaser$Ellipse0$height);
    }, null, null, 1, 0, 604, "bottom"],
    set$bottom: [function(_, value) {
      if (J.$lt$n(value, this.Phaser$Ellipse0$y))
        this.Phaser$Ellipse0$height = 0;
      else
        this.Phaser$Ellipse0$height = J.$add$ns(this.Phaser$Ellipse0$y, value);
    }, null, null, 3, 0, 605, 100, [], "bottom"],
    get$empty: [function() {
      return J.$eq(this.Phaser$Ellipse0$width, 0) || J.$eq(this.Phaser$Ellipse0$height, 0);
    }, null, null, 1, 0, 209, "empty"],
    set$1: [function(value) {
      if (J.$eq(value, true))
        this.setTo$4(0, 0, 0, 0);
    }, "call$1", "get$set", 2, 0, 650, 100, [], "set"],
    setTo$4: [function(x, y, width, height) {
      this.Phaser$Ellipse0$x = x;
      this.Phaser$Ellipse0$y = y;
      this.Phaser$Ellipse0$width = width;
      this.Phaser$Ellipse0$height = height;
      return this;
    }, "call$4", "get$setTo", 8, 0, 1231, 6, [], 7, [], 10, [], 11, [], "setTo"],
    copyFrom$1: [function(source) {
      var t1 = J.getInterceptor$x(source);
      return this.setTo$4(t1.get$x(source), t1.get$y(source), t1.get$width(source), t1.get$height(source));
    }, "call$1", "get$copyFrom", 2, 0, 1232, 170, [], "copyFrom"],
    copyTo$1: [function(dest) {
      var t1 = J.getInterceptor$x(dest);
      t1.set$x(dest, this.Phaser$Ellipse0$x);
      t1.set$y(dest, this.Phaser$Ellipse0$y);
      t1.set$width(dest, this.Phaser$Ellipse0$width);
      t1.set$height(dest, this.Phaser$Ellipse0$height);
      return dest;
    }, "call$1", "get$copyTo", 2, 0, 63, 1221, [], "copyTo"],
    clone$1: [function(_, out) {
      var t1, t2, t3, t4;
      t1 = this.Phaser$Ellipse0$x;
      t2 = this.Phaser$Ellipse0$y;
      t3 = this.Phaser$Ellipse0$width;
      t4 = this.Phaser$Ellipse0$height;
      if (out == null) {
        out = new R.Ellipse0(null, null, null, null, null, 0, 0, 0, 0);
        out.Ellipse$4(t1, t2, t3, t4);
      } else
        out.setTo$4(t1, t2, t3, t4);
      return out;
    }, function($receiver) {
      return this.clone$1($receiver, null);
    }, "clone$0", "call$1", "call$0", "get$clone", 0, 2, 1233, 32, 317, [], "clone"],
    contains$2: [function(_, x, y) {
      var normx, normy;
      if (J.$le$n(this.Phaser$Ellipse0$width, 0) || J.$le$n(this.Phaser$Ellipse0$height, 0))
        return false;
      normx = J.$sub$n(J.$div$n(J.$sub$n(x, this.Phaser$Ellipse0$x), this.Phaser$Ellipse0$width), 0.5);
      normy = J.$sub$n(J.$div$n(J.$sub$n(y, this.Phaser$Ellipse0$y), this.Phaser$Ellipse0$height), 0.5);
      return J.$lt$n(J.$add$ns(J.$mul$ns(normx, normx), J.$mul$ns(normy, normy)), 0.25);
    }, "call$2", "get$contains", 4, 0, 625, 6, [], 7, [], "contains"],
    toString$0: [function(_) {
      return "[{Phaser.Ellipse (x=" + H.S(this.Phaser$Ellipse0$x) + " y=" + H.S(this.Phaser$Ellipse0$y) + " width=" + H.S(this.Phaser$Ellipse0$width) + " height=" + H.S(this.Phaser$Ellipse0$height) + ")}]";
    }, "call$0", "get$toString", 0, 0, 782, "toString"],
    getBounds$0: [function() {
      return new R.Rectangle1(this.Phaser$Ellipse0$x, this.Phaser$Ellipse0$y, this.Phaser$Ellipse0$width, this.Phaser$Ellipse0$height, 0, 0, 0, 0);
    }, "call$0", "get$getBounds", 0, 0, 1234, "getBounds"],
    Ellipse$4: function(x, y, width, height) {
      this.type = 16;
      this.Phaser$Ellipse0$x = x;
      this.Phaser$Ellipse0$y = y;
      this.Phaser$Ellipse0$width = width;
      this.Phaser$Ellipse0$height = height;
    },
    static: {Ellipse$0: [function(x, y, width, height) {
        var t1 = new R.Ellipse0(null, null, null, null, null, 0, 0, 0, 0);
        t1.Ellipse$4(x, y, width, height);
        return t1;
      }, null, null, 8, 0, 306, 6, [], 7, [], 10, [], 11, [], "new Ellipse"]}
  },
  "+Ellipse": [1235],
  Line: {
    "^": "Object;x1*-601,x2*-601,y1*-601,y2*-601,start*-600,end@-600",
    start$1: function($receiver, arg0) {
      return this.start.call$1(arg0);
    },
    start$0: function($receiver) {
      return this.start.call$0();
    },
    start$3: function($receiver, arg0, arg1, arg2) {
      return this.start.call$3(arg0, arg1, arg2);
    },
    start$2: function($receiver, arg0, arg1) {
      return this.start.call$2(arg0, arg1);
    },
    start$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.start.call$4(arg0, arg1, arg2, arg3);
    },
    start$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.start.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    end$0: function() {
      return this.end.call$0();
    },
    setTo$4: [function(x1, y1, x2, y2) {
      this.start.setTo$2(x1, y1);
      this.end.setTo$2(x2, y2);
      return this;
    }, function(x1, y1) {
      return this.setTo$4(x1, y1, 0, 0);
    }, "setTo$2", function(x1, y1, x2) {
      return this.setTo$4(x1, y1, x2, 0);
    }, "setTo$3", function() {
      return this.setTo$4(0, 0, 0, 0);
    }, "setTo$0", function(x1) {
      return this.setTo$4(x1, 0, 0, 0);
    }, "setTo$1", "call$4", "call$2", "call$3", "call$0", "call$1", "get$setTo", 0, 8, 1078, 5, 5, 5, 5, 307, [], 308, [], 309, [], 310, [], "setTo"],
    fromSprite$3: [function(startSprite, endSprite, useCenter) {
      var t1, t2, t3, t4;
      if (useCenter === true) {
        t1 = startSprite.get$center().x;
        t2 = startSprite.get$center().y;
        t3 = endSprite.get$center().x;
        t4 = endSprite.get$center().y;
        this.start.setTo$2(t1, t2);
        this.end.setTo$2(t3, t4);
        return this;
      } else {
        t1 = J.getInterceptor$x(startSprite);
        t2 = t1.get$x(startSprite);
        t1 = t1.get$y(startSprite);
        t3 = J.getInterceptor$x(endSprite);
        t4 = t3.get$x(endSprite);
        t3 = t3.get$y(endSprite);
        this.start.setTo$2(t2, t1);
        this.end.setTo$2(t4, t3);
        return this;
      }
    }, function(startSprite, endSprite) {
      return this.fromSprite$3(startSprite, endSprite, false);
    }, "fromSprite$2", "call$3", "call$2", "get$fromSprite", 4, 2, 1236, 95, 1237, [], 1238, [], 1239, [], "fromSprite"],
    intersects$3: [function(_, line, asSegment, result) {
      return R.Line_intersectsPoints(this.start, this.end, J.get$start$x(line), line.get$end(), asSegment, result);
    }, function($receiver, line) {
      return this.intersects$3($receiver, line, null, null);
    }, "intersects$1", function($receiver, line, asSegment) {
      return this.intersects$3($receiver, line, asSegment, null);
    }, "intersects$2", "call$3", "call$1", "call$2", "get$intersects", 2, 4, 1240, 32, 32, 1197, [], 314, [], 315, [], "intersects"],
    pointOnLine$2: [function(x, y) {
      return J.$eq(J.$mul$ns(J.$sub$n(x, J.get$x$x(this.start)), J.$sub$n(J.get$y$x(this.end), J.get$y$x(this.start))), J.$mul$ns(J.$sub$n(J.get$x$x(this.end), J.get$x$x(this.start)), J.$sub$n(y, J.get$y$x(this.start))));
    }, "call$2", "get$pointOnLine", 4, 0, 909, 6, [], 7, [], "pointOnLine"],
    pointOnSegment$2: [function(x, y) {
      var xMin, xMax, yMin, yMax, t1, t2;
      xMin = P.min(J.get$x$x(this.start), J.get$x$x(this.end));
      xMax = P.max(J.get$x$x(this.start), J.get$x$x(this.end));
      yMin = P.min(J.get$y$x(this.start), J.get$y$x(this.end));
      yMax = P.max(J.get$y$x(this.start), J.get$y$x(this.end));
      t1 = J.getInterceptor$n(x);
      t2 = J.getInterceptor$n(y);
      if (J.$eq(J.$mul$ns(t1.$sub(x, J.get$x$x(this.start)), J.$sub$n(J.get$y$x(this.end), J.get$y$x(this.start))), J.$mul$ns(J.$sub$n(J.get$x$x(this.end), J.get$x$x(this.start)), t2.$sub(y, J.get$y$x(this.start)))))
        t1 = t1.$ge(x, xMin) && t1.$le(x, xMax) && t2.$ge(y, yMin) && t2.$le(y, yMax);
      else
        t1 = false;
      return t1;
    }, "call$2", "get$pointOnSegment", 4, 0, 909, 6, [], 7, [], "pointOnSegment"],
    coordinatesOnLine$2: [function(stepRate, results) {
      var x1, y1, x2, y2, dx, dy, sx, sy, err, t1, t2, i, e2;
      if (results == null)
        results = [];
      x1 = J.round$0$n(J.get$x$x(this.start));
      y1 = J.round$0$n(J.get$y$x(this.start));
      x2 = J.round$0$n(J.get$x$x(this.end));
      y2 = J.round$0$n(J.get$y$x(this.end));
      dx = C.JSInt_methods.abs$0(x2 - x1);
      dy = C.JSInt_methods.abs$0(y2 - y1);
      sx = x1 < x2 ? 1 : -1;
      sy = y1 < y2 ? 1 : -1;
      err = dx - dy;
      t1 = J.getInterceptor$ax(results);
      t1.add$1(results, [x1, y1]);
      t2 = -dy;
      i = 1;
      while (true) {
        if (!!(x1 === x2 && y1 === y2))
          break;
        e2 = err << 1 >>> 0;
        if (e2 > t2) {
          err -= dy;
          x1 += sx;
        }
        if (e2 < dx) {
          err += dx;
          y1 += sy;
        }
        if (typeof stepRate !== "number")
          return H.iae(stepRate);
        if (C.JSInt_methods.$mod(i, stepRate) === 0)
          t1.add$1(results, [x1, y1]);
        ++i;
      }
      return results;
    }, function(stepRate) {
      return this.coordinatesOnLine$2(stepRate, null);
    }, "coordinatesOnLine$1", function() {
      return this.coordinatesOnLine$2(1, null);
    }, "coordinatesOnLine$0", "call$2", "call$1", "call$0", "get$coordinatesOnLine", 0, 4, 1241, 390, 32, 1242, [], 1243, [], "coordinatesOnLine"],
    get$length: [function(_) {
      var t1 = J.$add$ns(J.$mul$ns(J.$sub$n(J.get$x$x(this.end), J.get$x$x(this.start)), J.$sub$n(J.get$x$x(this.end), J.get$x$x(this.start))), J.$mul$ns(J.$sub$n(J.get$y$x(this.end), J.get$y$x(this.start)), J.$sub$n(J.get$y$x(this.end), J.get$y$x(this.start))));
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      return Math.sqrt(t1);
    }, null, null, 1, 0, 367, "length"],
    get$angle: [function() {
      var t1, t2;
      t1 = J.$sub$n(J.get$y$x(this.end), J.get$y$x(this.start));
      t2 = J.$sub$n(J.get$x$x(this.end), J.get$x$x(this.start));
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      return Math.atan2(t1, t2);
    }, null, null, 1, 0, 604, "angle"],
    angle$0: function() {
      return this.get$angle().call$0();
    },
    angle$2: function(arg0, arg1) {
      return this.get$angle().call$2(arg0, arg1);
    },
    get$slope: [function() {
      return J.$div$n(J.$sub$n(J.get$y$x(this.end), J.get$y$x(this.start)), J.$sub$n(J.get$x$x(this.end), J.get$x$x(this.start)));
    }, null, null, 1, 0, 604, "slope"],
    get$perpSlope: [function() {
      return J.$negate$n(J.$div$n(J.$sub$n(J.get$x$x(this.end), J.get$x$x(this.start)), J.$sub$n(J.get$y$x(this.end), J.get$y$x(this.start))));
    }, null, null, 1, 0, 604, "perpSlope"],
    get$x: [function(_) {
      return P.min(J.get$x$x(this.start), J.get$x$x(this.end));
    }, null, null, 1, 0, 604, "x"],
    get$y: [function(_) {
      return P.min(J.get$y$x(this.start), J.get$y$x(this.end));
    }, null, null, 1, 0, 604, "y"],
    get$left: [function(_) {
      return P.min(J.get$x$x(this.start), J.get$x$x(this.end));
    }, null, null, 1, 0, 604, "left"],
    get$right: [function(_) {
      return P.max(J.get$x$x(this.start), J.get$x$x(this.end));
    }, null, null, 1, 0, 604, "right"],
    get$bottom: [function(_) {
      return P.max(J.get$y$x(this.start), J.get$y$x(this.end));
    }, null, null, 1, 0, 604, "bottom"],
    get$width: [function(_) {
      return J.abs$0$n(J.$sub$n(J.get$x$x(this.start), J.get$x$x(this.end)));
    }, null, null, 1, 0, 604, "width"],
    get$height: [function(_) {
      return J.abs$0$n(J.$sub$n(J.get$y$x(this.start), J.get$y$x(this.end)));
    }, null, null, 1, 0, 604, "height"],
    $isLine: true,
    static: {Line$: [function(x1, y1, x2, y2) {
        var t1, t2;
        t1 = new R.Line(x1, x2, y1, y2, null, null);
        t2 = new R.Point(null, null);
        t2.x = x1;
        t2.y = y1;
        t1.start = t2;
        t2 = new R.Point(null, null);
        t2.x = x2;
        t2.y = y2;
        t1.end = t2;
        return t1;
      }, null, null, 0, 8, 9, 5, 5, 5, 5, 307, [], 308, [], 309, [], 310, [], "new Line"], Line_intersectsPoints: [function(a, b, e, f, asSegment, result) {
        var t1, t2, a1, t3, t4, a2, b1, b2, c1, c2, t5, t6, denom, t7, uc, ua, ub;
        if (result == null) {
          result = new R.Point(null, null);
          result.x = 0;
          result.y = 0;
        }
        t1 = J.getInterceptor$x(b);
        t2 = J.getInterceptor$x(a);
        a1 = J.$sub$n(t1.get$y(b), t2.get$y(a));
        t3 = J.getInterceptor$x(f);
        t4 = J.getInterceptor$x(e);
        a2 = J.$sub$n(t3.get$y(f), t4.get$y(e));
        b1 = J.$sub$n(t2.get$x(a), t1.get$x(b));
        b2 = J.$sub$n(t4.get$x(e), t3.get$x(f));
        c1 = J.$sub$n(J.$mul$ns(t1.get$x(b), t2.get$y(a)), J.$mul$ns(t2.get$x(a), t1.get$y(b)));
        c2 = J.$sub$n(J.$mul$ns(t3.get$x(f), t4.get$y(e)), J.$mul$ns(t4.get$x(e), t3.get$y(f)));
        t5 = J.getInterceptor$ns(a1);
        t6 = J.getInterceptor$ns(a2);
        denom = J.$sub$n(t5.$mul(a1, b2), t6.$mul(a2, b1));
        if (J.$eq(denom, 0))
          return;
        t7 = J.getInterceptor$x(result);
        t7.set$x(result, J.$div$n(J.$sub$n(J.$mul$ns(b1, c2), J.$mul$ns(b2, c1)), denom));
        t7.set$y(result, J.$div$n(J.$sub$n(t6.$mul(a2, c1), t5.$mul(a1, c2)), denom));
        if (asSegment === true) {
          uc = J.$sub$n(J.$mul$ns(J.$sub$n(t3.get$y(f), t4.get$y(e)), J.$sub$n(t1.get$x(b), t2.get$x(a))), J.$mul$ns(J.$sub$n(t3.get$x(f), t4.get$x(e)), J.$sub$n(t1.get$y(b), t2.get$y(a))));
          ua = J.$div$n(J.$sub$n(J.$mul$ns(J.$sub$n(t3.get$x(f), t4.get$x(e)), J.$sub$n(t2.get$y(a), t4.get$y(e))), J.$mul$ns(J.$sub$n(t3.get$y(f), t4.get$y(e)), J.$sub$n(t2.get$x(a), t4.get$x(e)))), uc);
          ub = J.$div$n(J.$sub$n(J.$mul$ns(J.$sub$n(t1.get$x(b), t2.get$x(a)), J.$sub$n(t2.get$y(a), t4.get$y(e))), J.$mul$ns(J.$sub$n(t1.get$y(b), t2.get$y(a)), J.$sub$n(t2.get$x(a), t4.get$x(e)))), uc);
          t1 = J.getInterceptor$n(ua);
          if (t1.$ge(ua, 0))
            if (t1.$le(ua, 1)) {
              t1 = J.getInterceptor$n(ub);
              t1 = t1.$ge(ub, 0) && t1.$le(ub, 1);
            } else
              t1 = false;
          else
            t1 = false;
          if (t1)
            return result;
          else
            return;
        }
        return result;
      }, function(a, b, e, f) {
        return R.Line_intersectsPoints(a, b, e, f, true, null);
      }, null, function(a, b, e, f, asSegment) {
        return R.Line_intersectsPoints(a, b, e, f, asSegment, null);
      }, null, "call$6", "call$4", "call$5", "Line_intersectsPoints$closure", 8, 4, 311, 39, 32, 304, [], 305, [], 312, [], 313, [], 314, [], 315, [], "intersectsPoints"]}
  },
  "+Line": [632],
  Point: {
    "^": "Point0;x-601,y-601",
    copyFrom$1: [function(source) {
      var t1 = J.getInterceptor$x(source);
      return this.setTo$2(t1.get$x(source), t1.get$y(source));
    }, "call$1", "get$copyFrom", 2, 0, 1244, 170, [], "copyFrom"],
    invert$0: [function() {
      return this.setTo$2(this.y, this.x);
    }, "call$0", "get$invert", 0, 0, 1019, "invert"],
    setTo$2: [function(x, y) {
      this.x = x;
      this.y = y == null ? x : y;
      return this;
    }, function() {
      return this.setTo$2(0, null);
    }, "setTo$0", function(x) {
      return this.setTo$2(x, null);
    }, "setTo$1", "call$2", "call$0", "call$1", "get$setTo", 0, 4, 1245, 5, 32, 6, [], 7, [], "setTo"],
    set$2: [function(x, y) {
      this.x = x;
      this.y = y == null ? x : y;
      return this;
    }, function(x) {
      return this.set$2(x, null);
    }, "set$1", function() {
      return this.set$2(0, null);
    }, "set$0", "call$2", "call$1", "call$0", "get$set", 0, 4, 1245, 5, 32, 6, [], 7, [], "set"],
    add$2: [function(_, x, y) {
      this.x = J.$add$ns(this.x, x);
      this.y = J.$add$ns(this.y, y);
      return this;
    }, "call$2", "get$add", 4, 0, 1246, 6, [], 7, [], "add"],
    subtract$2: [function(x, y) {
      this.x = J.$sub$n(this.x, x);
      this.y = J.$sub$n(this.y, y);
      return this;
    }, "call$2", "get$subtract", 4, 0, 1246, 6, [], 7, [], "subtract"],
    multiply$2: [function(x, y) {
      this.x = J.$mul$ns(this.x, x);
      this.y = J.$mul$ns(this.y, y);
      return this;
    }, "call$2", "get$multiply", 4, 0, 1246, 6, [], 7, [], "multiply"],
    divide$2: [function(x, y) {
      this.x = J.$div$n(this.x, x);
      this.y = J.$div$n(this.y, y);
      return this;
    }, "call$2", "get$divide", 4, 0, 1246, 6, [], 7, [], "divide"],
    clampX$2: [function(min, max) {
      var t1, t2;
      t1 = this.x;
      t2 = J.getInterceptor$n(t1);
      if (t2.$lt(t1, min))
        t1 = min;
      else if (t2.$gt(t1, max))
        t1 = max;
      this.x = t1;
      return this;
    }, "call$2", "get$clampX", 4, 0, 1246, 364, [], 365, [], "clampX"],
    clampY$2: [function(min, max) {
      var t1, t2;
      t1 = this.y;
      t2 = J.getInterceptor$n(t1);
      if (t2.$lt(t1, min))
        t1 = min;
      else if (t2.$gt(t1, max))
        t1 = max;
      this.y = t1;
      return this;
    }, "call$2", "get$clampY", 4, 0, 1246, 364, [], 365, [], "clampY"],
    clamp$2: [function(_, min, max) {
      var t1, t2;
      t1 = this.x;
      t2 = J.getInterceptor$n(t1);
      if (t2.$lt(t1, min))
        t1 = min;
      else if (t2.$gt(t1, max))
        t1 = max;
      this.x = t1;
      t1 = this.y;
      t2 = J.getInterceptor$n(t1);
      if (t2.$lt(t1, min))
        t1 = min;
      else if (t2.$gt(t1, max))
        t1 = max;
      this.y = t1;
      return this;
    }, "call$2", "get$clamp", 4, 0, 1246, 364, [], 365, [], "clamp"],
    clone$1: [function(_, output) {
      var t1, t2;
      t1 = this.x;
      t2 = this.y;
      if (output == null) {
        output = new R.Point(null, null);
        output.x = t1;
        output.y = t2;
      } else
        output.setTo$2(t1, t2);
      return output;
    }, function($receiver) {
      return this.clone$1($receiver, null);
    }, "clone$0", "call$1", "call$0", "get$clone", 0, 2, 1247, 32, 973, [], "clone"],
    copyTo$1: [function(dest) {
      var t1 = J.getInterceptor$x(dest);
      t1.set$x(dest, this.x);
      t1.set$y(dest, this.y);
      return dest;
    }, "call$1", "get$copyTo", 2, 0, 63, 1221, [], "copyTo"],
    distance$2: [function(b, round) {
      var t1, t2, t3;
      t1 = J.getInterceptor$x(b);
      t2 = this.x;
      t3 = this.y;
      if (round === true)
        return C.JSNumber_methods.toInt$0(C.JSDouble_methods.roundToDouble$0(R.Math_distance(t2, t3, t1.get$x(b), t1.get$y(b))));
      else
        return R.Math_distance(t2, t3, t1.get$x(b), t1.get$y(b));
    }, function(b) {
      return this.distance$2(b, false);
    }, "distance$1", "call$2", "call$1", "get$distance", 2, 2, 1248, 95, 305, [], 1222, [], "distance"],
    equals$1: [function(a) {
      var t1 = J.getInterceptor$x(a);
      return J.$eq(t1.get$x(a), this.x) && J.$eq(t1.get$y(a), this.y);
    }, "call$1", "get$equals", 2, 0, 1249, 304, [], "equals"],
    angle$2: [function(a, asDegrees) {
      var t1, t2;
      t1 = J.getInterceptor$x(a);
      if (asDegrees === true) {
        t2 = J.$sub$n(t1.get$y(a), this.y);
        t1 = J.$sub$n(t1.get$x(a), this.x);
        if (typeof t2 !== "number")
          H.throwExpression(P.ArgumentError$(t2));
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        return Math.atan2(t2, t1) * 57.29577951308232;
      } else {
        t2 = J.$sub$n(t1.get$y(a), this.y);
        t1 = J.$sub$n(t1.get$x(a), this.x);
        if (typeof t2 !== "number")
          H.throwExpression(P.ArgumentError$(t2));
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        return Math.atan2(t2, t1);
      }
    }, function(a) {
      return this.angle$2(a, false);
    }, "angle$1", "call$2", "call$1", "get$angle", 2, 2, 1250, 95, 304, [], 1225, [], "angle"],
    angleSq$1: [function(a) {
      return this.$sub(0, a).angle$1(J.$sub$n(a, this));
    }, "call$1", "get$angleSq", 2, 0, 1251, 304, [], "angleSq"],
    rotate$5: [function(_, x, y, angle, asDegrees, distance) {
      var t1, t2, t3;
      if (asDegrees === true)
        angle = J.$mul$ns(angle, 0.017453292519943295);
      if (distance == null)
        distance = R.Math_distance(x, y, this.x, this.y);
      t1 = typeof angle !== "number";
      if (t1)
        H.throwExpression(P.ArgumentError$(angle));
      t2 = J.getInterceptor$ns(distance);
      t3 = J.$add$ns(x, t2.$mul(distance, Math.cos(angle)));
      if (t1)
        H.throwExpression(P.ArgumentError$(angle));
      return this.setTo$2(t3, J.$add$ns(y, t2.$mul(distance, Math.sin(angle))));
    }, function($receiver, x, y, angle) {
      return this.rotate$5($receiver, x, y, angle, false, null);
    }, "rotate$3", function($receiver, x, y, angle, asDegrees) {
      return this.rotate$5($receiver, x, y, angle, asDegrees, null);
    }, "rotate$4", "call$5", "call$3", "call$4", "get$rotate", 6, 4, 1252, 95, 32, 6, [], 7, [], 373, [], 1225, [], 1253, [], "rotate"],
    getMagnitude$0: [function() {
      var t1, t2;
      t1 = this.x;
      t1 = J.$mul$ns(t1, t1);
      t2 = this.y;
      t2 = J.$add$ns(t1, J.$mul$ns(t2, t2));
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      return Math.sqrt(t2);
    }, "call$0", "get$getMagnitude", 0, 0, 604, "getMagnitude"],
    getMagnitudeSq$0: [function() {
      var t1, t2;
      t1 = this.x;
      t1 = J.$mul$ns(t1, t1);
      t2 = this.y;
      return J.$add$ns(t1, J.$mul$ns(t2, t2));
    }, "call$0", "get$getMagnitudeSq", 0, 0, 604, "getMagnitudeSq"],
    setMagnitude$1: [function(magnitude) {
      var t1, t2, m;
      if (!(J.$eq(this.x, 0) && J.$eq(this.y, 0))) {
        t1 = this.x;
        t1 = J.$mul$ns(t1, t1);
        t2 = this.y;
        t2 = J.$add$ns(t1, J.$mul$ns(t2, t2));
        if (typeof t2 !== "number")
          H.throwExpression(P.ArgumentError$(t2));
        m = Math.sqrt(t2);
        this.x = J.$div$n(this.x, m);
        this.y = J.$div$n(this.y, m);
      }
      this.x = J.$mul$ns(this.x, magnitude);
      this.y = J.$mul$ns(this.y, magnitude);
      return this;
    }, "call$1", "get$setMagnitude", 2, 0, 1254, 1255, [], "setMagnitude"],
    normalize$0: [function() {
      var t1, t2, m;
      if (!(J.$eq(this.x, 0) && J.$eq(this.y, 0))) {
        t1 = this.x;
        t1 = J.$mul$ns(t1, t1);
        t2 = this.y;
        t2 = J.$add$ns(t1, J.$mul$ns(t2, t2));
        if (typeof t2 !== "number")
          H.throwExpression(P.ArgumentError$(t2));
        m = Math.sqrt(t2);
        this.x = J.$div$n(this.x, m);
        this.y = J.$div$n(this.y, m);
      }
      return this;
    }, "call$0", "get$normalize", 0, 0, 1019, "normalize"],
    isZero$0: [function() {
      return J.$eq(this.x, 0) && J.$eq(this.y, 0);
    }, "call$0", "get$isZero", 0, 0, 209, "isZero"],
    dot$1: [function(a) {
      var t1 = J.getInterceptor$x(a);
      return J.$add$ns(J.$mul$ns(this.x, t1.get$x(a)), J.$mul$ns(this.y, t1.get$y(a)));
    }, "call$1", "get$dot", 2, 0, 63, 304, [], "dot"],
    cross$1: [function(a) {
      var t1 = J.getInterceptor$x(a);
      return J.$sub$n(J.$mul$ns(this.x, t1.get$y(a)), J.$mul$ns(this.y, t1.get$x(a)));
    }, "call$1", "get$cross", 2, 0, 1256, 304, [], "cross"],
    perp$0: [function() {
      return this.setTo$2(J.$negate$n(this.y), this.x);
    }, "call$0", "get$perp", 0, 0, 1019, "perp"],
    rperp$0: [function() {
      return this.setTo$2(this.y, J.$negate$n(this.x));
    }, "call$0", "get$rperp", 0, 0, 1019, "rperp"],
    normalRightHand$0: [function() {
      return this.setTo$2(J.$mul$ns(this.y, -1), this.x);
    }, "call$0", "get$normalRightHand", 0, 0, 1019, "normalRightHand"],
    toString$0: [function(_) {
      return "[{Point (x=" + H.S(this.x) + " y=" + H.S(this.y) + ")}]";
    }, "call$0", "get$toString", 0, 0, 782, "toString"],
    $add: [function(_, b) {
      var out, t1;
      out = new R.Point(null, null);
      out.x = 0;
      out.y = 0;
      t1 = J.getInterceptor$x(b);
      out.x = J.$add$ns(this.x, t1.get$x(b));
      out.y = J.$add$ns(this.y, t1.get$y(b));
      return out;
    }, "call$1", "get$+", 2, 0, 1244, 305, [], "+"],
    $sub: [function(_, b) {
      var out, t1;
      out = new R.Point(null, null);
      out.x = 0;
      out.y = 0;
      t1 = J.getInterceptor$x(b);
      out.x = J.$sub$n(this.x, t1.get$x(b));
      out.y = J.$sub$n(this.y, t1.get$y(b));
      return out;
    }, "call$1", "get$-", 2, 0, 1244, 305, [], "-"],
    $mul: [function(_, b) {
      var out, t1;
      out = new R.Point(null, null);
      out.x = 0;
      out.y = 0;
      t1 = J.getInterceptor$x(b);
      out.x = J.$mul$ns(this.x, t1.get$x(b));
      out.y = J.$mul$ns(this.y, t1.get$y(b));
      return out;
    }, "call$1", "get$*", 2, 0, 1244, 305, [], "*"],
    $div: [function(_, b) {
      var out, t1;
      out = new R.Point(null, null);
      out.x = 0;
      out.y = 0;
      t1 = J.getInterceptor$x(b);
      out.x = J.$div$n(this.x, t1.get$x(b));
      out.y = J.$div$n(this.y, t1.get$y(b));
      return out;
    }, "call$1", "get$/", 2, 0, 1244, 305, [], "/"],
    $eq: [function(_, b) {
      var t1;
      if (b == null)
        return false;
      t1 = J.getInterceptor$x(b);
      return J.$eq(this.x, t1.get$x(b)) && J.$eq(this.y, t1.get$y(b));
    }, "call$1", "get$==", 2, 0, 1249, 305, [], "=="],
    get$hashCode: [function(_) {
      var t1, t2;
      t1 = J.get$hashCode$(this.x);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = J.get$hashCode$(this.y);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return 37 * (629 + t1) + t2;
    }, null, null, 1, 0, 367, "hashCode"],
    multiplyAdd$4: [function(a, b, s, out) {
      var t1, t2;
      if (out == null) {
        out = new R.Point(null, null);
        out.x = 0;
        out.y = 0;
      }
      t1 = J.getInterceptor$x(a);
      t2 = J.getInterceptor$x(b);
      return out.setTo$2(J.$add$ns(t1.get$x(a), J.$mul$ns(t2.get$x(b), s)), J.$add$ns(t1.get$y(a), J.$mul$ns(t2.get$y(b), s)));
    }, function(a, b, s) {
      return this.multiplyAdd$4(a, b, s, null);
    }, "multiplyAdd$3", "call$4", "call$3", "get$multiplyAdd", 6, 2, 316, 32, 304, [], 305, [], 502, [], 317, [], "multiplyAdd"],
    $isPoint: true,
    static: {Point$0: [function(x, y) {
        var t1 = new R.Point(null, null);
        t1.x = x;
        t1.y = y;
        return t1;
      }, null, null, 0, 4, 16, 5, 5, 6, [], 7, [], "new Point"], Point_interpolate: [function(a, b, f, out) {
        var t1, t2;
        if (out == null) {
          out = new R.Point(null, null);
          out.x = 0;
          out.y = 0;
        }
        t1 = J.getInterceptor$x(a);
        t2 = J.getInterceptor$x(b);
        return out.setTo$2(J.$add$ns(t1.get$x(a), J.$mul$ns(J.$sub$n(t2.get$x(b), t1.get$x(a)), f)), J.$add$ns(t1.get$y(a), J.$mul$ns(J.$sub$n(t2.get$y(b), t1.get$y(a)), f)));
      }, function(a, b, f) {
        return R.Point_interpolate(a, b, f, null);
      }, null, "call$4", "call$3", "Point_interpolate$closure", 6, 2, 316, 32, 304, [], 305, [], 313, [], 317, [], "interpolate"], Point_project: [function(a, b, out) {
        var amt, t1, t2;
        if (out == null) {
          out = new R.Point(null, null);
          out.x = 0;
          out.y = 0;
        }
        amt = J.$div$n(a.dot$1(b), b.getMagnitudeSq$0());
        t1 = J.getInterceptor(amt);
        if (!t1.$eq(amt, 0)) {
          t2 = J.getInterceptor$x(b);
          out.setTo$2(t1.$mul(amt, t2.get$x(b)), t1.$mul(amt, t2.get$y(b)));
        }
        return out;
      }, function(a, b) {
        return R.Point_project(a, b, null);
      }, null, "call$3", "call$2", "Point_project$closure", 4, 2, 318, 32, 304, [], 305, [], 317, [], "project"], Point_projectUnit: [function(a, b, out) {
        var amt, t1, t2;
        if (out == null) {
          out = new R.Point(null, null);
          out.x = 0;
          out.y = 0;
        }
        amt = a.dot$1(b);
        t1 = J.getInterceptor(amt);
        if (!t1.$eq(amt, 0)) {
          t2 = J.getInterceptor$x(b);
          out.setTo$2(t1.$mul(amt, t2.get$x(b)), t1.$mul(amt, t2.get$y(b)));
        }
        return out;
      }, function(a, b) {
        return R.Point_projectUnit(a, b, null);
      }, null, "call$3", "call$2", "Point_projectUnit$closure", 4, 2, 318, 32, 304, [], 305, [], 317, [], "projectUnit"], Point_centroid: [function(points, out) {
        var t1, pointslength, t2, i;
        if (out == null) {
          out = new R.Point(null, null);
          out.x = 0;
          out.y = 0;
        }
        t1 = H.checkSubtype(points, "$isList", [R.Point], "$asList");
        if (!t1)
          throw H.wrapException(P.Exception_Exception("Phaser.Point. Parameter 'points' must be an array"));
        t1 = J.getInterceptor$asx(points);
        pointslength = t1.get$length(points);
        t2 = J.getInterceptor$n(pointslength);
        if (t2.$lt(pointslength, 1))
          throw H.wrapException(P.Exception_Exception("Phaser.Point. Parameter 'points' array must not be empty"));
        if (t2.$eq(pointslength, 1)) {
          out.copyFrom$1(t1.$index(points, 0));
          return out;
        }
        if (typeof pointslength !== "number")
          return H.iae(pointslength);
        t2 = J.getInterceptor$ax(out);
        i = 0;
        for (; i < pointslength; ++i)
          t2.add$2(out, J.get$x$x(t1.$index(points, i)), J.get$y$x(t1.$index(points, i)));
        out.divide$2(pointslength, pointslength);
        return out;
      }, function(points) {
        return R.Point_centroid(points, null);
      }, null, "call$2", "call$1", "Point_centroid$closure", 2, 2, 319, 32, 17, [], 317, [], "centroid"]}
  },
  "+Point": [634],
  Polygon0: {
    "^": "Object;_points@-1257,type*-599",
    get$points: [function(_) {
      return this._points;
    }, null, null, 1, 0, 1258, "points"],
    set$1: [function(points) {
      this._points = points;
    }, "call$1", "get$set", 2, 0, 320, 17, [], "set"],
    get$area: [function() {
      var i, y0, t1, area, p1, t2, p2;
      i = 0;
      y0 = 1 / 0;
      while (true) {
        t1 = J.get$length$asx(this._points);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$lt$n(J.get$y$x(J.$index$asx(this._points, i)), y0))
          y0 = J.get$y$x(J.$index$asx(this._points, i));
        ++i;
      }
      i = 0;
      area = 0;
      while (true) {
        t1 = J.get$length$asx(this._points);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        p1 = J.$index$asx(this._points, i);
        t1 = J.$sub$n(J.get$length$asx(this._points), 1);
        t2 = this._points;
        p2 = i === t1 ? J.$index$asx(t2, 0) : J.$index$asx(t2, i + 1);
        t1 = J.getInterceptor$x(p1);
        t2 = J.getInterceptor$x(p2);
        t2 = J.$mul$ns(J.$div$n(J.$add$ns(J.$sub$n(t1.get$y(p1), y0), J.$sub$n(t2.get$y(p2), y0)), 2), J.$sub$n(t1.get$x(p1), t2.get$x(p2)));
        if (typeof t2 !== "number")
          return H.iae(t2);
        area += t2;
        ++i;
      }
      return area;
    }, null, null, 1, 0, 604, "area"],
    clone$0: [function(_) {
      var points, i, t1;
      points = [];
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._points);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        points.push(J.clone$0$x(J.$index$asx(this._points, i)));
        ++i;
      }
      t1 = new R.Polygon0(points, null);
      t1.type = 12;
      return t1;
    }, "call$0", "get$clone", 0, 0, 13, "clone"],
    contains$2: [function(_, x, y) {
      var j, t1, t2, inside, i, t3, xi, yi, xj, yj, i0;
      j = J.$sub$n(J.get$length$asx(this._points), 1);
      t1 = J.getInterceptor$n(y);
      t2 = J.getInterceptor$n(x);
      inside = false;
      i = 0;
      while (true) {
        t3 = J.get$length$asx(this._points);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        xi = J.get$x$x(J.$index$asx(this._points, i));
        yi = J.get$y$x(J.$index$asx(this._points, i));
        xj = J.get$x$x(J.$index$asx(this._points, j));
        yj = J.get$y$x(J.$index$asx(this._points, j));
        t3 = J.getInterceptor$n(yj);
        if (J.$gt$n(yi, y) !== t3.$gt(yj, y) && t2.$lt(x, J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(xj, xi), t1.$sub(y, yi)), t3.$sub(yj, yi)), xi)))
          inside = !inside;
        i0 = i + 1;
        j = i;
        i = i0;
      }
      return inside;
    }, "call$2", "get$contains", 4, 0, 111, 6, [], 7, [], "contains"],
    static: {Polygon$0: [function(_points) {
        var t1 = new R.Polygon0(_points, null);
        t1.type = 12;
        return t1;
      }, null, null, 2, 0, 320, 321, [], "new Polygon"]}
  },
  "+Polygon": [632],
  Rectangle1: {
    "^": "Rectangle0;x:Phaser$Rectangle1$x*-601,y:Phaser$Rectangle1$y*-601,width:Phaser$Rectangle1$width*-601,height:Phaser$Rectangle1$height*-601,x-601,y-601,width-601,height-601",
    get$halfWidth: [function() {
      return J.round$0$n(J.$div$n(this.get$width(this), 2));
    }, null, null, 1, 0, 604, "halfWidth"],
    get$halfHeight: [function() {
      return J.round$0$n(J.$div$n(this.get$height(this), 2));
    }, null, null, 1, 0, 604, "halfHeight"],
    get$bottom: [function(_) {
      return J.$add$ns(this.get$y(this), this.get$height(this));
    }, null, null, 1, 0, 604, "bottom"],
    set$bottom: [function(_, value) {
      if (J.$le$n(value, this.get$y(this)))
        this.set$height(0, 0);
      else
        this.set$height(0, J.$sub$n(this.get$y(this), value));
    }, null, null, 3, 0, 605, 100, [], "bottom"],
    get$bottomRight: [function(_) {
      var t1, t2, t3;
      t1 = this.get$right(this);
      t2 = this.get$bottom(this);
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1019, "bottomRight"],
    set$bottomRight: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      this.set$right(0, t1.get$x(value));
      t1 = t1.get$y(value);
      if (J.$le$n(t1, this.get$y(this)))
        this.set$height(0, 0);
      else
        this.set$height(0, J.$sub$n(this.get$y(this), t1));
    }, null, null, 3, 0, 1020, 100, [], "bottomRight"],
    get$left: [function(_) {
      return this.get$x(this);
    }, null, null, 1, 0, 604, "left"],
    set$left: [function(_, value) {
      if (J.$ge$n(value, this.get$right(this)))
        this.set$width(0, 0);
      else
        this.set$width(0, J.$sub$n(this.get$right(this), value));
      this.set$x(0, value);
    }, null, null, 3, 0, 605, 100, [], "left"],
    get$right: [function(_) {
      return J.$add$ns(this.get$x(this), this.get$width(this));
    }, null, null, 1, 0, 604, "right"],
    set$right: [function(_, value) {
      if (J.$le$n(value, this.get$x(this)))
        this.set$width(0, 0);
      else
        this.set$width(0, J.$add$ns(this.get$x(this), value));
    }, null, null, 3, 0, 605, 100, [], "right"],
    get$volume: [function(_) {
      return J.$mul$ns(this.get$width(this), this.get$height(this));
    }, null, null, 1, 0, 604, "volume"],
    get$perimeter: [function() {
      return J.$add$ns(J.$mul$ns(this.get$width(this), 2), J.$mul$ns(this.get$height(this), 2));
    }, null, null, 1, 0, 604, "perimeter"],
    get$centerX: [function() {
      return J.$add$ns(this.get$x(this), this.get$halfWidth());
    }, null, null, 1, 0, 604, "centerX"],
    set$centerX: [function(value) {
      this.set$x(0, J.$sub$n(value, this.get$halfWidth()));
    }, null, null, 3, 0, 605, 100, [], "centerX"],
    get$centerY: [function() {
      return J.$add$ns(this.get$x(this), this.get$halfHeight());
    }, null, null, 1, 0, 604, "centerY"],
    set$centerY: [function(value) {
      this.set$y(0, J.$sub$n(value, this.get$halfHeight()));
    }, null, null, 3, 0, 605, 100, [], "centerY"],
    get$top: [function(_) {
      return this.get$y(this);
    }, null, null, 1, 0, 604, "top"],
    set$top: [function(_, value) {
      if (J.$ge$n(value, this.get$bottom(this))) {
        this.set$height(0, 0);
        this.set$y(0, value);
      } else
        this.set$height(0, J.$sub$n(this.get$bottom(this), value));
    }, null, null, 3, 0, 605, 100, [], "top"],
    get$topLeft: [function(_) {
      var t1, t2, t3;
      t1 = this.get$x(this);
      t2 = this.get$y(this);
      t3 = new R.Point(null, null);
      t3.x = t1;
      t3.y = t2;
      return t3;
    }, null, null, 1, 0, 1019, "topLeft"],
    set$topLeft: [function(_, value) {
      var t1 = J.getInterceptor$x(value);
      this.set$x(0, t1.get$x(value));
      this.set$y(0, t1.get$y(value));
    }, null, null, 3, 0, 1020, 100, [], "topLeft"],
    get$empty: [function() {
      return J.$eq(this.get$width(this), 0) || J.$eq(this.get$height(this), 0);
    }, null, null, 1, 0, 209, "empty"],
    set$empty: [function(value) {
      if (J.$eq(value, true))
        this.setTo$4(0, 0, 0, 0);
    }, null, null, 3, 0, 650, 100, [], "empty"],
    offsetRect$2: [function(dx, dy) {
      this.set$x(0, J.$add$ns(this.get$x(this), dx));
      this.set$y(0, J.$add$ns(this.get$y(this), dy));
      return this;
    }, "call$2", "get$offsetRect", 4, 0, 1259, 1227, [], 1228, [], "offsetRect"],
    offsetPoint$1: [function(point) {
      var t1, t2;
      t1 = J.getInterceptor$x(point);
      t2 = t1.get$x(point);
      t1 = t1.get$y(point);
      this.set$x(0, J.$add$ns(this.get$x(this), t2));
      this.set$y(0, J.$add$ns(this.get$y(this), t1));
      return this;
    }, "call$1", "get$offsetPoint", 2, 0, 1260, 433, [], "offsetPoint"],
    setTo$4: [function(x, y, width, height) {
      this.set$x(0, x);
      this.set$y(0, y);
      this.set$width(0, width);
      this.set$height(0, height);
      return this;
    }, "call$4", "get$setTo", 8, 0, 1261, 6, [], 7, [], 10, [], 11, [], "setTo"],
    floor$0: [function(_) {
      this.set$x(0, J.floor$0$n(this.get$x(this)));
      this.set$y(0, J.floor$0$n(this.get$y(this)));
    }, "call$0", "get$floor", 0, 0, 13, "floor"],
    floorAll$0: [function() {
      this.set$x(0, J.floor$0$n(this.get$x(this)));
      this.set$y(0, J.floor$0$n(this.get$y(this)));
      this.set$width(0, J.floor$0$n(this.get$width(this)));
      this.set$height(0, J.floor$0$n(this.get$height(this)));
    }, "call$0", "get$floorAll", 0, 0, 13, "floorAll"],
    copyFrom$1: [function(source) {
      var t1 = J.getInterceptor$x(source);
      return this.setTo$4(t1.get$x(source), t1.get$y(source), t1.get$width(source), t1.get$height(source));
    }, "call$1", "get$copyFrom", 2, 0, 1262, 170, [], "copyFrom"],
    copyTo$1: [function(dest) {
      var t1 = J.getInterceptor$x(dest);
      t1.set$x(dest, this.get$x(this));
      t1.set$y(dest, this.get$y(this));
      t1.set$width(dest, this.get$width(this));
      t1.set$height(dest, this.get$height(this));
      return dest;
    }, "call$1", "get$copyTo", 2, 0, 1263, 1221, [], "copyTo"],
    inflate$2: [function(dx, dy) {
      var t1;
      this.set$x(0, J.$sub$n(this.get$x(this), dx));
      t1 = this.get$width(this);
      if (typeof dx !== "number")
        return H.iae(dx);
      this.set$width(0, J.$add$ns(t1, 2 * dx));
      this.set$y(0, J.$sub$n(this.get$y(this), dy));
      t1 = this.get$height(this);
      if (typeof dy !== "number")
        return H.iae(dy);
      this.set$height(0, J.$add$ns(t1, 2 * dy));
      return this;
    }, "call$2", "get$inflate", 4, 0, 1259, 1227, [], 1228, [], "inflate"],
    size$1: [function(_, output) {
      var t1, t2;
      if (output == null) {
        t1 = this.get$width(this);
        t2 = this.get$height(this);
        output = new R.Point(null, null);
        output.x = t1;
        output.y = t2;
      } else
        output.setTo$2(this.get$width(this), this.get$height(this));
      return output;
    }, function($receiver) {
      return this.size$1($receiver, null);
    }, "size$0", "call$1", "call$0", "get$size", 0, 2, 1247, 32, 973, [], "size"],
    clone$1: [function(_, output) {
      if (output == null)
        output = new R.Rectangle1(this.get$x(this), this.get$y(this), this.get$width(this), this.get$height(this), 0, 0, 0, 0);
      else
        output.setTo$4(this.get$x(this), this.get$y(this), this.get$width(this), this.get$height(this));
      return output;
    }, function($receiver) {
      return this.clone$1($receiver, null);
    }, "clone$0", "call$1", "call$0", "get$clone", 0, 2, 971, 32, 973, [], "clone"],
    contains$2: [function(_, x, y) {
      var t1;
      if (J.$le$n(this.get$width(this), 0) || J.$le$n(this.get$height(this), 0))
        return false;
      t1 = J.getInterceptor$n(x);
      if (t1.$ge(x, this.get$x(this)))
        if (t1.$le(x, this.get$right(this))) {
          t1 = J.getInterceptor$n(y);
          t1 = t1.$ge(y, this.get$y(this)) && t1.$le(y, this.get$bottom(this));
        } else
          t1 = false;
      else
        t1 = false;
      return t1;
    }, "call$2", "get$contains", 4, 0, 558, 6, [], 7, [], "contains"],
    containsRect$1: [function(b) {
      var t1 = J.getInterceptor$x(b);
      if (J.$gt$n(J.$mul$ns(this.get$width(this), this.get$height(this)), t1.get$volume(b)))
        return false;
      return J.$ge$n(this.get$x(this), t1.get$x(b)) && J.$ge$n(this.get$y(this), t1.get$y(b)) && J.$le$n(this.get$right(this), t1.get$right(b)) && J.$le$n(this.get$bottom(this), t1.get$bottom(b));
    }, "call$1", "get$containsRect", 2, 0, 1264, 305, [], "containsRect"],
    equals$1: [function(b) {
      var t1 = J.getInterceptor$x(b);
      return J.$eq(this.get$x(this), t1.get$x(b)) && J.$eq(this.get$y(this), t1.get$y(b)) && J.$eq(this.get$width(this), t1.get$width(b)) && J.$eq(this.get$height(this), t1.get$height(b));
    }, "call$1", "get$equals", 2, 0, 1264, 305, [], "equals"],
    intersection$2: [function(_, b, output) {
      var t1, t2, t3, t4;
      if (output == null)
        output = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      if (this.intersects$1(0, b)) {
        t1 = J.getInterceptor$x(b);
        t2 = J.getInterceptor$x(output);
        t2.set$x(output, P.max(this.get$x(this), t1.get$x(b)));
        t2.set$y(output, P.max(this.get$y(this), t1.get$y(b)));
        t3 = P.min(this.get$right(this), t1.get$right(b));
        t4 = t2.get$x(output);
        if (typeof t4 !== "number")
          return H.iae(t4);
        t2.set$width(output, t3 - t4);
        t1 = P.min(this.get$bottom(this), t1.get$bottom(b));
        t4 = t2.get$y(output);
        if (typeof t4 !== "number")
          return H.iae(t4);
        t2.set$height(output, t1 - t4);
      }
      return output;
    }, function($receiver, b) {
      return this.intersection$2($receiver, b, null);
    }, "intersection$1", "call$2", "call$1", "get$intersection", 2, 2, 1265, 32, 305, [], 973, [], "intersection"],
    intersects$2: [function(_, b, tolerance) {
      var t1;
      if (!J.$le$n(this.get$width(this), 0))
        if (!J.$le$n(this.get$height(this), 0)) {
          t1 = J.getInterceptor$x(b);
          t1 = J.$le$n(t1.get$width(b), 0) || J.$le$n(t1.get$height(b), 0);
        } else
          t1 = true;
      else
        t1 = true;
      if (t1)
        return false;
      t1 = J.getInterceptor$x(b);
      return !(J.$lt$n(this.get$right(this), t1.get$x(b)) || J.$lt$n(this.get$bottom(this), t1.get$y(b)) || J.$gt$n(this.get$x(this), t1.get$right(b)) || J.$gt$n(this.get$y(this), t1.get$bottom(b)));
    }, function($receiver, b) {
      return this.intersects$2($receiver, b, 0);
    }, "intersects$1", "call$2", "call$1", "get$intersects", 2, 2, 1266, 5, 305, [], 401, [], "intersects"],
    intersectsRaw$5: [function(left, right, $top, bottom, tolerance) {
      var t1, t2;
      t1 = J.getInterceptor$ns(right);
      t2 = J.getInterceptor$n(left);
      if (!t2.$gt(left, t1.$add(right, tolerance)))
        if (!t1.$lt(right, t2.$sub(left, tolerance))) {
          t1 = J.getInterceptor$ns(bottom);
          t2 = J.getInterceptor$n($top);
          t1 = t2.$gt($top, t1.$add(bottom, tolerance)) || t1.$lt(bottom, t2.$sub($top, tolerance));
        } else
          t1 = true;
      else
        t1 = true;
      return !t1;
    }, function(left, right, top, bottom) {
      return this.intersectsRaw$5(left, right, top, bottom, 0);
    }, "intersectsRaw$4", "call$5", "call$4", "get$intersectsRaw", 8, 2, 1267, 5, 160, [], 419, [], 1268, [], 1269, [], 401, [], "intersectsRaw"],
    union$2: [function(b, output) {
      var t1;
      if (output == null)
        output = new R.Rectangle1(0, 0, 0, 0, 0, 0, 0, 0);
      t1 = J.getInterceptor$x(b);
      return output.setTo$4(P.min(this.get$x(this), t1.get$x(b)), P.min(this.get$y(this), t1.get$y(b)), P.max(this.get$right(this), t1.get$right(b)) - P.min(this.get$x(this), t1.get$left(b)), P.max(this.get$bottom(this), t1.get$bottom(b)) - P.min(this.get$y(this), t1.get$top(b)));
    }, "call$2", "get$union", 4, 0, 1270, 305, [], 973, [], "union"],
    toString$0: [function(_) {
      var t1 = "[{Rectangle (x=" + H.S(this.get$x(this)) + " y=" + H.S(this.get$y(this)) + " width=" + H.S(this.get$width(this)) + " height=" + H.S(this.get$height(this)) + " empty=";
      return t1 + (J.$eq(this.get$width(this), 0) || J.$eq(this.get$height(this), 0)) + ")}]";
    }, "call$0", "get$toString", 0, 0, 13, "toString"],
    $isRectangle1: true,
    static: {Rectangle$1: [function(x, y, width, height) {
        return new R.Rectangle1(x, y, width, height, 0, 0, 0, 0);
      }, null, null, 0, 8, 9, 5, 5, 5, 5, 6, [], 7, [], 10, [], 11, [], "new Rectangle"]}
  },
  "+Rectangle": [641],
  Gamepad: {
    "^": "Object;",
    static: {Gamepad$: [function() {
        return new R.Gamepad();
      }, null, null, 0, 0, 13, "new Gamepad"]}
  },
  "+Gamepad": [632],
  GamepadButton: {
    "^": "Object;",
    static: {GamepadButton$: [function() {
        return new R.GamepadButton();
      }, null, null, 0, 0, 13, "new GamepadButton"]}
  },
  "+GamepadButton": [632],
  Input: {
    "^": "Object;game@-598,hitCanvas@-808,hitContext@-850,moveCallbacks@-720,moveCallback@-0,pollRate@-629,disabled*-602,multiInputOverride@-599,position*-600,speed@-600,circle@-1271,scale*-600,maxPointers@-599,currentPointers@-599,tapRate@-599,doubleTapRate@-599,holdRate@-599,justPressedRate@-599,justReleasedRate@-599,recordPointerHistory@-602,recordRate@-599,recordLimit@-599,pointers@-1272,activePointer@-1273,mousePointer@-1273,mouse@-1274,keyboard@-1275,touch@-1276,resetLocked@-602,onDown@-1277,onUp@-1277,onTap@-1277,onHold@-1277,minPriorityID@-599,interactiveItems@-1278,_localPoint@-600,_pollCounter@-599,_oldPosition@-600,_x@-601,_y@-601",
    moveCallback$3: function(arg0, arg1, arg2) {
      return this.moveCallback.call$3(arg0, arg1, arg2);
    },
    circle$4: function(arg0, arg1, arg2, arg3) {
      return this.circle.call$4(arg0, arg1, arg2, arg3);
    },
    scale$2: function($receiver, arg0, arg1) {
      return this.scale.call$2(arg0, arg1);
    },
    get$x: [function(_) {
      return this._x;
    }, null, null, 1, 0, 604, "x"],
    set$x: [function(_, value) {
      this._x = J.floor$0$n(value);
    }, null, null, 3, 0, 605, 100, [], "x"],
    get$y: [function(_) {
      return this._y;
    }, null, null, 1, 0, 604, "y"],
    set$y: [function(_, value) {
      this._y = J.floor$0$n(value);
    }, null, null, 3, 0, 605, 100, [], "y"],
    get$pollLocked: [function() {
      return J.$gt$n(this.pollRate, 0) && J.$lt$n(this._pollCounter, this.pollRate);
    }, null, null, 1, 0, 209, "pollLocked"],
    get$totalInactivePointers: [function() {
      var t1 = this.currentPointers;
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 10 - t1;
    }, null, null, 1, 0, 367, "totalInactivePointers"],
    get$totalActivePointers: [function() {
      this.currentPointers = 0;
      for (var i = 1; i <= 10; ++i)
        if (J.$index$asx(this.pointers, i) != null && J.$index$asx(this.pointers, i).get$active() === true)
          this.currentPointers = J.$add$ns(this.currentPointers, 1);
      return this.currentPointers;
    }, null, null, 1, 0, 367, "totalActivePointers"],
    get$worldX: [function() {
      return J.$add$ns(J.get$x$x(J.get$view$x(this.game.get$camera())), this._x);
    }, null, null, 1, 0, 604, "worldX"],
    get$worldY: [function() {
      return J.$add$ns(J.get$y$x(J.get$view$x(this.game.get$camera())), this._y);
    }, null, null, 1, 0, 604, "worldY"],
    boot$0: [function() {
      var t1, t2;
      this.mousePointer = R.Pointer$(this.game, 0);
      J.$indexSet$ax(this.pointers, 1, R.Pointer$(this.game, 1));
      J.$indexSet$ax(this.pointers, 2, R.Pointer$(this.game, 2));
      t1 = this.game;
      t2 = new R.Mouse(t1, null, null, null, null, null, null, false, -1, 0, false, false, false, null, null, null, null, null, null, null, null, null);
      t2.Mouse$1(t1);
      this.mouse = t2;
      t2 = this.game;
      t1 = new R.Keyboard(t2, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t1.Keyboard$1(t2);
      this.keyboard = t1;
      t1 = this.game;
      t2 = new R.Touch(t1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2.Touch$1(t1);
      this.touch = t2;
      this.onDown = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onUp = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onTap = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onHold = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      t2 = new R.Point(null, null);
      t2.x = 1;
      t2.y = 1;
      this.scale = t2;
      t2 = new R.Point(null, null);
      t2.x = 0;
      t2.y = 0;
      this.speed = t2;
      t2 = new R.Point(null, null);
      t2.x = 0;
      t2.y = 0;
      this.position = t2;
      t2 = new R.Point(null, null);
      t2.x = 0;
      t2.y = 0;
      this._oldPosition = t2;
      this.circle = R.Circle$(0, 0, 44);
      this.activePointer = this.mousePointer;
      this.currentPointers = 0;
      t2 = document.createElement("canvas", null);
      this.hitCanvas = t2;
      J.set$width$x(t2, 1);
      J.set$height$x(this.hitCanvas, 1);
      this.hitContext = J.getContext$1$x(this.hitCanvas, "2d");
      J.start$0$x(this.mouse);
      J.start$0$x(this.keyboard);
      J.start$0$x(this.touch);
      this.mousePointer.set$active(true);
    }, "call$0", "get$boot", 0, 0, 13, "boot"],
    destroy$0: [function() {
      J.stop$0$x(this.mouse);
      J.stop$0$x(this.keyboard);
      J.stop$0$x(this.touch);
      this.moveCallbacks = [];
      this.moveCallback = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    setMoveCallback$1: [function(callback) {
      this.moveCallback = callback;
    }, "call$1", "get$setMoveCallback", 2, 0, 1030, 272, [], "setMoveCallback"],
    addMoveCallback$2: [function(callback, callbackContext) {
      J.add$1$ax(this.moveCallbacks, P.LinkedHashMap_LinkedHashMap$_literal(["callback", callback, "context", callbackContext], null, null));
      return J.$sub$n(J.get$length$asx(this.moveCallbacks), 1);
    }, "call$2", "get$addMoveCallback", 4, 0, 1279, 272, [], 1280, [], "addMoveCallback"],
    deleteMoveCallback$1: [function(index) {
      if (J.$index$asx(this.moveCallbacks, index) === true)
        J.removeAt$1$ax(this.moveCallbacks, index);
    }, "call$1", "get$deleteMoveCallback", 2, 0, 60, 243, [], "deleteMoveCallback"],
    addPointer$0: [function() {
      var next, i;
      for (next = 0, i = 10; i > 0; --i)
        if (J.$index$asx(this.pointers, i) == null)
          next = i;
      if (next === 0) {
        window;
        if (typeof console != "undefined")
          console.warn("You can only have 10 Pointer objects");
        return;
      } else {
        J.$indexSet$ax(this.pointers, next, R.Pointer$(this.game, next));
        return J.$index$asx(this.pointers, next);
      }
    }, "call$0", "get$addPointer", 0, 0, 1281, "addPointer"],
    update$0: [function() {
      this.keyboard.update$0();
      if (J.$gt$n(this.pollRate, 0) && J.$lt$n(this._pollCounter, this.pollRate)) {
        this._pollCounter = J.$add$ns(this._pollCounter, 1);
        return;
      }
      J.set$x$x(this.speed, J.$sub$n(J.get$x$x(this.position), J.get$x$x(this._oldPosition)));
      J.set$y$x(this.speed, J.$sub$n(J.get$y$x(this.position), J.get$y$x(this._oldPosition)));
      this._oldPosition.copyFrom$1(this.position);
      this.mousePointer.update$0();
      J.$index$asx(this.pointers, 1).update$0();
      J.$index$asx(this.pointers, 2).update$0();
      if (J.$index$asx(this.pointers, 3) != null)
        J.$index$asx(this.pointers, 3).update$0();
      if (J.$index$asx(this.pointers, 4) != null)
        J.$index$asx(this.pointers, 4).update$0();
      if (J.$index$asx(this.pointers, 5) != null)
        J.$index$asx(this.pointers, 5).update$0();
      if (J.$index$asx(this.pointers, 6) != null)
        J.$index$asx(this.pointers, 6).update$0();
      if (J.$index$asx(this.pointers, 7) != null)
        J.$index$asx(this.pointers, 7).update$0();
      if (J.$index$asx(this.pointers, 8) != null)
        J.$index$asx(this.pointers, 8).update$0();
      if (J.$index$asx(this.pointers, 9) != null)
        J.$index$asx(this.pointers, 9).update$0();
      if (J.$index$asx(this.pointers, 10) != null)
        J.$index$asx(this.pointers, 10).update$0();
      this._pollCounter = 0;
    }, "call$0", "get$update", 0, 0, 13, "update"],
    reset$1: [function(_, hard) {
      var i;
      if (this.game.get$isBooted() !== true || this.resetLocked === true)
        return;
      J.reset$1$x(this.keyboard, hard);
      J.reset$0$x(this.mousePointer);
      for (i = 1; i <= 10; ++i)
        if (J.$index$asx(this.pointers, i) != null)
          J.reset$0$x(J.$index$asx(this.pointers, i));
      this.currentPointers = 0;
      if (!J.$eq(J.get$cursor$x(J.get$style$x(J.get$canvas$x(this.game))), "none"))
        J.set$cursor$x(J.get$style$x(J.get$canvas$x(this.game)), "inherit");
      if (hard === true) {
        this.onDown.dispose$0();
        this.onUp.dispose$0();
        this.onTap.dispose$0();
        this.onHold.dispose$0();
        this.onDown = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
        this.onUp = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
        this.onTap = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
        this.onHold = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
        this.moveCallbacks = [];
      }
      this._pollCounter = 0;
    }, function($receiver) {
      return this.reset$1($receiver, false);
    }, "reset$0", "call$1", "call$0", "get$reset", 0, 2, 932, 95, 1282, [], "reset"],
    resetSpeed$2: [function(x, y) {
      this._oldPosition.setTo$2(x, y);
      this.speed.setTo$2(0, 0);
    }, "call$2", "get$resetSpeed", 4, 0, 1283, 6, [], 7, [], "resetSpeed"],
    startPointer$1: [function($event) {
      var i;
      if (J.$lt$n(this.maxPointers, 10) && J.$eq(this.get$totalActivePointers(), this.maxPointers))
        return;
      if (J.$eq(J.$index$asx(this.pointers, 1).get$active(), false))
        return J.start$1$x(J.$index$asx(this.pointers, 1), $event);
      else if (J.$eq(J.$index$asx(this.pointers, 2).get$active(), false))
        return J.start$1$x(J.$index$asx(this.pointers, 2), $event);
      else
        for (i = 3; i <= 10; ++i)
          if (J.$index$asx(this.pointers, i) != null && J.$eq(J.$index$asx(this.pointers, i).get$active(), false))
            return J.start$1$x(J.$index$asx(this.pointers, i), $event);
      return;
    }, "call$1", "get$startPointer", 2, 0, 1284, 815, [], "startPointer"],
    updatePointer$1: [function($event) {
      var t1, identifier, i;
      t1 = J.getInterceptor($event);
      identifier = !!t1.$isJsObject ? t1.$index($event, "identifier") : t1.get$identifier($event);
      if (J.$index$asx(this.pointers, 1).get$active() === true && J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, 1)), identifier))
        return J.$index$asx(this.pointers, 1).move$1($event);
      else if (J.$index$asx(this.pointers, 2).get$active() === true && J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, 2)), identifier))
        return J.$index$asx(this.pointers, 2).move$1($event);
      else
        for (i = 3; i <= 10; ++i)
          if (J.$index$asx(this.pointers, i) != null && J.$index$asx(this.pointers, i).get$active() === true && J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, i)), identifier))
            return J.$index$asx(this.pointers, i).move$1($event);
      return;
    }, "call$1", "get$updatePointer", 2, 0, 1284, 815, [], "updatePointer"],
    stopPointer$1: [function($event) {
      var t1, identifier, i;
      t1 = J.getInterceptor($event);
      identifier = !!t1.$isJsObject ? t1.$index($event, "identifier") : t1.get$identifier($event);
      if (J.$index$asx(this.pointers, 1).get$active() === true && J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, 1)), identifier))
        return J.stop$1$x(J.$index$asx(this.pointers, 1), $event);
      else if (J.$index$asx(this.pointers, 2).get$active() === true && J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, 2)), identifier))
        return J.stop$1$x(J.$index$asx(this.pointers, 2), $event);
      else
        for (i = 3; i <= 10; ++i)
          if (J.$index$asx(this.pointers, i) != null && J.$index$asx(this.pointers, i).get$active() === true && J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, i)), identifier))
            return J.stop$1$x(J.$index$asx(this.pointers, i), $event);
      return;
    }, "call$1", "get$stopPointer", 2, 0, 1284, 815, [], "stopPointer"],
    getPointer$1: [function(state) {
      var i;
      if (J.$eq(J.$index$asx(this.pointers, 1).get$active(), state))
        return J.$index$asx(this.pointers, 1);
      else if (J.$eq(J.$index$asx(this.pointers, 2).get$active(), state))
        return J.$index$asx(this.pointers, 2);
      else
        for (i = 3; i <= 10; ++i)
          if (J.$index$asx(this.pointers, i) != null && J.$eq(J.$index$asx(this.pointers, i).get$active(), state))
            return J.$index$asx(this.pointers, i);
      return;
    }, function() {
      return this.getPointer$1(false);
    }, "getPointer$0", "call$1", "call$0", "get$getPointer", 0, 2, 1285, 95, 250, [], "getPointer"],
    getPointerFromIdentifier$1: [function(identifier) {
      var i;
      if (J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, 1)), identifier))
        return J.$index$asx(this.pointers, 1);
      else if (J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, 2)), identifier))
        return J.$index$asx(this.pointers, 2);
      else
        for (i = 3; i <= 10; ++i)
          if (J.$index$asx(this.pointers, i) != null && J.$eq(J.get$identifier$x(J.$index$asx(this.pointers, i)), identifier))
            return J.$index$asx(this.pointers, i);
      return;
    }, "call$1", "get$getPointerFromIdentifier", 2, 0, 1286, 1287, [], "getPointerFromIdentifier"],
    getPointerFromId$1: [function(pointerId) {
      var i;
      if (J.$eq(J.$index$asx(this.pointers, 1).get$pointerId(), pointerId))
        return J.$index$asx(this.pointers, 1);
      else if (J.$eq(J.$index$asx(this.pointers, 2).get$pointerId(), pointerId))
        return J.$index$asx(this.pointers, 2);
      else
        for (i = 3; i <= 10; ++i)
          if (J.$index$asx(this.pointers, i) != null && J.$eq(J.$index$asx(this.pointers, i).get$pointerId(), pointerId))
            return J.$index$asx(this.pointers, i);
      return;
    }, "call$1", "get$getPointerFromId", 2, 0, 1286, 1288, [], "getPointerFromId"],
    getLocalPosition$3: [function(displayObject, pointer, output) {
      var wt, t1, t2, id;
      if (output == null) {
        output = new R.Point(null, null);
        output.x = 0;
        output.y = 0;
      }
      wt = displayObject.get$worldTransform();
      t1 = J.getInterceptor$x(wt);
      t2 = J.$add$ns(J.$mul$ns(t1.get$a(wt), wt.get$d()), J.$mul$ns(wt.get$b(), J.$negate$n(wt.get$c())));
      if (typeof t2 !== "number")
        return H.iae(t2);
      id = 1 / t2;
      t2 = J.getInterceptor$x(pointer);
      return output.setTo$2(J.$add$ns(J.$add$ns(J.$mul$ns(J.$mul$ns(wt.get$d(), id), t2.get$x(pointer)), J.$mul$ns(J.$mul$ns(J.$negate$n(wt.get$b()), id), t2.get$y(pointer))), J.$mul$ns(J.$sub$n(J.$mul$ns(wt.get$ty(), wt.get$b()), J.$mul$ns(wt.get$tx(), wt.get$d())), id)), J.$add$ns(J.$add$ns(J.$mul$ns(J.$mul$ns(t1.get$a(wt), id), t2.get$y(pointer)), J.$mul$ns(J.$mul$ns(J.$negate$n(wt.get$c()), id), t2.get$x(pointer))), J.$mul$ns(J.$add$ns(J.$mul$ns(J.$negate$n(wt.get$ty()), t1.get$a(wt)), J.$mul$ns(wt.get$tx(), wt.get$c())), id)));
    }, "call$3", "get$getLocalPosition", 6, 0, 1289, 805, [], 994, [], 973, [], "getLocalPosition"],
    hitTest$3: [function(displayObject, pointer, localPoint) {
      var t1, width, height, x1, y1, len, i;
      if (!displayObject.get$worldVisible())
        return false;
      this.getLocalPosition$3(displayObject, pointer, this._localPoint);
      localPoint.copyFrom$1(this._localPoint);
      if (displayObject.get$hitArea() != null) {
        if (J.contains$2$asx(displayObject.get$hitArea(), J.get$x$x(this._localPoint), J.get$y$x(this._localPoint)))
          return true;
        return false;
      } else {
        t1 = J.getInterceptor(displayObject);
        if (!!t1.$isTileSprite) {
          width = displayObject.PIXI$TilingSprite$_width;
          height = displayObject.PIXI$TilingSprite$_height;
          x1 = J.$mul$ns(J.$negate$n(width), J.get$x$x(displayObject.anchor));
          if (J.$gt$n(J.get$x$x(this._localPoint), x1) && J.$lt$n(J.get$x$x(this._localPoint), J.$add$ns(x1, width))) {
            y1 = J.$mul$ns(J.$negate$n(height), J.get$y$x(displayObject.anchor));
            if (J.$gt$n(J.get$y$x(this._localPoint), y1) && J.$lt$n(J.get$y$x(this._localPoint), J.$add$ns(y1, height)))
              return true;
          }
        } else if (!!t1.$isSpriteInterface) {
          width = J.get$width$x(displayObject.get$texture().get$frame());
          height = J.get$height$x(displayObject.get$texture().get$frame());
          x1 = J.$mul$ns(J.$negate$n(width), J.get$x$x(displayObject.get$anchor()));
          if (J.$gt$n(J.get$x$x(this._localPoint), x1) && J.$lt$n(J.get$x$x(this._localPoint), J.$add$ns(x1, width))) {
            y1 = J.$mul$ns(J.$negate$n(height), J.get$y$x(displayObject.get$anchor()));
            if (J.$gt$n(J.get$y$x(this._localPoint), y1) && J.$lt$n(J.get$y$x(this._localPoint), J.$add$ns(y1, height)))
              return true;
          }
        }
      }
      len = J.get$length$asx(t1.get$children(displayObject));
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        if (this.hitTest$3(J.$index$asx(t1.get$children(displayObject), i), pointer, localPoint))
          return true;
      return false;
    }, "call$3", "get$hitTest", 6, 0, 1290, 805, [], 994, [], 1291, [], "hitTest"],
    Input$1: function(game) {
      var t1;
      this.hitCanvas = null;
      this.hitContext = null;
      this.moveCallbacks = [];
      this.moveCallback = null;
      this.pollRate = 0;
      this.disabled = false;
      this.multiInputOverride = 2;
      this.position = null;
      this.speed = null;
      this.circle = null;
      this.scale = null;
      this.maxPointers = 10;
      this.currentPointers = 0;
      this.tapRate = 200;
      this.doubleTapRate = 300;
      this.holdRate = 2000;
      this.justPressedRate = 200;
      this.justReleasedRate = 200;
      this.recordPointerHistory = false;
      this.recordRate = 100;
      this.recordLimit = 100;
      this.activePointer = null;
      this.mousePointer = null;
      this.mouse = null;
      this.keyboard = null;
      this.touch = null;
      this.resetLocked = false;
      this.onDown = null;
      this.onUp = null;
      this.onTap = null;
      this.onHold = null;
      this.minPriorityID = 0;
      this.interactiveItems = [];
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this._localPoint = t1;
      this._pollCounter = 0;
      this._oldPosition = null;
      this._x = 0;
      this._y = 0;
    },
    static: {"^": "Input_MOUSE_OVERRIDES_TOUCH<-599,Input_TOUCH_OVERRIDES_MOUSE<-599,Input_MOUSE_TOUCH_COMBINE<-599", Input$: [function(game) {
        var t1 = Array(11);
        t1.fixed$length = init;
        t1 = new R.Input(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo(t1, [R.Pointer]), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0);
        t1.Input$1(game);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new Input"]}
  },
  "+Input": [632],
  InputHandler: {
    "^": "Object;sprite@-2,game@-598,enabled@-602,priorityID@-599,useHandCursor@-602,_setHandCursor@-602,isDragged@-602,allowHorizontalDrag@-602,allowVerticalDrag@-602,bringToTop@-602,snapOffset@-600,snapOnDrag@-602,snapOnRelease@-602,snapX@-601,snapY@-601,snapOffsetX@-601,snapOffsetY@-601,pixelPerfectOver@-602,pixelPerfectClick@-602,pixelPerfectAlpha@-599,draggable*-602,boundsRect@-974,boundsSprite@-937,consumePointerEvent@-602,_dragPhase@-602,_wasEnabled@-602,_tempPoint@-600,_pointerData@-1272,_draggedPointerID@-599,_dragPoint@-600,dragOffset@-600,dragFromCenter@-602",
    sprite$3: function(arg0, arg1, arg2) {
      return this.sprite.call$3(arg0, arg1, arg2);
    },
    sprite$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.sprite.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    sprite$4: function(arg0, arg1, arg2, arg3) {
      return this.sprite.call$4(arg0, arg1, arg2, arg3);
    },
    bringToTop$0: function() {
      return this.bringToTop.call$0();
    },
    bringToTop$1: function(arg0) {
      return this.bringToTop.call$1(arg0);
    },
    start$2: [function(_, priority, useHandCursor) {
      var i, t1, t2;
      if (J.$eq(this.enabled, false)) {
        J.add$1$ax(this.game.get$input().get$interactiveItems(), this);
        this.useHandCursor = useHandCursor;
        this.priorityID = priority;
        for (i = 0; i < 10; ++i) {
          t1 = this._pointerData;
          t2 = R.Pointer$(this.sprite.get$game(), i);
          t2.x = 0;
          t2.y = 0;
          t2.isDown = false;
          t2.isUp = false;
          t2.isOver = false;
          t2.isOut = false;
          t2.timeOver = 0;
          t2.timeOut = 0;
          t2.timeDown = 0;
          t2.timeUp = 0;
          t2.downDuration = 0;
          t2.isDragged = false;
          J.$indexSet$ax(t1, i, t2);
        }
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        this.snapOffset = t1;
        this.enabled = true;
        this._wasEnabled = true;
        if (this.sprite.get$events() != null && this.sprite.get$events().get$onInputOver() == null) {
          this.sprite.get$events().set$onInputOver(H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
          this.sprite.get$events().set$onInputOut(H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
          this.sprite.get$events().set$onInputDown(H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
          this.sprite.get$events().set$onInputUp(H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
          J.set$onDragStart$x(this.sprite.get$events(), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
          this.sprite.get$events().set$onDragStop(H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]));
        }
      }
      J.add$1$ax(this.sprite.get$events().get$onAddedToGroup(), this.get$addedToGroup());
      J.add$1$ax(this.sprite.get$events().get$onRemovedFromGroup(), this.get$removedFromGroup());
      return this.sprite;
    }, function($receiver, priority) {
      return this.start$2($receiver, priority, false);
    }, "start$1", function($receiver) {
      return this.start$2($receiver, 0, false);
    }, "start$0", "call$2", "call$1", "call$0", "get$start", 0, 4, 1292, 5, 95, 989, [], 1293, [], "start"],
    addedToGroup$2: [function(s, w) {
      if (this._dragPhase === true)
        return;
      if (this._wasEnabled === true && this.enabled !== true)
        this.start$0(0);
    }, "call$2", "get$addedToGroup", 4, 0, 1294, 502, [], 594, [], "addedToGroup"],
    removedFromGroup$2: [function(s, w) {
      if (this._dragPhase === true)
        return;
      if (this.enabled === true) {
        this._wasEnabled = true;
        this.stop$0(0);
      } else
        this._wasEnabled = false;
    }, "call$2", "get$removedFromGroup", 4, 0, 1294, 502, [], 594, [], "removedFromGroup"],
    reset$0: [function(_) {
      var i, t1, t2;
      this.enabled = false;
      for (i = 0; i < 10; ++i) {
        t1 = this._pointerData;
        t2 = R.Pointer$(this.sprite.get$game(), i);
        t2.x = 0;
        t2.y = 0;
        t2.isDown = false;
        t2.isUp = false;
        t2.isOver = false;
        t2.isOut = false;
        t2.timeOver = 0;
        t2.timeOut = 0;
        t2.timeDown = 0;
        t2.timeUp = 0;
        t2.downDuration = 0;
        t2.isDragged = false;
        J.$indexSet$ax(t1, i, t2);
      }
    }, "call$0", "get$reset", 0, 0, 13, "reset"],
    stop$0: [function(_) {
      if (J.$eq(this.enabled, false))
        return;
      else {
        this.enabled = false;
        J.remove$1$ax(this.game.get$input().get$interactiveItems(), this);
      }
    }, "call$0", "get$stop", 0, 0, 13, "stop"],
    destroy$0: [function() {
      if (this.sprite != null) {
        if (this._setHandCursor === true) {
          J.set$cursor$x(J.get$style$x(J.get$canvas$x(this.game)), "default");
          this._setHandCursor = false;
        }
        this.enabled = false;
        J.remove$1$ax(this.game.get$input().get$interactiveItems(), this);
        this._pointerData = null;
        this.boundsRect = null;
        this.boundsSprite = null;
        this.sprite = null;
      }
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    validForInput$3: [function(highestID, highestRenderID, includePixelPerfect) {
      var t1;
      if (J.$eq(J.get$x$x(J.get$scale$x(this.sprite)), 0) || J.$eq(J.get$y$x(J.get$scale$x(this.sprite)), 0) || J.$lt$n(this.priorityID, this.game.get$input().get$minPriorityID()))
        return false;
      if (includePixelPerfect !== true)
        t1 = this.pixelPerfectClick === true || this.pixelPerfectOver === true;
      else
        t1 = false;
      if (t1)
        return true;
      if (!J.$gt$n(this.priorityID, highestID))
        t1 = J.$eq(this.priorityID, highestID) && J.$lt$n(J.$index$asx(this.sprite.get$_cache(), 3), highestRenderID);
      else
        t1 = true;
      if (t1)
        return true;
      return false;
    }, function(highestID, highestRenderID) {
      return this.validForInput$3(highestID, highestRenderID, true);
    }, "validForInput$2", "call$3", "call$2", "get$validForInput", 4, 2, 1295, 39, 1296, [], 1297, [], 1298, [], "validForInput"],
    pointerX$1: [function(pointer) {
      return J.get$x$x(J.$index$asx(this._pointerData, pointer));
    }, function() {
      return this.pointerX$1(0);
    }, "pointerX$0", "call$1", "call$0", "get$pointerX", 0, 2, 1299, 5, 994, [], "pointerX"],
    pointerY$1: [function(pointer) {
      return J.get$y$x(J.$index$asx(this._pointerData, pointer));
    }, function() {
      return this.pointerY$1(0);
    }, "pointerY$0", "call$1", "call$0", "get$pointerY", 0, 2, 1299, 5, 994, [], "pointerY"],
    pointerDown$1: [function(pointer) {
      return J.$index$asx(this._pointerData, pointer).get$isDown();
    }, function() {
      return this.pointerDown$1(0);
    }, "pointerDown$0", "call$1", "call$0", "get$pointerDown", 0, 2, 1300, 5, 994, [], "pointerDown"],
    pointerUp$1: [function(pointer) {
      return J.$index$asx(this._pointerData, pointer).get$isUp();
    }, function() {
      return this.pointerUp$1(0);
    }, "pointerUp$0", "call$1", "call$0", "get$pointerUp", 0, 2, 1300, 5, 994, [], "pointerUp"],
    pointerTimeDown$1: [function(pointer) {
      return J.$index$asx(this._pointerData, pointer).get$timeDown();
    }, function() {
      return this.pointerTimeDown$1(0);
    }, "pointerTimeDown$0", "call$1", "call$0", "get$pointerTimeDown", 0, 2, 1301, 5, 994, [], "pointerTimeDown"],
    pointerTimeUp$1: [function(pointer) {
      return J.$index$asx(this._pointerData, pointer).get$timeUp();
    }, function() {
      return this.pointerTimeUp$1(0);
    }, "pointerTimeUp$0", "call$1", "call$0", "get$pointerTimeUp", 0, 2, 1301, 5, 994, [], "pointerTimeUp"],
    pointerOver$1: [function(index) {
      var i;
      if (this.enabled === true)
        if (index == null) {
          for (i = 0; i < 10; ++i)
            if (J.$index$asx(this._pointerData, i).get$isOver() === true)
              return true;
        } else
          return J.$index$asx(this._pointerData, index).get$isOver();
      return false;
    }, function() {
      return this.pointerOver$1(null);
    }, "pointerOver$0", "call$1", "call$0", "get$pointerOver", 0, 2, 1300, 32, 243, [], "pointerOver"],
    pointerOut$1: [function(index) {
      var i;
      if (this.enabled === true)
        if (index == null) {
          for (i = 0; i < 10; ++i)
            if (J.$index$asx(this._pointerData, i).get$isOut() === true)
              return true;
        } else
          return J.$index$asx(this._pointerData, index).get$isOut();
      return false;
    }, function() {
      return this.pointerOut$1(null);
    }, "pointerOut$0", "call$1", "call$0", "get$pointerOut", 0, 2, 1300, 32, 243, [], "pointerOut"],
    pointerTimeOver$1: [function(pointer) {
      return J.$index$asx(this._pointerData, pointer).get$timeOver();
    }, function() {
      return this.pointerTimeOver$1(0);
    }, "pointerTimeOver$0", "call$1", "call$0", "get$pointerTimeOver", 0, 2, 1301, 5, 994, [], "pointerTimeOver"],
    pointerTimeOut$1: [function(pointer) {
      return J.$index$asx(this._pointerData, pointer).get$timeOut();
    }, function() {
      return this.pointerTimeOut$1(0);
    }, "pointerTimeOut$0", "call$1", "call$0", "get$pointerTimeOut", 0, 2, 1301, 5, 994, [], "pointerTimeOut"],
    pointerDragged$1: [function(pointer) {
      return J.$index$asx(this._pointerData, pointer).get$isDragged();
    }, function() {
      return this.pointerDragged$1(0);
    }, "pointerDragged$0", "call$1", "call$0", "get$pointerDragged", 0, 2, 1300, 5, 994, [], "pointerDragged"],
    checkPointerDown$1: [function(pointer) {
      var t1;
      if (pointer.get$isDown() === true)
        if (this.enabled === true) {
          t1 = this.sprite;
          t1 = t1 == null || J.get$parent$x(t1) == null || this.sprite.get$visible() !== true || J.get$parent$x(this.sprite).get$visible() !== true;
        } else
          t1 = true;
      else
        t1 = true;
      if (t1)
        return false;
      if (this.game.get$input().hitTest$3(this.sprite, pointer, this._tempPoint))
        if (this.pixelPerfectClick === true)
          return this.checkPixel$2(J.get$x$x(this._tempPoint), J.get$y$x(this._tempPoint));
        else
          return true;
      return false;
    }, "call$1", "get$checkPointerDown", 2, 0, 1302, 994, [], "checkPointerDown"],
    checkPointerOver$1: [function(pointer) {
      var t1;
      if (this.enabled === true) {
        t1 = this.sprite;
        t1 = t1 == null || J.get$parent$x(t1) == null || this.sprite.get$visible() !== true || J.get$parent$x(this.sprite).get$visible() !== true;
      } else
        t1 = true;
      if (t1)
        return false;
      if (this.game.get$input().hitTest$3(this.sprite, pointer, this._tempPoint))
        if (this.pixelPerfectOver === true)
          return this.checkPixel$2(J.get$x$x(this._tempPoint), J.get$y$x(this._tempPoint));
        else
          return true;
      return false;
    }, "call$1", "get$checkPointerOver", 2, 0, 1302, 994, [], "checkPointerOver"],
    checkPixel$3: [function(x, y, pointer) {
      var t1, t2;
      t1 = this.sprite;
      if (!J.getInterceptor(t1).$isSprite)
        return false;
      H.interceptedTypeCast(t1, "$isSprite");
      if (J.get$source$x(t1.get$texture().get$baseTexture()) != null) {
        J.clearRect$4$x(this.game.get$input().get$hitContext(), 0, 0, 1, 1);
        if (x == null && y == null) {
          this.game.get$input().getLocalPosition$3(this.sprite, pointer, this._tempPoint);
          x = J.get$x$x(this._tempPoint);
          y = J.get$y$x(this._tempPoint);
        }
        if (!J.$eq(J.get$x$x(this.sprite.get$anchor()), 0))
          x = J.$sub$n(x, J.$mul$ns(J.$negate$n(J.get$width$x(t1.get$texture().get$frame())), J.get$x$x(this.sprite.get$anchor())));
        if (!J.$eq(J.get$y$x(this.sprite.get$anchor()), 0))
          y = J.$sub$n(y, J.$mul$ns(J.$negate$n(J.get$height$x(t1.get$texture().get$frame())), J.get$y$x(this.sprite.get$anchor())));
        x = J.$add$ns(x, J.get$x$x(t1.get$texture().get$frame()));
        y = J.$add$ns(y, J.get$y$x(t1.get$texture().get$frame()));
        J.drawImageScaledFromSource$9$x(this.game.get$input().get$hitContext(), J.get$source$x(t1.get$texture().get$baseTexture()), x, y, 1, 1, 0, 0, 1, 1);
        t1 = J.get$data$x(J.getImageData$4$x(this.game.get$input().get$hitContext(), 0, 0, 1, 1));
        if (3 >= t1.length)
          return H.ioore(t1, 3);
        t1 = t1[3];
        t2 = this.pixelPerfectAlpha;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (t1 >= t2)
          return true;
      }
      return false;
    }, function(x, y) {
      return this.checkPixel$3(x, y, null);
    }, "checkPixel$2", "call$3", "call$2", "get$checkPixel", 4, 2, 1303, 32, 6, [], 7, [], 994, [], "checkPixel"],
    update$1: [function(pointer) {
      var t1 = this.sprite;
      if (t1 == null || J.get$parent$x(t1) == null)
        return false;
      if (this.enabled !== true || this.sprite.get$visible() !== true || J.get$parent$x(this.sprite).get$visible() !== true) {
        this._pointerOutHandler$1(pointer);
        return false;
      }
      if (this.draggable === true && J.$eq(this._draggedPointerID, J.get$id$x(pointer)))
        return this.updateDrag$1(pointer);
      else {
        t1 = J.getInterceptor$x(pointer);
        if (J.$eq(J.$index$asx(this._pointerData, t1.get$id(pointer)).get$isOver(), true))
          if (this.checkPointerOver$1(pointer)) {
            J.set$x$x(J.$index$asx(this._pointerData, t1.get$id(pointer)), J.$sub$n(t1.get$x(pointer), J.get$x$x(this.sprite)));
            J.set$y$x(J.$index$asx(this._pointerData, t1.get$id(pointer)), J.$sub$n(t1.get$y(pointer), J.get$y$x(this.sprite)));
            return true;
          } else {
            this._pointerOutHandler$1(pointer);
            return false;
          }
      }
      return true;
    }, "call$1", "get$update", 2, 0, 1302, 994, [], "update"],
    _pointerOverHandler$1: [function(pointer) {
      var t1;
      if (this.sprite == null)
        return;
      t1 = J.getInterceptor$x(pointer);
      if (J.$eq(J.$index$asx(this._pointerData, t1.get$id(pointer)).get$isOver(), false)) {
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isOver(true);
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isOut(false);
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$timeOver(this.game.get$time().get$now());
        J.set$x$x(J.$index$asx(this._pointerData, t1.get$id(pointer)), J.$sub$n(t1.get$x(pointer), J.get$x$x(this.sprite)));
        J.set$y$x(J.$index$asx(this._pointerData, t1.get$id(pointer)), J.$sub$n(t1.get$y(pointer), J.get$y$x(this.sprite)));
        if (this.useHandCursor === true && J.$eq(J.$index$asx(this._pointerData, t1.get$id(pointer)).get$isDragged(), false)) {
          J.set$cursor$x(J.get$style$x(J.get$canvas$x(this.game)), "pointer");
          this._setHandCursor = true;
        }
        t1 = this.sprite;
        if (t1 != null && t1.get$events() != null)
          this.sprite.get$events().get$onInputOver().dispatch$1([this.sprite, pointer]);
      }
    }, "call$1", "get$_pointerOverHandler", 2, 0, 1304, 994, [], "_pointerOverHandler"],
    _pointerOutHandler$1: [function(pointer) {
      var t1;
      if (this.sprite == null)
        return;
      t1 = J.getInterceptor$x(pointer);
      J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isOver(false);
      J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isOut(true);
      J.$index$asx(this._pointerData, t1.get$id(pointer)).set$timeOut(this.game.get$time().get$now());
      if (this.useHandCursor === true && J.$eq(J.$index$asx(this._pointerData, t1.get$id(pointer)).get$isDragged(), false)) {
        J.set$cursor$x(J.get$style$x(J.get$canvas$x(this.game)), "default");
        this._setHandCursor = false;
      }
      t1 = this.sprite;
      if (t1 != null && t1.get$events() != null)
        this.sprite.get$events().get$onInputOut().dispatch$1([this.sprite, pointer]);
    }, "call$1", "get$_pointerOutHandler", 2, 0, 1304, 994, [], "_pointerOutHandler"],
    _touchedHandler$1: [function(pointer) {
      var t1, t2, t3, t4, bounds;
      if (this.sprite == null)
        return false;
      t1 = J.getInterceptor$x(pointer);
      if (J.$eq(J.$index$asx(this._pointerData, t1.get$id(pointer)).get$isDown(), false) && J.$eq(J.$index$asx(this._pointerData, t1.get$id(pointer)).get$isOver(), true)) {
        if (this.pixelPerfectClick === true && !this.checkPixel$3(null, null, pointer))
          return false;
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isDown(true);
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isUp(false);
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$timeDown(this.game.get$time().get$now());
        t2 = this.sprite;
        if (t2 != null && t2.get$events() != null)
          this.sprite.get$events().get$onInputDown().dispatch$1([this.sprite, pointer]);
        if (this.draggable === true && J.$eq(this.isDragged, false)) {
          this.isDragged = true;
          this._draggedPointerID = t1.get$id(pointer);
          J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isDragged(true);
          if (this.sprite.get$fixedToCamera() === true) {
            t2 = this.dragFromCenter;
            t3 = this._dragPoint;
            t4 = this.sprite;
            if (t2 === true)
              t3.setTo$2(J.$sub$n(J.get$x$x(t4.get$cameraOffset()), t1.get$x(pointer)), J.$sub$n(J.get$y$x(this.sprite.get$cameraOffset()), t1.get$y(pointer)));
            else
              t3.setTo$2(J.$sub$n(J.get$x$x(t4.get$cameraOffset()), t1.get$x(pointer)), J.$sub$n(J.get$y$x(this.sprite.get$cameraOffset()), t1.get$y(pointer)));
          } else {
            t2 = this.dragFromCenter;
            t3 = this.sprite;
            if (t2 === true) {
              bounds = t3.getBounds$0();
              J.set$x$x(this.sprite, J.$add$ns(t1.get$x(pointer), J.$sub$n(J.get$x$x(this.sprite), bounds.get$centerX())));
              J.set$y$x(this.sprite, J.$add$ns(t1.get$y(pointer), J.$sub$n(J.get$y$x(this.sprite), bounds.get$centerY())));
              this._dragPoint.setTo$2(J.$sub$n(J.get$x$x(this.sprite), t1.get$x(pointer)), J.$sub$n(J.get$y$x(this.sprite), t1.get$y(pointer)));
            } else
              this._dragPoint.setTo$2(J.$sub$n(J.get$x$x(t3), t1.get$x(pointer)), J.$sub$n(J.get$y$x(this.sprite), t1.get$y(pointer)));
          }
          this.updateDrag$1(pointer);
          if (this.bringToTop === true) {
            this._dragPhase = true;
            this.sprite.bringToTop$0();
          }
          J.get$onDragStart$x(this.sprite.get$events()).dispatch$1([this.sprite, pointer]);
        }
        if (this.bringToTop === true)
          this.sprite.bringToTop$0();
      }
      return this.consumePointerEvent;
    }, "call$1", "get$_touchedHandler", 2, 0, 1302, 994, [], "_touchedHandler"],
    _releasedHandler$1: [function(pointer) {
      var t1, t2;
      if (this.sprite == null)
        return;
      t1 = J.getInterceptor$x(pointer);
      if (J.$index$asx(this._pointerData, t1.get$id(pointer)).get$isDown() === true && pointer.get$isUp() === true) {
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isDown(false);
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isUp(true);
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$timeUp(this.game.get$time().get$now());
        J.$index$asx(this._pointerData, t1.get$id(pointer)).set$downDuration(J.$sub$n(J.$index$asx(this._pointerData, t1.get$id(pointer)).get$timeUp(), J.$index$asx(this._pointerData, t1.get$id(pointer)).get$timeDown()));
        if (this.checkPointerOver$1(pointer)) {
          t2 = this.sprite;
          if (t2 != null && t2.get$events() != null)
            this.sprite.get$events().get$onInputUp().dispatch$1([this.sprite, pointer, true]);
        } else {
          t2 = this.sprite;
          if (t2 != null && t2.get$events() != null)
            this.sprite.get$events().get$onInputUp().dispatch$1([this.sprite, pointer, false]);
          if (this.useHandCursor === true) {
            J.set$cursor$x(J.get$style$x(J.get$canvas$x(this.game)), "default");
            this._setHandCursor = false;
          }
        }
        if (this.draggable === true && this.isDragged === true && J.$eq(this._draggedPointerID, t1.get$id(pointer)))
          this.stopDrag$1(pointer);
      }
    }, "call$1", "get$_releasedHandler", 2, 0, 1304, 994, [], "_releasedHandler"],
    updateDrag$1: [function(pointer) {
      var t1, t2, t3, t4;
      if (pointer.get$isUp() === true) {
        this.stopDrag$1(pointer);
        return false;
      }
      if (this.sprite.get$fixedToCamera() === true) {
        if (this.allowHorizontalDrag === true)
          J.set$x$x(this.sprite.get$cameraOffset(), J.$add$ns(J.$add$ns(J.get$x$x(pointer), J.get$x$x(this._dragPoint)), J.get$x$x(this.dragOffset)));
        if (this.allowVerticalDrag === true)
          J.set$y$x(this.sprite.get$cameraOffset(), J.$add$ns(J.$add$ns(J.get$y$x(pointer), J.get$y$x(this._dragPoint)), J.get$y$x(this.dragOffset)));
        if (this.boundsRect != null)
          this.checkBoundsRect$0();
        if (this.boundsSprite != null)
          this.checkBoundsSprite$0();
        if (this.snapOnDrag === true) {
          t1 = this.sprite.get$cameraOffset();
          t2 = J.round$0$n(J.$div$n(J.$sub$n(J.get$x$x(this.sprite.get$cameraOffset()), J.$mod$n(this.snapOffsetX, this.snapX)), this.snapX));
          t3 = this.snapX;
          if (typeof t3 !== "number")
            return H.iae(t3);
          J.set$x$x(t1, t2 * t3 + J.$mod$n(this.snapOffsetX, t3));
          t3 = this.sprite.get$cameraOffset();
          t2 = J.round$0$n(J.$div$n(J.$sub$n(J.get$y$x(this.sprite.get$cameraOffset()), J.$mod$n(this.snapOffsetY, this.snapY)), this.snapY));
          t1 = this.snapY;
          if (typeof t1 !== "number")
            return H.iae(t1);
          J.set$y$x(t3, t2 * t1 + J.$mod$n(this.snapOffsetY, t1));
        }
      } else {
        if (this.allowHorizontalDrag === true)
          J.set$x$x(this.sprite, J.$add$ns(J.$add$ns(J.get$x$x(pointer), J.get$x$x(this._dragPoint)), J.get$x$x(this.dragOffset)));
        if (this.allowVerticalDrag === true)
          J.set$y$x(this.sprite, J.$add$ns(J.$add$ns(J.get$y$x(pointer), J.get$y$x(this._dragPoint)), J.get$y$x(this.dragOffset)));
        if (this.boundsRect != null)
          this.checkBoundsRect$0();
        if (this.boundsSprite != null)
          this.checkBoundsSprite$0();
        if (this.snapOnDrag === true) {
          t1 = this.sprite;
          t2 = J.getInterceptor$x(t1);
          t3 = J.round$0$n(J.$div$n(J.$sub$n(t2.get$x(t1), J.$mod$n(this.snapOffsetX, this.snapX)), this.snapX));
          t4 = this.snapX;
          if (typeof t4 !== "number")
            return H.iae(t4);
          t2.set$x(t1, t3 * t4 + J.$mod$n(this.snapOffsetX, t4));
          t4 = this.sprite;
          t3 = J.getInterceptor$x(t4);
          t1 = J.round$0$n(J.$div$n(J.$sub$n(t3.get$y(t4), J.$mod$n(this.snapOffsetY, this.snapY)), this.snapY));
          t2 = this.snapY;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t3.set$y(t4, t1 * t2 + J.$mod$n(this.snapOffsetY, t2));
        }
      }
      return true;
    }, "call$1", "get$updateDrag", 2, 0, 1302, 994, [], "updateDrag"],
    justOver$2: [function(pointer, delay) {
      return J.$index$asx(this._pointerData, pointer).get$isOver() === true && J.$lt$n(this.overDuration$1(pointer), delay);
    }, function() {
      return this.justOver$2(0, 500);
    }, "justOver$0", function(pointer) {
      return this.justOver$2(pointer, 500);
    }, "justOver$1", "call$2", "call$0", "call$1", "get$justOver", 0, 4, 1305, 5, 1306, 994, [], 473, [], "justOver"],
    justOut$2: [function(pointer, delay) {
      return J.$index$asx(this._pointerData, pointer).get$isOut() === true && J.$lt$n(J.$sub$n(this.game.get$time().get$now(), J.$index$asx(this._pointerData, pointer).get$timeOut()), delay);
    }, function() {
      return this.justOut$2(0, 500);
    }, "justOut$0", function(pointer) {
      return this.justOut$2(pointer, 500);
    }, "justOut$1", "call$2", "call$0", "call$1", "get$justOut", 0, 4, 1305, 5, 1306, 994, [], 473, [], "justOut"],
    justPressed$2: [function(pointer, delay) {
      return J.$index$asx(this._pointerData, pointer).get$isDown() === true && J.$lt$n(this.downDuration$1(pointer), delay);
    }, function(pointer) {
      return this.justPressed$2(pointer, 500);
    }, "justPressed$1", function() {
      return this.justPressed$2(0, 500);
    }, "justPressed$0", "call$2", "call$1", "call$0", "get$justPressed", 0, 4, 1305, 5, 1306, 994, [], 473, [], "justPressed"],
    justReleased$2: [function(pointer, delay) {
      return J.$index$asx(this._pointerData, pointer).get$isUp() === true && J.$lt$n(J.$sub$n(this.game.get$time().get$now(), J.$index$asx(this._pointerData, pointer).get$timeUp()), delay);
    }, function(pointer) {
      return this.justReleased$2(pointer, 500);
    }, "justReleased$1", function() {
      return this.justReleased$2(0, 500);
    }, "justReleased$0", "call$2", "call$1", "call$0", "get$justReleased", 0, 4, 1305, 5, 1306, 994, [], 473, [], "justReleased"],
    overDuration$1: [function(pointer) {
      if (J.$index$asx(this._pointerData, pointer).get$isOver() === true)
        return J.$sub$n(this.game.get$time().get$now(), J.$index$asx(this._pointerData, pointer).get$timeOver());
      return -1;
    }, function() {
      return this.overDuration$1(0);
    }, "overDuration$0", "call$1", "call$0", "get$overDuration", 0, 2, 1301, 5, 994, [], "overDuration"],
    downDuration$1: [function(pointer) {
      if (J.$index$asx(this._pointerData, pointer).get$isDown() === true)
        return J.$sub$n(this.game.get$time().get$now(), J.$index$asx(this._pointerData, pointer).get$timeDown());
      return -1;
    }, function() {
      return this.downDuration$1(0);
    }, "downDuration$0", "call$1", "call$0", "get$downDuration", 0, 2, 1301, 5, 994, [], "downDuration"],
    enableDrag$6: [function(lockCenter, bringToTop, pixelPerfect, alphaThreshold, boundsRect, boundsSprite) {
      var t1;
      if (lockCenter == null)
        lockCenter = false;
      if (bringToTop == null)
        bringToTop = false;
      if (pixelPerfect == null)
        pixelPerfect = false;
      if (alphaThreshold == null)
        alphaThreshold = 255;
      if (boundsRect == null)
        boundsRect = null;
      if (boundsSprite == null)
        boundsSprite = null;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this._dragPoint = t1;
      this.draggable = true;
      this.bringToTop = bringToTop;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.dragOffset = t1;
      this.dragFromCenter = lockCenter;
      this.pixelPerfectClick = pixelPerfect;
      this.pixelPerfectAlpha = alphaThreshold;
      if (boundsRect != null)
        this.boundsRect = boundsRect;
      if (boundsSprite != null)
        this.boundsSprite = boundsSprite;
    }, function() {
      return this.enableDrag$6(false, false, false, 255, null, null);
    }, "enableDrag$0", function(lockCenter) {
      return this.enableDrag$6(lockCenter, false, false, 255, null, null);
    }, "enableDrag$1", function(lockCenter, bringToTop) {
      return this.enableDrag$6(lockCenter, bringToTop, false, 255, null, null);
    }, "enableDrag$2", function(lockCenter, bringToTop, pixelPerfect) {
      return this.enableDrag$6(lockCenter, bringToTop, pixelPerfect, 255, null, null);
    }, "enableDrag$3", function(lockCenter, bringToTop, pixelPerfect, alphaThreshold) {
      return this.enableDrag$6(lockCenter, bringToTop, pixelPerfect, alphaThreshold, null, null);
    }, "enableDrag$4", function(lockCenter, bringToTop, pixelPerfect, alphaThreshold, boundsRect) {
      return this.enableDrag$6(lockCenter, bringToTop, pixelPerfect, alphaThreshold, boundsRect, null);
    }, "enableDrag$5", "call$6", "call$0", "call$1", "call$2", "call$3", "call$4", "call$5", "get$enableDrag", 0, 12, 1307, 95, 95, 95, 508, 32, 32, 1308, [], 1309, [], 1310, [], 1311, [], 1312, [], 1313, [], "enableDrag"],
    disableDrag$0: [function() {
      if (this._pointerData != null)
        for (var i = 0; i < 10; ++i)
          J.$index$asx(this._pointerData, i).set$isDragged(false);
      this.draggable = false;
      this.isDragged = false;
      this._draggedPointerID = -1;
    }, "call$0", "get$disableDrag", 0, 0, 13, "disableDrag"],
    startDrag$1: [function(pointer) {
      var t1, t2, t3, t4, bounds;
      this.isDragged = true;
      t1 = J.getInterceptor$x(pointer);
      this._draggedPointerID = t1.get$id(pointer);
      J.$index$asx(this._pointerData, t1.get$id(pointer)).set$isDragged(true);
      if (this.sprite.get$fixedToCamera() === true) {
        t2 = this.dragFromCenter;
        t3 = this._dragPoint;
        t4 = this.sprite;
        if (t2 === true)
          t3.setTo$2(J.$sub$n(J.get$x$x(t4.get$cameraOffset()), t1.get$x(pointer)), J.$sub$n(J.get$y$x(this.sprite.get$cameraOffset()), t1.get$y(pointer)));
        else
          t3.setTo$2(J.$sub$n(J.get$x$x(t4.get$cameraOffset()), t1.get$x(pointer)), J.$sub$n(J.get$y$x(this.sprite.get$cameraOffset()), t1.get$y(pointer)));
      } else {
        t2 = this.dragFromCenter;
        t3 = this.sprite;
        if (t2 === true) {
          bounds = t3.getBounds$0();
          J.set$x$x(this.sprite, J.$add$ns(t1.get$x(pointer), J.$sub$n(J.get$x$x(this.sprite), bounds.get$centerX())));
          J.set$y$x(this.sprite, J.$add$ns(t1.get$y(pointer), J.$sub$n(J.get$y$x(this.sprite), bounds.get$centerY())));
          this._dragPoint.setTo$2(J.$sub$n(J.get$x$x(this.sprite), t1.get$x(pointer)), J.$sub$n(J.get$y$x(this.sprite), t1.get$y(pointer)));
        } else
          this._dragPoint.setTo$2(J.$sub$n(J.get$x$x(t3), t1.get$x(pointer)), J.$sub$n(J.get$y$x(this.sprite), t1.get$y(pointer)));
      }
      this.updateDrag$1(pointer);
      if (this.bringToTop === true) {
        this._dragPhase = true;
        this.sprite.bringToTop$0();
      }
      J.get$onDragStart$x(this.sprite.get$events()).dispatch$1([this.sprite, pointer]);
    }, "call$1", "get$startDrag", 2, 0, 1304, 994, [], "startDrag"],
    stopDrag$1: [function(pointer) {
      var t1, t2, t3, t4;
      this.isDragged = false;
      this._draggedPointerID = -1;
      J.$index$asx(this._pointerData, J.get$id$x(pointer)).set$isDragged(false);
      this._dragPhase = false;
      if (this.snapOnRelease === true) {
        t1 = this.sprite.get$fixedToCamera();
        t2 = this.sprite;
        if (t1 === true) {
          t1 = t2.get$cameraOffset();
          t2 = J.round$0$n(J.$div$n(J.$sub$n(J.get$x$x(this.sprite.get$cameraOffset()), J.$mod$n(this.snapOffsetX, this.snapX)), this.snapX));
          t3 = this.snapX;
          if (typeof t3 !== "number")
            return H.iae(t3);
          J.set$x$x(t1, t2 * t3 + J.$mod$n(this.snapOffsetX, t3));
          t3 = this.sprite.get$cameraOffset();
          t2 = J.round$0$n(J.$div$n(J.$sub$n(J.get$y$x(this.sprite.get$cameraOffset()), J.$mod$n(this.snapOffsetY, this.snapY)), this.snapY));
          t1 = this.snapY;
          if (typeof t1 !== "number")
            return H.iae(t1);
          J.set$y$x(t3, t2 * t1 + J.$mod$n(this.snapOffsetY, t1));
        } else {
          t1 = J.getInterceptor$x(t2);
          t3 = J.round$0$n(J.$div$n(J.$sub$n(t1.get$x(t2), J.$mod$n(this.snapOffsetX, this.snapX)), this.snapX));
          t4 = this.snapX;
          if (typeof t4 !== "number")
            return H.iae(t4);
          t1.set$x(t2, t3 * t4 + J.$mod$n(this.snapOffsetX, t4));
          t4 = this.sprite;
          t3 = J.getInterceptor$x(t4);
          t2 = J.round$0$n(J.$div$n(J.$sub$n(t3.get$y(t4), J.$mod$n(this.snapOffsetY, this.snapY)), this.snapY));
          t1 = this.snapY;
          if (typeof t1 !== "number")
            return H.iae(t1);
          t3.set$y(t4, t2 * t1 + J.$mod$n(this.snapOffsetY, t1));
        }
      }
      this.sprite.get$events().get$onDragStop().dispatch$1([this.sprite, pointer]);
      if (!this.checkPointerOver$1(pointer))
        this._pointerOutHandler$1(pointer);
    }, "call$1", "get$stopDrag", 2, 0, 1304, 994, [], "stopDrag"],
    setDragLock$2: [function(allowHorizontal, allowVertical) {
      this.allowHorizontalDrag = allowHorizontal;
      this.allowVerticalDrag = allowVertical;
    }, function() {
      return this.setDragLock$2(true, true);
    }, "setDragLock$0", function(allowHorizontal) {
      return this.setDragLock$2(allowHorizontal, true);
    }, "setDragLock$1", "call$2", "call$0", "call$1", "get$setDragLock", 0, 4, 945, 39, 39, 1314, [], 1315, [], "setDragLock"],
    enableSnap$6: [function(snapX, snapY, onDrag, onRelease, snapOffsetX, snapOffsetY) {
      this.snapX = snapX;
      this.snapY = snapY;
      this.snapOffsetX = snapOffsetX;
      this.snapOffsetY = snapOffsetY;
      this.snapOnDrag = onDrag;
      this.snapOnRelease = onRelease;
    }, function(snapX, snapY) {
      return this.enableSnap$6(snapX, snapY, true, true, 0, 0);
    }, "enableSnap$2", function(snapX, snapY, onDrag) {
      return this.enableSnap$6(snapX, snapY, onDrag, true, 0, 0);
    }, "enableSnap$3", function(snapX, snapY, onDrag, onRelease) {
      return this.enableSnap$6(snapX, snapY, onDrag, onRelease, 0, 0);
    }, "enableSnap$4", function(snapX, snapY, onDrag, onRelease, snapOffsetX) {
      return this.enableSnap$6(snapX, snapY, onDrag, onRelease, snapOffsetX, 0);
    }, "enableSnap$5", "call$6", "call$2", "call$3", "call$4", "call$5", "get$enableSnap", 4, 8, 1316, 39, 39, 5, 5, 1317, [], 1318, [], 1319, [], 1320, [], 1321, [], 1322, [], "enableSnap"],
    disableSnap$0: [function() {
      this.snapOnDrag = false;
      this.snapOnRelease = false;
    }, "call$0", "get$disableSnap", 0, 0, 13, "disableSnap"],
    checkBoundsRect$0: [function() {
      if (this.sprite.get$fixedToCamera() === true) {
        if (J.$lt$n(J.get$x$x(this.sprite.get$cameraOffset()), J.get$left$x(this.boundsRect)))
          J.set$x$x(this.sprite.get$cameraOffset(), J.get$left$x(this.boundsRect));
        else if (J.$gt$n(J.$add$ns(J.get$x$x(this.sprite.get$cameraOffset()), J.get$width$x(this.sprite)), J.get$right$x(this.boundsRect)))
          J.set$x$x(this.sprite.get$cameraOffset(), J.$sub$n(J.get$right$x(this.boundsRect), J.get$width$x(this.sprite)));
        if (J.$lt$n(J.get$y$x(this.sprite.get$cameraOffset()), J.get$top$x(this.boundsRect)))
          J.set$y$x(this.sprite.get$cameraOffset(), J.get$top$x(this.boundsRect));
        else if (J.$gt$n(J.$add$ns(J.get$y$x(this.sprite.get$cameraOffset()), J.get$height$x(this.sprite)), J.get$bottom$x(this.boundsRect)))
          J.set$y$x(this.sprite.get$cameraOffset(), J.$sub$n(J.get$bottom$x(this.boundsRect), J.get$height$x(this.sprite)));
      } else {
        if (J.$lt$n(J.get$x$x(this.sprite), J.get$left$x(this.boundsRect)))
          J.set$x$x(this.sprite, J.get$x$x(this.boundsRect));
        else if (J.$gt$n(J.$add$ns(J.get$x$x(this.sprite), J.get$width$x(this.sprite)), J.get$right$x(this.boundsRect)))
          J.set$x$x(this.sprite, J.$sub$n(J.get$right$x(this.boundsRect), J.get$width$x(this.sprite)));
        if (J.$lt$n(J.get$y$x(this.sprite), J.get$top$x(this.boundsRect)))
          J.set$y$x(this.sprite, J.get$top$x(this.boundsRect));
        else if (J.$gt$n(J.$add$ns(J.get$y$x(this.sprite), J.get$height$x(this.sprite)), J.get$bottom$x(this.boundsRect)))
          J.set$y$x(this.sprite, J.$sub$n(J.get$bottom$x(this.boundsRect), J.get$height$x(this.sprite)));
      }
    }, "call$0", "get$checkBoundsRect", 0, 0, 13, "checkBoundsRect"],
    checkBoundsSprite$0: [function() {
      if (this.sprite.get$fixedToCamera() === true && this.boundsSprite.get$fixedToCamera() === true) {
        if (J.$lt$n(J.get$x$x(this.sprite.get$cameraOffset()), J.get$x$x(this.boundsSprite.get$camerOffset())))
          J.set$x$x(this.sprite.get$cameraOffset(), J.get$x$x(this.boundsSprite.get$camerOffset()));
        else if (J.$gt$n(J.$add$ns(J.get$x$x(this.sprite.get$cameraOffset()), J.get$width$x(this.sprite)), J.$add$ns(J.get$x$x(this.boundsSprite.get$camerOffset()), J.get$width$x(this.boundsSprite))))
          J.set$x$x(this.sprite.get$cameraOffset(), J.$sub$n(J.$add$ns(J.get$x$x(this.boundsSprite.get$camerOffset()), J.get$width$x(this.boundsSprite)), J.get$width$x(this.sprite)));
        if (J.$lt$n(J.get$y$x(this.sprite.get$cameraOffset()), J.get$y$x(this.boundsSprite.get$camerOffset())))
          J.set$y$x(this.sprite.get$cameraOffset(), J.get$y$x(this.boundsSprite.get$camerOffset()));
        else if (J.$gt$n(J.$add$ns(J.get$y$x(this.sprite.get$cameraOffset()), J.get$height$x(this.sprite)), J.$add$ns(J.get$y$x(this.boundsSprite.get$camerOffset()), J.get$height$x(this.boundsSprite))))
          J.set$y$x(this.sprite.get$cameraOffset(), J.$sub$n(J.$add$ns(J.get$y$x(this.boundsSprite.get$camerOffset()), J.get$height$x(this.boundsSprite)), J.get$height$x(this.sprite)));
      } else {
        if (J.$lt$n(J.get$x$x(this.sprite), J.get$x$x(this.boundsSprite)))
          J.set$x$x(this.sprite, J.get$x$x(this.boundsSprite));
        else if (J.$gt$n(J.$add$ns(J.get$x$x(this.sprite), J.get$width$x(this.sprite)), J.$add$ns(J.get$x$x(this.boundsSprite), J.get$width$x(this.boundsSprite))))
          J.set$x$x(this.sprite, J.$sub$n(J.$add$ns(J.get$x$x(this.boundsSprite), J.get$width$x(this.boundsSprite)), J.get$width$x(this.sprite)));
        if (J.$lt$n(J.get$y$x(this.sprite), J.get$y$x(this.boundsSprite)))
          J.set$y$x(this.sprite, J.get$y$x(this.boundsSprite));
        else if (J.$gt$n(J.$add$ns(J.get$y$x(this.sprite), J.get$height$x(this.sprite)), J.$add$ns(J.get$y$x(this.boundsSprite), J.get$height$x(this.boundsSprite))))
          J.set$y$x(this.sprite, J.$sub$n(J.$add$ns(J.get$y$x(this.boundsSprite), J.get$height$x(this.boundsSprite)), J.get$height$x(this.sprite)));
      }
    }, "call$0", "get$checkBoundsSprite", 0, 0, 13, "checkBoundsSprite"],
    InputHandler$1: function(sprite) {
      var t1, t2;
      this.game = this.sprite.get$game();
      this.enabled = false;
      this.priorityID = 0;
      this.useHandCursor = false;
      this._setHandCursor = false;
      this.isDragged = false;
      this.allowHorizontalDrag = true;
      this.allowVerticalDrag = true;
      this.bringToTop = false;
      this.snapOffset = null;
      this.snapOnDrag = false;
      this.snapOnRelease = false;
      this.snapX = 0;
      this.snapY = 0;
      this.snapOffsetX = 0;
      this.snapOffsetY = 0;
      this.pixelPerfectOver = false;
      this.pixelPerfectClick = false;
      this.pixelPerfectAlpha = 255;
      this.draggable = false;
      this.boundsRect = null;
      this.boundsSprite = null;
      this.consumePointerEvent = false;
      this._dragPhase = false;
      this._wasEnabled = false;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this._tempPoint = t1;
      t1 = Array(11);
      t1.fixed$length = init;
      t1 = H.setRuntimeTypeInfo(t1, [R.Pointer]);
      this._pointerData = t1;
      t2 = R.Pointer$(this.sprite.get$game(), 0);
      t2.x = 0;
      t2.y = 0;
      t2.isDown = false;
      t2.isUp = false;
      t2.isOver = false;
      t2.isOut = false;
      t2.timeOver = 0;
      t2.timeOut = 0;
      t2.timeDown = 0;
      t2.timeUp = 0;
      t2.downDuration = 0;
      t2.isDragged = false;
      if (0 < 0 || 0 >= 11)
        return H.ioore(t1, 0);
      t1[0] = t2;
    },
    static: {InputHandler$: [function(sprite) {
        var t1 = new R.InputHandler(sprite, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.InputHandler$1(sprite);
        return t1;
      }, null, null, 2, 0, 277, 113, [], "new InputHandler"]}
  },
  "+InputHandler": [632],
  Key: {
    "^": "Object;game@-598,enabled@-602,event@-32,isDown@-602,isUp@-602,altKey*-602,ctrlKey*-602,shiftKey*-602,timeDown@-629,duration*-629,timeUp@-629,repeats@-599,keyCode*-599,onDown@-1323,onHoldCallback@-0,onUp@-1323",
    isDown$1: function(arg0) {
      return this.isDown.call$1(arg0);
    },
    onHoldCallback$1: function(arg0) {
      return this.onHoldCallback.call$1(arg0);
    },
    update$0: [function() {
      if (this.enabled !== true)
        return;
      if (this.isDown === true) {
        this.duration = J.$sub$n(this.game.get$time().get$now(), this.timeDown);
        this.repeats = J.$add$ns(this.repeats, 1);
        if (this.onHoldCallback != null)
          this.onHoldCallback$1(this);
      }
    }, "call$0", "get$update", 0, 0, 13, "update"],
    processKeyDown$1: [function($event) {
      var t1;
      if (this.enabled !== true)
        return;
      this.event = $event;
      if (this.isDown === true)
        return;
      t1 = J.getInterceptor$x($event);
      this.altKey = t1.get$altKey($event);
      this.ctrlKey = t1.get$ctrlKey($event);
      this.shiftKey = t1.get$shiftKey($event);
      this.isDown = true;
      this.isUp = false;
      this.timeDown = this.game.get$time().get$now();
      this.duration = 0;
      this.repeats = 0;
      this.onDown.dispatch$1(this);
    }, "call$1", "get$processKeyDown", 2, 0, 1324, 815, [], "processKeyDown"],
    processKeyUp$1: [function($event) {
      if (this.enabled !== true)
        return;
      this.event = $event;
      if (this.isUp === true)
        return;
      this.isDown = false;
      this.isUp = true;
      this.timeUp = this.game.get$time().get$now();
      this.duration = J.$sub$n(this.game.get$time().get$now(), this.timeDown);
      this.onUp.dispatch$1(this);
    }, "call$1", "get$processKeyUp", 2, 0, 1324, 815, [], "processKeyUp"],
    reset$1: [function(_, hard) {
      this.isDown = false;
      this.isUp = true;
      this.timeUp = this.game.get$time().get$now();
      this.duration = 0;
      this.enabled = true;
      if (hard === true) {
        this.onDown.removeAll$0();
        this.onUp.removeAll$0();
        this.onHoldCallback = null;
      }
    }, function($receiver) {
      return this.reset$1($receiver, true);
    }, "reset$0", "call$1", "call$0", "get$reset", 0, 2, 932, 39, 1282, [], "reset"],
    justPressed$1: [function(duration) {
      return this.isDown === true && J.$lt$n(this.duration, duration);
    }, function() {
      return this.justPressed$1(50);
    }, "justPressed$0", "call$1", "call$0", "get$justPressed", 0, 2, 1300, 361, 55, [], "justPressed"],
    justReleased$1: [function(duration) {
      return this.isDown !== true && J.$lt$n(J.$sub$n(this.game.get$time().get$now(), this.timeUp), duration);
    }, function() {
      return this.justReleased$1(50);
    }, "justReleased$0", "call$1", "call$0", "get$justReleased", 0, 2, 1300, 361, 55, [], "justReleased"],
    Key$2: function(game, keycode) {
      this.enabled = true;
      this.event = null;
      this.isDown = false;
      this.isUp = true;
      this.altKey = false;
      this.ctrlKey = false;
      this.shiftKey = false;
      this.timeDown = 0;
      this.duration = 0;
      this.timeUp = -2500;
      this.repeats = 0;
      this.keyCode = keycode;
      this.onDown = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onHoldCallback = null;
      this.onUp = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
    },
    static: {Key$: [function(game, keycode) {
        var t1 = new R.Key(game, null, null, null, null, null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), null, null);
        t1.Key$2(game, keycode);
        return t1;
      }, null, null, 4, 0, 322, 214, [], 323, [], "new Key"]}
  },
  "+Key": [632],
  CursorKeys: {
    "^": "Object;up@-1325,down@-1325,left*-1325,right*-1325",
    static: {CursorKeys$: [function() {
        return new R.CursorKeys(null, null, null, null);
      }, null, null, 0, 0, 324, "new CursorKeys"]}
  },
  "+CursorKeys": [632],
  Keyboard: {
    "^": "Object;game@-598,disabled*-602,event@-32,pressEvent@-32,callbackContext@-32,onDownCallback@-0,onPressCallback@-0,onUpCallback@-0,_Phaser$_keys@-1326,_capture@-893,_onKeyDown@-0,_onKeyPress@-0,_onKeyUp@-0,_i@-599,_k@-599",
    get$lastChar: [function() {
      if (J.$eq(J.get$charCode$x(this.event), 32))
        return "";
      else
        return H.Primitives_stringFromCharCode(J.get$charCode$x(this.pressEvent));
    }, null, null, 1, 0, 782, "lastChar"],
    get$lastKey: [function() {
      return J.$index$asx(this._Phaser$_keys, this._k);
    }, null, null, 1, 0, 1327, "lastKey"],
    addCallbacks$4: [function(context, onDown, onUp, onPress) {
      this.callbackContext = context;
      if (onDown != null)
        this.onDownCallback = onDown;
      if (onUp != null)
        this.onUpCallback = onUp;
      if (onPress != null)
        this.onPressCallback = onPress;
    }, function(context) {
      return this.addCallbacks$4(context, null, null, null);
    }, "addCallbacks$1", function(context, onDown) {
      return this.addCallbacks$4(context, onDown, null, null);
    }, "addCallbacks$2", function(context, onDown, onUp) {
      return this.addCallbacks$4(context, onDown, onUp, null);
    }, "addCallbacks$3", "call$4", "call$1", "call$2", "call$3", "get$addCallbacks", 2, 6, 1328, 32, 32, 32, 104, [], 1329, [], 1330, [], 1331, [], "addCallbacks"],
    addKey$1: [function(_, keycode) {
      if (J.$index$asx(this._Phaser$_keys, keycode) == null) {
        J.$indexSet$ax(this._Phaser$_keys, keycode, R.Key$(this.game, keycode));
        this.addKeyCapture$1(keycode);
      }
      return J.$index$asx(this._Phaser$_keys, keycode);
    }, "call$1", "get$addKey", 2, 0, 1332, 323, [], "addKey"],
    removeKey$1: [function(keycode) {
      if (J.$index$asx(this._Phaser$_keys, keycode) != null) {
        J.$indexSet$ax(this._Phaser$_keys, keycode, null);
        J.remove$1$ax(this._capture, keycode);
      }
    }, "call$1", "get$removeKey", 2, 0, 63, 323, [], "removeKey"],
    createCursorKeys$0: [function() {
      var t1 = new R.CursorKeys(null, null, null, null);
      t1.up = this.addKey$1(0, 38);
      t1.down = this.addKey$1(0, 40);
      t1.left = this.addKey$1(0, 37);
      t1.right = this.addKey$1(0, 39);
      return t1;
    }, "call$0", "get$createCursorKeys", 0, 0, 324, "createCursorKeys"],
    start$0: [function(_) {
      var t1;
      if (this.game.get$device().get$cocoonJS() === true)
        return;
      if (this._onKeyDown != null)
        return;
      t1 = new R.Keyboard_start_closure(this);
      this._onKeyDown = t1;
      this._onKeyUp = new R.Keyboard_start_closure0(this);
      this._onKeyPress = new R.Keyboard_start_closure1(this);
      C.Window_methods.addEventListener$3(window, "keydown", t1, false);
      C.Window_methods.addEventListener$3(window, "keyup", this._onKeyUp, false);
      C.Window_methods.addEventListener$3(window, "keypress", this._onKeyPress, false);
    }, "call$0", "get$start", 0, 0, 13, "start"],
    stop$0: [function(_) {
      C.Window_methods.removeEventListener$2(window, "keydown", this._onKeyDown);
      C.Window_methods.removeEventListener$2(window, "keyup", this._onKeyUp);
      C.Window_methods.removeEventListener$2(window, "keypress", this._onKeyPress);
      this._onKeyDown = null;
      this._onKeyUp = null;
      this._onKeyPress = null;
    }, "call$0", "get$stop", 0, 0, 13, "stop"],
    destroy$0: [function() {
      this.stop$0(0);
      this._capture = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      J.clear$0$ax(this._Phaser$_keys);
      this._i = 0;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    addKeyCapture$1: [function(keycode) {
      var t1, t2, key;
      t1 = J.getInterceptor(keycode);
      if (!!t1.$isMap)
        for (t2 = J.get$iterator$ax(t1.get$keys(keycode)); t2.moveNext$0();) {
          key = t2.get$current();
          J.$indexSet$ax(this._capture, t1.$index(keycode, key), true);
        }
      else
        J.$indexSet$ax(this._capture, keycode, true);
    }, "call$1", "get$addKeyCapture", 2, 0, 63, 323, [], "addKeyCapture"],
    removeKeyCapture$1: [function(keycode) {
      J.remove$1$ax(this._capture, keycode);
    }, "call$1", "get$removeKeyCapture", 2, 0, 63, 323, [], "removeKeyCapture"],
    clearCaptures$0: [function() {
      this._capture = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
    }, "call$0", "get$clearCaptures", 0, 0, 13, "clearCaptures"],
    update$0: [function() {
      var t1, t2;
      this._i = J.get$length$asx(this._Phaser$_keys);
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$index$asx(this._Phaser$_keys, this._i) != null)
          J.$index$asx(this._Phaser$_keys, this._i).update$0();
    }, "call$0", "get$update", 0, 0, 13, "update"],
    processKeyDown$1: [function($event) {
      var t1;
      this.event = $event;
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      t1 = J.getInterceptor$x($event);
      if (J.$index$asx(this._capture, t1.get$keyCode($event)) != null)
        t1.preventDefault$0($event);
      if (J.$index$asx(this._Phaser$_keys, t1.get$keyCode($event)) == null)
        J.$indexSet$ax(this._Phaser$_keys, t1.get$keyCode($event), R.Key$(this.game, t1.get$keyCode($event)));
      J.$index$asx(this._Phaser$_keys, t1.get$keyCode($event)).processKeyDown$1($event);
      this._k = t1.get$keyCode($event);
      t1 = this.onDownCallback;
      if (t1 != null)
        t1.call$2(this.callbackContext, $event);
    }, "call$1", "get$processKeyDown", 2, 0, 63, 815, [], "processKeyDown"],
    processKeyPress$1: [function($event) {
      var t1;
      this.pressEvent = $event;
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      t1 = this.onPressCallback;
      if (t1 != null)
        t1.call$3(this.callbackContext, H.Primitives_stringFromCharCode(J.get$charCode$x($event)), $event);
    }, "call$1", "get$processKeyPress", 2, 0, 63, 815, [], "processKeyPress"],
    processKeyUp$1: [function($event) {
      var t1;
      this.event = $event;
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      t1 = J.getInterceptor$x($event);
      if (J.$index$asx(this._capture, t1.get$keyCode($event)) != null)
        t1.preventDefault$0($event);
      if (J.$index$asx(this._Phaser$_keys, t1.get$keyCode($event)) == null)
        J.$indexSet$ax(this._Phaser$_keys, t1.get$keyCode($event), R.Key$(this.game, t1.get$keyCode($event)));
      J.$index$asx(this._Phaser$_keys, t1.get$keyCode($event)).processKeyUp$1($event);
      t1 = this.onUpCallback;
      if (t1 != null)
        t1.call$2(this.callbackContext, $event);
    }, "call$1", "get$processKeyUp", 2, 0, 63, 815, [], "processKeyUp"],
    reset$1: [function(_, hard) {
      var i, t1, i0;
      this.event = null;
      i = J.get$length$asx(this._Phaser$_keys);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        if (J.$index$asx(this._Phaser$_keys, i0) != null)
          J.reset$1$x(J.$index$asx(this._Phaser$_keys, i0), hard);
    }, function($receiver) {
      return this.reset$1($receiver, true);
    }, "reset$0", "call$1", "call$0", "get$reset", 0, 2, 932, 39, 1282, [], "reset"],
    justPressed$2: [function(keycode, duration) {
      if (J.$index$asx(this._Phaser$_keys, keycode) != null)
        return J.$index$asx(this._Phaser$_keys, keycode).justPressed$1(duration);
      else
        return false;
    }, function(keycode) {
      return this.justPressed$2(keycode, 50);
    }, "justPressed$1", "call$2", "call$1", "get$justPressed", 2, 2, 1333, 361, 323, [], 55, [], "justPressed"],
    justReleased$2: [function(keycode, duration) {
      if (J.$index$asx(this._Phaser$_keys, keycode) != null)
        return J.$index$asx(this._Phaser$_keys, keycode).justReleased$1(duration);
      else
        return false;
    }, function(keycode) {
      return this.justReleased$2(keycode, 50);
    }, "justReleased$1", "call$2", "call$1", "get$justReleased", 2, 2, 1334, 361, 323, [], 55, [], "justReleased"],
    isDown$1: [function(keycode) {
      if (J.$index$asx(this._Phaser$_keys, keycode) != null)
        return J.$index$asx(this._Phaser$_keys, keycode).get$isDown();
      return false;
    }, "call$1", "get$isDown", 2, 0, 60, 323, [], "isDown"],
    Keyboard$1: function(game) {
      this.disabled = false;
      this.event = null;
      this.pressEvent = null;
      this.callbackContext = this;
      this.onDownCallback = null;
      this.onPressCallback = null;
      this.onUpCallback = null;
      this._Phaser$_keys = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._capture = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._onKeyDown = null;
      this._onKeyPress = null;
      this._onKeyUp = null;
      this._i = 0;
      this._k = 0;
    },
    static: {"^": "Keyboard_A<-599,Keyboard_B<-599,Keyboard_C<-599,Keyboard_D<-599,Keyboard_E<-599,Keyboard_F<-599,Keyboard_G<-599,Keyboard_H<-599,Keyboard_I<-599,Keyboard_J<-599,Keyboard_K<-599,Keyboard_L<-599,Keyboard_M<-599,Keyboard_N<-599,Keyboard_O<-599,Keyboard_P<-599,Keyboard_Q<-599,Keyboard_R<-599,Keyboard_S<-599,Keyboard_T<-599,Keyboard_U<-599,Keyboard_V<-599,Keyboard_W<-599,Keyboard_X<-599,Keyboard_Y<-599,Keyboard_Z<-599,Keyboard_ZERO<-599,Keyboard_ONE<-599,Keyboard_TWO<-599,Keyboard_THREE<-599,Keyboard_FOUR<-599,Keyboard_FIVE<-599,Keyboard_SIX<-599,Keyboard_SEVEN<-599,Keyboard_EIGHT<-599,Keyboard_NINE<-599,Keyboard_NUMPAD_0<-599,Keyboard_NUMPAD_1<-599,Keyboard_NUMPAD_2<-599,Keyboard_NUMPAD_3<-599,Keyboard_NUMPAD_4<-599,Keyboard_NUMPAD_5<-599,Keyboard_NUMPAD_6<-599,Keyboard_NUMPAD_7<-599,Keyboard_NUMPAD_8<-599,Keyboard_NUMPAD_9<-599,Keyboard_NUMPAD_MULTIPLY<-599,Keyboard_NUMPAD_ADD<-599,Keyboard_NUMPAD_ENTER<-599,Keyboard_NUMPAD_SUBTRACT<-599,Keyboard_NUMPAD_DECIMAL<-599,Keyboard_NUMPAD_DIVIDE<-599,Keyboard_F1<-599,Keyboard_F2<-599,Keyboard_F3<-599,Keyboard_F4<-599,Keyboard_F5<-599,Keyboard_F6<-599,Keyboard_F7<-599,Keyboard_F8<-599,Keyboard_F9<-599,Keyboard_F10<-599,Keyboard_F11<-599,Keyboard_F12<-599,Keyboard_F13<-599,Keyboard_F14<-599,Keyboard_F15<-599,Keyboard_COLON<-599,Keyboard_EQUALS<-599,Keyboard_UNDERSCORE<-599,Keyboard_QUESTION_MARK<-599,Keyboard_TILDE<-599,Keyboard_OPEN_BRACKET<-599,Keyboard_BACKWARD_SLASH<-599,Keyboard_CLOSED_BRACKET<-599,Keyboard_QUOTES<-599,Keyboard_BACKSPACE<-599,Keyboard_TAB<-599,Keyboard_CLEAR<-599,Keyboard_ENTER<-599,Keyboard_SHIFT<-599,Keyboard_CONTROL<-599,Keyboard_ALT<-599,Keyboard_CAPS_LOCK<-599,Keyboard_ESC<-599,Keyboard_SPACEBAR<-599,Keyboard_PAGE_UP<-599,Keyboard_PAGE_DOWN<-599,Keyboard_END<-599,Keyboard_HOME<-599,Keyboard_LEFT<-599,Keyboard_UP<-599,Keyboard_RIGHT<-599,Keyboard_DOWN<-599,Keyboard_INSERT<-599,Keyboard_DELETE<-599,Keyboard_HELP<-599,Keyboard_NUM_LOCK<-599", Keyboard$: [function(game) {
        var t1 = new R.Keyboard(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Keyboard$1(game);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new Keyboard"]}
  },
  "+Keyboard": [632],
  Keyboard_start_closure: {
    "^": "Closure:63;_this_0",
    call$1: [function($event) {
      return this._this_0.processKeyDown$1($event);
    }, "call$1", null, 2, 0, 63, 815, [], "call"],
    $isFunction: true
  },
  Keyboard_start_closure0: {
    "^": "Closure:63;_this_1",
    call$1: [function($event) {
      return this._this_1.processKeyUp$1($event);
    }, "call$1", null, 2, 0, 63, 815, [], "call"],
    $isFunction: true
  },
  Keyboard_start_closure1: {
    "^": "Closure:63;_this_2",
    call$1: [function($event) {
      return this._this_2.processKeyPress$1($event);
    }, "call$1", null, 2, 0, 63, 815, [], "call"],
    $isFunction: true
  },
  Mouse: {
    "^": "Object;game@-598,mouseDownCallback@-0,mouseMoveCallback@-0,mouseUpCallback@-0,mouseOutCallback@-0,mouseOverCallback@-0,mouseWheelCallback@-0,capture@-602,button*-599,wheelDelta@-601,disabled*-602,locked@-602,stopOnGameOut@-602,pointerLock@-1115,event@-1335,_onMouseDown@-0,_onMouseMove@-0,_onMouseUp@-0,_onMouseOut@-0,_onMouseOver@-0,_onMouseWheel@-0,_pointerLockChange@-0",
    mouseDownCallback$1: function(arg0) {
      return this.mouseDownCallback.call$1(arg0);
    },
    mouseMoveCallback$1: function(arg0) {
      return this.mouseMoveCallback.call$1(arg0);
    },
    mouseUpCallback$1: function(arg0) {
      return this.mouseUpCallback.call$1(arg0);
    },
    mouseOutCallback$1: function(arg0) {
      return this.mouseOutCallback.call$1(arg0);
    },
    mouseOverCallback$1: function(arg0) {
      return this.mouseOverCallback.call$1(arg0);
    },
    mouseWheelCallback$1: function(arg0) {
      return this.mouseWheelCallback.call$1(arg0);
    },
    button$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.button.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    button$9: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
      return this.button.call$9(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    },
    button$8: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      return this.button.call$8(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
    },
    start$0: [function(_) {
      if (this.game.get$device().get$android() === true && J.$eq(this.game.get$device().get$chrome(), false))
        return;
      if (this._onMouseDown != null)
        return;
      this._onMouseDown = new R.Mouse_start_closure(this);
      this._onMouseMove = new R.Mouse_start_closure0(this);
      this._onMouseUp = new R.Mouse_start_closure1(this);
      this._onMouseOut = new R.Mouse_start_closure2(this);
      this._onMouseOver = new R.Mouse_start_closure3(this);
      this._onMouseWheel = new R.Mouse_start_closure4(this);
      J.addEventListener$3$x(J.get$canvas$x(this.game), "mousedown", this._onMouseDown, true);
      J.addEventListener$3$x(J.get$canvas$x(this.game), "mousemove", this._onMouseMove, true);
      J.addEventListener$3$x(J.get$canvas$x(this.game), "mouseup", this._onMouseUp, true);
      J.addEventListener$3$x(J.get$canvas$x(this.game), "mousewheel", this._onMouseWheel, true);
      J.addEventListener$3$x(J.get$canvas$x(this.game), "DOMMouseScroll", this._onMouseWheel, true);
      if (this.game.get$device().get$cocoonJS() !== true) {
        J.addEventListener$3$x(J.get$canvas$x(this.game), "mouseover", this._onMouseOver, true);
        J.addEventListener$3$x(J.get$canvas$x(this.game), "mouseout", this._onMouseOut, true);
      }
    }, "call$0", "get$start", 0, 0, 13, "start"],
    onMouseDown$1: [function(_, $event) {
      this.event = $event;
      if (this.capture === true)
        J.preventDefault$0$x($event);
      this.button = J.get$button$x($event);
      if (this.mouseDownCallback != null)
        this.mouseDownCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      J.start$1$x(this.game.get$input().get$mousePointer(), $event);
    }, "call$1", "get$onMouseDown", 2, 0, 63, 815, [], "onMouseDown"],
    onMouseMove$1: [function(_, $event) {
      this.event = $event;
      if (this.capture === true)
        J.preventDefault$0$x($event);
      if (this.mouseMoveCallback != null)
        this.mouseMoveCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      this.game.get$input().get$mousePointer().move$1($event);
    }, "call$1", "get$onMouseMove", 2, 0, 814, 815, [], "onMouseMove"],
    onMouseUp$1: [function(_, $event) {
      this.event = $event;
      if (this.capture === true)
        J.preventDefault$0$x($event);
      this.button = -1;
      if (this.mouseUpCallback != null)
        this.mouseUpCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      J.stop$1$x(this.game.get$input().get$mousePointer(), $event);
    }, "call$1", "get$onMouseUp", 2, 0, 63, 815, [], "onMouseUp"],
    onMouseOut$1: [function(_, $event) {
      this.event = $event;
      if (this.capture === true)
        J.preventDefault$0$x($event);
      if (this.mouseOutCallback != null)
        this.mouseOutCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      this.game.get$input().get$mousePointer().set$withinGame(false);
      if (this.stopOnGameOut != null)
        J.stop$1$x(this.game.get$input().get$mousePointer(), $event);
    }, "call$1", "get$onMouseOut", 2, 0, 63, 815, [], "onMouseOut"],
    onMouseWheel$1: [function(_, $event) {
      var val;
      this.event = $event;
      if (this.capture === true)
        J.preventDefault$0$x($event);
      val = $event.get$wheelDeltaY();
      this.wheelDelta = P.max(-1, P.min(1, val));
      if (this.mouseWheelCallback != null)
        this.mouseWheelCallback$1($event);
    }, "call$1", "get$onMouseWheel", 2, 0, 1336, 815, [], "onMouseWheel"],
    onMouseOver$1: [function(_, $event) {
      this.event = $event;
      if (this.capture === true)
        J.preventDefault$0$x($event);
      if (this.mouseOverCallback != null)
        this.mouseOverCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      this.game.get$input().get$mousePointer().set$withinGame(true);
    }, "call$1", "get$onMouseOver", 2, 0, 63, 815, [], "onMouseOver"],
    requestPointerLock$0: [function(_) {
      var element, t1;
      if (this.game.get$device().get$pointerLock() === true) {
        element = J.get$canvas$x(this.game);
        t1 = J.getInterceptor$x(element);
        t1.set$requestPointerLock(element, t1.get$requestPointerLock(element));
        t1.requestPointerLock$0(element);
        t1 = new R.Mouse_requestPointerLock_closure(this);
        this._pointerLockChange = t1;
        C.HtmlDocument_methods.addEventListener$3(document, "pointerlockchange", t1, true);
        C.HtmlDocument_methods.addEventListener$3(document, "mozpointerlockchange", this._pointerLockChange, true);
        C.HtmlDocument_methods.addEventListener$3(document, "webkitpointerlockchange", this._pointerLockChange, true);
      }
    }, "call$0", "get$requestPointerLock", 0, 0, 13, "requestPointerLock"],
    pointerLockChange$1: [function($event) {
      var element, t1;
      element = J.get$canvas$x(this.game);
      t1 = document.webkitPointerLockElement;
      if (t1 == null ? element == null : t1 === element) {
        this.locked = true;
        this.pointerLock.dispatch$1([true, $event]);
      } else {
        this.locked = false;
        this.pointerLock.dispatch$1([false, $event]);
      }
    }, "call$1", "get$pointerLockChange", 2, 0, 63, 815, [], "pointerLockChange"],
    releasePointerLock$0: [function() {
      document.webkitExitPointerLock();
      C.HtmlDocument_methods.removeEventListener$3(document, "pointerlockchange", this._pointerLockChange, true);
      C.HtmlDocument_methods.removeEventListener$3(document, "mozpointerlockchange", this._pointerLockChange, true);
      C.HtmlDocument_methods.removeEventListener$3(document, "webkitpointerlockchange", this._pointerLockChange, true);
    }, "call$0", "get$releasePointerLock", 0, 0, 13, "releasePointerLock"],
    stop$0: [function(_) {
      J.removeEventListener$3$x(J.get$canvas$x(this.game), "mousedown", this._onMouseDown, true);
      J.removeEventListener$3$x(J.get$canvas$x(this.game), "mousemove", this._onMouseMove, true);
      J.removeEventListener$3$x(J.get$canvas$x(this.game), "mouseup", this._onMouseUp, true);
      J.removeEventListener$3$x(J.get$canvas$x(this.game), "mouseover", this._onMouseOver, true);
      J.removeEventListener$3$x(J.get$canvas$x(this.game), "mouseout", this._onMouseOut, true);
      J.removeEventListener$3$x(J.get$canvas$x(this.game), "mousewheel", this._onMouseWheel, true);
      J.removeEventListener$3$x(J.get$canvas$x(this.game), "DOMMouseScroll", this._onMouseWheel, true);
    }, "call$0", "get$stop", 0, 0, 13, "stop"],
    Mouse$1: function(game) {
      this.mouseDownCallback = null;
      this.mouseMoveCallback = null;
      this.mouseUpCallback = null;
      this.mouseOutCallback = null;
      this.mouseOverCallback = null;
      this.mouseWheelCallback = null;
      this.capture = false;
      this.button = -1;
      this.wheelDelta = 0;
      this.disabled = false;
      this.locked = false;
      this.stopOnGameOut = false;
      this.pointerLock = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.event = null;
      this._onMouseDown = null;
      this._onMouseMove = null;
      this._onMouseUp = null;
      this._onMouseOut = null;
      this._onMouseOver = null;
      this._onMouseWheel = null;
    },
    static: {"^": "Mouse_NO_BUTTON<-599,Mouse_LEFT_BUTTON<-599,Mouse_MIDDLE_BUTTON<-599,Mouse_RIGHT_BUTTON<-599,Mouse_WHEEL_UP<-599,Mouse_WHEEL_DOWN<-599", Mouse$: [function(game) {
        var t1 = new R.Mouse(game, null, null, null, null, null, null, false, -1, 0, false, false, false, null, null, null, null, null, null, null, null, null);
        t1.Mouse$1(game);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new Mouse"]}
  },
  "+Mouse": [632],
  Mouse_start_closure: {
    "^": "Closure:63;_this_0",
    call$1: [function($event) {
      return this._this_0.onMouseDown$1(0, $event);
    }, "call$1", null, 2, 0, 63, 815, [], "call"],
    $isFunction: true
  },
  Mouse_start_closure0: {
    "^": "Closure:63;_this_1",
    call$1: [function($event) {
      return this._this_1.onMouseMove$1(0, $event);
    }, "call$1", null, 2, 0, 63, 815, [], "call"],
    $isFunction: true
  },
  Mouse_start_closure1: {
    "^": "Closure:63;_this_2",
    call$1: [function($event) {
      return this._this_2.onMouseUp$1(0, $event);
    }, "call$1", null, 2, 0, 63, 815, [], "call"],
    $isFunction: true
  },
  Mouse_start_closure2: {
    "^": "Closure:63;_this_3",
    call$1: [function($event) {
      return this._this_3.onMouseOut$1(0, $event);
    }, "call$1", null, 2, 0, 63, 815, [], "call"],
    $isFunction: true
  },
  Mouse_start_closure3: {
    "^": "Closure:63;_this_4",
    call$1: [function($event) {
      return this._this_4.onMouseOver$1(0, $event);
    }, "call$1", null, 2, 0, 63, 815, [], "call"],
    $isFunction: true
  },
  Mouse_start_closure4: {
    "^": "Closure:63;_this_5",
    call$1: [function($event) {
      var t1, val;
      t1 = this._this_5;
      t1.event = $event;
      if (t1.capture === true)
        J.preventDefault$0$x($event);
      val = $event.get$wheelDeltaY();
      t1.wheelDelta = P.max(-1, P.min(1, val));
      if (t1.mouseWheelCallback != null)
        t1.mouseWheelCallback$1($event);
      return;
    }, "call$1", null, 2, 0, 63, 815, [], "call"],
    $isFunction: true
  },
  Mouse_requestPointerLock_closure: {
    "^": "Closure:63;_this_0",
    call$1: [function($event) {
      var t1, element, t2;
      t1 = this._this_0;
      element = J.get$canvas$x(t1.game);
      t2 = document.webkitPointerLockElement;
      if (t2 == null ? element == null : t2 === element) {
        t1.locked = true;
        t1.pointerLock.dispatch$1([true, $event]);
      } else {
        t1.locked = false;
        t1.pointerLock.dispatch$1([false, $event]);
      }
      return;
    }, "call$1", null, 2, 0, 63, 815, [], "call"],
    $isFunction: true
  },
  MSPointer: {
    "^": "Object;",
    static: {MSPointer$: [function() {
        return new R.MSPointer();
      }, null, null, 0, 0, 13, "new MSPointer"]}
  },
  "+MSPointer": [632],
  Pointer: {
    "^": "Object;game@-598,id*-599,type*-599,exists@-602,identifier*-599,pointerId@-599,target*-32,button*-32,_holdSent@-602,_history@-720,_nextDrop@-629,_stateReset@-602,withinGame@-602,clientX@-599,clientY@-599,pageX@-599,pageY@-599,screenX*-599,screenY*-599,rawMovementX@-599,rawMovementY@-599,movementX@-599,movementY@-599,x*-601,y*-601,isMouse@-602,isDown@-602,isUp@-602,isOver@-602,isOut@-602,timeOver@-629,timeOut@-629,timeDown@-629,timeUp@-629,downDuration@-629,isDragged@-602,previousTapTime@-629,totalTouches@-599,msSinceLastClick@-629,targetObject@-1111,_highestRenderOrderID@-599,_highestRenderObject@-1111,_highestInputPriorityID@-599,active@-602,position*-600,positionDown@-600,positionUp@-600,circle@-1271",
    button$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.button.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    button$9: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
      return this.button.call$9(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    },
    button$8: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      return this.button.call$8(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
    },
    isDown$1: function(arg0) {
      return this.isDown.call$1(arg0);
    },
    downDuration$1: function(arg0) {
      return this.downDuration.call$1(arg0);
    },
    downDuration$0: function() {
      return this.downDuration.call$0();
    },
    circle$4: function(arg0, arg1, arg2, arg3) {
      return this.circle.call$4(arg0, arg1, arg2, arg3);
    },
    get$duration: [function(_) {
      if (this.isUp === true)
        return -1;
      return J.$sub$n(this.game.get$time().get$now(), this.timeDown);
    }, null, null, 1, 0, 1337, "duration"],
    get$worldX: [function() {
      return J.$add$ns(J.get$x$x(this.game.get$world().get$camera()), this.x);
    }, null, null, 1, 0, 604, "worldX"],
    get$worldY: [function() {
      return J.$add$ns(J.get$y$x(this.game.get$world().get$camera()), this.y);
    }, null, null, 1, 0, 604, "worldY"],
    start$1: [function(_, $event) {
      var t1 = J.getInterceptor($event);
      if (!!t1.$isJsObject) {
        this.pointerId = t1.$index($event, "pointerId");
        this.identifier = t1.$index($event, "identifier");
        this.target = t1.$index($event, "target");
      } else if (!!t1.$isMouseEvent)
        this.target = W._convertNativeToDart_EventTarget($event.target);
      else {
        this.identifier = t1.get$identifier($event);
        this.target = t1.get$target($event);
      }
      if (!!t1.$isMouseEvent && $event.button != null)
        this.button = t1.get$button($event);
      this._history = [];
      this.active = true;
      this.withinGame = true;
      this.isDown = true;
      this.isUp = false;
      this.msSinceLastClick = J.$sub$n(this.game.get$time().get$now(), this.timeDown);
      this.timeDown = this.game.get$time().get$now();
      this._holdSent = false;
      this.move$2($event, true);
      this.positionDown.setTo$2(this.x, this.y);
      if (!J.$eq(this.game.get$input().get$multiInputOverride(), 0))
        if (!J.$eq(this.game.get$input().get$multiInputOverride(), 2))
          t1 = J.$eq(this.game.get$input().get$multiInputOverride(), 1) && J.$eq(this.game.get$input().get$currentPointers(), 0);
        else
          t1 = true;
      else
        t1 = true;
      if (t1) {
        J.set$x$x(this.game.get$input(), this.x);
        J.set$y$x(this.game.get$input(), this.y);
        J.get$position$x(this.game.get$input()).setTo$2(this.x, this.y);
        this.game.get$input().get$onDown().dispatch$1([this, $event]);
        this.game.get$input().resetSpeed$2(this.x, this.y);
      }
      this._stateReset = false;
      this.totalTouches = J.$add$ns(this.totalTouches, 1);
      if (this.isMouse !== true) {
        t1 = this.game.get$input();
        t1.set$currentPointers(J.$add$ns(t1.get$currentPointers(), 1));
      }
      t1 = this.targetObject;
      if (t1 != null)
        t1._touchedHandler$1(this);
      return this;
    }, "call$1", "get$start", 2, 0, 63, 815, [], "start"],
    update$0: [function() {
      var t1, t2, t3, t4;
      if (this.active === true) {
        if (J.$eq(this._holdSent, false) && J.$ge$n(this.get$duration(this), this.game.get$input().get$holdRate())) {
          if (!J.$eq(this.game.get$input().get$multiInputOverride(), 0))
            if (!J.$eq(this.game.get$input().get$multiInputOverride(), 2))
              t1 = J.$eq(this.game.get$input().get$multiInputOverride(), 1) && J.$eq(this.game.get$input().get$currentPointers(), 0);
            else
              t1 = true;
          else
            t1 = true;
          if (t1)
            this.game.get$input().get$onHold().dispatch$1(this);
          this._holdSent = true;
        }
        if (this.game.get$input().get$recordPointerHistory() === true && J.$ge$n(this.game.get$time().get$now(), this._nextDrop)) {
          this._nextDrop = J.$add$ns(this.game.get$time().get$now(), this.game.get$input().get$recordRate());
          t1 = this._history;
          t2 = J.get$x$x(this.position);
          t3 = this.x;
          t4 = J.get$y$x(this.position);
          J.add$1$ax(t1, P.LinkedHashMap_LinkedHashMap$_literal([t3, t2, this.y, t4], null, null));
          if (J.$gt$n(J.get$length$asx(this._history), this.game.get$input().get$recordLimit()))
            J.removeAt$1$ax(this._history, 0);
        }
      }
    }, "call$0", "get$update", 0, 0, 13, "update"],
    move$2: [function($event, fromClick) {
      var t1, t2, i, i0, t3, currentNode, t4;
      if (this.game.get$input().get$pollLocked())
        return this;
      t1 = J.getInterceptor($event);
      if (!!t1.$isMouseEvent && $event.button != null)
        this.button = t1.get$button($event);
      if (!!t1.$isJsObject) {
        this.clientX = t1.$index($event, "clientX");
        this.clientY = t1.$index($event, "clientY");
        this.pageX = t1.$index($event, "pageX");
        this.pageY = t1.$index($event, "pageY");
        this.screenX = t1.$index($event, "screenX");
        this.screenY = t1.$index($event, "screenY");
      } else {
        t2 = t1.get$client($event);
        this.clientX = t2.get$x(t2);
        t2 = t1.get$client($event);
        this.clientY = t2.get$y(t2);
        this.pageX = J.get$x$x(t1.get$page($event));
        this.pageY = J.get$y$x(t1.get$page($event));
        this.screenX = J.get$x$x(t1.get$screen($event));
        this.screenY = J.get$y$x(t1.get$screen($event));
      }
      if (this.isMouse === true && this.game.get$input().get$mouse().get$locked() === true && fromClick !== true) {
        this.rawMovementX = t1.get$movement($event).x;
        this.rawMovementY = t1.get$movement($event).y;
        this.movementX = J.$add$ns(this.movementX, this.rawMovementX);
        this.movementY = J.$add$ns(this.movementY, this.rawMovementY);
      }
      this.x = J.$mul$ns(J.$sub$n(this.pageX, J.get$x$x(J.get$offset$x(this.game.get$stage()))), J.get$x$x(J.get$scale$x(this.game.get$input())));
      t1 = J.$mul$ns(J.$sub$n(this.pageY, J.get$y$x(J.get$offset$x(this.game.get$stage()))), J.get$y$x(J.get$scale$x(this.game.get$input())));
      this.y = t1;
      this.position.setTo$2(this.x, t1);
      J.set$x$x(this.circle, this.x);
      J.set$y$x(this.circle, this.y);
      if (!J.$eq(this.game.get$input().get$multiInputOverride(), 0))
        if (!J.$eq(this.game.get$input().get$multiInputOverride(), 2))
          t1 = J.$eq(this.game.get$input().get$multiInputOverride(), 1) && J.$eq(this.game.get$input().get$currentPointers(), 0);
        else
          t1 = true;
      else
        t1 = true;
      if (t1) {
        this.game.get$input().set$activePointer(this);
        J.set$x$x(this.game.get$input(), this.x);
        J.set$y$x(this.game.get$input(), this.y);
        J.get$position$x(this.game.get$input()).setTo$2(J.get$x$x(this.game.get$input()), J.get$y$x(this.game.get$input()));
        J.set$x$x(this.game.get$input().get$circle(), J.get$x$x(this.game.get$input()));
        J.set$y$x(this.game.get$input().get$circle(), J.get$y$x(this.game.get$input()));
      }
      this.withinGame = J.contains$2$asx(J.get$scale$x(this.game).get$bounds(), this.pageX, this.pageY);
      if (J.get$paused$x(this.game) === true)
        return this;
      if (this.game.get$input().get$moveCallback() != null)
        this.game.get$input().moveCallback$3(this, this.x, this.y);
      i = J.get$length$asx(this.game.get$input().get$moveCallbacks());
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this.game.get$input().get$moveCallbacks(), i0).callback$3(this, this.x, this.y);
      t1 = this.targetObject;
      if (t1 != null && J.$eq(t1.get$isDragged(), true)) {
        if (J.$eq(this.targetObject.update$1(this), false))
          this.targetObject = null;
        return this;
      }
      this._highestRenderOrderID = 9999999999;
      this._highestRenderObject = null;
      this._highestInputPriorityID = -1;
      if (J.$gt$n(J.get$length$asx(this.game.get$input().get$interactiveItems()), 0))
        for (t1 = J.get$iterator$ax(this.game.get$input().get$interactiveItems()), t2 = fromClick === true, t3 = !t2; t1.moveNext$0();) {
          currentNode = t1.get$current();
          if (currentNode != null && currentNode.validForInput$2(this._highestInputPriorityID, this._highestRenderOrderID)) {
            if (!(t3 && currentNode.checkPointerOver$1(this)))
              t4 = t2 && currentNode.checkPointerDown$1(this);
            else
              t4 = true;
            if (t4) {
              this._highestRenderOrderID = J.$index$asx(currentNode.get$sprite().get$_cache(), 3);
              this._highestInputPriorityID = currentNode.get$priorityID();
              this._highestRenderObject = currentNode;
            }
          }
        }
      t1 = this._highestRenderObject;
      if (t1 == null) {
        t1 = this.targetObject;
        if (t1 != null) {
          t1._pointerOutHandler$1(this);
          this.targetObject = null;
        }
      } else {
        t2 = this.targetObject;
        if (t2 == null) {
          this.targetObject = t1;
          t1._pointerOverHandler$1(this);
        } else if (J.$eq(t2, t1)) {
          if (J.$eq(this._highestRenderObject.update$1(this), false))
            this.targetObject = null;
        } else {
          this.targetObject._pointerOutHandler$1(this);
          t1 = this._highestRenderObject;
          this.targetObject = t1;
          t1._pointerOverHandler$1(this);
        }
      }
      return this;
    }, function(event) {
      return this.move$2(event, false);
    }, "move$1", "call$2", "call$1", "get$move", 2, 2, 1338, 95, 815, [], 1339, [], "move"],
    leave$1: [function($event) {
      this.withinGame = false;
      this.move$2($event, false);
    }, "call$1", "get$leave", 2, 0, 63, 815, [], "leave"],
    stop$1: [function(_, $event) {
      var t1, t2, i, i0;
      if (this._stateReset === true) {
        J.preventDefault$0$x($event);
        return this;
      }
      this.timeUp = this.game.get$time().get$now();
      if (!J.$eq(this.game.get$input().get$multiInputOverride(), 0))
        if (!J.$eq(this.game.get$input().get$multiInputOverride(), 2))
          t1 = J.$eq(this.game.get$input().get$multiInputOverride(), 1) && J.$eq(this.game.get$input().get$currentPointers(), 0);
        else
          t1 = true;
      else
        t1 = true;
      if (t1) {
        this.game.get$input().get$onUp().dispatch$1([this, $event]);
        if (J.$ge$n(this.get$duration(this), 0) && J.$le$n(this.get$duration(this), this.game.get$input().get$tapRate())) {
          t1 = J.$lt$n(J.$sub$n(this.timeUp, this.previousTapTime), this.game.get$input().get$doubleTapRate());
          t2 = this.game;
          if (t1)
            t2.get$input().get$onTap().dispatch$1([this, true]);
          else
            t2.get$input().get$onTap().dispatch$1([this, false]);
          this.previousTapTime = this.timeUp;
        }
      }
      if (J.$gt$n(this.id, 0))
        this.active = false;
      this.withinGame = false;
      this.isDown = false;
      this.isUp = true;
      this.pointerId = null;
      this.identifier = null;
      this.positionUp.setTo$2(this.x, this.y);
      if (J.$eq(this.isMouse, false)) {
        t1 = this.game.get$input();
        t1.set$currentPointers(J.$sub$n(t1.get$currentPointers(), 1));
      }
      i = J.get$length$asx(this.game.get$input().get$interactiveItems());
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this.game.get$input().get$interactiveItems(), i0)._releasedHandler$1(this);
      this.targetObject = null;
      return this;
    }, "call$1", "get$stop", 2, 0, 1284, 815, [], "stop"],
    justPressed$1: [function(duration) {
      if (duration == null)
        duration = this.game.get$input().get$justPressedRate();
      return J.$eq(this.isDown, true) && J.$gt$n(J.$add$ns(this.timeDown, duration), this.game.get$time().get$now());
    }, function() {
      return this.justPressed$1(null);
    }, "justPressed$0", "call$1", "call$0", "get$justPressed", 0, 2, 1300, 32, 55, [], "justPressed"],
    justReleased$1: [function(duration) {
      if (duration == null)
        duration = this.game.get$input().get$justPressedRate();
      return J.$eq(this.isUp, true) && J.$gt$n(J.$add$ns(this.timeUp, duration), this.game.get$time().get$now());
    }, function() {
      return this.justReleased$1(null);
    }, "justReleased$0", "call$1", "call$0", "get$justReleased", 0, 2, 1300, 32, 55, [], "justReleased"],
    reset$0: [function(_) {
      var t1;
      if (J.$eq(this.isMouse, false))
        this.active = false;
      this.pointerId = null;
      this.identifier = null;
      this.isDown = false;
      this.isUp = true;
      this.totalTouches = 0;
      this._holdSent = false;
      J.set$length$asx(this._history, 0);
      this._stateReset = true;
      t1 = this.targetObject;
      if (t1 != null)
        t1._releasedHandler$1(this);
      this.targetObject = null;
    }, "call$0", "get$reset", 0, 0, 13, "reset"],
    resetMovement$0: [function() {
      this.movementX = 0;
      this.movementY = 0;
    }, "call$0", "get$resetMovement", 0, 0, 13, "resetMovement"],
    Pointer$2: function(game, id) {
      var t1;
      this.game = this.game;
      this.id = this.id;
      this.type = 19;
      this.exists = true;
      this.identifier = 0;
      this.pointerId = null;
      this.target = null;
      this.button = null;
      this._holdSent = false;
      this._history = [];
      this._nextDrop = 0;
      this._stateReset = false;
      this.withinGame = false;
      this.clientX = -1;
      this.clientY = -1;
      this.pageX = -1;
      this.pageY = -1;
      this.screenX = -1;
      this.screenY = -1;
      this.rawMovementX = 0;
      this.rawMovementY = 0;
      this.movementX = 0;
      this.movementY = 0;
      this.x = -1;
      this.y = -1;
      this.isMouse = false;
      this.isDown = false;
      this.isUp = true;
      this.timeDown = 0;
      this.timeUp = 0;
      this.previousTapTime = 0;
      this.totalTouches = 0;
      this.msSinceLastClick = 999999999;
      this.targetObject = null;
      this.active = false;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.position = t1;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.positionDown = t1;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.positionUp = t1;
      this.circle = R.Circle$(0, 0, 44);
      if (J.$eq(this.id, 0))
        this.isMouse = true;
    },
    $isPointer: true,
    static: {Pointer$: [function(game, id) {
        var t1 = new R.Pointer(game, id, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 999999999, null, null, null, null, null, null, null, null, null);
        t1.Pointer$2(game, id);
        return t1;
      }, null, null, 4, 0, 322, 214, [], 183, [], "new Pointer"]}
  },
  "+Pointer": [632],
  SinglePad: {
    "^": "Object;",
    static: {SinglePad$: [function() {
        return new R.SinglePad();
      }, null, null, 0, 0, 13, "new SinglePad"]}
  },
  "+SinglePad": [632],
  Touch: {
    "^": "Object;game@-598,disabled*-602,touchStartCallback@-0,touchMoveCallback@-0,touchEndCallback@-0,touchEnterCallback@-0,touchLeaveCallback@-0,touchCancelCallback@-0,preventDefault*-602,event@-1340,onTouchStartListener@-1341,onTouchMoveListener@-1341,onTouchEndListener@-1341,onTouchCancelListener@-1341,onTouchEnterListener@-1341,onTouchLeaveListener@-1341",
    touchStartCallback$1: function(arg0) {
      return this.touchStartCallback.call$1(arg0);
    },
    touchMoveCallback$1: function(arg0) {
      return this.touchMoveCallback.call$1(arg0);
    },
    touchEndCallback$1: function(arg0) {
      return this.touchEndCallback.call$1(arg0);
    },
    touchEnterCallback$1: function(arg0) {
      return this.touchEnterCallback.call$1(arg0);
    },
    touchLeaveCallback$1: function(arg0) {
      return this.touchLeaveCallback.call$1(arg0);
    },
    touchCancelCallback$1: function(arg0) {
      return this.touchCancelCallback.call$1(arg0);
    },
    preventDefault$0: function($receiver) {
      return this.preventDefault.call$0();
    },
    start$0: [function(_) {
      var t1;
      if (this.game.get$device().get$touch() === true) {
        P.print("touch enabled!");
        t1 = C.EventStreamProvider_touchstart.forTarget$1(document);
        t1 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$onTouchStart(this)), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
        t1._tryResume$0();
        this.onTouchStartListener = t1;
        t1 = C.EventStreamProvider_touchmove.forTarget$1(document);
        t1 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$onTouchMove(this)), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
        t1._tryResume$0();
        this.onTouchMoveListener = t1;
        t1 = C.EventStreamProvider_touchend.forTarget$1(document);
        t1 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$onTouchEnd(this)), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
        t1._tryResume$0();
        this.onTouchEndListener = t1;
        t1 = C.EventStreamProvider_touchcancel.forTarget$1(document);
        t1 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._target, t1._eventType, W._wrapZone(this.get$onTouchCancel(this)), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
        t1._tryResume$0();
        this.onTouchCancelListener = t1;
        if (this.game.get$device().get$cocoonJS() !== true) {
          this.onTouchEnterListener = J.get$onTouchEnter$x(J.get$canvas$x(this.game)).listen$1(this.get$onTouchEnter(this));
          this.onTouchLeaveListener = J.get$onTouchLeave$x(J.get$canvas$x(this.game)).listen$1(this.get$onTouchLeave(this));
        }
      }
    }, "call$0", "get$start", 0, 0, 13, "start"],
    consumeDocumentTouches$0: [function() {
    }, "call$0", "get$consumeDocumentTouches", 0, 0, 13, "consumeDocumentTouches"],
    onTouchStart$1: [function(_, $event) {
      var t1, changedTouches, i, touchEvent;
      this.event = $event;
      if (this.touchStartCallback != null)
        this.touchStartCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      if (this.preventDefault === true)
        J.preventDefault$0$x($event);
      if (this.game.get$device().get$cocoonJS() === true) {
        t1 = [];
        C.JSArray_methods.addAll$1(t1, J.map$1$ax(J.$index$asx(P.JsObject_JsObject$fromBrowserObject($event), "changedTouches"), P._convertToJS$closure()));
        changedTouches = H.setRuntimeTypeInfo(new P.JsArray(t1), [null]);
        for (i = 0; i < changedTouches.get$length(changedTouches); ++i) {
          if (i === C.JSInt_methods.toInt$0(i))
            if (i >= changedTouches.get$length(changedTouches))
              H.throwExpression(P.RangeError$range(i, 0, changedTouches.get$length(changedTouches)));
          touchEvent = P.JsObject_JsObject$fromBrowserObject(P.JsObject.prototype.$index.call(changedTouches, changedTouches, i));
          this.game.get$input().startPointer$1(touchEvent);
        }
      } else {
        changedTouches = J.get$changedTouches$x($event);
        for (i = 0; i < changedTouches.length; ++i) {
          t1 = this.game.get$input();
          if (i >= changedTouches.length)
            return H.ioore(changedTouches, i);
          t1.startPointer$1(changedTouches[i]);
        }
      }
    }, "call$1", "get$onTouchStart", 2, 0, 1342, 815, [], "onTouchStart"],
    onTouchCancel$1: [function(_, $event) {
      var t1, changedTouches, i, touchEvent;
      this.event = $event;
      if (this.touchCancelCallback != null)
        this.touchCancelCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      if (this.preventDefault === true)
        J.preventDefault$0$x($event);
      if (this.game.get$device().get$cocoonJS() === true) {
        t1 = [];
        C.JSArray_methods.addAll$1(t1, J.map$1$ax(J.$index$asx(P.JsObject_JsObject$fromBrowserObject($event), "changedTouches"), P._convertToJS$closure()));
        changedTouches = H.setRuntimeTypeInfo(new P.JsArray(t1), [null]);
        for (i = 0; i < changedTouches.get$length(changedTouches); ++i) {
          if (i === C.JSInt_methods.toInt$0(i))
            if (i >= changedTouches.get$length(changedTouches))
              H.throwExpression(P.RangeError$range(i, 0, changedTouches.get$length(changedTouches)));
          touchEvent = P.JsObject_JsObject$fromBrowserObject(P.JsObject.prototype.$index.call(changedTouches, changedTouches, i));
          this.game.get$input().stopPointer$1(touchEvent);
        }
      } else {
        changedTouches = J.get$changedTouches$x($event);
        for (i = 0; i < changedTouches.length; ++i) {
          t1 = this.game.get$input();
          if (i >= changedTouches.length)
            return H.ioore(changedTouches, i);
          t1.stopPointer$1(changedTouches[i]);
        }
      }
    }, "call$1", "get$onTouchCancel", 2, 0, 1342, 815, [], "onTouchCancel"],
    onTouchEnter$1: [function(_, $event) {
      this.event = $event;
      if (this.touchEnterCallback != null)
        this.touchEnterCallback$1($event);
      if (J.get$disabled$x(this.game.get$input()) === true || this.disabled === true)
        return;
      if (this.preventDefault === true)
        J.preventDefault$0$x($event);
    }, "call$1", "get$onTouchEnter", 2, 0, 1342, 815, [], "onTouchEnter"],
    onTouchLeave$1: [function(_, $event) {
      this.event = $event;
      if (this.touchLeaveCallback != null)
        this.touchLeaveCallback$1($event);
      if (this.preventDefault === true)
        J.preventDefault$0$x($event);
    }, "call$1", "get$onTouchLeave", 2, 0, 1342, 815, [], "onTouchLeave"],
    onTouchMove$1: [function(_, $event) {
      var t1, changedTouches, i, touchEvent;
      this.event = $event;
      if (this.touchMoveCallback != null)
        this.touchMoveCallback$1($event);
      if (this.preventDefault === true)
        J.preventDefault$0$x($event);
      if (this.game.get$device().get$cocoonJS() === true) {
        t1 = [];
        C.JSArray_methods.addAll$1(t1, J.map$1$ax(J.$index$asx(P.JsObject_JsObject$fromBrowserObject($event), "changedTouches"), P._convertToJS$closure()));
        changedTouches = H.setRuntimeTypeInfo(new P.JsArray(t1), [null]);
        for (i = 0; i < changedTouches.get$length(changedTouches); ++i) {
          if (i === C.JSInt_methods.toInt$0(i))
            if (i >= changedTouches.get$length(changedTouches))
              H.throwExpression(P.RangeError$range(i, 0, changedTouches.get$length(changedTouches)));
          touchEvent = P.JsObject_JsObject$fromBrowserObject(P.JsObject.prototype.$index.call(changedTouches, changedTouches, i));
          this.game.get$input().updatePointer$1(touchEvent);
        }
      } else {
        changedTouches = J.get$changedTouches$x($event);
        for (i = 0; i < changedTouches.length; ++i) {
          t1 = this.game.get$input();
          if (i >= changedTouches.length)
            return H.ioore(changedTouches, i);
          t1.updatePointer$1(changedTouches[i]);
        }
      }
    }, "call$1", "get$onTouchMove", 2, 0, 1342, 815, [], "onTouchMove"],
    onTouchEnd$1: [function(_, $event) {
      var t1, changedTouches, i, touchEvent;
      this.event = $event;
      if (this.touchEndCallback != null)
        this.touchEndCallback$1($event);
      if (this.preventDefault === true)
        J.preventDefault$0$x($event);
      if (this.game.get$device().get$cocoonJS() === true) {
        t1 = [];
        C.JSArray_methods.addAll$1(t1, J.map$1$ax(J.$index$asx(P.JsObject_JsObject$fromBrowserObject($event), "changedTouches"), P._convertToJS$closure()));
        changedTouches = H.setRuntimeTypeInfo(new P.JsArray(t1), [null]);
        for (i = 0; i < changedTouches.get$length(changedTouches); ++i) {
          if (i === C.JSInt_methods.toInt$0(i))
            if (i >= changedTouches.get$length(changedTouches))
              H.throwExpression(P.RangeError$range(i, 0, changedTouches.get$length(changedTouches)));
          touchEvent = P.JsObject_JsObject$fromBrowserObject(P.JsObject.prototype.$index.call(changedTouches, changedTouches, i));
          this.game.get$input().stopPointer$1(touchEvent);
        }
      } else {
        changedTouches = J.get$changedTouches$x($event);
        for (i = 0; i < changedTouches.length; ++i) {
          t1 = this.game.get$input();
          if (i >= changedTouches.length)
            return H.ioore(changedTouches, i);
          t1.stopPointer$1(changedTouches[i]);
        }
      }
    }, "call$1", "get$onTouchEnd", 2, 0, 1342, 815, [], "onTouchEnd"],
    stop$0: [function(_) {
      if (this.game.get$device().get$touch() === true) {
        this.onTouchStartListener.cancel$0();
        this.onTouchMoveListener.cancel$0();
        this.onTouchEndListener.cancel$0();
        this.onTouchCancelListener.cancel$0();
        if (this.game.get$device().get$cocoonJS() !== true) {
          this.onTouchEnterListener.cancel$0();
          this.onTouchLeaveListener.cancel$0();
        }
      }
    }, "call$0", "get$stop", 0, 0, 13, "stop"],
    Touch$1: function(game) {
      this.disabled = false;
      this.touchStartCallback = null;
      this.touchMoveCallback = null;
      this.touchEndCallback = null;
      this.touchEnterCallback = null;
      this.touchLeaveCallback = null;
      this.touchCancelCallback = null;
      this.preventDefault = true;
      this.event = null;
    },
    static: {Touch$: [function(game) {
        var t1 = new R.Touch(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Touch$1(game);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new Touch"]}
  },
  "+Touch": [632],
  Cache: {
    "^": "Object;game@-598,_canvases@-754,_images@-754,_textures@-754,_sounds@-754,_text@-754,_json@-754,_physics@-754,_tilemaps@-754,_binary@-754,_bitmapDatas@-754,_bitmapFont@-754,onSoundUnlock@-1343,_cacheMap@-720",
    addCanvas$3: [function(key, canvas, context) {
      J.$indexSet$ax(this._canvases, key, P.LinkedHashMap_LinkedHashMap$_literal(["canvas", canvas, "context", context], null, null));
    }, "call$3", "get$addCanvas", 6, 0, 1344, 231, [], 116, [], 104, [], "addCanvas"],
    addBinary$2: [function(key, binaryData) {
      J.$indexSet$ax(this._binary, key, binaryData);
    }, "call$2", "get$addBinary", 4, 0, 80, 231, [], 1345, [], "addBinary"],
    addBitmapData$2: [function(key, bitmapData) {
      J.$indexSet$ax(this._bitmapDatas, key, bitmapData);
      return bitmapData;
    }, "call$2", "get$addBitmapData", 4, 0, 1346, 231, [], 1347, [], "addBitmapData"],
    addRenderTexture$2: [function(key, texture) {
      var t1, frame;
      t1 = J.getInterceptor$x(texture);
      frame = R.Frame$(0, 0, 0, t1.get$width(texture), t1.get$height(texture), "", "");
      J.$indexSet$ax(this._textures, key, P.LinkedHashMap_LinkedHashMap$_literal(["texture", texture, "frame", frame], null, null));
    }, "call$2", "get$addRenderTexture", 4, 0, 1348, 231, [], 28, [], "addRenderTexture"],
    addSpriteSheet$8: [function(key, url, data, frameWidth, frameHeight, frameMax, margin, spacing) {
      J.$indexSet$ax(this._images, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data, "spriteSheet", true, "frameWidth", frameWidth, "frameHeight", frameHeight, "margin", margin, "spacing", spacing], null, null));
      J.$indexSet$ax($.get$BaseTextureCache(), key, M.BaseTexture$(data, C.scaleModes_0));
      J.$indexSet$ax(J.$index$asx(this._images, key), "frameData", R.AnimationParser_spriteSheet(this.game, key, frameWidth, frameHeight, frameMax, margin, spacing));
    }, function(key, url, data, frameWidth, frameHeight, frameMax) {
      return this.addSpriteSheet$8(key, url, data, frameWidth, frameHeight, frameMax, 0, 0);
    }, "addSpriteSheet$6", function(key, url, data, frameWidth, frameHeight) {
      return this.addSpriteSheet$8(key, url, data, frameWidth, frameHeight, -1, 0, 0);
    }, "addSpriteSheet$5", function(key, url, data, frameWidth, frameHeight, frameMax, margin) {
      return this.addSpriteSheet$8(key, url, data, frameWidth, frameHeight, frameMax, margin, 0);
    }, "addSpriteSheet$7", "call$8", "call$6", "call$5", "call$7", "get$addSpriteSheet", 10, 6, 1349, 230, 5, 5, 231, [], 88, [], 48, [], 232, [], 233, [], 234, [], 235, [], 236, [], "addSpriteSheet"],
    addTilemap$4: [function(key, url, mapData, format) {
      J.$indexSet$ax(this._tilemaps, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", mapData, "format", format], null, null));
    }, "call$4", "get$addTilemap", 8, 0, 1350, 231, [], 88, [], 1351, [], 1352, [], "addTilemap"],
    addTextureAtlas$5: [function(key, url, data, atlasData, format) {
      var t1;
      J.$indexSet$ax(this._images, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data, "spriteSheet", true], null, null));
      J.$indexSet$ax($.get$BaseTextureCache(), key, M.BaseTexture$(data, C.scaleModes_0));
      t1 = J.getInterceptor(format);
      if (t1.$eq(format, 0))
        J.$indexSet$ax(J.$index$asx(this._images, key), "frameData", R.AnimationParser_JSONData(this.game, atlasData, key));
      else if (t1.$eq(format, 1))
        J.$indexSet$ax(J.$index$asx(this._images, key), "frameData", R.AnimationParser_JSONDataHash(this.game, atlasData, key));
      else if (t1.$eq(format, 2))
        J.$indexSet$ax(J.$index$asx(this._images, key), "frameData", R.AnimationParser_XMLData(this.game, atlasData, key));
    }, "call$5", "get$addTextureAtlas", 10, 0, 1353, 231, [], 88, [], 48, [], 1354, [], 1352, [], "addTextureAtlas"],
    addBitmapFont$6: [function(key, url, data, xmlData, xSpacing, ySpacing) {
      J.$indexSet$ax(this._images, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data, "spriteSheet", true], null, null));
      J.$indexSet$ax($.get$BaseTextureCache(), key, M.BaseTexture$(data, C.scaleModes_0));
      R.LoaderParser_bitmapFont(this.game, xmlData, key, xSpacing, ySpacing);
    }, function(key, url, data, xmlData) {
      return this.addBitmapFont$6(key, url, data, xmlData, 0, 0);
    }, "addBitmapFont$4", function(key, url, data, xmlData, xSpacing) {
      return this.addBitmapFont$6(key, url, data, xmlData, xSpacing, 0);
    }, "addBitmapFont$5", "call$6", "call$4", "call$5", "get$addBitmapFont", 8, 4, 1355, 5, 5, 231, [], 88, [], 48, [], 1356, [], 291, [], 292, [], "addBitmapFont"],
    addPhysicsData$4: [function(key, url, JSONData, format) {
      J.$indexSet$ax(this._physics, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", JSONData, "format", format], null, null));
    }, "call$4", "get$addPhysicsData", 8, 0, 1350, 231, [], 88, [], 1357, [], 1352, [], "addPhysicsData"],
    addDefaultImage$0: [function() {
      var img = W.ImageElement_ImageElement(null, null, null);
      J.set$src$x(img, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==");
      J.$indexSet$ax(this._images, "__default", P.LinkedHashMap_LinkedHashMap$_literal(["url", null, "data", img, "spriteSheet", false], null, null));
      J.$indexSet$ax(J.$index$asx(this._images, "__default"), "frame", R.Frame$(0, 0, 0, 32, 32, "", ""));
      J.$indexSet$ax($.get$BaseTextureCache(), "__default", M.BaseTexture$(img, C.scaleModes_0));
      J.$indexSet$ax($.get$TextureCache(), "__default", M.Texture$(J.$index$asx($.get$BaseTextureCache(), "__default"), null));
    }, "call$0", "get$addDefaultImage", 0, 0, 13, "addDefaultImage"],
    addMissingImage$0: [function() {
      var img = W.ImageElement_ImageElement(null, null, null);
      J.set$src$x(img, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==");
      J.$indexSet$ax(this._images, "__missing", P.LinkedHashMap_LinkedHashMap$_literal(["url", null, "data", img, "spriteSheet", false], null, null));
      J.$indexSet$ax(J.$index$asx(this._images, "__missing"), "frame", R.Frame$(0, 0, 0, 32, 32, "", ""));
      J.$indexSet$ax($.get$BaseTextureCache(), "__missing", M.BaseTexture$(img, C.scaleModes_0));
      J.$indexSet$ax($.get$TextureCache(), "__missing", M.Texture$(J.$index$asx($.get$BaseTextureCache(), "__missing"), null));
    }, "call$0", "get$addMissingImage", 0, 0, 13, "addMissingImage"],
    addText$3: [function(key, url, data) {
      J.$indexSet$ax(this._text, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data], null, null));
    }, "call$3", "get$addText", 6, 0, 1358, 231, [], 88, [], 48, [], "addText"],
    addJSON$3: [function(key, url, data) {
      J.$indexSet$ax(this._json, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data], null, null));
    }, "call$3", "get$addJSON", 6, 0, 1358, 231, [], 88, [], 48, [], "addJSON"],
    addImage$3: [function(key, url, data) {
      var t1;
      J.$indexSet$ax(this._images, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data, "spriteSheet", false], null, null));
      t1 = J.getInterceptor$x(data);
      J.$indexSet$ax(J.$index$asx(this._images, key), "frame", R.Frame$(0, 0, 0, t1.get$width(data), t1.get$height(data), key, this.game.get$rnd().uuid$0()));
      J.$indexSet$ax($.get$BaseTextureCache(), key, M.BaseTexture$(data, C.scaleModes_0));
      J.$indexSet$ax($.get$TextureCache(), key, M.Texture$(J.$index$asx($.get$BaseTextureCache(), key), null));
    }, "call$3", "get$addImage", 6, 0, 1358, 231, [], 88, [], 48, [], "addImage"],
    addSound$5: [function(key, url, data, webAudio, audioTag) {
      var decoded = audioTag === true && true;
      J.$indexSet$ax(this._sounds, key, P.LinkedHashMap_LinkedHashMap$_literal(["url", url, "data", data, "isDecoding", false, "decoded", decoded, "webAudio", webAudio, "audioTag", audioTag, "locked", this.game.get$sound().get$touchLocked()], null, null));
    }, function(key, url, data) {
      return this.addSound$5(key, url, data, true, false);
    }, "addSound$3", function(key, url, data, webAudio) {
      return this.addSound$5(key, url, data, webAudio, false);
    }, "addSound$4", "call$5", "call$3", "call$4", "get$addSound", 6, 4, 1359, 39, 95, 231, [], 88, [], 48, [], 1360, [], 1361, [], "addSound"],
    reloadSound$1: [function(key) {
      if (J.$index$asx(this._sounds, key) != null) {
        J.set$src$x(J.$index$asx(J.$index$asx(this._sounds, key), "data"), J.get$url$x(J.$index$asx(this._sounds, key)));
        J.addEventListener$3$x(J.$index$asx(J.$index$asx(this._sounds, key), "data"), "canplaythrough", new R.Cache_reloadSound_closure(this, key), false);
        J.load$0$x(J.$index$asx(J.$index$asx(this._sounds, key), "data"));
      }
    }, "call$1", "get$reloadSound", 2, 0, 52, 231, [], "reloadSound"],
    reloadSoundComplete$1: [function(key) {
      if (J.$index$asx(this._sounds, key) != null) {
        J.$indexSet$ax(J.$index$asx(this._sounds, key), "locked", false);
        this.onSoundUnlock.dispatch$1(key);
      }
    }, "call$1", "get$reloadSoundComplete", 2, 0, 52, 231, [], "reloadSoundComplete"],
    updateSound$3: [function(key, property, value) {
      if (J.$index$asx(this._sounds, key) != null)
        J.$indexSet$ax(J.$index$asx(this._sounds, key), property, value);
    }, "call$3", "get$updateSound", 6, 0, 1358, 231, [], 1362, [], 100, [], "updateSound"],
    decodedSound$2: [function(key, data) {
      J.$indexSet$ax(J.$index$asx(this._sounds, key), "data", data);
      J.$indexSet$ax(J.$index$asx(this._sounds, key), "decoded", true);
      J.$indexSet$ax(J.$index$asx(this._sounds, key), "isDecoding", false);
    }, "call$2", "get$decodedSound", 4, 0, 80, 231, [], 48, [], "decodedSound"],
    getCanvas$1: [function(key) {
      var t1;
      if (J.$index$asx(this._canvases, key) != null)
        return J.$index$asx(J.$index$asx(this._canvases, key), "canvas");
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getCanvas: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
      }
    }, "call$1", "get$getCanvas", 2, 0, 52, 231, [], "getCanvas"],
    getBitmapData$1: [function(key) {
      var t1;
      if (J.$index$asx(this._bitmapDatas, key) != null)
        return J.$index$asx(this._bitmapDatas, key);
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getBitmapData: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
      }
    }, "call$1", "get$getBitmapData", 2, 0, 52, 231, [], "getBitmapData"],
    getBitmapFont$1: [function(key) {
      var t1;
      if (J.$index$asx(this._bitmapFont, key) != null)
        return J.$index$asx(this._bitmapFont, key);
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getBitmapFont: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getBitmapFont", 2, 0, 1363, 231, [], "getBitmapFont"],
    getPhysicsData$3: [function(key, object, fixtureKey) {
      var t1, fixtures, t2, fixture;
      if (object == null)
        if (J.$index$asx(this._physics, key) === true)
          return J.get$data$x(J.$index$asx(this._physics, key));
        else {
          window;
          t1 = C.JSString_methods.$add("Phaser.Cache.getPhysicsData: Invalid key: \"", key) + "\"";
          if (typeof console != "undefined")
            console.warn(t1);
        }
      else if (J.$index$asx(this._physics, key) === true && J.$index$asx(J.$index$asx(J.$index$asx(this._physics, key), "data"), object) === true) {
        fixtures = J.$index$asx(J.$index$asx(J.$index$asx(this._physics, key), "data"), object);
        if (fixtures != null && fixtureKey != null) {
          for (t1 = J.getInterceptor$x(fixtures), t2 = J.get$iterator$ax(t1.get$keys(fixtures)); t2.moveNext$0();) {
            fixture = t1.$index(fixtures, t2.get$current());
            fixture.get$fixtureKey();
          }
          window;
          t1 = C.JSString_methods.$add(C.JSString_methods.$add("Phaser.Cache.getPhysicsData: Could not find given fixtureKey: \"", fixtureKey) + " in ", key) + "\"";
          if (typeof console != "undefined")
            console.warn(t1);
        } else
          return fixtures;
      } else {
        window;
        t1 = C.JSString_methods.$add(C.JSString_methods.$add("Phaser.Cache.getPhysicsData: Invalid key/object: \"", key) + " / ", object) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
      }
      return;
    }, "call$3", "get$getPhysicsData", 6, 0, 1364, 231, [], 541, [], 1365, [], "getPhysicsData"],
    checkKey$2: [function(type, key) {
      if (J.$index$asx(J.$index$asx(this._cacheMap, type), key) != null)
        return true;
      return false;
    }, "call$2", "get$checkKey", 4, 0, 1366, 99, [], 231, [], "checkKey"],
    checkCanvasKey$1: [function(key) {
      return this.checkKey$2(1, key);
    }, "call$1", "get$checkCanvasKey", 2, 0, 1367, 231, [], "checkCanvasKey"],
    checkImageKey$1: [function(key) {
      return this.checkKey$2(2, key);
    }, "call$1", "get$checkImageKey", 2, 0, 1367, 231, [], "checkImageKey"],
    checkTextureKey$1: [function(key) {
      return this.checkKey$2(3, key);
    }, "call$1", "get$checkTextureKey", 2, 0, 1367, 231, [], "checkTextureKey"],
    checkSoundKey$1: [function(key) {
      return this.checkKey$2(4, key);
    }, "call$1", "get$checkSoundKey", 2, 0, 1367, 231, [], "checkSoundKey"],
    checkTextKey$1: [function(key) {
      return this.checkKey$2(5, key);
    }, "call$1", "get$checkTextKey", 2, 0, 1367, 231, [], "checkTextKey"],
    checkPhysicsKey$1: [function(key) {
      return this.checkKey$2(6, key);
    }, "call$1", "get$checkPhysicsKey", 2, 0, 1367, 231, [], "checkPhysicsKey"],
    checkTilemapKey$1: [function(key) {
      return this.checkKey$2(7, key);
    }, "call$1", "get$checkTilemapKey", 2, 0, 1367, 231, [], "checkTilemapKey"],
    checkBinaryKey$1: [function(key) {
      return this.checkKey$2(8, key);
    }, "call$1", "get$checkBinaryKey", 2, 0, 1367, 231, [], "checkBinaryKey"],
    checkBitmapDataKey$1: [function(key) {
      return this.checkKey$2(9, key);
    }, "call$1", "get$checkBitmapDataKey", 2, 0, 1367, 231, [], "checkBitmapDataKey"],
    checkBitmapFontKey$1: [function(key) {
      return this.checkKey$2(10, key);
    }, "call$1", "get$checkBitmapFontKey", 2, 0, 1367, 231, [], "checkBitmapFontKey"],
    checkJSONKey$1: [function(key) {
      return this.checkKey$2(11, key);
    }, "call$1", "get$checkJSONKey", 2, 0, 1367, 231, [], "checkJSONKey"],
    getImage$1: [function(key) {
      var t1;
      if (J.$index$asx(this._images, key) != null)
        return J.$index$asx(J.$index$asx(this._images, key), "data");
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getImage: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getImage", 2, 0, 1368, 231, [], "getImage"],
    getTilemapData$1: [function(key) {
      var t1;
      if (J.$index$asx(this._tilemaps, key) != null)
        return J.$index$asx(this._tilemaps, key);
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getTilemapData: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getTilemapData", 2, 0, 1363, 231, [], "getTilemapData"],
    getFrameData$1: [function(key) {
      if (J.$index$asx(this._images, key) != null && J.$index$asx(J.$index$asx(this._images, key), "frameData") != null)
        return J.$index$asx(J.$index$asx(this._images, key), "frameData");
      return;
    }, "call$1", "get$getFrameData", 2, 0, 1369, 231, [], "getFrameData"],
    updateFrameData$2: [function(key, frameData) {
      if (J.$index$asx(this._images, key) != null) {
        J.$indexSet$ax(J.$index$asx(this._images, key), "spriteSheet", true);
        J.$indexSet$ax(J.$index$asx(this._images, key), "frameData", frameData);
      }
    }, "call$2", "get$updateFrameData", 4, 0, 1370, 231, [], 951, [], "updateFrameData"],
    getFrameByIndex$2: [function(key, frame) {
      if (J.$index$asx(this._images, key) != null && J.$index$asx(J.$index$asx(this._images, key), "frameData") != null)
        return J.$index$asx(J.$index$asx(this._images, key), "frameData").getFrame$1(frame);
      return;
    }, "call$2", "get$getFrameByIndex", 4, 0, 1371, 231, [], 178, [], "getFrameByIndex"],
    getFrameByName$2: [function(key, frame) {
      if (J.$index$asx(this._images, key) != null && J.$index$asx(J.$index$asx(this._images, key), "frameData") != null)
        return J.$index$asx(J.$index$asx(this._images, key), "frameData").getFrameByName$1(frame);
      return;
    }, "call$2", "get$getFrameByName", 4, 0, 1371, 231, [], 178, [], "getFrameByName"],
    getFrame$1: [function(key) {
      if (J.$index$asx(this._images, key) != null && J.$eq(J.$index$asx(J.$index$asx(this._images, key), "spriteSheet"), false))
        return J.$index$asx(J.$index$asx(this._images, key), "frame");
      return;
    }, "call$1", "get$getFrame", 2, 0, 978, 231, [], "getFrame"],
    getTextureFrame$1: [function(key) {
      if (J.$index$asx(this._textures, key) != null)
        return J.$index$asx(J.$index$asx(this._textures, key), "frame");
      return;
    }, "call$1", "get$getTextureFrame", 2, 0, 978, 231, [], "getTextureFrame"],
    getTexture$1: [function(key) {
      var t1;
      if (J.$index$asx(this._textures, key) != null)
        return J.$index$asx(this._textures, key);
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getTexture: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getTexture", 2, 0, 1372, 231, [], "getTexture"],
    getSound$1: [function(key) {
      var t1;
      if (J.$index$asx(this._sounds, key) != null)
        return J.$index$asx(this._sounds, key);
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getSound: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getSound", 2, 0, 1363, 231, [], "getSound"],
    getSoundData$1: [function(key) {
      var t1;
      if (J.$index$asx(this._sounds, key) != null)
        return J.$index$asx(J.$index$asx(this._sounds, key), "data");
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getSoundData: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getSoundData", 2, 0, 52, 231, [], "getSoundData"],
    isSoundDecoded$1: [function(key) {
      if (J.$index$asx(this._sounds, key) != null)
        return J.$index$asx(J.$index$asx(this._sounds, key), "decoded");
      return;
    }, "call$1", "get$isSoundDecoded", 2, 0, 1367, 231, [], "isSoundDecoded"],
    isSoundReady$1: [function(key) {
      return J.$index$asx(this._sounds, key) != null && J.$index$asx(J.$index$asx(this._sounds, key), "decoded") === true && J.$eq(this.game.get$sound().get$touchLocked(), false);
    }, "call$1", "get$isSoundReady", 2, 0, 1367, 231, [], "isSoundReady"],
    isSpriteSheet$1: [function(key) {
      if (J.$index$asx(this._images, key) != null)
        return J.$index$asx(J.$index$asx(this._images, key), "spriteSheet");
      return false;
    }, "call$1", "get$isSpriteSheet", 2, 0, 1367, 231, [], "isSpriteSheet"],
    getText$1: [function(key) {
      var t1;
      if (J.$index$asx(this._text, key) != null)
        return J.$index$asx(J.$index$asx(this._text, key), "data");
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getText: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getText", 2, 0, 1363, 231, [], "getText"],
    getJSON$1: [function(key) {
      var t1;
      if (J.$index$asx(this._json, key) != null)
        return J.$index$asx(J.$index$asx(this._json, key), "data");
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getJSON: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getJSON", 2, 0, 1363, 231, [], "getJSON"],
    getBinary$1: [function(key) {
      var t1;
      if (J.$index$asx(this._binary, key) != null)
        return J.$index$asx(this._binary, key);
      else {
        window;
        t1 = C.JSString_methods.$add("Phaser.Cache.getBinary: Invalid key: \"", key) + "\"";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
    }, "call$1", "get$getBinary", 2, 0, 1363, 231, [], "getBinary"],
    getKeys$1: [function(type) {
      var array;
      switch (type) {
        case 1:
          array = this._canvases;
          break;
        case 2:
          return J.where$1$ax(J.get$keys$x(this._images), new R.Cache_getKeys_closure()).toList$0(0);
        case 3:
          array = this._textures;
          break;
        case 4:
          array = this._sounds;
          break;
        case 5:
          array = this._text;
          break;
        case 6:
          array = this._physics;
          break;
        case 7:
          array = this._tilemaps;
          break;
        case 8:
          array = this._binary;
          break;
        case 9:
          array = this._bitmapDatas;
          break;
        case 10:
          array = this._bitmapFont;
          break;
        case 11:
          array = this._json;
          break;
        default:
          array = null;
      }
      if (array == null)
        return [];
      return J.toList$0$ax(J.get$keys$x(array));
    }, "call$1", "get$getKeys", 2, 0, 1373, 99, [], "getKeys"],
    removeCanvas$1: [function(key) {
      J.remove$1$ax(this._canvases, key);
    }, "call$1", "get$removeCanvas", 2, 0, 52, 231, [], "removeCanvas"],
    removeImage$1: [function(key) {
      J.remove$1$ax(this._images, key);
    }, "call$1", "get$removeImage", 2, 0, 52, 231, [], "removeImage"],
    removeSound$1: [function(key) {
      J.remove$1$ax(this._sounds, key);
    }, "call$1", "get$removeSound", 2, 0, 52, 231, [], "removeSound"],
    removeText$1: [function(key) {
      J.remove$1$ax(this._text, key);
    }, "call$1", "get$removeText", 2, 0, 52, 231, [], "removeText"],
    removeJSON$1: [function(key) {
      J.remove$1$ax(this._json, key);
    }, "call$1", "get$removeJSON", 2, 0, 52, 231, [], "removeJSON"],
    removePhysics$1: [function(key) {
      J.remove$1$ax(this._physics, key);
    }, "call$1", "get$removePhysics", 2, 0, 52, 231, [], "removePhysics"],
    removeTilemap$1: [function(key) {
      J.remove$1$ax(this._tilemaps, key);
    }, "call$1", "get$removeTilemap", 2, 0, 52, 231, [], "removeTilemap"],
    removeBinary$1: [function(key) {
      J.remove$1$ax(this._binary, key);
    }, "call$1", "get$removeBinary", 2, 0, 52, 231, [], "removeBinary"],
    removeBitmapData$1: [function(key) {
      J.remove$1$ax(this._bitmapDatas, key);
    }, "call$1", "get$removeBitmapData", 2, 0, 52, 231, [], "removeBitmapData"],
    removeBitmapFont$1: [function(key) {
      J.remove$1$ax(this._bitmapFont, key);
    }, "call$1", "get$removeBitmapFont", 2, 0, 52, 231, [], "removeBitmapFont"],
    destroy$0: [function() {
      var t1, item, t2;
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._canvases)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._canvases, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._images)); t1.moveNext$0();) {
        item = t1.get$current();
        t2 = J.getInterceptor(item);
        if (!t2.$eq(item, "__default") && !t2.$eq(item, "__missing"))
          J.remove$1$ax(this._images, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._sounds)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._sounds, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._text)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._text, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._json)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._json, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._textures)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._textures, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._physics)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._physics, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._tilemaps)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._tilemaps, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._binary)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._binary, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._bitmapDatas)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._bitmapDatas, item);
      }
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._bitmapFont)); t1.moveNext$0();) {
        item = t1.get$current();
        J.remove$1$ax(this._bitmapFont, item);
      }
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    Cache$1: function(game) {
      var img, t1, t2;
      this._canvases = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._images = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._textures = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._sounds = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._text = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._json = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._physics = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._tilemaps = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._binary = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._bitmapDatas = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._bitmapFont = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      img = W.ImageElement_ImageElement(null, null, null);
      J.set$src$x(img, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==");
      J.$indexSet$ax(this._images, "__default", P.LinkedHashMap_LinkedHashMap$_literal(["url", null, "data", img, "spriteSheet", false], null, null));
      J.$indexSet$ax(J.$index$asx(this._images, "__default"), "frame", R.Frame$(0, 0, 0, 32, 32, "", ""));
      J.$indexSet$ax($.get$BaseTextureCache(), "__default", M.BaseTexture$(img, C.scaleModes_0));
      J.$indexSet$ax($.get$TextureCache(), "__default", M.Texture$(J.$index$asx($.get$BaseTextureCache(), "__default"), null));
      img = W.ImageElement_ImageElement(null, null, null);
      J.set$src$x(img, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==");
      J.$indexSet$ax(this._images, "__missing", P.LinkedHashMap_LinkedHashMap$_literal(["url", null, "data", img, "spriteSheet", false], null, null));
      J.$indexSet$ax(J.$index$asx(this._images, "__missing"), "frame", R.Frame$(0, 0, 0, 32, 32, "", ""));
      J.$indexSet$ax($.get$BaseTextureCache(), "__missing", M.BaseTexture$(img, C.scaleModes_0));
      J.$indexSet$ax($.get$TextureCache(), "__missing", M.Texture$(J.$index$asx($.get$BaseTextureCache(), "__missing"), null));
      this.onSoundUnlock = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      t1 = Array(12);
      t1.fixed$length = init;
      this._cacheMap = t1;
      t2 = this._canvases;
      if (1 < 0 || 1 >= 12)
        return H.ioore(t1, 1);
      t1[1] = t2;
      J.$indexSet$ax(this._cacheMap, 2, this._images);
      J.$indexSet$ax(this._cacheMap, 3, this._textures);
      J.$indexSet$ax(this._cacheMap, 4, this._sounds);
      J.$indexSet$ax(this._cacheMap, 5, this._text);
      J.$indexSet$ax(this._cacheMap, 6, this._physics);
      J.$indexSet$ax(this._cacheMap, 7, this._tilemaps);
      J.$indexSet$ax(this._cacheMap, 8, this._binary);
      J.$indexSet$ax(this._cacheMap, 9, this._bitmapDatas);
      J.$indexSet$ax(this._cacheMap, 10, this._bitmapFont);
      J.$indexSet$ax(this._cacheMap, 11, this._json);
    },
    static: {"^": "Cache_CANVAS<-599,Cache_IMAGE<-599,Cache_TEXTURE<-599,Cache_SOUND<-599,Cache_TEXT<-599,Cache_PHYSICS<-599,Cache_TILEMAP<-599,Cache_BINARY<-599,Cache_BITMAPDATA<-599,Cache_BITMAPFONT<-599,Cache_JSON<-599", Cache$: [function(game) {
        var t1 = new R.Cache(game, null, null, null, null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), null);
        t1.Cache$1(game);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new Cache"]}
  },
  "+Cache": [632],
  Cache_reloadSound_closure: {
    "^": "Closure:63;this_0,key_1",
    call$1: [function(e) {
      var t1, t2;
      t1 = this.this_0;
      t2 = this.key_1;
      if (J.$index$asx(t1._sounds, t2) != null) {
        J.$indexSet$ax(J.$index$asx(t1._sounds, t2), "locked", false);
        t1.onSoundUnlock.dispatch$1(t2);
      }
      return;
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  Cache_getKeys_closure: {
    "^": "Closure:63;",
    call$1: [function(s) {
      var t1 = J.getInterceptor(s);
      return !t1.$eq(s, "__default") && !t1.$eq(s, "__missing");
    }, "call$1", null, 2, 0, 63, 502, [], "call"],
    $isFunction: true
  },
  Loader: {
    "^": "Object;game@-598,isLoading@-602,hasLoaded@-602,progress@-599,progressFloat@-629,preloadSprite@-754,crossOrigin*-639,baseURL@-639,onLoadStart*-1374,onFileStart@-1375,onFileComplete@-1376,onFileError@-1377,onLoadComplete@-1015,onPackComplete@-1378,_packList@-1379,_packIndex@-599,_fileList@-1379,_fileIndex@-599,_progressChunk@-601,_xhr@-825",
    setPreloadSprite$2: [function(sprite, direction) {
      var t1, t2, t3;
      t1 = J.getInterceptor$x(sprite);
      this.preloadSprite = P.LinkedHashMap_LinkedHashMap$_literal(["sprite", sprite, "direction", direction, "width", t1.get$width(sprite), "height", t1.get$height(sprite), "rect", null], null, null);
      t2 = J.$eq(direction, 0);
      t3 = this.preloadSprite;
      if (t2)
        J.$indexSet$ax(t3, "rect", new R.Rectangle1(0, 0, 1, t1.get$height(sprite), 0, 0, 0, 0));
      else
        J.$indexSet$ax(t3, "rect", new R.Rectangle1(0, 0, t1.get$width(sprite), 1, 0, 0, 0, 0));
      sprite.crop$1(J.$index$asx(this.preloadSprite, "rect"));
      sprite.set$visible(true);
    }, function(sprite) {
      return this.setPreloadSprite$2(sprite, 0);
    }, "setPreloadSprite$1", "call$2", "call$1", "get$setPreloadSprite", 2, 2, 985, 5, 113, [], 538, [], "setPreloadSprite"],
    checkKeyExists$2: [function(type, key) {
      var i, t1;
      if (J.$gt$n(J.get$length$asx(this._fileList), 0)) {
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this._fileList);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$eq(J.$index$asx(J.$index$asx(this._fileList, i), "type"), type) && J.$eq(J.$index$asx(J.$index$asx(this._fileList, i), "key"), key))
            return true;
          ++i;
        }
      }
      return false;
    }, "call$2", "get$checkKeyExists", 4, 0, 1380, 99, [], 231, [], "checkKeyExists"],
    getAssetIndex$2: [function(type, key) {
      var i, t1;
      if (J.$gt$n(J.get$length$asx(this._fileList), 0)) {
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this._fileList);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$eq(J.$index$asx(J.$index$asx(this._fileList, i), "type"), type) && J.$eq(J.$index$asx(J.$index$asx(this._fileList, i), "key"), key))
            return i;
          ++i;
        }
      }
      return -1;
    }, "call$2", "get$getAssetIndex", 4, 0, 1381, 99, [], 231, [], "getAssetIndex"],
    getAsset$2: [function(type, key) {
      var i, t1;
      if (J.$gt$n(J.get$length$asx(this._fileList), 0)) {
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this._fileList);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$eq(J.$index$asx(J.$index$asx(this._fileList, i), "type"), type) && J.$eq(J.$index$asx(J.$index$asx(this._fileList, i), "key"), key))
            return P.LinkedHashMap_LinkedHashMap$_literal([["index"], i, ["file"], J.$index$asx(this._fileList, i)], null, null);
          ++i;
        }
      }
      return;
    }, "call$2", "get$getAsset", 4, 0, 1382, 99, [], 231, [], "getAsset"],
    reset$0: [function(_) {
      this.preloadSprite = null;
      this.isLoading = false;
      J.clear$0$ax(this._packList);
      this._packIndex = 0;
      J.clear$0$ax(this._fileList);
      this._fileIndex = 0;
    }, "call$0", "get$reset", 0, 0, 13, "reset"],
    addToFileList$4: [function(type, key, url, properties) {
      var entry, t1, t2, prop;
      entry = P.LinkedHashMap_LinkedHashMap$_literal(["type", type, "key", key, "url", url, "data", null, "error", false, "loaded", false], null, null);
      if (properties != null)
        for (t1 = J.getInterceptor$x(properties), t2 = J.get$iterator$ax(t1.get$keys(properties)); t2.moveNext$0();) {
          prop = t2.get$current();
          entry.$indexSet(0, prop, t1.$index(properties, prop));
        }
      if (!this.checkKeyExists$2(type, key))
        J.add$1$ax(this._fileList, entry);
    }, function(type, key, url) {
      return this.addToFileList$4(type, key, url, null);
    }, "addToFileList$3", "call$4", "call$3", "get$addToFileList", 6, 2, 1383, 32, 99, [], 231, [], 88, [], 469, [], "addToFileList"],
    replaceInFileList$4: [function(type, key, url, properties) {
      var entry, t1, t2, prop, index;
      entry = P.LinkedHashMap_LinkedHashMap$_literal(["type", type, "key", key, "url", url, "data", null, "error", false, "loaded", false], null, null);
      if (properties != null)
        for (t1 = J.getInterceptor$x(properties), t2 = J.get$iterator$ax(t1.get$keys(properties)); t2.moveNext$0();) {
          prop = t2.get$current();
          entry.$indexSet(0, prop, t1.$index(properties, prop));
        }
      index = this.getAssetIndex$2(type, key);
      t1 = this._fileList;
      if (index === -1)
        J.add$1$ax(t1, entry);
      else
        J.$indexSet$ax(t1, index, entry);
    }, function(type, key, url) {
      return this.replaceInFileList$4(type, key, url, null);
    }, "replaceInFileList$3", "call$4", "call$3", "get$replaceInFileList", 6, 2, 1384, 32, 99, [], 231, [], 88, [], 469, [], "replaceInFileList"],
    pack$3: [function(key, url, data) {
      if (url == null && data == null) {
        window;
        if (typeof console != "undefined")
          console.warn("Phaser.Loader.pack - Both url and data are null. One must be set.");
        return this;
      }
      if (data != null)
        data = typeof data === "string" ? C.JsonCodec_null_null.decode$1(data) : data;
      J.add$1$ax(this._packList, P.LinkedHashMap_LinkedHashMap$_literal(["key", key, "url", url, "data", data, "loaded", false, "error", false], null, null));
      return this;
    }, function(key) {
      return this.pack$3(key, null, null);
    }, "pack$1", function(key, url) {
      return this.pack$3(key, url, null);
    }, "pack$2", "call$3", "call$1", "call$2", "get$pack", 2, 4, 1385, 32, 32, 231, [], 88, [], 48, [], "pack"],
    image$3: [function(key, url, overwrite) {
      if ((overwrite == null ? false : overwrite) === true)
        this.replaceInFileList$3("image", key, url);
      else
        this.addToFileList$3("image", key, url);
      return this;
    }, function(key, url) {
      return this.image$3(key, url, false);
    }, "image$2", "call$3", "call$2", "get$image", 4, 2, 1386, 95, 231, [], 88, [], 1387, [], "image"],
    text$3: [function(_, key, url, overwrite) {
      if ((overwrite == null ? false : overwrite) === true)
        this.replaceInFileList$3("text", key, url);
      else
        this.addToFileList$3("text", key, url);
      return this;
    }, function($receiver, key, url) {
      return this.text$3($receiver, key, url, false);
    }, "text$2", "call$3", "call$2", "get$text", 4, 2, 1386, 95, 231, [], 88, [], 1387, [], "text"],
    json$3: [function(key, url, overwrite) {
      if ((overwrite == null ? false : overwrite) === true)
        this.replaceInFileList$3("json", key, url);
      else
        this.addToFileList$3("json", key, url);
      return this;
    }, function(key, url) {
      return this.json$3(key, url, false);
    }, "json$2", "call$3", "call$2", "get$json", 4, 2, 1386, 95, 231, [], 88, [], 1387, [], "json"],
    script$3: [function(key, url, callback) {
      if (callback != null)
        this.addToFileList$4("script", key, url, P.LinkedHashMap_LinkedHashMap$_literal(["callback", callback], null, null));
      return this;
    }, function(key, url) {
      return this.script$3(key, url, null);
    }, "script$2", "call$3", "call$2", "get$script", 4, 2, 1388, 32, 231, [], 88, [], 272, [], "script"],
    binary$3: [function(key, url, callback) {
      if (callback != null)
        this.addToFileList$4("binary", key, url, P.LinkedHashMap_LinkedHashMap$_literal(["callback", callback], null, null));
      return this;
    }, function(key, url) {
      return this.binary$3(key, url, null);
    }, "binary$2", "call$3", "call$2", "get$binary", 4, 2, 1388, 32, 231, [], 88, [], 272, [], "binary"],
    spritesheet$7: [function(key, url, frameWidth, frameHeight, frameMax, margin, spacing) {
      this.addToFileList$4("spritesheet", key, url, P.LinkedHashMap_LinkedHashMap$_literal(["frameWidth", frameWidth, "frameHeight", frameHeight == null ? frameWidth : frameHeight, "frameMax", frameMax, "margin", margin, "spacing", spacing], null, null));
      return this;
    }, function(key, url, frameWidth) {
      return this.spritesheet$7(key, url, frameWidth, null, -1, 0, 0);
    }, "spritesheet$3", function(key, url, frameWidth, frameHeight) {
      return this.spritesheet$7(key, url, frameWidth, frameHeight, -1, 0, 0);
    }, "spritesheet$4", function(key, url, frameWidth, frameHeight, frameMax, margin) {
      return this.spritesheet$7(key, url, frameWidth, frameHeight, frameMax, margin, 0);
    }, "spritesheet$6", function(key, url, frameWidth, frameHeight, frameMax) {
      return this.spritesheet$7(key, url, frameWidth, frameHeight, frameMax, 0, 0);
    }, "spritesheet$5", "call$7", "call$3", "call$4", "call$6", "call$5", "get$spritesheet", 6, 8, 1389, 32, 230, 5, 5, 231, [], 88, [], 232, [], 233, [], 234, [], 235, [], 236, [], "spritesheet"],
    audio$3: [function(_, key, url, autoDecode) {
      this.addToFileList$4("audio", key, url, P.LinkedHashMap_LinkedHashMap$_literal(["buffer", null, "autoDecode", autoDecode], null, null));
      return this;
    }, function($receiver, key, url) {
      return this.audio$3($receiver, key, url, true);
    }, "audio$2", "call$3", "call$2", "get$audio", 4, 2, 1390, 39, 231, [], 88, [], 1391, [], "audio"],
    tilemap$4: [function(key, url, data, format) {
      if (format == null)
        format = 0;
      if (url == null && data == null) {
        window;
        if (typeof console != "undefined")
          console.warn("Phaser.Loader.tilemap - Both url and data are null. One must be set.");
        return this;
      }
      if (data != null) {
        switch (format) {
          case 0:
            break;
          case 1:
            if (typeof data === "string")
              data = C.JsonCodec_null_null.decode$1(data);
            break;
        }
        this.game.get$cache().addTilemap$4(key, null, data, format);
      } else
        this.addToFileList$4("tilemap", key, url, P.LinkedHashMap_LinkedHashMap$_literal(["format", format], null, null));
      return this;
    }, function(key) {
      return this.tilemap$4(key, null, null, null);
    }, "tilemap$1", function(key, url) {
      return this.tilemap$4(key, url, null, null);
    }, "tilemap$2", function(key, url, data) {
      return this.tilemap$4(key, url, data, null);
    }, "tilemap$3", "call$4", "call$1", "call$2", "call$3", "get$tilemap", 2, 6, 1392, 32, 32, 32, 231, [], 88, [], 48, [], 1352, [], "tilemap"],
    physics$4: [function(key, url, data, format) {
      if (format == null)
        format = 0;
      if (url == null && data == null) {
        window;
        if (typeof console != "undefined")
          console.warn("Phaser.Loader.physics - Both url and data are null. One must be set.");
        return this;
      }
      if (data != null) {
        if (J.$eq(data, C.Type_Ejg))
          data = C.JsonCodec_null_null.decode$1(data);
        this.game.get$cache().addPhysicsData$4(key, null, data, format);
      } else
        this.addToFileList$4("physics", key, url, P.LinkedHashMap_LinkedHashMap$_literal(["format", format], null, null));
      return this;
    }, function(key) {
      return this.physics$4(key, null, null, null);
    }, "physics$1", function(key, url) {
      return this.physics$4(key, url, null, null);
    }, "physics$2", function(key, url, data) {
      return this.physics$4(key, url, data, null);
    }, "physics$3", "call$4", "call$1", "call$2", "call$3", "get$physics", 2, 6, 1392, 32, 32, 32, 231, [], 88, [], 48, [], 1352, [], "physics"],
    bitmapFont$6: [function(key, textureURL, xmlURL, xmlData, xSpacing, ySpacing) {
      var xml, domparser, t1, exception;
      if (xmlURL != null)
        this.addToFileList$4("bitmapfont", key, textureURL, P.LinkedHashMap_LinkedHashMap$_literal(["xmlURL", xmlURL, "xSpacing", xSpacing, "ySpacing", ySpacing], null, null));
      else {
        t1 = xmlData;
        if (typeof t1 === "string") {
          xml = null;
          try {
            domparser = new DOMParser();
            xml = J.parseFromString$2$x(domparser, xmlData, "text/xml");
          } catch (exception) {
            H.unwrapException(exception);
            xml = null;
          }

          if (xml == null)
            throw H.wrapException(P.Exception_Exception("Phaser.Loader. Invalid Bitmap Font XML given"));
          else
            this.addToFileList$4("bitmapfont", key, textureURL, P.LinkedHashMap_LinkedHashMap$_literal(["xmlURL", null, "xmlData", xml, "xSpacing", xSpacing, "ySpacing", ySpacing], null, null));
        }
      }
      return this;
    }, function(key, textureURL) {
      return this.bitmapFont$6(key, textureURL, null, null, 0, 0);
    }, "bitmapFont$2", function(key, textureURL, xmlURL) {
      return this.bitmapFont$6(key, textureURL, xmlURL, null, 0, 0);
    }, "bitmapFont$3", function(key, textureURL, xmlURL, xmlData) {
      return this.bitmapFont$6(key, textureURL, xmlURL, xmlData, 0, 0);
    }, "bitmapFont$4", function(key, textureURL, xmlURL, xmlData, xSpacing) {
      return this.bitmapFont$6(key, textureURL, xmlURL, xmlData, xSpacing, 0);
    }, "bitmapFont$5", "call$6", "call$2", "call$3", "call$4", "call$5", "get$bitmapFont", 4, 8, 1393, 32, 32, 5, 5, 231, [], 1394, [], 1395, [], 1356, [], 291, [], 292, [], "bitmapFont"],
    atlasJSONArray$4: [function(key, textureURL, atlasURL, atlasData) {
      return this.atlas$5(key, textureURL, atlasURL, atlasData, 0);
    }, function(key, textureURL) {
      return this.atlasJSONArray$4(key, textureURL, null, null);
    }, "atlasJSONArray$2", function(key, textureURL, atlasURL) {
      return this.atlasJSONArray$4(key, textureURL, atlasURL, null);
    }, "atlasJSONArray$3", "call$4", "call$2", "call$3", "get$atlasJSONArray", 4, 4, 1396, 32, 32, 231, [], 1394, [], 1397, [], 1354, [], "atlasJSONArray"],
    atlasJSONHash$4: [function(key, textureURL, atlasURL, atlasData) {
      return this.atlas$5(key, textureURL, atlasURL, atlasData, 1);
    }, function(key, textureURL) {
      return this.atlasJSONHash$4(key, textureURL, null, null);
    }, "atlasJSONHash$2", function(key, textureURL, atlasURL) {
      return this.atlasJSONHash$4(key, textureURL, atlasURL, null);
    }, "atlasJSONHash$3", "call$4", "call$2", "call$3", "get$atlasJSONHash", 4, 4, 1396, 32, 32, 231, [], 1394, [], 1397, [], 1354, [], "atlasJSONHash"],
    atlasXML$4: [function(key, textureURL, atlasURL, atlasData) {
      return this.atlas$5(key, textureURL, atlasURL, atlasData, 2);
    }, function(key, textureURL) {
      return this.atlasXML$4(key, textureURL, null, null);
    }, "atlasXML$2", function(key, textureURL, atlasURL) {
      return this.atlasXML$4(key, textureURL, atlasURL, null);
    }, "atlasXML$3", "call$4", "call$2", "call$3", "get$atlasXML", 4, 4, 1396, 32, 32, 231, [], 1394, [], 1397, [], 1354, [], "atlasXML"],
    atlas$5: [function(key, textureURL, atlasURL, atlasData, format) {
      var xml, domparser, t1, exception;
      if (format == null)
        format = 0;
      if (atlasURL != null)
        this.addToFileList$4("textureatlas", key, textureURL, P.LinkedHashMap_LinkedHashMap$_literal(["atlasURL", atlasURL, "format", format], null, null));
      else {
        switch (format) {
          case 0:
            t1 = atlasData;
            if (typeof t1 === "string")
              atlasData = C.JsonCodec_null_null.decode$1(atlasData);
            break;
          case 2:
            t1 = atlasData;
            if (typeof t1 === "string") {
              xml = null;
              try {
                domparser = new DOMParser();
                xml = J.parseFromString$2$x(domparser, atlasData, "text/xml");
              } catch (exception) {
                H.unwrapException(exception);
                xml = null;
              }

              if (xml == null)
                throw H.wrapException(P.Exception_Exception("Phaser.Loader. Invalid Texture Atlas XML given"));
              else
                atlasData = xml;
            }
            break;
        }
        this.addToFileList$4("textureatlas", key, textureURL, P.LinkedHashMap_LinkedHashMap$_literal(["atlasURL", null, "atlasData", atlasData, "format", format], null, null));
      }
      return this;
    }, function(key, textureURL) {
      return this.atlas$5(key, textureURL, null, null, null);
    }, "atlas$2", function(key, textureURL, atlasURL) {
      return this.atlas$5(key, textureURL, atlasURL, null, null);
    }, "atlas$3", function(key, textureURL, atlasURL, atlasData) {
      return this.atlas$5(key, textureURL, atlasURL, atlasData, null);
    }, "atlas$4", "call$5", "call$2", "call$3", "call$4", "get$atlas", 4, 6, 1398, 32, 32, 32, 231, [], 1394, [], 1397, [], 1354, [], 1352, [], "atlas"],
    removeFile$2: [function(type, key) {
      var file = this.getAsset$2(type, key);
      if (file != null)
        J.removeAt$1$ax(this._fileList, file.$index(0, "index"));
    }, "call$2", "get$removeFile", 4, 0, 743, 99, [], 231, [], "removeFile"],
    removeAll$0: [function() {
      J.clear$0$ax(this._fileList);
    }, "call$0", "get$removeAll", 0, 0, 13, "removeAll"],
    start$0: [function(_) {
      if (this.isLoading === true)
        return;
      if (J.$gt$n(J.get$length$asx(this._packList), 0)) {
        this._packIndex = 0;
        this.loadPack$0();
      } else
        this.beginLoad$0();
    }, "call$0", "get$start", 0, 0, 13, "start"],
    beginLoad$0: [function() {
      this.progress = 0;
      this.progressFloat = 0;
      this.hasLoaded = false;
      this.isLoading = true;
      this.onLoadStart.dispatch$1(J.get$length$asx(this._fileList));
      if (J.$gt$n(J.get$length$asx(this._fileList), 0)) {
        this._fileIndex = 0;
        var t1 = J.get$length$asx(this._fileList);
        if (typeof t1 !== "number")
          return H.iae(t1);
        this._progressChunk = 100 / t1;
        this.loadFile$0();
      } else {
        this.progress = 100;
        this.progressFloat = 100;
        this.hasLoaded = true;
        this.isLoading = false;
        this.onLoadComplete.dispatch$0();
      }
    }, "call$0", "get$beginLoad", 0, 0, 13, "beginLoad"],
    loadPack$0: [function() {
      var t1, pack, t2, t3;
      if (J.$index$asx(this._packList, this._packIndex) == null) {
        window;
        t1 = C.JSString_methods.$add("Phaser.Loader loadPackList invalid index ", J.toString$0(this._packIndex));
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      pack = J.$index$asx(this._packList, this._packIndex);
      t1 = J.getInterceptor$asx(pack);
      t2 = t1.$index(pack, "data");
      t3 = this._packIndex;
      if (t2 != null)
        this.packLoadComplete$2(t3, false);
      else
        this.xhrLoad$5(t3, J.$add$ns(this.baseURL, t1.$index(pack, "url")), "text", this.get$packLoadComplete(), this.get$packError());
    }, "call$0", "get$loadPack", 0, 0, 13, "loadPack"],
    packLoadComplete$2: [function(index, parse) {
      var t1, pack, data, t2, i, t3, file, t4, t5, overwrite, frameHeight, frameHeight0, t6, t7;
      if (J.$index$asx(this._packList, index) == null) {
        window;
        t1 = C.JSString_methods.$add("Phaser.Loader packLoadComplete invalid index ", J.toString$0(index));
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      pack = J.$index$asx(this._packList, index);
      t1 = J.getInterceptor$ax(pack);
      t1.$indexSet(pack, "loaded", true);
      data = parse === true ? C.JsonCodec_null_null.decode$1(J.get$responseText$x(this._xhr)) : J.$index$asx(J.$index$asx(this._packList, index), "data");
      t2 = J.getInterceptor$asx(data);
      if (t2.$index(data, t1.$index(pack, "key")) != null) {
        i = 0;
        while (true) {
          t3 = J.get$length$asx(t2.$index(data, t1.$index(pack, "key")));
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          file = J.$index$asx(t2.$index(data, t1.$index(pack, "key")), i);
          t3 = J.getInterceptor$asx(file);
          switch (t3.$index(file, "type")) {
            case "image":
              t4 = t3.$index(file, "key");
              t5 = t3.$index(file, "url");
              overwrite = t3.$index(file, "overwrite");
              if ((overwrite == null ? false : overwrite) === true)
                this.replaceInFileList$3("image", t4, t5);
              else
                this.addToFileList$3("image", t4, t5);
              break;
            case "text":
              t4 = t3.$index(file, "key");
              t5 = t3.$index(file, "url");
              overwrite = t3.$index(file, "overwrite");
              if ((overwrite == null ? false : overwrite) === true)
                this.replaceInFileList$3("text", t4, t5);
              else
                this.addToFileList$3("text", t4, t5);
              break;
            case "json":
              t4 = t3.$index(file, "key");
              t5 = t3.$index(file, "url");
              overwrite = t3.$index(file, "overwrite");
              if ((overwrite == null ? false : overwrite) === true)
                this.replaceInFileList$3("json", t4, t5);
              else
                this.addToFileList$3("json", t4, t5);
              break;
            case "script":
              t4 = t3.$index(file, "key");
              t5 = t3.$index(file, "url");
              t3 = t3.$index(file, "callback");
              if (t3 != null)
                this.addToFileList$4("script", t4, t5, P.LinkedHashMap_LinkedHashMap$_literal(["callback", t3], null, null));
              break;
            case "binary":
              t4 = t3.$index(file, "key");
              t5 = t3.$index(file, "url");
              t3 = t3.$index(file, "callback");
              if (t3 != null)
                this.addToFileList$4("binary", t4, t5, P.LinkedHashMap_LinkedHashMap$_literal(["callback", t3], null, null));
              break;
            case "spritesheet":
              t4 = t3.$index(file, "key");
              t5 = t3.$index(file, "url");
              frameHeight = t3.$index(file, "frameWidth");
              frameHeight0 = t3.$index(file, "frameHeight");
              t6 = t3.$index(file, "frameMax");
              t7 = t3.$index(file, "margin");
              t3 = t3.$index(file, "spacing");
              this.addToFileList$4("spritesheet", t4, t5, P.LinkedHashMap_LinkedHashMap$_literal(["frameWidth", frameHeight, "frameHeight", frameHeight0 == null ? frameHeight : frameHeight0, "frameMax", t6, "margin", t7, "spacing", t3], null, null));
              break;
            case "audio":
              this.addToFileList$4("audio", t3.$index(file, "key"), t3.$index(file, "urls"), P.LinkedHashMap_LinkedHashMap$_literal(["buffer", null, "autoDecode", t3.$index(file, "autoDecode")], null, null));
              break;
            case "tilemap":
              this.tilemap$4(t3.$index(file, "key"), t3.$index(file, "url"), t3.$index(file, "data"), C.Map_do86y.$index(0, t3.$index(file, "format")));
              break;
            case "physics":
              this.physics$4(t3.$index(file, "key"), t3.$index(file, "url"), t3.$index(file, "data"), C.Map_F9OTV.$index(0, t3.$index(file, "format")));
              break;
            case "bitmapFont":
              this.bitmapFont$6(t3.$index(file, "key"), t3.$index(file, "textureURL"), t3.$index(file, "xmlURL"), t3.$index(file, "xmlData"), t3.$index(file, "xSpacing"), t3.$index(file, "ySpacing"));
              break;
            case "atlasJSONArray":
              this.atlas$5(t3.$index(file, "key"), t3.$index(file, "textureURL"), t3.$index(file, "atlasURL"), t3.$index(file, "atlasData"), 0);
              break;
            case "atlasJSONHash":
              this.atlas$5(t3.$index(file, "key"), t3.$index(file, "textureURL"), t3.$index(file, "atlasURL"), t3.$index(file, "atlasData"), 1);
              break;
            case "atlasXML":
              this.atlas$5(t3.$index(file, "key"), t3.$index(file, "textureURL"), t3.$index(file, "atlasURL"), t3.$index(file, "atlasData"), 2);
              break;
            case "atlas":
              this.atlas$5(t3.$index(file, "key"), t3.$index(file, "textureURL"), t3.$index(file, "atlasURL"), t3.$index(file, "atlasData"), C.Map_F9OTV.$index(0, t3.$index(file, "format")));
              break;
          }
          ++i;
        }
      }
      this.nextPack$2(index, true);
    }, function(index) {
      return this.packLoadComplete$2(index, true);
    }, "packLoadComplete$1", "call$2", "call$1", "get$packLoadComplete", 2, 2, 1399, 39, 243, [], 1400, [], "packLoadComplete"],
    packError$1: [function(index) {
      var t1;
      J.$indexSet$ax(J.$index$asx(this._packList, index), "loaded", true);
      J.$indexSet$ax(J.$index$asx(this._packList, index), "error", true);
      this.onFileError.dispatch$1([J.$index$asx(J.$index$asx(this._packList, index), "key"), J.$index$asx(this._packList, index)]);
      window;
      t1 = C.JSString_methods.$add(C.JSString_methods.$add("Phaser.Loader error loading pack file: ", J.$index$asx(J.$index$asx(this._packList, index), "key")) + " from URL ", J.$index$asx(J.$index$asx(this._packList, index), "url"));
      if (typeof console != "undefined")
        console.warn(t1);
      this.nextPack$2(index, false);
    }, "call$1", "get$packError", 2, 0, 60, 243, [], "packError"],
    nextPack$2: [function(index, success) {
      var t1;
      this.onPackComplete.dispatch$1([J.$index$asx(J.$index$asx(this._packList, index), "key"), success, this.totalLoadedPacks$0(), J.get$length$asx(this._packList)]);
      t1 = J.$add$ns(this._packIndex, 1);
      this._packIndex = t1;
      if (J.$lt$n(t1, J.get$length$asx(this._packList)))
        this.loadPack$0();
      else
        this.beginLoad$0();
    }, "call$2", "get$nextPack", 4, 0, 1401, 243, [], 1402, [], "nextPack"],
    loadFile$0: [function() {
      var t1, file, t2, t3, t4;
      if (J.$index$asx(this._fileList, this._fileIndex) == null) {
        window;
        t1 = "Phaser.Loader loadFile invalid index " + H.Primitives_objectToString(this) + "._fileIndex";
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      file = J.$index$asx(this._fileList, this._fileIndex);
      t1 = J.getInterceptor$asx(file);
      this.onFileStart.dispatch$1([this.progress, t1.$index(file, "key")]);
      switch (t1.$index(file, "type")) {
        case "image":
        case "spritesheet":
        case "textureatlas":
        case "bitmapfont":
          t2 = W.ImageElement_ImageElement(null, null, null);
          t2.toString;
          t3 = t1.$index(file, "key");
          t2.setAttribute("data-" + new W._DataAttributeMap(new W._ElementAttributeMap(t2))._toHyphenedName$1("name"), t3);
          t3 = J.getInterceptor$x(t2);
          t4 = t3.get$onLoad(t2);
          H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t4._target, t4._eventType, W._wrapZone(new R.Loader_loadFile_closure(this)), t4._useCapture), [H.getTypeArgumentByIndex(t4, 0)])._tryResume$0();
          t3 = t3.get$onError(t2);
          H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t3._target, t3._eventType, W._wrapZone(new R.Loader_loadFile_closure0(this)), t3._useCapture), [H.getTypeArgumentByIndex(t3, 0)])._tryResume$0();
          t1.$indexSet(file, "data", t2);
          if (this.crossOrigin != null)
            J.set$crossOrigin$x(t1.$index(file, "data"), this.crossOrigin);
          J.set$src$x(t1.$index(file, "data"), J.$add$ns(this.baseURL, t1.$index(file, "url")));
          break;
        case "audio":
          t1.$indexSet(file, "url", this.getAudioURL$1(t1.$index(file, "url")));
          if (t1.$index(file, "url") != null) {
            if (this.game.get$sound().get$usingWebAudio() === true)
              this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "url")), "arraybuffer", this.get$fileComplete(), this.get$fileError());
            else if (this.game.get$sound().get$usingAudioTag() === true)
              if (this.game.get$sound().get$touchLocked() === true) {
                t2 = W.AudioElement_AudioElement(null);
                t3 = t1.$index(file, "key");
                t2.setAttribute("data-" + new W._DataAttributeMap(new W._ElementAttributeMap(t2))._toHyphenedName$1("name"), t3);
                t2.preload = "auto";
                t2.src = J.$add$ns(this.baseURL, t1.$index(file, "url"));
                t1.$indexSet(file, "data", t2);
                this.fileComplete$1(this._fileIndex);
              } else {
                t2 = W.AudioElement_AudioElement(null);
                t3 = t1.$index(file, "key");
                t2.setAttribute("data-" + new W._DataAttributeMap(new W._ElementAttributeMap(t2))._toHyphenedName$1("name"), t3);
                t3 = C.EventStreamProvider_error.forElement$1(t2);
                H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t3._target, t3._eventType, W._wrapZone(new R.Loader_loadFile_closure1(this)), t3._useCapture), [H.getTypeArgumentByIndex(t3, 0)])._tryResume$0();
                t2.preload = "auto";
                t3 = C.EventStreamProvider_canplaythrough.forElement$1(t2);
                H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t3._target, t3._eventType, W._wrapZone(new R.Loader_loadFile_closure2(this)), t3._useCapture), [H.getTypeArgumentByIndex(t3, 0)])._tryResume$0();
                t2.src = J.$add$ns(this.baseURL, t1.$index(file, "url"));
                t2.load();
                t1.$indexSet(file, "data", t2);
              }
          } else
            this.fileError$1(this._fileIndex);
          break;
        case "json":
          this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "url")), "text", this.get$jsonLoadComplete(), this.get$dataLoadError());
          break;
        case "tilemap":
          if (J.$eq(t1.$index(file, "format"), 1))
            this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "url")), "text", this.get$jsonLoadComplete(), this.get$dataLoadError());
          else if (J.$eq(t1.$index(file, "format"), 0))
            this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "url")), "text", this.get$csvLoadComplete(), this.get$dataLoadError());
          else
            throw H.wrapException(P.Exception_Exception(C.JSString_methods.$add("Phaser.Loader. Invalid Tilemap format: ", t1.$index(file, "format"))));
          break;
        case "text":
        case "script":
        case "physics":
          this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "url")), "text", this.get$fileComplete(), this.get$fileError());
          break;
        case "binary":
          this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "url")), "arraybuffer", this.get$fileComplete(), this.get$fileError());
          break;
      }
    }, "call$0", "get$loadFile", 0, 0, 13, "loadFile"],
    xhrLoad$5: [function(index, url, type, onLoad, onError) {
      var t1 = new XMLHttpRequest();
      this._xhr = t1;
      C.HttpRequest_methods.open$3$async(t1, "GET", url, true);
      J.set$responseType$x(this._xhr, type);
      J.get$onLoad$x(this._xhr).listen$1(new R.Loader_xhrLoad_closure(index, onLoad));
      J.get$onError$x(this._xhr).listen$1(new R.Loader_xhrLoad_closure0(index, onError));
      J.send$0$x(this._xhr);
    }, "call$5", "get$xhrLoad", 10, 0, 1403, 243, [], 88, [], 99, [], 1404, [], 1405, [], "xhrLoad"],
    getAudioURL$1: [function(urls) {
      var t1, i, t2, url;
      if (typeof urls === "string")
        urls = [urls];
      t1 = J.getInterceptor$asx(urls);
      i = 0;
      while (true) {
        t2 = t1.get$length(urls);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        url = t1.$index(urls, i);
        if (this.game.get$device().canPlayAudio$1(C.JSArray_methods.get$last(J.split$1$s(url, "."))))
          return url;
        ++i;
      }
      return;
    }, "call$1", "get$getAudioURL", 2, 0, 63, 1406, [], "getAudioURL"],
    fileError$1: [function(index) {
      var t1;
      J.$indexSet$ax(J.$index$asx(this._fileList, index), "loaded", true);
      J.$indexSet$ax(J.$index$asx(this._fileList, index), "error", true);
      this.onFileError.dispatch$1([J.$index$asx(J.$index$asx(this._fileList, index), "key"), J.$index$asx(this._fileList, index)]);
      window;
      t1 = C.JSString_methods.$add(C.JSString_methods.$add("Phaser.Loader error loading file: ", J.$index$asx(J.$index$asx(this._fileList, index), "key")) + " from URL ", J.$index$asx(J.$index$asx(this._fileList, index), "url"));
      if (typeof console != "undefined")
        console.warn(t1);
      this.nextFile$2(index, false);
    }, "call$1", "get$fileError", 2, 0, 60, 243, [], "fileError"],
    fileComplete$1: [function(index) {
      var t1, file, loadNext, key, buffer, t2, data;
      if (J.$index$asx(this._fileList, index) == null) {
        window;
        t1 = C.JSString_methods.$add("Phaser.Loader fileComplete invalid index ", J.toString$0(index));
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      file = J.$index$asx(this._fileList, index);
      t1 = J.getInterceptor$ax(file);
      t1.$indexSet(file, "loaded", true);
      switch (t1.$index(file, "type")) {
        case "image":
          this.game.get$cache().addImage$3(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"));
          loadNext = true;
          break;
        case "spritesheet":
          this.game.get$cache().addSpriteSheet$8(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), t1.$index(file, "frameWidth"), t1.$index(file, "frameHeight"), t1.$index(file, "frameMax"), t1.$index(file, "margin"), t1.$index(file, "spacing"));
          loadNext = true;
          break;
        case "textureatlas":
          if (t1.$index(file, "atlasURL") == null) {
            this.game.get$cache().addTextureAtlas$5(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), t1.$index(file, "atlasData"), t1.$index(file, "format"));
            loadNext = true;
          } else {
            if (J.$eq(t1.$index(file, "format"), 0) || J.$eq(t1.$index(file, "format"), 1))
              this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "atlasURL")), "text", this.get$jsonLoadComplete(), this.get$dataLoadError());
            else if (J.$eq(t1.$index(file, "format"), 2))
              this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "atlasURL")), "text", this.get$xmlLoadComplete(), this.get$dataLoadError());
            else
              throw H.wrapException(P.Exception_Exception(C.JSString_methods.$add("Phaser.Loader. Invalid Texture Atlas format: ", t1.$index(file, "format"))));
            loadNext = false;
          }
          break;
        case "bitmapfont":
          if (t1.$index(file, "xmlURL") == null) {
            this.game.get$cache().addBitmapFont$6(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), t1.$index(file, "xmlData"), t1.$index(file, "xSpacing"), t1.$index(file, "ySpacing"));
            loadNext = true;
          } else {
            this.xhrLoad$5(this._fileIndex, J.$add$ns(this.baseURL, t1.$index(file, "xmlURL")), "text", this.get$xmlLoadComplete(), this.get$dataLoadError());
            loadNext = false;
          }
          break;
        case "audio":
          if (this.game.get$sound().get$usingWebAudio() === true) {
            t1.$indexSet(file, "data", J.get$response$x(this._xhr));
            this.game.get$cache().addSound$5(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), true, false);
            if (t1.$index(file, "autoDecode") === true) {
              key = t1.$index(file, "key");
              this.game.get$cache().updateSound$3(key, "isDecoding", true);
              buffer = t1.$index(file, "data");
              J.decodeAudioData$1$x(J.get$context$x(this.game.get$sound()), buffer).then$1(new R.Loader_fileComplete_closure(this, key));
            }
          } else {
            t2 = H.interceptedTypeCast(t1.$index(file, "data"), "$isAudioElement");
            t2.toString;
            t2 = C.EventStreamProvider_canplaythrough.forElement$1(t2);
            H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t2._target, t2._eventType, W._wrapZone(new R.Loader_fileComplete_closure0(this, index)), t2._useCapture), [H.getTypeArgumentByIndex(t2, 0)])._tryResume$0();
            this.game.get$cache().addSound$5(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), false, true);
          }
          loadNext = true;
          break;
        case "text":
          t1.$indexSet(file, "data", J.get$responseText$x(this._xhr));
          this.game.get$cache().addText$3(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"));
          loadNext = true;
          break;
        case "physics":
          data = C.JsonCodec_null_null.decode$1(J.get$responseText$x(this._xhr));
          this.game.get$cache().addPhysicsData$4(t1.$index(file, "key"), t1.$index(file, "url"), data, t1.$index(file, "format"));
          loadNext = true;
          break;
        case "binary":
          if (t1.$index(file, "callback") != null)
            t1.$indexSet(file, "data", t1.$index(file, "callback").call$2(t1.$index(file, "key"), J.get$response$x(this._xhr)));
          else
            t1.$indexSet(file, "data", J.get$response$x(this._xhr));
          this.game.get$cache().addBinary$2(t1.$index(file, "key"), t1.$index(file, "data"));
          loadNext = true;
          break;
        default:
          loadNext = true;
      }
      if (loadNext)
        this.nextFile$2(index, true);
    }, "call$1", "get$fileComplete", 2, 0, 60, 243, [], "fileComplete"],
    jsonLoadComplete$1: [function(index) {
      var t1, file, data, t2, t3;
      if (J.$index$asx(this._fileList, index) == null) {
        window;
        t1 = "Phaser.Loader jsonLoadComplete invalid index " + H.S(index);
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      file = J.$index$asx(this._fileList, index);
      data = C.JsonCodec_null_null.decode$1(J.get$responseText$x(this._xhr));
      t1 = J.getInterceptor$ax(file);
      t1.$indexSet(file, "loaded", true);
      if (J.$eq(t1.$index(file, "type"), "tilemap"))
        this.game.get$cache().addTilemap$4(t1.$index(file, "key"), t1.$index(file, "url"), data, t1.$index(file, "format"));
      else {
        t2 = J.$eq(t1.$index(file, "type"), "json");
        t3 = this.game;
        if (t2)
          t3.get$cache().addJSON$3(t1.$index(file, "key"), t1.$index(file, "url"), data);
        else
          t3.get$cache().addTextureAtlas$5(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), data, t1.$index(file, "format"));
      }
      this.nextFile$2(index, true);
    }, "call$1", "get$jsonLoadComplete", 2, 0, 60, 243, [], "jsonLoadComplete"],
    csvLoadComplete$1: [function(index) {
      var t1, file, data;
      if (J.$index$asx(this._fileList, index) == null) {
        window;
        t1 = C.JSString_methods.$add("Phaser.Loader csvLoadComplete invalid index ", J.toString$0(index));
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      file = J.$index$asx(this._fileList, index);
      data = J.get$responseText$x(this._xhr);
      t1 = J.getInterceptor$ax(file);
      t1.$indexSet(file, "loaded", true);
      this.game.get$cache().addTilemap$4(t1.$index(file, "key"), t1.$index(file, "url"), data, t1.$index(file, "format"));
      this.nextFile$2(index, true);
    }, "call$1", "get$csvLoadComplete", 2, 0, 60, 243, [], "csvLoadComplete"],
    dataLoadError$1: [function(index) {
      var file, t1;
      file = J.$index$asx(this._fileList, index);
      t1 = J.getInterceptor$ax(file);
      t1.$indexSet(file, "loaded", true);
      t1.$indexSet(file, "error", true);
      window;
      t1 = C.JSString_methods.$add("Phaser.Loader dataLoadError: ", t1.$index(file, "key"));
      if (typeof console != "undefined")
        console.warn(t1);
      this.nextFile$2(index, true);
    }, "call$1", "get$dataLoadError", 2, 0, 60, 243, [], "dataLoadError"],
    xmlLoadComplete$1: [function(index) {
      var data, xml, domparser, exception, file, t1;
      data = J.get$responseText$x(this._xhr);
      xml = null;
      try {
        domparser = new DOMParser();
        xml = J.parseFromString$2$x(domparser, data, "text/xml");
      } catch (exception) {
        H.unwrapException(exception);
        xml = null;
      }

      if (xml == null)
        throw H.wrapException(P.Exception_Exception("Phaser.Loader. Invalid XML given"));
      file = J.$index$asx(this._fileList, index);
      t1 = J.getInterceptor$ax(file);
      t1.$indexSet(file, "loaded", true);
      if (J.$eq(t1.$index(file, "type"), "bitmapfont"))
        this.game.get$cache().addBitmapFont$6(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), xml, t1.$index(file, "xSpacing"), t1.$index(file, "ySpacing"));
      else if (J.$eq(t1.$index(file, "type"), "textureatlas"))
        this.game.get$cache().addTextureAtlas$5(t1.$index(file, "key"), t1.$index(file, "url"), t1.$index(file, "data"), xml, t1.$index(file, "format"));
      this.nextFile$2(index, true);
    }, "call$1", "get$xmlLoadComplete", 2, 0, 60, 243, [], "xmlLoadComplete"],
    nextFile$2: [function(previousIndex, success) {
      var t1, t2;
      t1 = J.$add$ns(this.progressFloat, this._progressChunk);
      this.progressFloat = t1;
      t1 = J.round$0$n(t1);
      this.progress = t1;
      if (t1 > 100)
        this.progress = 100;
      t1 = this.preloadSprite;
      if (t1 != null) {
        t1 = J.$eq(J.$index$asx(t1, "direction"), 0);
        t2 = this.preloadSprite;
        if (t1) {
          J.set$width$x(J.$index$asx(t2, "rect"), J.floor$0$n(J.$mul$ns(J.$div$n(J.$index$asx(this.preloadSprite, "width"), 100), this.progress)));
          J.$index$asx(this.preloadSprite, "sprite").crop$1(J.$index$asx(this.preloadSprite, "rect"));
        } else {
          J.set$height$x(J.$index$asx(t2, "rect"), J.floor$0$n(J.$mul$ns(J.$div$n(J.$index$asx(this.preloadSprite, "height"), 100), this.progress)));
          J.$index$asx(this.preloadSprite, "sprite").crop$1(J.$index$asx(this.preloadSprite, "rect"));
        }
      }
      this.onFileComplete.dispatch$1([this.progress, J.$index$asx(J.$index$asx(this._fileList, previousIndex), "key"), success, this.totalLoadedFiles$0(), J.get$length$asx(this._fileList)]);
      if (this.totalQueuedFiles$0() > 0) {
        this._fileIndex = J.$add$ns(this._fileIndex, 1);
        this.loadFile$0();
      } else {
        this.hasLoaded = true;
        this.isLoading = false;
        J.clear$0$ax(this._fileList);
        this.onLoadComplete.dispatch$0();
      }
    }, "call$2", "get$nextFile", 4, 0, 1401, 1407, [], 1402, [], "nextFile"],
    totalLoadedFiles$0: [function() {
      var total, i, t1;
      total = 0;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._fileList);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(J.$index$asx(this._fileList, i), "loaded") === true)
          ++total;
        ++i;
      }
      return total;
    }, "call$0", "get$totalLoadedFiles", 0, 0, 13, "totalLoadedFiles"],
    totalQueuedFiles$0: [function() {
      var total, i, t1;
      total = 0;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._fileList);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$eq(J.$index$asx(J.$index$asx(this._fileList, i), "loaded"), false))
          ++total;
        ++i;
      }
      return total;
    }, "call$0", "get$totalQueuedFiles", 0, 0, 367, "totalQueuedFiles"],
    totalLoadedPacks$0: [function() {
      var total, i, t1;
      total = 0;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._packList);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(J.$index$asx(this._packList, i), "loaded") === true)
          ++total;
        ++i;
      }
      return total;
    }, "call$0", "get$totalLoadedPacks", 0, 0, 13, "totalLoadedPacks"],
    totalQueuedPacks$0: [function() {
      var total, i, t1;
      total = 0;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._packList);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$eq(J.$index$asx(J.$index$asx(this._packList, i), "loaded"), false))
          ++total;
        ++i;
      }
      return total;
    }, "call$0", "get$totalQueuedPacks", 0, 0, 13, "totalQueuedPacks"],
    Loader$1: function(game) {
      this.isLoading = false;
      this.hasLoaded = false;
      this.progress = 0;
      this.progressFloat = 0;
      this.preloadSprite = null;
      this.crossOrigin = null;
      this.baseURL = "";
      this.onLoadStart = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onFileStart = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onFileComplete = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onFileError = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onLoadComplete = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onPackComplete = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this._packList = [];
      this._packIndex = 0;
      this._fileList = [];
      this._fileIndex = 0;
      this._progressChunk = 0;
      this._xhr = new XMLHttpRequest();
    },
    static: {"^": "Loader_TEXTURE_ATLAS_JSON_ARRAY<-599,Loader_TEXTURE_ATLAS_JSON_HASH<-599,Loader_TEXTURE_ATLAS_XML_STARLING<-599,Loader_PHYSICS_LIME_CORONA_JSON<-599,Loader_PHYSICS_PHASER_JSON<-599,Loader_Format<-921", Loader$0: [function(game) {
        var t1 = new R.Loader(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Loader$1(game);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new Loader"]}
  },
  "+Loader": [632],
  Loader_loadFile_closure: {
    "^": "Closure:63;_this_0",
    call$1: [function(e) {
      var t1 = this._this_0;
      return t1.fileComplete$1(t1._fileIndex);
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  Loader_loadFile_closure0: {
    "^": "Closure:63;_this_1",
    call$1: [function(e) {
      var t1 = this._this_1;
      return t1.fileError$1(t1._fileIndex);
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  Loader_loadFile_closure1: {
    "^": "Closure:63;_this_2",
    call$1: [function(e) {
      var t1 = this._this_2;
      return t1.fileError$1(t1._fileIndex);
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  Loader_loadFile_closure2: {
    "^": "Closure:63;this_3",
    call$1: [function(e) {
      var t1, t2, t3;
      t1 = $.get$GAMES();
      t2 = this.this_3;
      t3 = J.get$id$x(t2.game);
      if (t3 >>> 0 !== t3 || t3 >= t1.length)
        return H.ioore(t1, t3);
      J.get$load$x(t1[t3]).fileComplete$1(t2._fileIndex);
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  Loader_xhrLoad_closure: {
    "^": "Closure:63;index_0,onLoad_1",
    call$1: [function(e) {
      return this.onLoad_1.call$1(this.index_0);
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  Loader_xhrLoad_closure0: {
    "^": "Closure:63;index_2,onError_3",
    call$1: [function(e) {
      return this.onError_3.call$1(this.index_2);
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  Loader_fileComplete_closure: {
    "^": "Closure:1408;that_0,key_1",
    call$1: [function(buffer) {
      var t1, t2;
      if (buffer != null) {
        t1 = this.that_0;
        t2 = this.key_1;
        t1.game.get$cache().decodedSound$2(t2, buffer);
        t1.game.get$sound().get$onSoundDecode().dispatch$1([t2, t1.game.get$cache().getSound$1(t2)]);
      }
    }, "call$1", null, 2, 0, 1408, 860, [], "call"],
    $isFunction: true
  },
  Loader_fileComplete_closure0: {
    "^": "Closure:63;this_2,index_3",
    call$1: [function(e) {
      var t1, t2;
      t1 = $.get$GAMES();
      t2 = J.get$id$x(this.this_2.game);
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      J.get$load$x(t1[t2]).fileComplete$1(this.index_3);
    }, "call$1", null, 2, 0, 63, 312, [], "call"],
    $isFunction: true
  },
  LoaderParser: {
    "^": "Object;",
    static: {LoaderParser$: [function() {
        return new R.LoaderParser();
      }, null, null, 0, 0, 325, "new LoaderParser"], LoaderParser_bitmapFont: [function(game, xml, cacheKey, xSpacing, ySpacing) {
        var data, t1, t2, info, common, letters, i, charCode, t3, t4, t5, t6, t7, t8, kernings, first, second, amount;
        data = new M.ChartData(null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        t1 = J.getInterceptor$x(xml);
        t2 = t1.getElementsByTagName$1(xml, "info");
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        info = t2[0];
        t2 = t1.getElementsByTagName$1(xml, "common");
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        common = t2[0];
        t2 = J.getInterceptor$x(info);
        data.font = t2.getAttribute$1(info, "face");
        data.size = H.Primitives_parseInt(t2.getAttribute$1(info, "size"), null, null);
        data.lineHeight = J.$add$ns(H.Primitives_parseInt(J.getAttribute$1$x(common, "lineHeight"), null, null), ySpacing);
        data.chars = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        letters = t1.getElementsByTagName$1(xml, "char");
        for (i = 0; i < letters.length; ++i) {
          charCode = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "id"), null, null);
          if (i >= letters.length)
            return H.ioore(letters, i);
          t2 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "x"), null, null);
          if (i >= letters.length)
            return H.ioore(letters, i);
          t3 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "y"), null, null);
          if (i >= letters.length)
            return H.ioore(letters, i);
          t4 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "width"), null, null);
          if (i >= letters.length)
            return H.ioore(letters, i);
          t5 = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "height"), null, null);
          t6 = data.chars;
          t7 = new M.Char(null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
          if (i >= letters.length)
            return H.ioore(letters, i);
          t7.xOffset = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "xoffset"), null, null);
          if (i >= letters.length)
            return H.ioore(letters, i);
          t7.yOffset = H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "yoffset"), null, null);
          if (i >= letters.length)
            return H.ioore(letters, i);
          t7.xAdvance = J.$add$ns(H.Primitives_parseInt(J.getAttribute$1$x(letters[i], "xadvance"), null, null), xSpacing);
          t7.kernings = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
          t8 = $.get$TextureCache();
          t5 = M.Texture$(J.$index$asx($.get$BaseTextureCache(), cacheKey), new M.Rectangle0(t2, t3, t4, t5));
          J.$indexSet$ax(t8, cacheKey, t5);
          t7.texture = t5;
          J.$indexSet$ax(t6, charCode, t7);
        }
        kernings = t1.getElementsByTagName$1(xml, "kerning");
        for (i = 0; i < kernings.length; ++i) {
          first = H.Primitives_parseInt(J.getAttribute$1$x(kernings[i], "first"), null, null);
          if (i >= kernings.length)
            return H.ioore(kernings, i);
          second = H.Primitives_parseInt(J.getAttribute$1$x(kernings[i], "second"), null, null);
          if (i >= kernings.length)
            return H.ioore(kernings, i);
          amount = H.Primitives_parseInt(J.getAttribute$1$x(kernings[i], "amount"), null, null);
          J.$indexSet$ax(J.$index$asx(data.chars, second).get$kernings(), first, amount);
        }
        J.$indexSet$ax($.get$BitmapText_fonts(), cacheKey, data);
      }, "call$5", "LoaderParser_bitmapFont$closure", 10, 0, 326, 214, [], 241, [], 239, [], 291, [], 292, [], "bitmapFont"]}
  },
  "+LoaderParser": [632],
  SinCosTable: {
    "^": "Object;sin@-1409,cos@-1409,length*-599",
    static: {SinCosTable$: [function() {
        return new R.SinCosTable(null, null, null);
      }, null, null, 0, 0, 327, "new SinCosTable"]}
  },
  "+SinCosTable": [632],
  Math: {
    "^": "Object;",
    static: {"^": "Math_SQRT1_2<-629,Math_SQRT2<-629,Math_PI<-629,Math_PI2<-629,Math_random<-1337,Math__degreeToRadiansFactor<-629,Math__radianToDegreesFactor<-629", Math$_: [function() {
        return new R.Math();
      }, null, null, 0, 0, 13, "new Math$_"], Math_pow: [function(th, exp) {
        if (typeof th !== "number")
          H.throwExpression(P.ArgumentError$(th));
        if (typeof exp !== "number")
          H.throwExpression(P.ArgumentError$(exp));
        return Math.pow(th, exp);
      }, "call$2", "Math_pow$closure", 4, 0, 328, 329, [], 330, [], "pow"], Math_cos: [function(th) {
        if (typeof th !== "number")
          H.throwExpression(P.ArgumentError$(th));
        return Math.cos(th);
      }, "call$1", "Math_cos$closure", 2, 0, 331, 329, [], "cos"], Math_sin: [function(th) {
        if (typeof th !== "number")
          H.throwExpression(P.ArgumentError$(th));
        return Math.sin(th);
      }, "call$1", "Math_sin$closure", 2, 0, 331, 329, [], "sin"], Math_abs: [function(val) {
        return J.abs$0$n(val);
      }, "call$1", "Math_abs$closure", 2, 0, 331, 332, [], "abs"], Math_sqrt: [function(val) {
        if (typeof val !== "number")
          H.throwExpression(P.ArgumentError$(val));
        return Math.sqrt(val);
      }, "call$1", "Math_sqrt$closure", 2, 0, 331, 332, [], "sqrt"], Math_atan2: [function(a, b) {
        if (typeof a !== "number")
          H.throwExpression(P.ArgumentError$(a));
        if (typeof b !== "number")
          H.throwExpression(P.ArgumentError$(b));
        return Math.atan2(a, b);
      }, "call$2", "Math_atan2$closure", 4, 0, 328, 304, [], 305, [], "atan2"], Math_round: [function(val) {
        return J.round$0$n(val);
      }, "call$1", "Math_round$closure", 2, 0, 331, 332, [], "round"], Math_fuzzyEqual: [function(a, b, epsilon) {
        return J.$lt$n(J.abs$0$n(J.$sub$n(a, b)), epsilon);
      }, function(a, b) {
        return R.Math_fuzzyEqual(a, b, 0.0001);
      }, null, "call$3", "call$2", "Math_fuzzyEqual$closure", 4, 2, 333, 334, 304, [], 305, [], 335, [], "fuzzyEqual"], Math_fuzzyLessThan: [function(a, b, epsilon) {
        return J.$lt$n(a, J.$add$ns(b, epsilon));
      }, function(a, b) {
        return R.Math_fuzzyLessThan(a, b, 0.0001);
      }, null, "call$3", "call$2", "Math_fuzzyLessThan$closure", 4, 2, 333, 334, 304, [], 305, [], 335, [], "fuzzyLessThan"], Math_fuzzyGreaterThan: [function(a, b, epsilon) {
        return J.$gt$n(a, J.$sub$n(b, epsilon));
      }, function(a, b) {
        return R.Math_fuzzyGreaterThan(a, b, 0.0001);
      }, null, "call$3", "call$2", "Math_fuzzyGreaterThan$closure", 4, 2, 333, 334, 304, [], 305, [], 335, [], "fuzzyGreaterThan"], Math_fuzzyCeil: [function(val, epsilon) {
        return J.ceil$0$n(J.$sub$n(val, epsilon));
      }, function(val) {
        return R.Math_fuzzyCeil(val, 0.0001);
      }, null, "call$2", "call$1", "Math_fuzzyCeil$closure", 2, 2, 336, 334, 332, [], 335, [], "fuzzyCeil"], Math_fuzzyFloor: [function(val, epsilon) {
        return J.floor$0$n(J.$add$ns(val, epsilon));
      }, function(val) {
        return R.Math_fuzzyFloor(val, 0.0001);
      }, null, "call$2", "call$1", "Math_fuzzyFloor$closure", 2, 2, 336, 334, 332, [], 335, [], "fuzzyFloor"], Math_average: [function(args) {
        var t1 = J.getInterceptor$ax(args);
        return J.$div$n(t1.fold$2(args, 0, new R.Math_average_closure()), t1.get$length(args));
      }, "call$1", "Math_average$closure", 2, 0, 337, 338, [], "average"], Math_truncate: [function(n) {
        var t1 = J.getInterceptor$n(n);
        return t1.$gt(n, 0) ? t1.floor$0(n) : t1.ceil$0(n);
      }, "call$1", "Math_truncate$closure", 2, 0, 339, 340, [], "truncate"], Math_shear: [function(n) {
        return J.$mod$n(n, 1);
      }, "call$1", "Math_shear$closure", 2, 0, 210, 340, [], "shear"], Math_snapTo: [function(input, gap, start) {
        var t1 = J.getInterceptor(gap);
        if (t1.$eq(gap, 0))
          return input;
        return J.$add$ns(start, t1.$mul(gap, J.round$0$n(J.$div$n(J.$sub$n(input, start), gap))));
      }, function(input, gap) {
        return R.Math_snapTo(input, gap, 0);
      }, null, "call$3", "call$2", "Math_snapTo$closure", 4, 2, 341, 5, 342, [], 343, [], 223, [], "snapTo"], Math_snapToFloor: [function(input, gap, start) {
        var t1 = J.getInterceptor(gap);
        if (t1.$eq(gap, 0))
          return input;
        return J.$add$ns(start, t1.$mul(gap, J.floor$0$n(J.$div$n(J.$sub$n(input, start), gap))));
      }, function(input, gap) {
        return R.Math_snapToFloor(input, gap, 0);
      }, null, "call$3", "call$2", "Math_snapToFloor$closure", 4, 2, 341, 5, 342, [], 343, [], 223, [], "snapToFloor"], Math_snapToCeil: [function(input, gap, start) {
        var t1 = J.getInterceptor(gap);
        if (t1.$eq(gap, 0))
          return input;
        return J.$add$ns(start, t1.$mul(gap, J.ceil$0$n(J.$div$n(J.$sub$n(input, start), gap))));
      }, function(input, gap) {
        return R.Math_snapToCeil(input, gap, 0);
      }, null, "call$3", "call$2", "Math_snapToCeil$closure", 4, 2, 341, 5, 342, [], 343, [], 223, [], "snapToCeil"], Math_snapToInArray: [function(input, arr, sort) {
        var t1, t2, i, low, t3, high;
        if (sort === true)
          J.sort$0$ax(arr);
        t1 = J.getInterceptor$asx(arr);
        t2 = J.getInterceptor$n(input);
        if (t2.$lt(input, t1.$index(arr, 0)))
          return t1.$index(arr, 0);
        for (i = 1; J.$lt$n(t1.$index(arr, i), input);)
          ++i;
        low = t1.$index(arr, i - 1);
        t3 = t1.get$length(arr);
        if (typeof t3 !== "number")
          return H.iae(t3);
        high = i < t3 ? t1.$index(arr, i) : 1 / 0;
        return J.$le$n(J.$sub$n(high, input), t2.$sub(input, low)) ? high : low;
      }, function(input, arr) {
        return R.Math_snapToInArray(input, arr, true);
      }, null, "call$3", "call$2", "Math_snapToInArray$closure", 4, 2, 344, 39, 342, [], 345, [], 346, [], "snapToInArray"], Math_roundTo: [function(value, place, base) {
        var t1, p;
        t1 = J.$negate$n(place);
        if (typeof base !== "number")
          H.throwExpression(P.ArgumentError$(base));
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        p = Math.pow(base, t1);
        return J.round$0$n(J.$div$n(J.$mul$ns(value, p), p));
      }, function(value) {
        return R.Math_roundTo(value, 0, 10);
      }, null, function(value, place) {
        return R.Math_roundTo(value, place, 10);
      }, null, "call$3", "call$1", "call$2", "Math_roundTo$closure", 2, 4, 347, 5, 348, 100, [], 349, [], 350, [], "roundTo"], Math_floorTo: [function(value, place, base) {
        var t1, p;
        t1 = J.$negate$n(place);
        if (typeof base !== "number")
          H.throwExpression(P.ArgumentError$(base));
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        p = Math.pow(base, t1);
        return J.floor$0$n(J.$div$n(J.$mul$ns(value, p), p));
      }, function(value) {
        return R.Math_floorTo(value, 0, 10);
      }, null, function(value, place) {
        return R.Math_floorTo(value, place, 10);
      }, null, "call$3", "call$1", "call$2", "Math_floorTo$closure", 2, 4, 347, 5, 348, 100, [], 349, [], 350, [], "floorTo"], Math_ceilTo: [function(value, place, base) {
        var t1, p;
        t1 = J.$negate$n(place);
        if (typeof base !== "number")
          H.throwExpression(P.ArgumentError$(base));
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        p = Math.pow(base, t1);
        return J.floor$0$n(J.$div$n(J.$mul$ns(value, p), p));
      }, function(value) {
        return R.Math_ceilTo(value, 0, 10);
      }, null, function(value, place) {
        return R.Math_ceilTo(value, place, 10);
      }, null, "call$3", "call$1", "call$2", "Math_ceilTo$closure", 2, 4, 347, 5, 348, 100, [], 349, [], 350, [], "ceilTo"], Math_interpolateFloat: [function(a, b, weight) {
        return J.$add$ns(J.$mul$ns(J.$sub$n(b, a), weight), a);
      }, "call$3", "Math_interpolateFloat$closure", 6, 0, 351, 304, [], 305, [], 352, [], "interpolateFloat"], Math_angleBetween: [function(x1, y1, x2, y2) {
        var t1, t2;
        t1 = J.$sub$n(y2, y1);
        t2 = J.$sub$n(x2, x1);
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        if (typeof t2 !== "number")
          H.throwExpression(P.ArgumentError$(t2));
        return Math.atan2(t1, t2);
      }, "call$4", "Math_angleBetween$closure", 8, 0, 353, 307, [], 308, [], 309, [], 310, [], "angleBetween"], Math_angleBetweenPoints: [function(point1, point2) {
        var t1, t2, t3;
        t1 = J.getInterceptor$x(point2);
        t2 = J.getInterceptor$x(point1);
        t3 = J.$sub$n(t1.get$y(point2), t2.get$y(point1));
        point1 = J.$sub$n(t1.get$x(point2), t2.get$x(point1));
        if (typeof t3 !== "number")
          H.throwExpression(P.ArgumentError$(t3));
        if (typeof point1 !== "number")
          H.throwExpression(P.ArgumentError$(point1));
        return Math.atan2(t3, point1);
      }, "call$2", "Math_angleBetweenPoints$closure", 4, 0, 354, 355, [], 356, [], "angleBetweenPoints"], Math_reverseAngle: [function(angleRad) {
        angleRad = J.$mod$n(J.$add$ns(angleRad, 3.141592653589793), 6.283185307179586);
        return angleRad >= 0 ? angleRad : angleRad + 6.283185307179586;
      }, "call$1", "Math_reverseAngle$closure", 2, 0, 331, 357, [], "reverseAngle"], Math_normalizeAngle: [function(angleRad) {
        angleRad = J.$mod$n(angleRad, 6.283185307179586);
        return angleRad >= 0 ? angleRad : angleRad + 6.283185307179586;
      }, "call$1", "Math_normalizeAngle$closure", 2, 0, 331, 357, [], "normalizeAngle"], Math_normalizeLatitude: [function(lat) {
        return P.max(-90, P.min(90, lat));
      }, "call$1", "Math_normalizeLatitude$closure", 2, 0, 331, 358, [], "normalizeLatitude"], Math_normalizeLongitude: [function(lng) {
        var t1 = J.getInterceptor$n(lng);
        if (t1.$mod(lng, 360) === 180)
          return 180;
        lng = t1.$mod(lng, 360);
        if (lng < -180)
          t1 = lng + 360;
        else
          t1 = lng > 180 ? lng - 360 : lng;
        return t1;
      }, "call$1", "Math_normalizeLongitude$closure", 2, 0, 331, 359, [], "normalizeLongitude"], Math_chanceRoll: [function(chance) {
        var t1 = J.getInterceptor$n(chance);
        if (t1.$le(chance, 0))
          return false;
        else if (t1.$ge(chance, 100))
          return true;
        else if (J.$ge$n(J.$mul$ns($.get$Math_random().call$0(), 100), chance))
          return false;
        else
          return true;
      }, function() {
        return R.Math_chanceRoll(50);
      }, null, "call$1", "call$0", "Math_chanceRoll$closure", 0, 2, 360, 361, 362, [], "chanceRoll"], Math_numberArray: [function(min, max) {
        var result, i, t1;
        result = [];
        for (i = min; t1 = J.getInterceptor$n(i), t1.$le(i, max); i = t1.$add(i, 1))
          result.push(i);
        return result;
      }, "call$2", "Math_numberArray$closure", 4, 0, 363, 364, [], 365, [], "numberArray"], Math_maxAdd: [function(value, amount, max) {
        value = J.$add$ns(value, amount);
        return J.$gt$n(value, max) ? max : value;
      }, "call$3", "Math_maxAdd$closure", 6, 0, 351, 100, [], 366, [], 365, [], "maxAdd"], Math_minSub: [function(value, amount, min) {
        value = J.$sub$n(value, amount);
        return J.$lt$n(value, min) ? min : value;
      }, "call$3", "Math_minSub$closure", 6, 0, 351, 100, [], 366, [], 364, [], "minSub"], Math_wrap: [function(value, min, max) {
        var range, result;
        range = J.$sub$n(max, min);
        if (J.$le$n(range, 0))
          return 0;
        result = J.$mod$n(J.$sub$n(value, min), range);
        if (result < 0) {
          if (typeof range !== "number")
            return H.iae(range);
          result += range;
        }
        if (typeof min !== "number")
          return H.iae(min);
        return result + min;
      }, "call$3", "Math_wrap$closure", 6, 0, 351, 100, [], 364, [], 365, [], "wrap"], Math_wrapValue: [function(value, amount, max) {
        value = J.abs$0$n(value);
        amount = J.abs$0$n(amount);
        max = J.abs$0$n(max);
        return J.$mod$n(J.$add$ns(value, amount), max);
      }, "call$3", "Math_wrapValue$closure", 6, 0, 351, 100, [], 366, [], 365, [], "wrapValue"], Math_limitValue: [function(value, min, max) {
        var t1 = J.getInterceptor$n(value);
        if (t1.$lt(value, min))
          t1 = min;
        else
          t1 = t1.$gt(value, max) ? max : value;
        return t1;
      }, "call$3", "Math_limitValue$closure", 6, 0, 351, 100, [], 364, [], 365, [], "limitValue"], Math_randomSign: [function() {
        return J.$gt$n($.get$Math_random().call$0(), 0.5) ? 1 : -1;
      }, "call$0", "Math_randomSign$closure", 0, 0, 367, "randomSign"], Math_isOdd: [function(n) {
        return J.$mod$n(n, 2) === 1;
      }, "call$1", "Math_isOdd$closure", 2, 0, 368, 340, [], "isOdd"], Math_isEven: [function(n) {
        return J.$mod$n(n, 2) === 0;
      }, "call$1", "Math_isEven$closure", 2, 0, 368, 340, [], "isEven"], Math_min: [function(a, b) {
        return P.min(a, b);
      }, "call$2", "Math_min$closure", 4, 0, 328, 304, [], 305, [], "min"], Math_max: [function(a, b) {
        return P.max(a, b);
      }, "call$2", "Math_max$closure", 4, 0, 328, 304, [], 305, [], "max"], Math_minList: [function(args) {
        return J.fold$2$ax(args, 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368, new R.Math_minList_closure());
      }, "call$1", "Math_minList$closure", 2, 0, 369, 338, [], "minList"], Math_maxList: [function(args) {
        return J.fold$2$ax(args, -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368, new R.Math_maxList_closure());
      }, "call$1", "Math_maxList$closure", 2, 0, 369, 338, [], "maxList"], Math_minProperty: [function(args, prop) {
        return J.fold$2$ax(J.map$1$ax(args, prop), 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368, new R.Math_minProperty_closure());
      }, "call$2", "Math_minProperty$closure", 4, 0, 370, 338, [], 371, [], "minProperty"], Math_maxProperty: [function(args, prop) {
        return J.fold$2$ax(J.map$1$ax(args, prop), -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368, new R.Math_maxProperty_closure());
      }, "call$2", "Math_maxProperty$closure", 4, 0, 370, 338, [], 371, [], "maxProperty"], Math_wrapAngle: [function(angle, radians) {
        var radianFactor = radians === true ? 0.017453292519943295 : 1;
        return R.Math_wrap(angle, -180 * radianFactor, 180 * radianFactor);
      }, function(angle) {
        return R.Math_wrapAngle(angle, false);
      }, null, "call$2", "call$1", "Math_wrapAngle$closure", 2, 2, 372, 95, 373, [], 374, [], "wrapAngle"], Math_angleLimit: [function(angle, min, max) {
        var t1, result;
        t1 = J.getInterceptor$n(angle);
        if (t1.$gt(angle, max))
          result = max;
        else
          result = t1.$lt(angle, min) ? min : angle;
        return result;
      }, "call$3", "Math_angleLimit$closure", 6, 0, 351, 373, [], 364, [], 365, [], "angleLimit"], Math_linearInterpolation: [function(v, k) {
        var t1, m, t2, f, t3, i, t4;
        t1 = J.getInterceptor$asx(v);
        m = J.$sub$n(t1.get$length(v), 1);
        t2 = J.getInterceptor$ns(m);
        f = t2.$mul(m, k);
        t3 = J.getInterceptor$n(f);
        i = t3.floor$0(f);
        t4 = J.getInterceptor$n(k);
        if (t4.$lt(k, 0)) {
          t2 = t1.$index(v, 0);
          return J.$add$ns(J.$mul$ns(J.$sub$n(t1.$index(v, 1), t2), f), t2);
        }
        if (t4.$gt(k, 1)) {
          t3 = t1.$index(v, m);
          t1 = t1.$index(v, t2.$sub(m, 1));
          t2 = t2.$sub(m, f);
          return J.$add$ns(J.$mul$ns(J.$sub$n(t1, t3), t2), t3);
        }
        t2 = t1.$index(v, i);
        t4 = i + 1;
        if (typeof m !== "number")
          return H.iae(m);
        if (t4 > m)
          t4 = m;
        t4 = t1.$index(v, t4);
        t3 = t3.$sub(f, i);
        return J.$add$ns(J.$mul$ns(J.$sub$n(t4, t2), t3), t2);
      }, "call$2", "Math_linearInterpolation$closure", 4, 0, 375, 376, [], 377, [], "linearInterpolation"], Math_bezierInterpolation: [function(v, k) {
        var t1, n, b, i, t2, t3, t4, t5;
        t1 = J.getInterceptor$asx(v);
        n = J.$sub$n(t1.get$length(v), 1);
        if (typeof n !== "number")
          return H.iae(n);
        b = 0;
        i = 0;
        for (; i <= n; ++i) {
          if (typeof k !== "number")
            return H.iae(k);
          t2 = n - i;
          t3 = Math.pow(1 - k, t2);
          t4 = Math.pow(k, i);
          t5 = t1.$index(v, i);
          if (typeof t5 !== "number")
            return H.iae(t5);
          t2 = J.$div$n(J.$div$n(R.Math_factorial(n), R.Math_factorial(i)), R.Math_factorial(t2));
          if (typeof t2 !== "number")
            return H.iae(t2);
          b += t3 * t4 * t5 * t2;
        }
        return b;
      }, "call$2", "Math_bezierInterpolation$closure", 4, 0, 375, 376, [], 377, [], "bezierInterpolation"], Math_catmullRomInterpolation: [function(v, k) {
        var t1, m, t2, f, t3, i, t4, t5, t6, t7;
        t1 = J.getInterceptor$asx(v);
        m = J.$sub$n(t1.get$length(v), 1);
        t2 = J.getInterceptor$ns(m);
        f = t2.$mul(m, k);
        t3 = J.getInterceptor$n(f);
        i = t3.floor$0(f);
        if (J.$eq(t1.$index(v, 0), t1.$index(v, m))) {
          if (J.$lt$n(k, 0)) {
            if (typeof k !== "number")
              return H.iae(k);
            f = t2.$mul(m, 1 + k);
            i = J.floor$0$n(f);
          }
          if (typeof m !== "number")
            return H.iae(m);
          return R.Math_catmullRom(t1.$index(v, C.JSNumber_methods.$mod(i - 1 + m, m)), t1.$index(v, i), t1.$index(v, C.JSInt_methods.$mod(i + 1, m)), t1.$index(v, C.JSInt_methods.$mod(i + 2, m)), J.$sub$n(f, i));
        } else {
          t4 = J.getInterceptor$n(k);
          if (t4.$lt(k, 0)) {
            t2 = t1.$index(v, 0);
            t3 = R.Math_catmullRom(t1.$index(v, 0), t1.$index(v, 0), t1.$index(v, 1), t1.$index(v, 1), t3.$negate(f));
            t1 = t1.$index(v, 0);
            if (typeof t1 !== "number")
              return H.iae(t1);
            return J.$sub$n(t2, t3 - t1);
          }
          if (t4.$gt(k, 1)) {
            t4 = t1.$index(v, m);
            t3 = R.Math_catmullRom(t1.$index(v, m), t1.$index(v, m), t1.$index(v, t2.$sub(m, 1)), t1.$index(v, t2.$sub(m, 1)), t3.$sub(f, m));
            t1 = t1.$index(v, m);
            if (typeof t1 !== "number")
              return H.iae(t1);
            return J.$sub$n(t4, t3 - t1);
          }
          t4 = t1.$index(v, 0);
          t5 = t1.$index(v, i);
          t6 = i + 1;
          t6 = t1.$index(v, t2.$lt(m, t6) ? m : t6);
          t7 = i + 2;
          return R.Math_catmullRom(t4, t5, t6, t1.$index(v, t2.$lt(m, t7) ? m : t7), t3.$sub(f, i));
        }
      }, "call$2", "Math_catmullRomInterpolation$closure", 4, 0, 375, 376, [], 377, [], "catmullRomInterpolation"], Math_linear: [function(p0, p1, t) {
        return J.$add$ns(J.$mul$ns(J.$sub$n(p1, p0), t), p0);
      }, "call$3", "Math_linear$closure", 6, 0, 351, 378, [], 379, [], 380, [], "linear"], Math_bernstein: [function(n, i) {
        return J.$div$n(J.$div$n(R.Math_factorial(n), R.Math_factorial(i)), R.Math_factorial(J.$sub$n(n, i)));
      }, "call$2", "Math_bernstein$closure", 4, 0, 328, 340, [], 381, [], "bernstein"], Math_factorial: [function(value) {
        var res;
        if (J.$eq(value, 0))
          return 1;
        for (res = value; value = J.$sub$n(value, 1), J.$ge$n(value, 0);)
          res = J.$mul$ns(res, value);
        return res;
      }, "call$1", "Math_factorial$closure", 2, 0, 331, 100, [], "factorial"], Math_catmullRom: [function(p0, p1, p2, p3, t) {
        var v0, v1, t1, t2, t3;
        v0 = J.$mul$ns(J.$sub$n(p2, p0), 0.5);
        v1 = J.$mul$ns(J.$sub$n(p3, p1), 0.5);
        t1 = J.getInterceptor$ns(t);
        t2 = t1.$mul(t, t);
        t3 = t1.$mul(t, t2);
        if (typeof p1 !== "number")
          return H.iae(p1);
        if (typeof p2 !== "number")
          return H.iae(p2);
        if (typeof v0 !== "number")
          return H.iae(v0);
        if (typeof v1 !== "number")
          return H.iae(v1);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (typeof t !== "number")
          return H.iae(t);
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
      }, "call$5", "Math_catmullRom$closure", 10, 0, 382, 378, [], 379, [], 383, [], 384, [], 380, [], "catmullRom"], Math_difference: [function(a, b) {
        return J.abs$0$n(J.$sub$n(a, b));
      }, "call$2", "Math_difference$closure", 4, 0, 328, 304, [], 305, [], "difference"], Math_getRandom: [function(objects, startIndex, $length) {
        var t1, l;
        if (objects != null) {
          t1 = J.getInterceptor($length);
          l = t1.$eq($length, 0) || t1.$gt($length, J.$sub$n(J.get$length$asx(objects), startIndex)) ? J.$sub$n(J.get$length$asx(objects), startIndex) : $length;
          if (J.$gt$n(l, 0))
            return J.$index$asx(objects, J.$add$ns(startIndex, J.floor$0$n(J.$mul$ns($.get$Math_random().call$0(), l))));
        }
        return;
      }, function(objects) {
        return R.Math_getRandom(objects, 0, 0);
      }, null, function(objects, startIndex) {
        return R.Math_getRandom(objects, startIndex, 0);
      }, null, "call$3", "call$1", "call$2", "Math_getRandom$closure", 2, 4, 385, 5, 5, 386, [], 387, [], 388, [], "getRandom"], Math_removeRandom: [function(objects, startIndex, $length) {
        var t1, l;
        if (objects != null) {
          t1 = J.getInterceptor($length);
          l = t1.$eq($length, 0) || t1.$gt($length, J.$sub$n(J.get$length$asx(objects), startIndex)) ? J.$sub$n(J.get$length$asx(objects), startIndex) : $length;
          if (J.$gt$n(l, 0))
            return J.$index$asx(J.removeAt$1$ax(objects, J.toInt$0$n(J.$add$ns(startIndex, J.$mul$ns($.get$Math_random().call$0(), l)))), 0);
        }
        return;
      }, function(objects) {
        return R.Math_removeRandom(objects, 0, 0);
      }, null, function(objects, startIndex) {
        return R.Math_removeRandom(objects, startIndex, 0);
      }, null, "call$3", "call$1", "call$2", "Math_removeRandom$closure", 2, 4, 385, 5, 5, 386, [], 387, [], 388, [], "removeRandom"], Math_floor: [function(value) {
        return J.floor$0$n(value);
      }, "call$1", "Math_floor$closure", 2, 0, 339, 100, [], "floor"], Math_ceil: [function(value) {
        return J.ceil$0$n(value);
      }, "call$1", "Math_ceil$closure", 2, 0, 339, 100, [], "ceil"], Math_sinCosGenerator: [function($length, sinAmplitude, cosAmplitude, frequency) {
        var frq, t1, cosTable, sinTable, cos, sin, c, t2, t3;
        frq = J.$div$n(J.$mul$ns(frequency, 3.141592653589793), $length);
        t1 = P.num;
        cosTable = H.setRuntimeTypeInfo(new P.DoubleLinkedQueue(null, 0), [t1]);
        t1 = H.setRuntimeTypeInfo(new P._DoubleLinkedQueueEntrySentinel(null, null, null), [t1]);
        t1._link$2(t1, t1);
        cosTable._sentinel = t1;
        t1 = P.num;
        sinTable = H.setRuntimeTypeInfo(new P.DoubleLinkedQueue(null, 0), [t1]);
        t1 = H.setRuntimeTypeInfo(new P._DoubleLinkedQueueEntrySentinel(null, null, null), [t1]);
        t1._link$2(t1, t1);
        sinTable._sentinel = t1;
        if (typeof $length !== "number")
          return H.iae($length);
        cos = cosAmplitude;
        sin = sinAmplitude;
        c = 0;
        for (; c < $length; ++c) {
          t1 = J.getInterceptor$ns(sin);
          cos = J.$sub$n(cos, t1.$mul(sin, frq));
          sin = t1.$add(sin, J.$mul$ns(cos, frq));
          t1 = cosTable._sentinel;
          t2 = new P.DoubleLinkedQueueEntry(null, null, cos);
          t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
          t3 = t1._previous;
          t2._next = t1;
          t2._previous = t3;
          t3.set$_next(t2);
          t1._previous = t2;
          ++cosTable._elementCount;
          t2 = sinTable._sentinel;
          t1 = new P.DoubleLinkedQueueEntry(null, null, sin);
          t1.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
          t3 = t2._previous;
          t1._next = t2;
          t1._previous = t3;
          t3.set$_next(t1);
          t2._previous = t1;
          ++sinTable._elementCount;
        }
        t1 = new R.SinCosTable(null, null, null);
        t1.sin = sinTable;
        t1.cos = cosTable;
        t1.length = $length;
        return t1;
      }, function(length) {
        return R.Math_sinCosGenerator(length, 1, 1, 1);
      }, null, function(length, sinAmplitude) {
        return R.Math_sinCosGenerator(length, sinAmplitude, 1, 1);
      }, null, function(length, sinAmplitude, cosAmplitude) {
        return R.Math_sinCosGenerator(length, sinAmplitude, cosAmplitude, 1);
      }, null, "call$4", "call$1", "call$2", "call$3", "Math_sinCosGenerator$closure", 2, 6, 389, 390, 390, 390, 388, [], 391, [], 392, [], 393, [], "sinCosGenerator"], Math_shift: [function(stack) {
        var s = stack.removeFirst$0();
        J.add$1$ax(stack, s);
        return s;
      }, "call$1", "Math_shift$closure", 2, 0, 394, 395, [], "shift"], Math_shuffleArray: [function(array) {
        var t1 = P.List_List$from(array, true, null);
        H.IterableMixinWorkaround_shuffleList(t1, null);
        return t1;
      }, "call$1", "Math_shuffleArray$closure", 2, 0, 396, 15, [], "shuffleArray"], Math_distance: [function(x1, y1, x2, y2) {
        var dx, dy, t1;
        dx = J.$sub$n(x1, x2);
        dy = J.$sub$n(y1, y2);
        t1 = J.$add$ns(J.$mul$ns(dx, dx), J.$mul$ns(dy, dy));
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        return Math.sqrt(t1);
      }, "call$4", "Math_distance$closure", 8, 0, 353, 307, [], 308, [], 309, [], 310, [], "distance"], Math_distancePow: [function(x1, y1, x2, y2, power) {
        var t1, t2, t3;
        t1 = J.$sub$n(x2, x1);
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        t2 = typeof power !== "number";
        if (t2)
          H.throwExpression(P.ArgumentError$(power));
        t1 = Math.pow(t1, power);
        t3 = J.$sub$n(y2, y1);
        if (typeof t3 !== "number")
          H.throwExpression(P.ArgumentError$(t3));
        if (t2)
          H.throwExpression(P.ArgumentError$(power));
        t2 = Math.pow(t3, power);
        return Math.sqrt(t1 + t2);
      }, function(x1, y1, x2, y2) {
        return R.Math_distancePow(x1, y1, x2, y2, 2);
      }, null, "call$5", "call$4", "Math_distancePow$closure", 8, 2, 397, 398, 307, [], 308, [], 309, [], 310, [], 399, [], "distancePow"], Math_distanceRounded: [function(x1, y1, x2, y2) {
        return C.JSNumber_methods.toInt$0(C.JSDouble_methods.roundToDouble$0(R.Math_distance(x1, y1, x2, y2)));
      }, "call$4", "Math_distanceRounded$closure", 8, 0, 353, 307, [], 308, [], 309, [], 310, [], "distanceRounded"], Math_clamp: [function(x, a, b) {
        var t1 = J.getInterceptor$n(x);
        if (t1.$lt(x, a))
          t1 = a;
        else
          t1 = t1.$gt(x, b) ? b : x;
        return t1;
      }, "call$3", "Math_clamp$closure", 6, 0, 351, 6, [], 304, [], 305, [], "clamp"], Math_clampBottom: [function(x, a) {
        return J.$lt$n(x, a) ? a : x;
      }, "call$2", "Math_clampBottom$closure", 4, 0, 328, 6, [], 304, [], "clampBottom"], Math_within: [function(a, b, tolerance) {
        return J.$le$n(J.abs$0$n(J.$sub$n(a, b)), tolerance);
      }, "call$3", "Math_within$closure", 6, 0, 400, 304, [], 305, [], 401, [], "within"], Math_mapLinear: [function(x, a1, a2, b1, b2) {
        return J.$add$ns(b1, J.$div$n(J.$mul$ns(J.$sub$n(x, a1), J.$sub$n(b2, b1)), J.$sub$n(a2, a1)));
      }, "call$5", "Math_mapLinear$closure", 10, 0, 382, 6, [], 402, [], 403, [], 404, [], 405, [], "mapLinear"], Math_smoothstep: [function(x, min, max) {
        x = P.max(0, P.min(1, J.$div$n(J.$sub$n(x, min), J.$sub$n(max, min))));
        return x * x * (3 - 2 * x);
      }, "call$3", "Math_smoothstep$closure", 6, 0, 351, 6, [], 364, [], 365, [], "smoothstep"], Math_smootherstep: [function(x, min, max) {
        x = P.max(0, P.min(1, J.$div$n(J.$sub$n(x, min), J.$sub$n(max, min))));
        return x * x * x * (x * (x * 6 - 15) + 10);
      }, "call$3", "Math_smootherstep$closure", 6, 0, 351, 6, [], 364, [], 365, [], "smootherstep"], Math_sign: [function(x) {
        return J.get$sign$n(x);
      }, "call$1", "Math_sign$closure", 2, 0, 331, 6, [], "sign"], Math_percent: [function(a, b, base) {
        var t1 = J.getInterceptor$n(a);
        if (t1.$gt(a, b) || J.$gt$n(base, b))
          return 1;
        else if (t1.$lt(a, base) || J.$gt$n(base, a))
          return 0;
        else
          return J.$div$n(t1.$sub(a, base), b);
      }, function(a, b) {
        return R.Math_percent(a, b, 0);
      }, null, "call$3", "call$2", "Math_percent$closure", 4, 2, 406, 5, 304, [], 305, [], 350, [], "percent"], Math_degToRad: [function(degrees) {
        return J.$mul$ns(degrees, 0.017453292519943295);
      }, "call$1", "Math_degToRad$closure", 2, 0, 331, 407, [], "degToRad"], Math_radToDeg: [function(radians) {
        return J.$mul$ns(radians, 57.29577951308232);
      }, "call$1", "Math_radToDeg$closure", 2, 0, 331, 374, [], "radToDeg"]}
  },
  "+Math": [632],
  Math_average_closure: {
    "^": "Closure:935;",
    call$2: [function(a, b) {
      return J.$add$ns(a, b);
    }, "call$2", null, 4, 0, 935, 304, [], 305, [], "call"],
    $isFunction: true
  },
  Math_minList_closure: {
    "^": "Closure:935;",
    call$2: [function(i, n) {
      return J.$lt$n(i, n) ? i : n;
    }, "call$2", null, 4, 0, 935, 381, [], 340, [], "call"],
    $isFunction: true
  },
  Math_maxList_closure: {
    "^": "Closure:935;",
    call$2: [function(i, n) {
      return J.$gt$n(i, n) ? i : n;
    }, "call$2", null, 4, 0, 935, 381, [], 340, [], "call"],
    $isFunction: true
  },
  Math_minProperty_closure: {
    "^": "Closure:935;",
    call$2: [function(i, n) {
      return J.$lt$n(i, n) ? i : n;
    }, "call$2", null, 4, 0, 935, 381, [], 340, [], "call"],
    $isFunction: true
  },
  Math_maxProperty_closure: {
    "^": "Closure:935;",
    call$2: [function(i, n) {
      return J.$gt$n(i, n) ? i : n;
    }, "call$2", null, 4, 0, 935, 381, [], 340, [], "call"],
    $isFunction: true
  },
  Bounds: {
    "^": "Object;x*-599,y*-599,width*-599,height*-599,subWidth@-599,subHeight@-599,right*-599,bottom*-599",
    static: {Bounds$: [function() {
        return new R.Bounds(null, null, null, null, null, null, null, null);
      }, null, null, 0, 0, 408, "new Bounds"]}
  },
  "+Bounds": [632],
  QuadTree: {
    "^": "Object;maxObjects@-599,maxLevels@-599,level@-599,bounds@-1410,objects<-1411,nodes>-1412",
    reset$7: [function(_, x, y, width, height, maxObjects, maxLevels, level) {
      var t1, t2, t3, t4, t5;
      this.maxObjects = maxObjects == null ? 10 : maxObjects;
      this.maxLevels = maxLevels == null ? 4 : maxLevels;
      this.level = level == null ? 0 : level;
      t1 = new R.Bounds(null, null, null, null, null, null, null, null);
      t2 = J.getInterceptor$n(x);
      t1.x = t2.round$0(x);
      t3 = J.getInterceptor$n(y);
      t1.y = t3.round$0(y);
      t1.width = width;
      t1.height = height;
      t4 = J.getInterceptor$n(width);
      t1.subWidth = J.floor$0$n(t4.$div(width, 2));
      t5 = J.getInterceptor$n(height);
      t1.subHeight = J.floor$0$n(t5.$div(height, 2));
      t1.right = t2.round$0(x) + J.floor$0$n(t4.$div(width, 2));
      t1.bottom = t3.round$0(y) + J.floor$0$n(t5.$div(height, 2));
      this.bounds = t1;
      J.clear$0$ax(this.objects);
      t1 = this.nodes;
      t5 = J.getInterceptor$ax(t1);
      t5.$indexSet(t1, 3, null);
      t5.$indexSet(t1, 2, null);
      t5.$indexSet(t1, 1, null);
      t5.$indexSet(t1, 0, null);
    }, function($receiver, x, y, width, height) {
      return this.reset$7($receiver, x, y, width, height, null, null, null);
    }, "reset$4", function($receiver, x, y, width, height, maxObjects, maxLevels) {
      return this.reset$7($receiver, x, y, width, height, maxObjects, maxLevels, null);
    }, "reset$6", function($receiver, x, y, width, height, maxObjects) {
      return this.reset$7($receiver, x, y, width, height, maxObjects, null, null);
    }, "reset$5", "call$7", "call$4", "call$6", "call$5", "get$reset", 8, 6, 1413, 32, 32, 32, 6, [], 7, [], 10, [], 11, [], 410, [], 411, [], 412, [], "reset"],
    populate$1: [function(group) {
      J.forEach$2$ax(group, this.get$populateHandler(), true);
    }, "call$1", "get$populate", 2, 0, 1414, 253, [], "populate"],
    populateHandler$1: [function(sprite) {
      var t1 = J.getInterceptor$x(sprite);
      if (t1.get$body(sprite) != null && sprite.get$exists() === true)
        this.insert$1(0, t1.get$body(sprite));
    }, "call$1", "get$populateHandler", 2, 0, 1415, 113, [], "populateHandler"],
    split$0: [function(_) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11;
      this.level = J.$add$ns(this.level, 1);
      t1 = this.nodes;
      t2 = J.get$right$x(this.bounds);
      t3 = J.get$y$x(this.bounds);
      t4 = this.bounds.get$subWidth();
      t5 = this.bounds.get$subHeight();
      t6 = this.maxObjects;
      t7 = this.maxLevels;
      t8 = this.level;
      t9 = H.setRuntimeTypeInfo([], [R.Body0]);
      t10 = Array(4);
      t10.fixed$length = init;
      t10 = new R.QuadTree(10, 4, 0, null, t9, H.setRuntimeTypeInfo(t10, [R.QuadTree]));
      t10.reset$7(0, J.toInt$0$n(t2), J.toInt$0$n(t3), J.toInt$0$n(t4), J.toInt$0$n(t5), t6, t7, t8);
      t8 = J.getInterceptor$ax(t1);
      t8.$indexSet(t1, 0, t10);
      t10 = J.get$x$x(this.bounds);
      t7 = J.get$y$x(this.bounds);
      t6 = this.bounds.get$subWidth();
      t5 = this.bounds.get$subHeight();
      t4 = this.maxObjects;
      t3 = this.maxLevels;
      t2 = this.level;
      t9 = H.setRuntimeTypeInfo([], [R.Body0]);
      t11 = Array(4);
      t11.fixed$length = init;
      t11 = new R.QuadTree(10, 4, 0, null, t9, H.setRuntimeTypeInfo(t11, [R.QuadTree]));
      t11.reset$7(0, J.toInt$0$n(t10), J.toInt$0$n(t7), J.toInt$0$n(t6), J.toInt$0$n(t5), t4, t3, t2);
      t8.$indexSet(t1, 1, t11);
      t11 = J.get$x$x(this.bounds);
      t2 = J.get$bottom$x(this.bounds);
      t3 = this.bounds.get$subWidth();
      t4 = this.bounds.get$subHeight();
      t5 = this.maxObjects;
      t6 = this.maxLevels;
      t7 = this.level;
      t10 = H.setRuntimeTypeInfo([], [R.Body0]);
      t9 = Array(4);
      t9.fixed$length = init;
      t9 = new R.QuadTree(10, 4, 0, null, t10, H.setRuntimeTypeInfo(t9, [R.QuadTree]));
      t9.reset$7(0, J.toInt$0$n(t11), J.toInt$0$n(t2), J.toInt$0$n(t3), J.toInt$0$n(t4), t5, t6, t7);
      t8.$indexSet(t1, 2, t9);
      t9 = J.get$right$x(this.bounds);
      t7 = J.get$bottom$x(this.bounds);
      t6 = this.bounds.get$subWidth();
      t5 = this.bounds.get$subHeight();
      t4 = this.maxObjects;
      t3 = this.maxLevels;
      t2 = this.level;
      t11 = H.setRuntimeTypeInfo([], [R.Body0]);
      t10 = Array(4);
      t10.fixed$length = init;
      t10 = new R.QuadTree(10, 4, 0, null, t11, H.setRuntimeTypeInfo(t10, [R.QuadTree]));
      t10.reset$7(0, J.toInt$0$n(t9), J.toInt$0$n(t7), J.toInt$0$n(t6), J.toInt$0$n(t5), t4, t3, t2);
      t8.$indexSet(t1, 3, t10);
    }, "call$0", "get$split", 0, 0, 13, "split"],
    insert$1: [function(_, body) {
      var t1, t2, index, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, i;
      t1 = this.nodes;
      t2 = J.getInterceptor$asx(t1);
      if (t2.$index(t1, 0) != null) {
        index = this.getIndex$1(body);
        if (index !== -1) {
          J.insert$1$ax(t2.$index(t1, index), body);
          return;
        }
      }
      t3 = this.objects;
      t4 = J.getInterceptor$ax(t3);
      t4.add$1(t3, body);
      if (J.$gt$n(t4.get$length(t3), this.maxObjects) && J.$lt$n(this.level, this.maxLevels)) {
        if (t2.$index(t1, 0) == null) {
          this.level = J.$add$ns(this.level, 1);
          t5 = J.get$right$x(this.bounds);
          t6 = J.get$y$x(this.bounds);
          t7 = this.bounds.get$subWidth();
          t8 = this.bounds.get$subHeight();
          t9 = this.maxObjects;
          t10 = this.maxLevels;
          t11 = this.level;
          t12 = H.setRuntimeTypeInfo([], [R.Body0]);
          t13 = Array(4);
          t13.fixed$length = init;
          t13 = new R.QuadTree(10, 4, 0, null, t12, H.setRuntimeTypeInfo(t13, [R.QuadTree]));
          t13.reset$7(0, J.toInt$0$n(t5), J.toInt$0$n(t6), J.toInt$0$n(t7), J.toInt$0$n(t8), t9, t10, t11);
          t2.$indexSet(t1, 0, t13);
          t13 = J.get$x$x(this.bounds);
          t11 = J.get$y$x(this.bounds);
          t10 = this.bounds.get$subWidth();
          t9 = this.bounds.get$subHeight();
          t8 = this.maxObjects;
          t7 = this.maxLevels;
          t6 = this.level;
          t5 = H.setRuntimeTypeInfo([], [R.Body0]);
          t12 = Array(4);
          t12.fixed$length = init;
          t12 = new R.QuadTree(10, 4, 0, null, t5, H.setRuntimeTypeInfo(t12, [R.QuadTree]));
          t12.reset$7(0, J.toInt$0$n(t13), J.toInt$0$n(t11), J.toInt$0$n(t10), J.toInt$0$n(t9), t8, t7, t6);
          t2.$indexSet(t1, 1, t12);
          t12 = J.get$x$x(this.bounds);
          t6 = J.get$bottom$x(this.bounds);
          t7 = this.bounds.get$subWidth();
          t8 = this.bounds.get$subHeight();
          t9 = this.maxObjects;
          t10 = this.maxLevels;
          t11 = this.level;
          t13 = H.setRuntimeTypeInfo([], [R.Body0]);
          t5 = Array(4);
          t5.fixed$length = init;
          t5 = new R.QuadTree(10, 4, 0, null, t13, H.setRuntimeTypeInfo(t5, [R.QuadTree]));
          t5.reset$7(0, J.toInt$0$n(t12), J.toInt$0$n(t6), J.toInt$0$n(t7), J.toInt$0$n(t8), t9, t10, t11);
          t2.$indexSet(t1, 2, t5);
          t5 = J.get$right$x(this.bounds);
          t11 = J.get$bottom$x(this.bounds);
          t10 = this.bounds.get$subWidth();
          t9 = this.bounds.get$subHeight();
          t8 = this.maxObjects;
          t7 = this.maxLevels;
          t6 = this.level;
          t12 = H.setRuntimeTypeInfo([], [R.Body0]);
          t13 = Array(4);
          t13.fixed$length = init;
          t13 = new R.QuadTree(10, 4, 0, null, t12, H.setRuntimeTypeInfo(t13, [R.QuadTree]));
          t13.reset$7(0, J.toInt$0$n(t5), J.toInt$0$n(t11), J.toInt$0$n(t10), J.toInt$0$n(t9), t8, t7, t6);
          t2.$indexSet(t1, 3, t13);
        }
        i = 0;
        while (true) {
          t5 = t4.get$length(t3);
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (!(i < t5))
            break;
          index = this.getIndex$1(t4.$index(t3, i));
          if (index !== -1)
            J.insert$1$ax(t2.$index(t1, index), t4.removeAt$1(t3, i));
          else
            ++i;
        }
      }
    }, "call$1", "get$insert", 2, 0, 1416, 1417, [], "insert"],
    getIndex$1: [function(rect) {
      var t1, index;
      t1 = J.getInterceptor$x(rect);
      if (J.$lt$n(t1.get$x(rect), J.get$right$x(this.bounds)) && J.$lt$n(t1.get$right(rect), J.get$right$x(this.bounds)))
        if (J.$lt$n(t1.get$y(rect), J.get$bottom$x(this.bounds)) && J.$lt$n(t1.get$bottom(rect), J.get$bottom$x(this.bounds)))
          index = 1;
        else
          index = J.$gt$n(t1.get$y(rect), J.get$bottom$x(this.bounds)) ? 2 : -1;
      else if (J.$gt$n(t1.get$x(rect), J.get$right$x(this.bounds)))
        if (J.$lt$n(t1.get$y(rect), J.get$bottom$x(this.bounds)) && J.$lt$n(t1.get$bottom(rect), J.get$bottom$x(this.bounds)))
          index = 0;
        else
          index = J.$gt$n(t1.get$y(rect), J.get$bottom$x(this.bounds)) ? 3 : -1;
      else
        index = -1;
      return index;
    }, "call$1", "get$getIndex", 2, 0, 1263, 1094, [], "getIndex"],
    retrieve$1: [function(source) {
      var t1, returnObjects, index, t2, t3;
      t1 = J.getInterceptor(source);
      if (!!t1.$isRectangle1) {
        returnObjects = this.objects;
        index = this.getIndex$1(source);
      } else {
        if (t1.get$body(source) == null)
          return C.List_empty;
        returnObjects = this.objects;
        index = this.getIndex$1(t1.get$body(source));
      }
      t1 = this.nodes;
      t2 = J.getInterceptor$asx(t1);
      if (J.$gt$n(t2.get$length(t1), 0) && t2.$index(t1, 0) != null) {
        t3 = J.getInterceptor$ax(returnObjects);
        if (index !== -1)
          t3.addAll$1(returnObjects, t2.$index(t1, index).retrieve$1(source));
        else {
          t3.addAll$1(returnObjects, t2.$index(t1, 0).retrieve$1(source));
          t3.addAll$1(returnObjects, t2.$index(t1, 1).retrieve$1(source));
          t3.addAll$1(returnObjects, t2.$index(t1, 2).retrieve$1(source));
          t3.addAll$1(returnObjects, t2.$index(t1, 3).retrieve$1(source));
        }
      }
      return returnObjects;
    }, "call$1", "get$retrieve", 2, 0, 1418, 170, [], "retrieve"],
    clear$0: [function(_) {
      var t1, t2, i, t3, i0;
      J.clear$0$ax(this.objects);
      t1 = this.nodes;
      t2 = J.getInterceptor$asx(t1);
      i = t2.get$length(t1);
      for (; t3 = J.getInterceptor$n(i), i0 = t3.$sub(i, 1), t3.$gt(i, 0); i = i0)
        if (t2.$index(t1, i0) != null) {
          J.clear$0$ax(t2.$index(t1, i0));
          t2.$indexSet(t1, i0, null);
        }
    }, "call$0", "get$clear", 0, 0, 13, "clear"],
    $isQuadTree: true,
    static: {"^": "QuadTree__empty<-720", QuadTree$: [function(x, y, width, height, maxObjects, maxLevels, level) {
        var t1, t2;
        t1 = H.setRuntimeTypeInfo([], [R.Body0]);
        t2 = Array(4);
        t2.fixed$length = init;
        t2 = new R.QuadTree(10, 4, 0, null, t1, H.setRuntimeTypeInfo(t2, [R.QuadTree]));
        t2.reset$7(0, J.toInt$0$n(x), J.toInt$0$n(y), J.toInt$0$n(width), J.toInt$0$n(height), maxObjects, maxLevels, level);
        return t2;
      }, null, null, 8, 6, 409, 32, 32, 32, 6, [], 7, [], 10, [], 11, [], 410, [], 411, [], 412, [], "new QuadTree"]}
  },
  "+QuadTree": [632],
  RandomDataGenerator: {
    "^": "Object;c@-599,s0@-629,s1@-629,s2@-629",
    rnd$0: [function() {
      var t1, t2, t;
      t1 = this.s0;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = J.$mul$ns(this.c, 2.3283064365386963e-10);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t = 2091639 * t1 + t2;
      t2 = C.JSNumber_methods.toInt$0(Math.floor(t));
      this.c = t2;
      this.s0 = this.s1;
      this.s1 = this.s2;
      t2 = t - t2;
      this.s2 = t2;
      return t2;
    }, "call$0", "get$rnd", 0, 0, 1337, "rnd"],
    sow$1: [function(seeds) {
      var t1, i, i0, seed;
      if (seeds == null)
        seeds = [];
      t1 = this.hash$1(0, " ");
      this.s0 = t1;
      t1 = this.hash$1(0, t1);
      this.s1 = t1;
      this.s2 = this.hash$1(0, t1);
      this.c = 1;
      for (t1 = J.getInterceptor$asx(seeds), i = 0; i0 = i + 1, seed = t1.$index(seeds, i), seed === true; i = i0) {
        this.s0 = J.$sub$n(this.s0, this.hash$1(0, seed));
        this.s1 = J.$sub$n(this.s1, this.hash$1(0, seed));
        this.s2 = J.$sub$n(this.s2, this.hash$1(0, seed));
      }
    }, "call$1", "get$sow", 2, 0, 63, 413, [], "sow"],
    hash$1: [function(_, data) {
      var t1, i, n, t2, h;
      data = J.toString$0(data);
      t1 = J.getInterceptor$asx(data);
      i = 0;
      n = 4022871197;
      while (true) {
        t2 = t1.get$length(data);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        h = C.JSDouble_methods.toInt$0(0.02519603282416938 * C.JSInt_methods.$add(n, data.charCodeAt$1(i)));
        n = C.JSInt_methods._shrOtherPositive$1(h, 0);
        h = (h - n) * n;
        n = C.JSInt_methods._shrOtherPositive$1(h, 0);
        n += (h - n) * 4294967296;
        ++i;
      }
      return C.JSInt_methods._shrOtherPositive$1(n, 0) * 2.3283064365386963e-10;
    }, "call$1", "get$hash", 2, 0, 63, 48, [], "hash"],
    integer$0: [function() {
      return J.floor$0$n(J.$mul$ns(this.rnd$0(), 4294967296));
    }, "call$0", "get$integer", 0, 0, 367, "integer"],
    frac$0: [function() {
      return J.$add$ns(this.rnd$0(), J.toInt$0$n(J.$mul$ns(this.rnd$0(), 2097152)) * 1.1102230246251565e-16);
    }, "call$0", "get$frac", 0, 0, 1337, "frac"],
    real$0: [function() {
      var t1, t2;
      t1 = J.floor$0$n(J.$mul$ns(this.rnd$0(), 4294967296));
      t2 = this.frac$0();
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 + t2;
    }, "call$0", "get$real", 0, 0, 1337, "real"],
    integerInRange$2: [function(min, max) {
      var t1 = J.$add$ns(J.$sub$n(max, min), 1);
      return J.floor$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(this.frac$0(), J.$sub$n(t1, 0)), 0), min));
    }, "call$2", "get$integerInRange", 4, 0, 1419, 364, [], 365, [], "integerInRange"],
    realInRange$2: [function(min, max) {
      return J.$add$ns(J.$mul$ns(this.frac$0(), J.$sub$n(max, min)), min);
    }, "call$2", "get$realInRange", 4, 0, 328, 364, [], 365, [], "realInRange"],
    normal$0: [function() {
      var t1 = this.frac$0();
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 1 - 2 * t1;
    }, "call$0", "get$normal", 0, 0, 604, "normal"],
    uuid$0: [function() {
      var t1 = $.RandomDataGenerator_UUID;
      $.RandomDataGenerator_UUID = J.$add$ns(t1, 1);
      return H.S(t1);
    }, "call$0", "get$uuid", 0, 0, 782, "uuid"],
    pick$1: [function(ary) {
      var t1 = J.getInterceptor$asx(ary);
      return t1.$index(ary, this.integerInRange$2(0, J.$sub$n(t1.get$length(ary), 1)));
    }, "call$1", "get$pick", 2, 0, 14, 1420, [], "pick"],
    weightedPick$1: [function(ary) {
      var t1, t2, t3;
      t1 = this.frac$0();
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      t1 = Math.pow(t1, 2);
      t2 = J.getInterceptor$asx(ary);
      t3 = J.$sub$n(t2.get$length(ary), 1);
      if (typeof t3 !== "number")
        return H.iae(t3);
      return t2.$index(ary, t1 * t3);
    }, "call$1", "get$weightedPick", 2, 0, 14, 1420, [], "weightedPick"],
    timestamp$2: [function(min, max) {
      return J.$add$ns(J.$mul$ns(this.frac$0(), J.$sub$n(max, min)), min);
    }, function() {
      return this.timestamp$2(946684800000, 1577862000000);
    }, "timestamp$0", function(min) {
      return this.timestamp$2(min, 1577862000000);
    }, "timestamp$1", "call$2", "call$0", "call$1", "get$timestamp", 0, 4, 1421, 1422, 1423, 364, [], 365, [], "timestamp"],
    angle$0: [function() {
      return this.integerInRange$2(-180, 180);
    }, "call$0", "get$angle", 0, 0, 604, "angle"],
    static: {"^": "RandomDataGenerator_UUID@-599", RandomDataGenerator$: [function(seeds) {
        return new R.RandomDataGenerator(1, 0, 0, 0);
      }, null, null, 2, 0, 14, 413, [], "new RandomDataGenerator"]}
  },
  "+RandomDataGenerator": [632],
  Net: {
    "^": "Object;game@-598",
    getHostName$0: [function() {
      return window.location.hostname;
    }, "call$0", "get$getHostName", 0, 0, 782, "getHostName"],
    checkDomainName$1: [function(domain) {
      return J.indexOf$1$asx(window.location.hostname, domain) !== -1;
    }, "call$1", "get$checkDomainName", 2, 0, 1367, 1424, [], "checkDomainName"],
    updateQueryString$4: [function(key, value, redirect, url) {
      var t1, t2, re, t3, output, separator, hash;
      if (redirect == null)
        redirect = false;
      if (url == null || J.$eq(url, ""))
        url = window.location.href;
      t1 = C.JSString_methods.$add("([?|&])", key) + "=.*?(&|#|$)(.*)";
      t2 = H.JSSyntaxRegExp_makeNative(t1, true, true, false);
      re = new H.JSSyntaxRegExp(t1, t2, null, null);
      t1 = H.JSSyntaxRegExp_makeNative("(&|?)$", false, true, false);
      if (typeof url !== "string")
        H.throwExpression(P.ArgumentError$(url));
      if (t2.test(url)) {
        t2 = value != null && true;
        t3 = J.getInterceptor$s(url);
        if (t2)
          output = t3.replaceAll$2(url, re, "$1" + H.S(key) + "=" + H.S(value) + "$2$3");
        else {
          t2 = t3.replaceAll$2(url, re, "$1$3");
          output = H.stringReplaceAllUnchecked(t2, new H.JSSyntaxRegExp("(&|?)$", t1, null, null), "");
        }
      } else if (value != null) {
        t1 = J.getInterceptor$asx(url);
        separator = !J.$eq(t1.indexOf$1(url, "?"), -1) ? "&" : "?";
        hash = t1.split$1(url, "#");
        if (0 >= hash.length)
          return H.ioore(hash, 0);
        url = J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(hash[0], separator), key), "="), value);
        if (1 >= hash.length)
          return H.ioore(hash, 1);
        t1 = hash[1];
        if (t1 === true)
          url = J.$add$ns(url, C.JSString_methods.$add("#", t1));
        output = url;
      } else
        output = url;
      if (redirect === true) {
        window.location.href = output;
        return;
      } else
        return output;
    }, "call$4", "get$updateQueryString", 8, 0, 1425, 231, [], 100, [], 1426, [], 88, [], "updateQueryString"],
    getQueryString$1: [function(parameter) {
      var output, keyValues, t1, t2, i, key, t3, t4;
      if (parameter == null)
        parameter = "";
      output = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      keyValues = J.substring$1$s(window.location.search, 1).split("&");
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(keyValues, keyValues.length, 0, null), [H.getTypeArgumentByIndex(keyValues, 0)]), t2 = parameter != null; t1.moveNext$0();) {
        i = t1._current;
        if (i >>> 0 !== i || i >= keyValues.length)
          return H.ioore(keyValues, i);
        key = J.split$1$s(keyValues[i], "=");
        if (key.length > 1) {
          t3 = t2 && J.$eq(parameter, P.Uri__uriDecode(J.replaceAll$2$s(key[0], "+", " "), C.Utf8Codec_false, false));
          t4 = key.length;
          if (t3) {
            if (1 >= t4)
              return H.ioore(key, 1);
            return P.Uri__uriDecode(J.replaceAll$2$s(key[1], "+", " "), C.Utf8Codec_false, false);
          } else {
            if (0 >= t4)
              return H.ioore(key, 0);
            t3 = P.Uri__uriDecode(J.replaceAll$2$s(key[0], "+", " "), C.Utf8Codec_false, false);
            if (1 >= key.length)
              return H.ioore(key, 1);
            output.$indexSet(0, t3, P.Uri__uriDecode(J.replaceAll$2$s(key[1], "+", " "), C.Utf8Codec_false, false));
          }
        }
      }
      return output;
    }, "call$1", "get$getQueryString", 2, 0, 52, 1427, [], "getQueryString"],
    decodeURI$1: [function(value) {
      return P.Uri__uriDecode(J.replaceAll$2$s(value, "+", " "), C.Utf8Codec_false, false);
    }, "call$1", "get$decodeURI", 2, 0, 918, 100, [], "decodeURI"],
    static: {Net$: [function(game) {
        return new R.Net(game);
      }, null, null, 2, 0, 258, 214, [], "new Net"]}
  },
  "+Net": [632],
  Emitter: {
    "^": "Group;maxParticles@-599,area@-974,minParticleSpeed@-600,maxParticleSpeed@-600,minParticleScale@-601,maxParticleScale@-601,scaleData@-1182,minRotation@-601,maxRotation@-601,minParticleAlpha@-601,maxParticleAlpha@-601,alphaData@-1182,gravity@-601,particleClass@-1057,particleDrag@-600,angularDrag@-601,frequency@-601,lifespan@-601,bounce@-600,on*-602,particleAnchor@-600,emitX@-601,emitY@-601,autoScale@-602,autoAlpha@-602,particleBringToTop@-602,particleSendToBack@-602,_minParticleScale@-600,_maxParticleScale@-600,_quantity@-601,_timer@-601,_counter@-601,_explode@-602,_frames@-32,blendMode@-674,game-598,name-639,addToStage-602,enableBody-602,physicsBodyType-601,z-599,type-599,alive-602,exists-602,_Phaser$_dirty-602,cursor-32,cameraOffset-600,_sortProperty-639,enableBodyDebug-602,_cache-720,creator-281,renderOrderID-599,Phaser$Group$children-1017,autoCull-602,events-1018,_anchor-600,_Phaser$_currentBounds-974,Phaser$Group$position-600,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    get$width: [function(_) {
      return J.get$width$x(this.area);
    }, null, null, 1, 0, 604, "width"],
    set$width: [function(_, value) {
      J.set$width$x(this.area, value);
    }, null, null, 3, 0, 605, 100, [], "width"],
    get$height: [function(_) {
      return J.get$height$x(this.area);
    }, null, null, 1, 0, 604, "height"],
    set$height: [function(_, value) {
      J.set$height$x(this.area, value);
    }, null, null, 3, 0, 605, 100, [], "height"],
    get$x: [function(_) {
      return this.emitX;
    }, null, null, 1, 0, 604, "x"],
    set$x: [function(_, value) {
      this.emitX = value;
    }, null, null, 3, 0, 605, 100, [], "x"],
    get$y: [function(_) {
      return this.emitY;
    }, null, null, 1, 0, 604, "y"],
    set$y: [function(_, value) {
      this.emitY = value;
    }, null, null, 3, 0, 605, 100, [], "y"],
    get$left: [function(_) {
      return J.floor$0$n(J.$sub$n(this.emitX, J.$div$n(J.get$width$x(this.area), 2)));
    }, null, null, 1, 0, 604, "left"],
    get$right: [function(_) {
      return J.floor$0$n(J.$add$ns(this.emitX, J.$div$n(J.get$width$x(this.area), 2)));
    }, null, null, 1, 0, 604, "right"],
    get$top: [function(_) {
      return J.floor$0$n(J.$sub$n(this.emitY, J.$div$n(J.get$height$x(this.area), 2)));
    }, null, null, 1, 0, 604, "top"],
    get$bottom: [function(_) {
      return J.floor$0$n(J.$add$ns(this.emitY, J.$div$n(J.get$height$x(this.area), 2)));
    }, null, null, 1, 0, 604, "bottom"],
    update$0: [function() {
      var t1, i, i0;
      if (this.on === true)
        if (this._explode === true) {
          this._counter = 0;
          do {
            this.emitParticle$0();
            t1 = J.$add$ns(this._counter, 1);
            this._counter = t1;
          } while (J.$lt$n(t1, this._quantity));
          this.on = false;
        } else if (J.$ge$n(this.game.get$time().get$now(), this._timer)) {
          this.emitParticle$0();
          this._counter = J.$add$ns(this._counter, 1);
          if (J.$gt$n(this._quantity, 0))
            if (J.$ge$n(this._counter, this._quantity))
              this.on = false;
          this._timer = J.$add$ns(this.game.get$time().get$now(), this.frequency);
        }
      i = J.get$length$asx(this.Phaser$Group$children);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        if (J.$index$asx(this.Phaser$Group$children, i0).get$exists() === true)
          J.$index$asx(this.Phaser$Group$children, i0).update$0();
    }, "call$0", "get$update", 0, 0, 13, "update"],
    makeParticles$5: [function(keys, $frames, quantity, collide, collideWorldBounds) {
      var t1, t2, t3, rndFrame, rndKey, i, particle, t4;
      if ($frames == null)
        $frames = 0;
      if (quantity == null)
        quantity = this.maxParticles;
      if (collide == null)
        collide = false;
      if (collideWorldBounds == null)
        collideWorldBounds = false;
      this._frames = $frames;
      if (typeof quantity !== "number")
        return H.iae(quantity);
      t1 = collide === true;
      t2 = !!J.getInterceptor($frames).$isList;
      t3 = !!J.getInterceptor(keys).$isList;
      rndFrame = $frames;
      rndKey = keys;
      i = 0;
      for (; i < quantity;) {
        if (t3)
          rndKey = this.game.get$rnd().pick$1(keys);
        if (t2)
          rndFrame = this.game.get$rnd().pick$1($frames);
        particle = P.reflectClass(this.particleClass).newInstance$2(C.Symbol_0c4, [this.game, 0, 0, rndKey, rndFrame]).reflectee;
        J.enable$2$x(this.game.get$physics().get$arcade(), particle, false);
        t4 = J.getInterceptor$x(particle);
        if (t1) {
          J.set$any$ax(t4.get$body(particle).get$checkCollision(), true);
          t4.get$body(particle).get$checkCollision().set$none(false);
        } else
          t4.get$body(particle).get$checkCollision().set$none(true);
        J.get$body$x(particle).set$collideWorldBounds(collideWorldBounds);
        particle.set$exists(false);
        particle.set$visible(false);
        particle.get$anchor().copyFrom$1(this.particleAnchor);
        this.add$1(0, particle);
        ++i;
      }
      return this;
    }, function(keys) {
      return this.makeParticles$5(keys, 0, null, false, false);
    }, "makeParticles$1", function(keys, frames) {
      return this.makeParticles$5(keys, frames, null, false, false);
    }, "makeParticles$2", function(keys, frames, quantity) {
      return this.makeParticles$5(keys, frames, quantity, false, false);
    }, "makeParticles$3", function(keys, frames, quantity, collide) {
      return this.makeParticles$5(keys, frames, quantity, collide, false);
    }, "makeParticles$4", "call$5", "call$1", "call$2", "call$3", "call$4", "get$makeParticles", 2, 8, 1428, 5, 32, 95, 95, 1429, [], 25, [], 949, [], 1430, [], 1431, [], "makeParticles"],
    kill$0: [function() {
      this.on = false;
      this.alive = false;
      this.exists = false;
    }, "call$0", "get$kill", 0, 0, 13, "kill"],
    revive$0: [function() {
      this.alive = true;
      this.exists = true;
    }, "call$0", "get$revive", 0, 0, 13, "revive"],
    explode$2: [function(lifespan, quantity) {
      this.start$5(0, true, lifespan, 0, quantity, false);
    }, function() {
      return this.explode$2(0, 0);
    }, "explode$0", function(lifespan) {
      return this.explode$2(lifespan, 0);
    }, "explode$1", "call$2", "call$0", "call$1", "get$explode", 0, 4, 16, 5, 5, 1432, [], 949, [], "explode"],
    flow$3: [function(lifespan, frequency, quantity) {
      this.start$5(0, false, lifespan, frequency, quantity, true);
    }, function() {
      return this.flow$3(0, 0, 0);
    }, "flow$0", function(lifespan) {
      return this.flow$3(lifespan, 0, 0);
    }, "flow$1", function(lifespan, frequency) {
      return this.flow$3(lifespan, frequency, 0);
    }, "flow$2", "call$3", "call$0", "call$1", "call$2", "get$flow", 0, 6, 4, 5, 5, 5, 1432, [], 393, [], 949, [], "flow"],
    start$5: [function(_, explode, lifespan, frequency, quantity, forceQuantity) {
      if (explode == null)
        explode = true;
      if (lifespan == null)
        lifespan = 0;
      if (frequency == null)
        frequency = 250;
      if (quantity == null)
        quantity = 0;
      if (forceQuantity == null)
        forceQuantity = false;
      this.alive = true;
      this.exists = true;
      this.visible = true;
      this.on = true;
      this._explode = explode;
      this.lifespan = lifespan;
      this.frequency = frequency;
      if (explode === true || forceQuantity === true)
        this._quantity = quantity;
      else
        this._quantity = J.$add$ns(this._quantity, quantity);
      this._counter = 0;
      this._timer = J.$add$ns(this.game.get$time().get$now(), frequency);
    }, function($receiver, explode) {
      return this.start$5($receiver, explode, 0, 250, 0, false);
    }, "start$1", function($receiver) {
      return this.start$5($receiver, true, 0, 250, 0, false);
    }, "start$0", function($receiver, explode, lifespan, frequency) {
      return this.start$5($receiver, explode, lifespan, frequency, 0, false);
    }, "start$3", function($receiver, explode, lifespan) {
      return this.start$5($receiver, explode, lifespan, 250, 0, false);
    }, "start$2", function($receiver, explode, lifespan, frequency, quantity) {
      return this.start$5($receiver, explode, lifespan, frequency, quantity, false);
    }, "start$4", "call$5", "call$1", "call$0", "call$3", "call$2", "call$4", "get$start", 0, 10, 1433, 39, 5, 1434, 5, 95, 1435, [], 1432, [], 393, [], 949, [], 1436, [], "start"],
    emitParticle$0: [function() {
      var particle, t1, t2;
      particle = this.getFirstExists$1(false);
      if (particle == null)
        return;
      t1 = J.$gt$n(J.get$width$x(this.area), 1) || J.$gt$n(J.get$height$x(this.area), 1);
      t2 = J.getInterceptor$x(particle);
      if (t1)
        t2.reset$2(particle, this.game.get$rnd().integerInRange$2(J.floor$0$n(J.$sub$n(this.emitX, J.$div$n(J.get$width$x(this.area), 2))), J.floor$0$n(J.$add$ns(this.emitX, J.$div$n(J.get$width$x(this.area), 2)))), this.game.get$rnd().integerInRange$2(J.floor$0$n(J.$sub$n(this.emitY, J.$div$n(J.get$height$x(this.area), 2))), J.floor$0$n(J.$add$ns(this.emitY, J.$div$n(J.get$height$x(this.area), 2)))));
      else
        t2.reset$2(particle, this.emitX, this.emitY);
      particle.set$angle(0);
      particle.set$lifespan(this.lifespan);
      if (this.particleBringToTop === true)
        this.bringToTop$1(particle);
      else if (this.particleSendToBack === true)
        if (J.$eq(J.get$parent$x(particle), this) && J.$gt$n(J.indexOf$1$asx(this.Phaser$Group$children, particle), 0)) {
          this.remove$3(0, particle, false, true);
          this.addAt$3(particle, 0, true);
        }
      if (this.autoScale === true)
        particle.setScaleData$1(this.scaleData);
      else if (!J.$eq(this.minParticleScale, 1) || !J.$eq(this.maxParticleScale, 1))
        J.get$scale$x(particle).set$1(this.game.get$rnd().realInRange$2(this.minParticleScale, this.maxParticleScale));
      else if (!J.$eq(J.get$x$x(this._minParticleScale), J.get$x$x(this._maxParticleScale)) || !J.$eq(J.get$y$x(this._minParticleScale), J.get$y$x(this._maxParticleScale)))
        J.get$scale$x(particle).set$2(this.game.get$rnd().realInRange$2(J.get$x$x(this._minParticleScale), J.get$x$x(this._maxParticleScale)), this.game.get$rnd().realInRange$2(J.get$y$x(this._minParticleScale), J.get$y$x(this._maxParticleScale)));
      t1 = this._frames;
      if (t1 != null && !!J.getInterceptor(t1).$isList)
        particle.set$frame(this.game.get$rnd().pick$1(this._frames));
      else
        particle.set$frame(t1);
      if (this.autoAlpha === true)
        particle.setAlphaData$1(this.alphaData);
      else
        J.set$alpha$x(particle, this.game.get$rnd().realInRange$2(this.minParticleAlpha, this.maxParticleAlpha));
      particle.set$blendMode(this.blendMode);
      t1 = J.getInterceptor$x(particle);
      t1.get$body(particle).updateBounds$0();
      t1.get$body(particle).get$bounce().setTo$2(J.get$x$x(this.bounce), J.get$y$x(this.bounce));
      J.set$x$x(t1.get$body(particle).get$velocity(), this.game.get$rnd().integerInRange$2(J.get$x$x(this.minParticleSpeed), J.get$x$x(this.maxParticleSpeed)));
      J.set$y$x(t1.get$body(particle).get$velocity(), this.game.get$rnd().integerInRange$2(J.get$y$x(this.minParticleSpeed), J.get$y$x(this.maxParticleSpeed)));
      t1.get$body(particle).set$angularVelocity(this.game.get$rnd().integerInRange$2(this.minRotation, this.maxRotation));
      J.set$y$x(t1.get$body(particle).get$gravity(), this.gravity);
      J.set$x$x(t1.get$body(particle).get$drag(), J.get$x$x(this.particleDrag));
      J.set$y$x(t1.get$body(particle).get$drag(), J.get$y$x(this.particleDrag));
      t1.get$body(particle).set$angularDrag(this.angularDrag);
      particle.onEmit$0();
    }, "call$0", "get$emitParticle", 0, 0, 13, "emitParticle"],
    setSize$2: [function(width, height) {
      J.set$width$x(this.area, width);
      J.set$height$x(this.area, height);
    }, "call$2", "get$setSize", 4, 0, 111, 10, [], 11, [], "setSize"],
    setXSpeed$2: [function(min, max) {
      J.set$x$x(this.minParticleSpeed, min);
      J.set$x$x(this.maxParticleSpeed, max);
    }, function() {
      return this.setXSpeed$2(0, 0);
    }, "setXSpeed$0", function(min) {
      return this.setXSpeed$2(min, 0);
    }, "setXSpeed$1", "call$2", "call$0", "call$1", "get$setXSpeed", 0, 4, 16, 5, 5, 364, [], 365, [], "setXSpeed"],
    setYSpeed$2: [function(min, max) {
      J.set$y$x(this.minParticleSpeed, min);
      J.set$y$x(this.maxParticleSpeed, max);
    }, function() {
      return this.setYSpeed$2(0, 0);
    }, "setYSpeed$0", function(min) {
      return this.setYSpeed$2(min, 0);
    }, "setYSpeed$1", "call$2", "call$0", "call$1", "get$setYSpeed", 0, 4, 16, 5, 5, 364, [], 365, [], "setYSpeed"],
    setRotation$2: [function(min, max) {
      this.minRotation = min;
      this.maxRotation = max;
    }, function() {
      return this.setRotation$2(0, 0);
    }, "setRotation$0", function(min) {
      return this.setRotation$2(min, 0);
    }, "setRotation$1", "call$2", "call$0", "call$1", "get$setRotation", 0, 4, 16, 5, 5, 364, [], 365, [], "setRotation"],
    setAlpha$5: [function(min, max, rate, ease, yoyo) {
      var tweenData, tween, t1;
      if (min == null)
        min = 1;
      if (max == null)
        max = 1;
      if (rate == null)
        rate = 0;
      if (ease == null) {
        $.get$Easing_Linear().toString;
        ease = $.get$Linear_INOUT().compute;
      }
      if (yoyo == null)
        yoyo = false;
      this.minParticleAlpha = min;
      this.maxParticleAlpha = max;
      this.autoAlpha = false;
      if (J.$gt$n(rate, 0) && !J.$eq(min, max)) {
        tweenData = P.LinkedHashMap_LinkedHashMap$_literal(["v", min], null, null);
        tween = this.game.get$make().tween$1(tweenData).to$3(P.LinkedHashMap_LinkedHashMap$_literal(["v", max], null, null), rate, ease);
        tween.yoyo$1(yoyo);
        t1 = tween.generateData$1(60);
        this.alphaData = t1;
        this.alphaData = J.toList$0$ax(J.get$reversed$ax(t1));
        this.autoAlpha = true;
      }
    }, function() {
      return this.setAlpha$5(1, 1, 0, null, false);
    }, "setAlpha$0", function(min) {
      return this.setAlpha$5(min, 1, 0, null, false);
    }, "setAlpha$1", function(min, max) {
      return this.setAlpha$5(min, max, 0, null, false);
    }, "setAlpha$2", function(min, max, rate) {
      return this.setAlpha$5(min, max, rate, null, false);
    }, "setAlpha$3", function(min, max, rate, ease) {
      return this.setAlpha$5(min, max, rate, ease, false);
    }, "setAlpha$4", "call$5", "call$0", "call$1", "call$2", "call$3", "call$4", "get$setAlpha", 0, 10, 1437, 390, 390, 5, 32, 95, 364, [], 365, [], 1438, [], 1439, [], 1440, [], "setAlpha"],
    setScale$7: [function(minX, maxX, minY, maxY, rate, ease, yoyo) {
      var tweenData, tween, t1;
      if (minX == null)
        minX = 1;
      if (maxX == null)
        maxX = 1;
      if (minY == null)
        minY = 1;
      if (maxY == null)
        maxY = 1;
      if (rate == null)
        rate = 0;
      if (ease == null) {
        $.get$Easing_Linear().toString;
        ease = $.get$Linear_INOUT().compute;
      }
      if (yoyo == null)
        yoyo = false;
      this.minParticleScale = 1;
      this.maxParticleScale = 1;
      this._minParticleScale.set$2(minX, minY);
      this._maxParticleScale.set$2(maxX, maxY);
      this.autoScale = false;
      if (J.$gt$n(rate, 0) && !J.$eq(minX, maxX) || !J.$eq(minY, maxY)) {
        tweenData = P.LinkedHashMap_LinkedHashMap$_literal(["x", minX, "y", minY], null, null);
        tween = this.game.get$make().tween$1(tweenData).to$3(P.LinkedHashMap_LinkedHashMap$_literal(["x", maxX, "y", maxY], null, null), rate, ease);
        tween.yoyo$1(yoyo);
        t1 = tween.generateData$1(60);
        this.scaleData = t1;
        this.scaleData = J.toList$0$ax(J.get$reversed$ax(t1));
        this.autoScale = true;
      }
    }, function() {
      return this.setScale$7(1, 1, 1, 1, 0, null, false);
    }, "setScale$0", function(minX) {
      return this.setScale$7(minX, 1, 1, 1, 0, null, false);
    }, "setScale$1", function(minX, maxX) {
      return this.setScale$7(minX, maxX, 1, 1, 0, null, false);
    }, "setScale$2", function(minX, maxX, minY) {
      return this.setScale$7(minX, maxX, minY, 1, 0, null, false);
    }, "setScale$3", function(minX, maxX, minY, maxY) {
      return this.setScale$7(minX, maxX, minY, maxY, 0, null, false);
    }, "setScale$4", function(minX, maxX, minY, maxY, rate, ease) {
      return this.setScale$7(minX, maxX, minY, maxY, rate, ease, false);
    }, "setScale$6", function(minX, maxX, minY, maxY, rate) {
      return this.setScale$7(minX, maxX, minY, maxY, rate, null, false);
    }, "setScale$5", "call$7", "call$0", "call$1", "call$2", "call$3", "call$4", "call$6", "call$5", "get$setScale", 0, 14, 1441, 390, 390, 390, 390, 5, 32, 95, 1442, [], 1443, [], 1444, [], 1445, [], 1438, [], 1439, [], 1440, [], "setScale"],
    at$1: [function(object) {
      object.get$center();
      this.emitX = object.get$center().x;
      this.emitY = object.get$center().y;
    }, "call$1", "get$at", 2, 0, 277, 541, [], "at"],
    Emitter$4: function(game, x, y, maxParticles) {
      var t1, t2;
      this.maxParticles = maxParticles;
      t1 = $.Particles_ID;
      t2 = J.getInterceptor$ns(t1);
      $.Particles_ID = t2.$add(t1, 1);
      this.name = C.JSString_methods.$add("emitter", t2.toString$0(t1));
      this.type = 11;
      this.area = new R.Rectangle1(x, y, 1, 1, 0, 0, 0, 0);
      t1 = new R.Point(null, null);
      t1.x = -100;
      t1.y = -100;
      this.minParticleSpeed = t1;
      t1 = new R.Point(null, null);
      t1.x = 100;
      t1.y = 100;
      this.maxParticleSpeed = t1;
      this.minParticleScale = 1;
      this.maxParticleScale = 1;
      this.scaleData = null;
      this.minRotation = -360;
      this.maxRotation = 360;
      this.minParticleAlpha = 1;
      this.maxParticleAlpha = 1;
      this.alphaData = null;
      this.gravity = 100;
      this.particleClass = C.Type_1Od;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.particleDrag = t1;
      this.angularDrag = 0;
      this.frequency = 100;
      this.lifespan = 2000;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.bounce = t1;
      this.on = false;
      t1 = new R.Point(null, null);
      t1.x = 0.5;
      t1.y = 0.5;
      this.particleAnchor = t1;
      this.blendMode = C.BlendModes_0;
      this.emitX = x;
      this.emitY = y;
      this.autoScale = false;
      this.autoAlpha = false;
      this.particleBringToTop = false;
      this.particleSendToBack = false;
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this._minParticleScale = t1;
      t1 = new R.Point(null, null);
      t1.x = 1;
      t1.y = 1;
      this._maxParticleScale = t1;
      this._quantity = 0;
      this._timer = 0;
      this._counter = 0;
      this._explode = true;
      this._frames = null;
    },
    $asGroup: function() {
      return [null];
    },
    $asGroup: function() {
      return [null];
    },
    "<>": [],
    static: {Emitter$: [function(game, x, y, maxParticles) {
        var t1, t2, t3, t4, t5, t6;
        t1 = new R.Point(null, null);
        t1.x = 0;
        t1.y = 0;
        t2 = new R.Point(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = new R.Emitter(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "group", false, false, 0, null, null, null, null, null, null, null, null, null, null, null, null, [], null, null, t1, null, t2, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t1.Group$6(game, null, "group", false, false, 0, null);
        t1.Emitter$4(game, x, y, maxParticles);
        return t1;
      }, null, null, 2, 6, 414, 5, 5, 361, 214, [], 6, [], 7, [], 415, [], "new Emitter"]}
  },
  "+Emitter": [1074],
  Particles: {
    "^": "Object;Arcade@-754,game@-598,emitters@-1446",
    add$1: [function(_, emitter) {
      J.$indexSet$ax(this.emitters, J.get$name$x(emitter), emitter);
      return emitter;
    }, "call$1", "get$add", 2, 0, 1447, 1448, [], "add"],
    remove$1: [function(_, emitter) {
      J.remove$1$ax(this.emitters, J.get$name$x(emitter));
    }, "call$1", "get$remove", 2, 0, 63, 1448, [], "remove"],
    update$0: [function() {
      var t1, key;
      for (t1 = J.get$iterator$ax(J.get$keys$x(this.emitters)); t1.moveNext$0();) {
        key = t1.get$current();
        if (J.$index$asx(this.emitters, key).get$exists() === true)
          J.$index$asx(this.emitters, key).update$0();
      }
    }, "call$0", "get$update", 0, 0, 13, "update"],
    static: {"^": "Particles_ID@-599", Particles$: [function(game) {
        var t1 = new R.Particles(P.LinkedHashMap_LinkedHashMap$_empty(null, null), game, null);
        t1.emitters = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new Particles"]}
  },
  "+Particles": [632],
  Arcade0: {
    "^": "Object;game@-598,gravity@-600,bounds@-974,checkCollision@-603,maxObjects@-599,maxLevels@-599,OVERLAP_BIAS@-599,TILE_BIAS@-599,forceX@-602,quadTree@-1449,_overlap@-601,_maxOverlap@-601,_velocity1@-601,_velocity2@-601,_newVelocity1@-601,_newVelocity2@-601,_average@-601,_mapData@-720,_result@-602,_total@-599,_angle@-601,_Phaser$_dx@-601,_Phaser$_dy@-601,_velocityDelta@-601,_drag@-601,_potentials@-720",
    quadTree$2: function(arg0, arg1) {
      return this.quadTree.call$2(arg0, arg1);
    },
    setBounds$4: [function(x, y, width, height) {
      this.bounds.setTo$4(x, y, width, height);
    }, "call$4", "get$setBounds", 8, 0, 306, 6, [], 7, [], 10, [], 11, [], "setBounds"],
    setBoundsToWorld$0: [function() {
      this.bounds.setTo$4(J.get$x$x(this.game.get$world().get$bounds()), J.get$y$x(this.game.get$world().get$bounds()), J.get$width$x(this.game.get$world().get$bounds()), J.get$height$x(this.game.get$world().get$bounds()));
    }, "call$0", "get$setBoundsToWorld", 0, 0, 13, "setBoundsToWorld"],
    enable$2: [function(_, object, children) {
      var t1, i, t2, t3, i0, t4;
      t1 = J.getInterceptor(object);
      if (!!t1.$isList) {
        i = t1.get$length(object);
        for (t2 = children === true; t3 = J.getInterceptor$n(i), i0 = t3.$sub(i, 1), t3.$ge(i, 0); i = i0)
          if (!!J.getInterceptor(t1.$index(object, i0)).$isGroup)
            this.enable$2(0, J.get$children$x(t1.$index(object, i0)), children);
          else {
            t3 = t1.$index(object, i0);
            t4 = J.getInterceptor$x(t3);
            if (t4.get$body(t3) == null)
              t4.set$body(t3, O.Body$(t3));
            if (t2 && J.$gt$n(J.get$length$asx(J.get$children$x(t1.$index(object, i0))), 0))
              this.enable$2(0, t1.$index(object, i0), true);
          }
      } else if (!!t1.$isGroup)
        this.enable$2(0, t1.get$children(object), children);
      else {
        if (t1.get$body(object) == null)
          t1.set$body(object, O.Body$(object));
        if (children === true && J.$gt$n(J.get$length$asx(t1.get$children(object)), 0))
          this.enable$2(0, t1.get$children(object), true);
      }
    }, function($receiver, object) {
      return this.enable$2($receiver, object, true);
    }, "enable$1", "call$2", "call$1", "get$enable", 2, 2, 943, 39, 541, [], 1450, [], "enable"],
    enableBody$1: [function(object) {
      var t1 = J.getInterceptor$x(object);
      if (t1.get$body(object) == null)
        t1.set$body(object, O.Body$(object));
    }, "call$1", "get$enableBody", 2, 0, 1415, 541, [], "enableBody"],
    updateMotion$1: [function(body) {
      var t1;
      this._velocityDelta = J.$sub$n(this.computeVelocity$6(0, body, body.get$angularVelocity(), body.get$angularAcceleration(), body.get$angularDrag(), body.get$maxAngular()), body.get$angularVelocity());
      body.set$angularVelocity(J.$add$ns(body.get$angularVelocity(), this._velocityDelta));
      body.set$rotation(J.$add$ns(body.get$rotation(), J.$mul$ns(body.get$angularVelocity(), this.game.get$time().get$physicsElapsed())));
      t1 = J.getInterceptor$x(body);
      J.set$x$x(body.get$velocity(), this.computeVelocity$6(1, body, J.get$x$x(body.get$velocity()), J.get$x$x(t1.get$acceleration(body)), J.get$x$x(body.get$drag()), J.get$x$x(body.get$maxVelocity())));
      J.set$y$x(body.get$velocity(), this.computeVelocity$6(2, body, J.get$y$x(body.get$velocity()), J.get$y$x(t1.get$acceleration(body)), J.get$y$x(body.get$drag()), J.get$y$x(body.get$maxVelocity())));
    }, "call$1", "get$updateMotion", 2, 0, 1451, 1417, [], "updateMotion"],
    computeVelocity$6: [function(axis, body, velocity, acceleration, drag, max) {
      var t1, t2;
      t1 = J.getInterceptor(axis);
      if (t1.$eq(axis, 1) && body.get$allowGravity())
        velocity = J.$add$ns(velocity, J.$mul$ns(J.$add$ns(J.get$x$x(this.gravity), J.get$x$x(body.get$gravity())), this.game.get$time().get$physicsElapsed()));
      else if (t1.$eq(axis, 2) && body.get$allowGravity())
        velocity = J.$add$ns(velocity, J.$mul$ns(J.$add$ns(J.get$y$x(this.gravity), J.get$y$x(body.get$gravity())), this.game.get$time().get$physicsElapsed()));
      t1 = J.getInterceptor(acceleration);
      if (!t1.$eq(acceleration, 0))
        velocity = J.$add$ns(velocity, t1.$mul(acceleration, this.game.get$time().get$physicsElapsed()));
      else {
        t1 = J.getInterceptor(drag);
        if (!t1.$eq(drag, 0)) {
          t1 = t1.$mul(drag, this.game.get$time().get$physicsElapsed());
          this._drag = t1;
          t2 = J.getInterceptor$n(velocity);
          if (J.$gt$n(t2.$sub(velocity, t1), 0))
            velocity = t2.$sub(velocity, this._drag);
          else
            velocity = J.$lt$n(t2.$add(velocity, this._drag), 0) ? t2.$add(velocity, this._drag) : 0;
        }
      }
      t1 = J.getInterceptor$n(velocity);
      if (t1.$gt(velocity, max))
        velocity = max;
      else {
        t2 = J.getInterceptor$n(max);
        if (t1.$lt(velocity, t2.$negate(max)))
          velocity = t2.$negate(max);
      }
      return velocity;
    }, function(axis, body, velocity, acceleration, drag) {
      return this.computeVelocity$6(axis, body, velocity, acceleration, drag, 10000);
    }, "computeVelocity$5", "call$6", "call$5", "get$computeVelocity", 10, 2, 1452, 1453, 1454, [], 1417, [], 1455, [], 1456, [], 1457, [], 365, [], "computeVelocity"],
    overlap$4: [function(object1, object2, overlapCallback, processCallback) {
      var t1, len, i;
      this._result = false;
      this._total = 0;
      t1 = J.getInterceptor(object2);
      if (!!t1.$isList) {
        len = t1.get$length(object2);
        if (typeof len !== "number")
          return H.iae(len);
        i = 0;
        for (; i < len; ++i)
          this.collideHandler$5(object1, t1.$index(object2, i), overlapCallback, processCallback, true);
      } else
        this.collideHandler$5(object1, object2, overlapCallback, processCallback, true);
      return J.$gt$n(this._total, 0);
    }, function(object1, object2) {
      return this.overlap$4(object1, object2, null, null);
    }, "overlap$2", function(object1, object2, overlapCallback) {
      return this.overlap$4(object1, object2, overlapCallback, null);
    }, "overlap$3", "call$4", "call$2", "call$3", "get$overlap", 4, 4, 1458, 32, 32, 1459, [], 1460, [], 1461, [], 1462, [], "overlap"],
    collide$4: [function(object1, object2, collideCallback, processCallback) {
      var t1, len, i;
      this._result = false;
      this._total = 0;
      t1 = J.getInterceptor(object2);
      if (!!t1.$isList) {
        len = t1.get$length(object2);
        if (typeof len !== "number")
          return H.iae(len);
        i = 0;
        for (; i < len; ++i)
          this.collideHandler$5(object1, t1.$index(object2, i), collideCallback, processCallback, false);
      } else
        this.collideHandler$5(object1, object2, collideCallback, processCallback, false);
      return J.$gt$n(this._total, 0);
    }, function(object1, object2) {
      return this.collide$4(object1, object2, null, null);
    }, "collide$2", function(object1, object2, collideCallback) {
      return this.collide$4(object1, object2, collideCallback, null);
    }, "collide$3", "call$4", "call$2", "call$3", "get$collide", 4, 4, 1458, 32, 32, 1459, [], 1460, [], 1463, [], 1462, [], "collide"],
    collideHandler$5: [function(object1, object2, collideCallback, processCallback, overlapOnly) {
      var t1, t2;
      t1 = object2 == null;
      if (t1) {
        t2 = J.getInterceptor$x(object1);
        t2 = J.$eq(t2.get$type(object1), 7) || J.$eq(t2.get$type(object1), 11);
      } else
        t2 = false;
      if (t2) {
        this.collideGroupVsSelf$4(object1, collideCallback, processCallback, overlapOnly);
        return;
      }
      if (object1 != null && !t1 && object1.get$exists() === true && object2.get$exists() === true) {
        t1 = J.getInterceptor$x(object1);
        if (J.$eq(t1.get$type(object1), 0) || J.$eq(t1.get$type(object1), 5)) {
          t1 = J.getInterceptor$x(object2);
          if (J.$eq(t1.get$type(object2), 0) || J.$eq(t1.get$type(object2), 5))
            this.collideSpriteVsSprite$5(object1, object2, collideCallback, processCallback, overlapOnly);
          else if (J.$eq(t1.get$type(object2), 7) || J.$eq(t1.get$type(object2), 11))
            this.collideSpriteVsGroup$5(object1, object2, collideCallback, processCallback, overlapOnly);
          else if (J.$eq(t1.get$type(object2), 10))
            this.collideSpriteVsTilemapLayer$4(object1, object2, collideCallback, processCallback);
        } else if (J.$eq(t1.get$type(object1), 7)) {
          t1 = J.getInterceptor$x(object2);
          if (J.$eq(t1.get$type(object2), 0) || J.$eq(t1.get$type(object2), 5))
            this.collideSpriteVsGroup$5(object2, object1, collideCallback, processCallback, overlapOnly);
          else if (J.$eq(t1.get$type(object2), 7) || J.$eq(t1.get$type(object2), 11))
            this.collideGroupVsGroup$5(object1, object2, collideCallback, processCallback, overlapOnly);
          else if (J.$eq(t1.get$type(object2), 10))
            this.collideGroupVsTilemapLayer$4(object1, object2, collideCallback, processCallback);
        } else if (J.$eq(t1.get$type(object1), 10)) {
          t1 = J.getInterceptor$x(object2);
          if (J.$eq(t1.get$type(object2), 0) || J.$eq(t1.get$type(object2), 5))
            this.collideSpriteVsTilemapLayer$4(object2, object1, collideCallback, processCallback);
          else if (J.$eq(t1.get$type(object2), 7) || J.$eq(t1.get$type(object2), 11))
            this.collideGroupVsTilemapLayer$4(object2, object1, collideCallback, processCallback);
        } else if (J.$eq(t1.get$type(object1), 11)) {
          t1 = J.getInterceptor$x(object2);
          if (J.$eq(t1.get$type(object2), 0) || J.$eq(t1.get$type(object2), 5))
            this.collideSpriteVsGroup$5(object2, object1, collideCallback, processCallback, overlapOnly);
          else if (J.$eq(t1.get$type(object2), 7) || J.$eq(t1.get$type(object2), 11))
            this.collideGroupVsGroup$5(object1, object2, collideCallback, processCallback, overlapOnly);
          else if (J.$eq(t1.get$type(object2), 10))
            this.collideGroupVsTilemapLayer$3(object1, object2, collideCallback);
        }
      }
    }, function(object1, object2) {
      return this.collideHandler$5(object1, object2, null, null, false);
    }, "collideHandler$2", function(object1, object2, collideCallback) {
      return this.collideHandler$5(object1, object2, collideCallback, null, false);
    }, "collideHandler$3", function(object1, object2, collideCallback, processCallback) {
      return this.collideHandler$5(object1, object2, collideCallback, processCallback, false);
    }, "collideHandler$4", "call$5", "call$2", "call$3", "call$4", "get$collideHandler", 4, 6, 1464, 32, 32, 95, 1459, [], 1460, [], 1463, [], 1462, [], 1465, [], "collideHandler"],
    collideSpriteVsSprite$5: [function(sprite1, sprite2, collideCallback, processCallback, overlapOnly) {
      var t1 = J.getInterceptor$x(sprite1);
      if (t1.get$body(sprite1) == null || J.get$body$x(sprite2) == null)
        return false;
      if (this.separate$4(t1.get$body(sprite1), J.get$body$x(sprite2), processCallback, overlapOnly) === true) {
        if (collideCallback != null)
          collideCallback.call$2(sprite1, sprite2);
        this._total = J.$add$ns(this._total, 1);
      }
      return true;
    }, function(sprite1, sprite2) {
      return this.collideSpriteVsSprite$5(sprite1, sprite2, null, null, false);
    }, "collideSpriteVsSprite$2", function(sprite1, sprite2, collideCallback) {
      return this.collideSpriteVsSprite$5(sprite1, sprite2, collideCallback, null, false);
    }, "collideSpriteVsSprite$3", function(sprite1, sprite2, collideCallback, processCallback) {
      return this.collideSpriteVsSprite$5(sprite1, sprite2, collideCallback, processCallback, false);
    }, "collideSpriteVsSprite$4", "call$5", "call$2", "call$3", "call$4", "get$collideSpriteVsSprite", 4, 6, 1466, 32, 32, 95, 1467, [], 1468, [], 1463, [], 1462, [], 1465, [], "collideSpriteVsSprite"],
    collideSpriteVsGroup$5: [function(sprite, group, collideCallback, processCallback, overlapOnly) {
      var t1, len, t2, i;
      if (J.$eq(J.get$length$asx(group), 0) || J.get$body$x(sprite) == null)
        return;
      J.clear$0$ax(this.quadTree);
      J.reset$6$x(this.quadTree, J.get$x$x(this.game.get$world().get$bounds()), J.get$y$x(this.game.get$world().get$bounds()), J.get$width$x(this.game.get$world().get$bounds()), J.get$height$x(this.game.get$world().get$bounds()), this.maxObjects, this.maxLevels);
      this.quadTree.populate$1(group);
      t1 = this.quadTree.retrieve$1(sprite);
      this._potentials = t1;
      len = J.get$length$asx(t1);
      if (typeof len !== "number")
        return H.iae(len);
      t1 = J.getInterceptor$x(sprite);
      t2 = collideCallback != null;
      i = 0;
      for (; i < len; ++i)
        if (this.separate$4(t1.get$body(sprite), J.$index$asx(this._potentials, i), processCallback, overlapOnly) === true) {
          if (t2)
            collideCallback.call$2(sprite, J.$index$asx(this._potentials, i).get$sprite());
          this._total = J.$add$ns(this._total, 1);
        }
    }, function(sprite, group) {
      return this.collideSpriteVsGroup$5(sprite, group, null, null, false);
    }, "collideSpriteVsGroup$2", function(sprite, group, collideCallback) {
      return this.collideSpriteVsGroup$5(sprite, group, collideCallback, null, false);
    }, "collideSpriteVsGroup$3", function(sprite, group, collideCallback, processCallback) {
      return this.collideSpriteVsGroup$5(sprite, group, collideCallback, processCallback, false);
    }, "collideSpriteVsGroup$4", "call$5", "call$2", "call$3", "call$4", "get$collideSpriteVsGroup", 4, 6, 1469, 32, 32, 95, 113, [], 253, [], 1463, [], 1462, [], 1465, [], "collideSpriteVsGroup"],
    collideGroupVsSelf$4: [function(group, collideCallback, processCallback, overlapOnly) {
      var t1, len, i, j, j0;
      t1 = J.getInterceptor$asx(group);
      if (J.$eq(t1.get$length(group), 0))
        return false;
      len = J.get$length$asx(t1.get$children(group));
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; i = j)
        for (j = i + 1, j0 = j; j0 < len; ++j0)
          if (J.$index$asx(t1.get$children(group), i) != null && J.$index$asx(t1.get$children(group), j0) != null && J.$index$asx(t1.get$children(group), i).get$exists() === true && J.$index$asx(t1.get$children(group), j0).get$exists() === true)
            this.collideSpriteVsSprite$5(J.$index$asx(t1.get$children(group), i), J.$index$asx(t1.get$children(group), j0), collideCallback, processCallback, overlapOnly);
      return true;
    }, function(group) {
      return this.collideGroupVsSelf$4(group, null, null, false);
    }, "collideGroupVsSelf$1", function(group, collideCallback) {
      return this.collideGroupVsSelf$4(group, collideCallback, null, false);
    }, "collideGroupVsSelf$2", function(group, collideCallback, processCallback) {
      return this.collideGroupVsSelf$4(group, collideCallback, processCallback, false);
    }, "collideGroupVsSelf$3", "call$4", "call$1", "call$2", "call$3", "get$collideGroupVsSelf", 2, 6, 1470, 32, 32, 95, 253, [], 1463, [], 1462, [], 1465, [], "collideGroupVsSelf"],
    collideGroupVsGroup$5: [function(group1, group2, collideCallback, processCallback, overlapOnly) {
      var t1, len, i;
      t1 = J.getInterceptor$asx(group1);
      if (J.$eq(t1.get$length(group1), 0) || J.$eq(J.get$length$asx(group2), 0))
        return false;
      len = J.get$length$asx(t1.get$children(group1));
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        if (J.$index$asx(t1.get$children(group1), i).get$exists() === true)
          this.collideSpriteVsGroup$5(J.$index$asx(t1.get$children(group1), i), group2, collideCallback, processCallback, overlapOnly);
      return true;
    }, function(group1, group2) {
      return this.collideGroupVsGroup$5(group1, group2, null, null, false);
    }, "collideGroupVsGroup$2", function(group1, group2, collideCallback) {
      return this.collideGroupVsGroup$5(group1, group2, collideCallback, null, false);
    }, "collideGroupVsGroup$3", function(group1, group2, collideCallback, processCallback) {
      return this.collideGroupVsGroup$5(group1, group2, collideCallback, processCallback, false);
    }, "collideGroupVsGroup$4", "call$5", "call$2", "call$3", "call$4", "get$collideGroupVsGroup", 4, 6, 1471, 32, 32, 95, 1472, [], 1473, [], 1463, [], 1462, [], 1465, [], "collideGroupVsGroup"],
    collideSpriteVsTilemapLayer$4: [function(sprite, tilemapLayer, collideCallback, processCallback) {
      var t1, t2, t3, i, t4;
      t1 = J.getInterceptor$x(sprite);
      if (t1.get$body(sprite) == null)
        return false;
      t2 = tilemapLayer.getTiles$6(J.$sub$n(J.get$x$x(J.get$position$x(t1.get$body(sprite))), J.get$x$x(t1.get$body(sprite).get$tilePadding())), J.$sub$n(J.get$y$x(J.get$position$x(t1.get$body(sprite))), J.get$y$x(t1.get$body(sprite).get$tilePadding())), J.$add$ns(J.get$width$x(t1.get$body(sprite)), J.get$x$x(t1.get$body(sprite).get$tilePadding())), J.$add$ns(J.get$height$x(t1.get$body(sprite)), J.get$y$x(t1.get$body(sprite).get$tilePadding())), false, false);
      this._mapData = t2;
      if (J.$eq(J.get$length$asx(t2), 0))
        return false;
      t2 = processCallback != null;
      t3 = collideCallback != null;
      i = 0;
      while (true) {
        t4 = J.get$length$asx(this._mapData);
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (!(i < t4))
          break;
        if (t2) {
          if (processCallback.call$2(sprite, J.$index$asx(this._mapData, i)) === true)
            if (this.separateTile$3(i, t1.get$body(sprite), J.$index$asx(this._mapData, i))) {
              this._total = J.$add$ns(this._total, 1);
              if (t3)
                collideCallback.call$2(sprite, J.$index$asx(this._mapData, i));
            }
        } else if (this.separateTile$3(i, t1.get$body(sprite), J.$index$asx(this._mapData, i))) {
          this._total = J.$add$ns(this._total, 1);
          if (t3)
            collideCallback.call$2(sprite, J.$index$asx(this._mapData, i));
        }
        ++i;
      }
      return true;
    }, function(sprite, tilemapLayer) {
      return this.collideSpriteVsTilemapLayer$4(sprite, tilemapLayer, null, null);
    }, "collideSpriteVsTilemapLayer$2", function(sprite, tilemapLayer, collideCallback) {
      return this.collideSpriteVsTilemapLayer$4(sprite, tilemapLayer, collideCallback, null);
    }, "collideSpriteVsTilemapLayer$3", "call$4", "call$2", "call$3", "get$collideSpriteVsTilemapLayer", 4, 4, 1474, 32, 32, 113, [], 1475, [], 1463, [], 1462, [], "collideSpriteVsTilemapLayer"],
    collideGroupVsTilemapLayer$4: [function(group, tilemapLayer, collideCallback, processCallback) {
      var t1, len, i;
      t1 = J.getInterceptor$asx(group);
      if (J.$eq(t1.get$length(group), 0))
        return false;
      len = J.get$length$asx(t1.get$children(group));
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        if (J.$index$asx(t1.get$children(group), i).get$exists() === true)
          this.collideSpriteVsTilemapLayer$4(J.$index$asx(t1.get$children(group), i), tilemapLayer, collideCallback, processCallback);
      return true;
    }, function(group, tilemapLayer, collideCallback) {
      return this.collideGroupVsTilemapLayer$4(group, tilemapLayer, collideCallback, null);
    }, "collideGroupVsTilemapLayer$3", function(group, tilemapLayer) {
      return this.collideGroupVsTilemapLayer$4(group, tilemapLayer, null, null);
    }, "collideGroupVsTilemapLayer$2", "call$4", "call$3", "call$2", "get$collideGroupVsTilemapLayer", 4, 4, 1476, 32, 32, 253, [], 1475, [], 1463, [], 1462, [], "collideGroupVsTilemapLayer"],
    separate$4: [function(body1, body2, processCallback, overlapOnly) {
      var t1;
      if (J.get$enable$x(body1) !== true || J.get$enable$x(body2) !== true || !this.intersects$2(0, body1, body2))
        return false;
      if (processCallback != null && J.$eq(processCallback.call$2(body1.get$sprite(), body2.get$sprite()), false))
        return false;
      if (overlapOnly === true)
        return true;
      if (this.forceX === true || J.$lt$n(J.abs$0$n(J.$add$ns(J.get$y$x(this.gravity), J.get$y$x(body1.get$gravity()))), J.abs$0$n(J.$add$ns(J.get$x$x(this.gravity), J.get$x$x(body1.get$gravity()))))) {
        t1 = this.separateX$3(body1, body2, overlapOnly) || this.separateY$3(body1, body2, overlapOnly);
        this._result = t1;
      } else {
        t1 = this.separateY$3(body1, body2, overlapOnly) || this.separateX$3(body1, body2, overlapOnly);
        this._result = t1;
      }
      return t1;
    }, function(body1, body2) {
      return this.separate$4(body1, body2, null, false);
    }, "separate$2", function(body1, body2, processCallback) {
      return this.separate$4(body1, body2, processCallback, false);
    }, "separate$3", "call$4", "call$2", "call$3", "get$separate", 4, 4, 1477, 32, 95, 1478, [], 1479, [], 1462, [], 1465, [], "separate"],
    intersects$2: [function(_, body1, body2) {
      var t1, t2;
      t1 = J.getInterceptor$x(body1);
      t2 = J.getInterceptor$x(body2);
      if (J.$le$n(t1.get$right(body1), J.get$x$x(t2.get$position(body2))))
        return false;
      if (J.$le$n(t1.get$bottom(body1), J.get$y$x(t2.get$position(body2))))
        return false;
      if (J.$ge$n(J.get$x$x(t1.get$position(body1)), t2.get$right(body2)))
        return false;
      if (J.$ge$n(J.get$y$x(t1.get$position(body1)), t2.get$bottom(body2)))
        return false;
      return true;
    }, "call$2", "get$intersects", 4, 0, 1480, 1478, [], 1479, [], "intersects"],
    separateX$3: [function(body1, body2, overlapOnly) {
      var t1, t2;
      if (body1.get$immovable() === true && body2.get$immovable() === true)
        return false;
      this._overlap = 0;
      if (this.intersects$2(0, body1, body2)) {
        this._maxOverlap = J.$add$ns(J.$add$ns(body1.deltaAbsX$0(), body2.deltaAbsX$0()), this.OVERLAP_BIAS);
        t1 = J.getInterceptor$x(body1);
        if (J.$eq(t1.deltaX$0(body1), 0) && J.$eq(J.deltaX$0$x(body2), 0)) {
          body1.set$embedded(true);
          body2.set$embedded(true);
        } else {
          t2 = J.getInterceptor$x(body2);
          if (J.$gt$n(t1.deltaX$0(body1), t2.deltaX$0(body2))) {
            t2 = J.$sub$n(t1.get$right(body1), t2.get$x(body2));
            this._overlap = t2;
            if (J.$gt$n(t2, this._maxOverlap) || J.$eq(J.get$right$x(body1.get$checkCollision()), false) || J.$eq(J.get$left$x(body2.get$checkCollision()), false))
              this._overlap = 0;
            else {
              body1.get$touching().set$none(false);
              J.set$right$x(body1.get$touching(), true);
              body2.get$touching().set$none(false);
              J.set$left$x(body2.get$touching(), true);
            }
          } else if (J.$lt$n(t1.deltaX$0(body1), t2.deltaX$0(body2))) {
            t2 = J.$sub$n(J.$sub$n(t1.get$x(body1), t2.get$width(body2)), t2.get$x(body2));
            this._overlap = t2;
            if (J.$gt$n(J.$negate$n(t2), this._maxOverlap) || J.$eq(J.get$left$x(body1.get$checkCollision()), false) || J.$eq(J.get$right$x(body2.get$checkCollision()), false))
              this._overlap = 0;
            else {
              body1.get$touching().set$none(false);
              J.set$left$x(body1.get$touching(), true);
              body2.get$touching().set$none(false);
              J.set$right$x(body2.get$touching(), true);
            }
          }
        }
        if (!J.$eq(this._overlap, 0)) {
          body1.set$overlapX(this._overlap);
          body2.set$overlapX(this._overlap);
          if (overlapOnly === true || body1.get$customSeparateX() || body2.get$customSeparateX())
            return true;
          this._velocity1 = J.get$x$x(body1.get$velocity());
          this._velocity2 = J.get$x$x(body2.get$velocity());
          if (body1.get$immovable() !== true && body2.get$immovable() !== true) {
            this._overlap = J.$mul$ns(this._overlap, 0.5);
            t1.set$x(body1, J.$sub$n(t1.get$x(body1), this._overlap));
            t1 = J.getInterceptor$x(body2);
            t1.set$x(body2, J.$add$ns(t1.get$x(body2), this._overlap));
            t1 = this._velocity2;
            t1 = J.$div$n(J.$mul$ns(J.$mul$ns(t1, t1), body2.get$mass()), body1.get$mass());
            if (typeof t1 !== "number")
              H.throwExpression(P.ArgumentError$(t1));
            t1 = Math.sqrt(t1);
            this._newVelocity1 = t1 * (J.$gt$n(this._velocity2, 0) ? 1 : -1);
            t1 = this._velocity1;
            t1 = J.$div$n(J.$mul$ns(J.$mul$ns(t1, t1), body1.get$mass()), body2.get$mass());
            if (typeof t1 !== "number")
              H.throwExpression(P.ArgumentError$(t1));
            t1 = Math.sqrt(t1);
            t1 *= J.$gt$n(this._velocity1, 0) ? 1 : -1;
            this._newVelocity2 = t1;
            t1 = J.$mul$ns(J.$add$ns(this._newVelocity1, t1), 0.5);
            this._average = t1;
            this._newVelocity1 = J.$sub$n(this._newVelocity1, t1);
            this._newVelocity2 = J.$sub$n(this._newVelocity2, this._average);
            J.set$x$x(body1.get$velocity(), J.$add$ns(this._average, J.$mul$ns(this._newVelocity1, J.get$x$x(body1.get$bounce()))));
            J.set$x$x(body2.get$velocity(), J.$add$ns(this._average, J.$mul$ns(this._newVelocity2, J.get$x$x(body2.get$bounce()))));
          } else if (body1.get$immovable() !== true) {
            t1.set$x(body1, J.$sub$n(t1.get$x(body1), this._overlap));
            J.set$x$x(body1.get$velocity(), J.$sub$n(this._velocity2, J.$mul$ns(this._velocity1, J.get$x$x(body1.get$bounce()))));
          } else if (body2.get$immovable() !== true) {
            t1 = J.getInterceptor$x(body2);
            t1.set$x(body2, J.$add$ns(t1.get$x(body2), this._overlap));
            J.set$x$x(body2.get$velocity(), J.$sub$n(this._velocity1, J.$mul$ns(this._velocity2, J.get$x$x(body2.get$bounce()))));
          }
          return true;
        }
      }
      return false;
    }, "call$3", "get$separateX", 6, 0, 1481, 1478, [], 1479, [], 1465, [], "separateX"],
    separateY$3: [function(body1, body2, overlapOnly) {
      var t1, t2;
      if (body1.get$immovable() === true && body2.get$immovable() === true)
        return false;
      this._overlap = 0;
      if (this.intersects$2(0, body1, body2)) {
        this._maxOverlap = J.$add$ns(J.$add$ns(body1.deltaAbsY$0(), body2.deltaAbsY$0()), this.OVERLAP_BIAS);
        t1 = J.getInterceptor$x(body1);
        if (J.$eq(t1.deltaY$0(body1), 0) && J.$eq(J.deltaY$0$x(body2), 0)) {
          body1.set$embedded(true);
          body2.set$embedded(true);
        } else {
          t2 = J.getInterceptor$x(body2);
          if (J.$gt$n(t1.deltaY$0(body1), t2.deltaY$0(body2))) {
            t2 = J.$sub$n(t1.get$bottom(body1), t2.get$y(body2));
            this._overlap = t2;
            if (J.$gt$n(t2, this._maxOverlap) || J.$eq(body1.get$checkCollision().get$down(), false) || J.$eq(body2.get$checkCollision().get$up(), false))
              this._overlap = 0;
            else {
              body1.get$touching().set$none(false);
              body1.get$touching().set$down(true);
              body2.get$touching().set$none(false);
              body2.get$touching().set$up(true);
            }
          } else if (J.$lt$n(t1.deltaY$0(body1), t2.deltaY$0(body2))) {
            t2 = J.$sub$n(t1.get$y(body1), t2.get$bottom(body2));
            this._overlap = t2;
            if (J.$gt$n(J.$negate$n(t2), this._maxOverlap) || J.$eq(body1.get$checkCollision().get$up(), false) || J.$eq(body2.get$checkCollision().get$down(), false))
              this._overlap = 0;
            else {
              body1.get$touching().set$none(false);
              body1.get$touching().set$up(true);
              body2.get$touching().set$none(false);
              body2.get$touching().set$down(true);
            }
          }
        }
        if (!J.$eq(this._overlap, 0)) {
          body1.set$overlapY(this._overlap);
          body2.set$overlapY(this._overlap);
          if (overlapOnly === true || body1.get$customSeparateY() || body2.get$customSeparateY())
            return true;
          this._velocity1 = J.get$y$x(body1.get$velocity());
          this._velocity2 = J.get$y$x(body2.get$velocity());
          if (body1.get$immovable() !== true && body2.get$immovable() !== true) {
            this._overlap = J.$mul$ns(this._overlap, 0.5);
            t1.set$y(body1, J.$sub$n(t1.get$y(body1), this._overlap));
            t1 = J.getInterceptor$x(body2);
            t1.set$y(body2, J.$add$ns(t1.get$y(body2), this._overlap));
            t1 = this._velocity2;
            t1 = J.$div$n(J.$mul$ns(J.$mul$ns(t1, t1), body2.get$mass()), body1.get$mass());
            if (typeof t1 !== "number")
              H.throwExpression(P.ArgumentError$(t1));
            t1 = Math.sqrt(t1);
            this._newVelocity1 = t1 * (J.$gt$n(this._velocity2, 0) ? 1 : -1);
            t1 = this._velocity1;
            t1 = J.$div$n(J.$mul$ns(J.$mul$ns(t1, t1), body1.get$mass()), body2.get$mass());
            if (typeof t1 !== "number")
              H.throwExpression(P.ArgumentError$(t1));
            t1 = Math.sqrt(t1);
            t1 *= J.$gt$n(this._velocity1, 0) ? 1 : -1;
            this._newVelocity2 = t1;
            t1 = J.$mul$ns(J.$add$ns(this._newVelocity1, t1), 0.5);
            this._average = t1;
            this._newVelocity1 = J.$sub$n(this._newVelocity1, t1);
            this._newVelocity2 = J.$sub$n(this._newVelocity2, this._average);
            J.set$y$x(body1.get$velocity(), J.$add$ns(this._average, J.$mul$ns(this._newVelocity1, J.get$y$x(body1.get$bounce()))));
            J.set$y$x(body2.get$velocity(), J.$add$ns(this._average, J.$mul$ns(this._newVelocity2, J.get$y$x(body2.get$bounce()))));
          } else if (body1.get$immovable() !== true) {
            t1.set$y(body1, J.$sub$n(t1.get$y(body1), this._overlap));
            J.set$y$x(body1.get$velocity(), J.$sub$n(this._velocity2, J.$mul$ns(this._velocity1, J.get$y$x(body1.get$bounce()))));
            if (body2.get$moves() === true)
              t1.set$x(body1, J.$add$ns(t1.get$x(body1), J.$sub$n(J.get$x$x(body2), body2.get$prev().x)));
          } else if (body2.get$immovable() !== true) {
            t2 = J.getInterceptor$x(body2);
            t2.set$y(body2, J.$add$ns(t2.get$y(body2), this._overlap));
            J.set$y$x(body2.get$velocity(), J.$sub$n(this._velocity1, J.$mul$ns(this._velocity2, J.get$y$x(body2.get$bounce()))));
            if (body1.get$moves() === true)
              t2.set$x(body2, J.$add$ns(t2.get$x(body2), J.$sub$n(t1.get$x(body1), body1.get$prev().x)));
          }
          return true;
        }
      }
      return false;
    }, "call$3", "get$separateY", 6, 0, 1481, 1478, [], 1479, [], 1465, [], "separateY"],
    separateTile$3: [function(i, body, tile) {
      var t1, t2, minX, minY, t3, ox, oy;
      t1 = J.getInterceptor$x(body);
      if (t1.get$enable(body) !== true || !J.intersects$4$x(tile, J.get$x$x(t1.get$position(body)), J.get$y$x(t1.get$position(body)), t1.get$right(body), t1.get$bottom(body)))
        return false;
      if (tile.get$collisionCallback() != null && tile.collisionCallback$3(tile, body.get$sprite(), tile) !== true)
        return false;
      else {
        t2 = J.getInterceptor$x(tile);
        if (J.$ge$n(t2.get$index(tile), 0) && J.$gt$n(J.get$length$asx(t2.get$layer(tile).get$callbacks()), t2.get$index(tile)) && J.$index$asx(t2.get$layer(tile).get$callbacks(), t2.get$index(tile)).call$2(body.get$sprite(), tile) !== true)
          return false;
      }
      if (tile.get$faceLeft() !== true && tile.get$faceRight() !== true && tile.get$faceTop() !== true && tile.get$faceBottom() !== true)
        return false;
      if (J.$gt$n(body.deltaAbsX$0(), body.deltaAbsY$0())) {
        minX = -1;
        minY = 1;
      } else {
        minY = J.$lt$n(body.deltaAbsX$0(), body.deltaAbsY$0()) ? -1 : 1;
        minX = 0;
      }
      if (!J.$eq(t1.deltaX$0(body), 0))
        if (!J.$eq(t1.deltaY$0(body), 0))
          if (tile.get$faceLeft() === true || tile.get$faceRight() === true)
            t3 = tile.get$faceTop() === true || tile.get$faceBottom() === true;
          else
            t3 = false;
        else
          t3 = false;
      else
        t3 = false;
      if (t3) {
        minX = P.min(J.abs$0$n(J.$sub$n(J.get$x$x(t1.get$position(body)), t2.get$right(tile))), J.abs$0$n(J.$sub$n(t1.get$right(body), t2.get$left(tile))));
        minY = P.min(J.abs$0$n(J.$sub$n(J.get$y$x(t1.get$position(body)), t2.get$bottom(tile))), J.abs$0$n(J.$sub$n(t1.get$bottom(body), t2.get$top(tile))));
      }
      if (minX < minY) {
        if (tile.get$faceLeft() === true || tile.get$faceRight() === true) {
          ox = this.tileCheckX$2(body, tile);
          if (!J.$eq(ox, 0) && !t2.intersects$4(tile, J.get$x$x(t1.get$position(body)), J.get$y$x(t1.get$position(body)), t1.get$right(body), t1.get$bottom(body)))
            return true;
        } else
          ox = 0;
        oy = tile.get$faceTop() === true || tile.get$faceBottom() === true ? this.tileCheckY$2(body, tile) : 0;
      } else {
        if (tile.get$faceTop() === true || tile.get$faceBottom() === true) {
          oy = this.tileCheckY$2(body, tile);
          if (!J.$eq(oy, 0) && !t2.intersects$4(tile, J.get$x$x(t1.get$position(body)), J.get$y$x(t1.get$position(body)), t1.get$right(body), t1.get$bottom(body)))
            return true;
        } else
          oy = 0;
        ox = tile.get$faceLeft() === true || tile.get$faceRight() === true ? this.tileCheckX$2(body, tile) : 0;
      }
      return !J.$eq(ox, 0) || !J.$eq(oy, 0);
    }, "call$3", "get$separateTile", 6, 0, 1482, 381, [], 1417, [], 1483, [], "separateTile"],
    tileCheckX$2: [function(body, tile) {
      var t1, ox, t2;
      t1 = J.getInterceptor$x(body);
      if (J.$lt$n(t1.deltaX$0(body), 0) && J.get$left$x(body.get$blocked()) !== true && tile.get$collideRight() === true && J.get$left$x(body.get$checkCollision()) === true)
        if (tile.get$faceRight() === true && J.$lt$n(t1.get$x(body), J.get$right$x(tile))) {
          ox = J.$sub$n(t1.get$x(body), J.get$right$x(tile));
          if (J.$lt$n(ox, J.$negate$n(this.TILE_BIAS)))
            ox = 0;
        } else
          ox = 0;
      else if (J.$gt$n(t1.deltaX$0(body), 0) && J.get$right$x(body.get$blocked()) !== true && tile.get$collideLeft() === true && J.get$right$x(body.get$checkCollision()) === true)
        if (tile.get$faceLeft() === true && J.$gt$n(t1.get$right(body), J.get$left$x(tile))) {
          ox = J.$sub$n(t1.get$right(body), J.get$left$x(tile));
          if (J.$gt$n(ox, this.TILE_BIAS))
            ox = 0;
        } else
          ox = 0;
      else
        ox = 0;
      t2 = J.getInterceptor(ox);
      if (!t2.$eq(ox, 0)) {
        if (t2.$lt(ox, 0))
          J.set$left$x(body.get$blocked(), true);
        else if (t2.$gt(ox, 0))
          J.set$right$x(body.get$blocked(), true);
        t1 = t1.get$position(body);
        t2 = J.getInterceptor$x(t1);
        t2.set$x(t1, J.$sub$n(t2.get$x(t1), ox));
        if (J.$eq(J.get$x$x(body.get$bounce()), 0))
          J.set$x$x(body.get$velocity(), 0);
        else
          J.set$x$x(body.get$velocity(), J.$mul$ns(J.$negate$n(J.get$x$x(body.get$velocity())), J.get$x$x(body.get$bounce())));
      }
      return ox;
    }, "call$2", "get$tileCheckX", 4, 0, 1484, 1417, [], 1483, [], "tileCheckX"],
    tileCheckY$2: [function(body, tile) {
      var t1, oy, t2;
      t1 = J.getInterceptor$x(body);
      if (J.$lt$n(t1.deltaY$0(body), 0) && body.get$blocked().get$up() !== true && tile.get$collideDown() === true && body.get$checkCollision().get$up() === true)
        if (tile.get$faceBottom() === true && J.$lt$n(t1.get$y(body), J.get$bottom$x(tile))) {
          oy = J.$sub$n(t1.get$y(body), J.get$bottom$x(tile));
          if (J.$lt$n(oy, J.$negate$n(this.TILE_BIAS)))
            oy = 0;
        } else
          oy = 0;
      else if (J.$gt$n(t1.deltaY$0(body), 0) && body.get$blocked().get$down() !== true && tile.get$collideUp() === true && body.get$checkCollision().get$down() === true)
        if (tile.get$faceTop() === true && J.$gt$n(t1.get$bottom(body), J.get$top$x(tile))) {
          oy = J.$sub$n(t1.get$bottom(body), J.get$top$x(tile));
          if (J.$gt$n(oy, this.TILE_BIAS))
            oy = 0;
        } else
          oy = 0;
      else
        oy = 0;
      t2 = J.getInterceptor(oy);
      if (!t2.$eq(oy, 0)) {
        if (t2.$lt(oy, 0))
          body.get$blocked().set$up(true);
        else if (t2.$gt(oy, 0))
          body.get$blocked().set$down(true);
        t1 = t1.get$position(body);
        t2 = J.getInterceptor$x(t1);
        t2.set$y(t1, J.$sub$n(t2.get$y(t1), oy));
        if (J.$eq(J.get$y$x(body.get$bounce()), 0))
          J.set$y$x(body.get$velocity(), 0);
        else
          J.set$y$x(body.get$velocity(), J.$mul$ns(J.$negate$n(J.get$y$x(body.get$velocity())), J.get$y$x(body.get$bounce())));
      }
      return oy;
    }, "call$2", "get$tileCheckY", 4, 0, 1484, 1417, [], 1483, [], "tileCheckY"],
    processTileSeparationX$2: [function(body, x) {
      var t1, t2;
      t1 = J.getInterceptor$n(x);
      if (t1.$lt(x, 0))
        J.set$left$x(body.get$blocked(), true);
      else if (t1.$gt(x, 0))
        J.set$right$x(body.get$blocked(), true);
      t1 = J.get$position$x(body);
      t2 = J.getInterceptor$x(t1);
      t2.set$x(t1, J.$sub$n(t2.get$x(t1), x));
      if (J.$eq(J.get$x$x(body.get$bounce()), 0))
        J.set$x$x(body.get$velocity(), 0);
      else
        J.set$x$x(body.get$velocity(), J.$mul$ns(J.$negate$n(J.get$x$x(body.get$velocity())), J.get$x$x(body.get$bounce())));
      return true;
    }, "call$2", "get$processTileSeparationX", 4, 0, 1485, 1417, [], 6, [], "processTileSeparationX"],
    processTileSeparationY$2: [function(body, y) {
      var t1, t2;
      t1 = J.getInterceptor$n(y);
      if (t1.$lt(y, 0))
        body.get$blocked().set$up(true);
      else if (t1.$gt(y, 0))
        body.get$blocked().set$down(true);
      t1 = J.get$position$x(body);
      t2 = J.getInterceptor$x(t1);
      t2.set$y(t1, J.$sub$n(t2.get$y(t1), y));
      if (J.$eq(J.get$y$x(body.get$bounce()), 0))
        J.set$y$x(body.get$velocity(), 0);
      else
        J.set$y$x(body.get$velocity(), J.$mul$ns(J.$negate$n(J.get$y$x(body.get$velocity())), J.get$y$x(body.get$bounce())));
      return true;
    }, "call$2", "get$processTileSeparationY", 4, 0, 1485, 1417, [], 7, [], "processTileSeparationY"],
    getObjectsUnderPointer$3: [function(pointer, group, callback) {
      var t1, t2, t3, output, len, i;
      if (J.$eq(J.get$length$asx(group), 0) || pointer.get$exists() !== true)
        return [];
      J.clear$0$ax(this.quadTree);
      J.reset$6$x(this.quadTree, J.get$x$x(this.game.get$world().get$bounds()), J.get$y$x(this.game.get$world().get$bounds()), J.get$width$x(this.game.get$world().get$bounds()), J.get$height$x(this.game.get$world().get$bounds()), this.maxObjects, this.maxLevels);
      this.quadTree.populate$1(group);
      t1 = J.getInterceptor$x(pointer);
      t2 = t1.get$x(pointer);
      t3 = t1.get$y(pointer);
      output = [];
      t3 = this.quadTree.retrieve$1(new R.Rectangle1(t2, t3, 1, 1, 0, 0, 0, 0));
      this._potentials = t3;
      len = J.get$length$asx(t3);
      if (typeof len !== "number")
        return H.iae(len);
      t2 = callback != null;
      i = 0;
      for (; i < len; ++i)
        if (J.$index$asx(this._potentials, i).hitTest$2(t1.get$x(pointer), t1.get$y(pointer))) {
          if (t2)
            callback.call$2(pointer, J.$index$asx(this._potentials, i).get$sprite());
          output.push(J.$index$asx(this._potentials, i).get$sprite());
        }
      return output;
    }, "call$3", "get$getObjectsUnderPointer", 6, 0, 1486, 994, [], 253, [], 272, [], "getObjectsUnderPointer"],
    moveToObject$4: [function(displayObject, destination, speed, maxTime) {
      var t1, t2, t3, t4;
      if (speed == null)
        speed = 60;
      if (maxTime == null)
        maxTime = 0;
      t1 = J.getInterceptor$x(destination);
      t2 = J.getInterceptor$x(displayObject);
      t3 = J.$sub$n(t1.get$y(destination), t2.get$y(displayObject));
      t4 = J.$sub$n(t1.get$x(destination), t2.get$x(displayObject));
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      this._angle = Math.atan2(t3, t4);
      t3 = J.getInterceptor$n(maxTime);
      if (t3.$gt(maxTime, 0)) {
        this._Phaser$_dx = J.$sub$n(t2.get$x(displayObject), t1.get$x(destination));
        this._Phaser$_dy = J.$sub$n(t2.get$y(displayObject), t1.get$y(destination));
        t1 = this._Phaser$_dx;
        t1 = J.$mul$ns(t1, t1);
        t4 = this._Phaser$_dy;
        t4 = J.$add$ns(t1, J.$mul$ns(t4, t4));
        if (typeof t4 !== "number")
          H.throwExpression(P.ArgumentError$(t4));
        t1 = Math.sqrt(t4);
        t3 = t3.$div(maxTime, 1000);
        if (typeof t3 !== "number")
          return H.iae(t3);
        speed = t1 / t3;
      }
      t1 = t2.get$body(displayObject).get$velocity();
      t3 = this._angle;
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      t3 = Math.cos(t3);
      if (typeof speed !== "number")
        return H.iae(speed);
      J.set$x$x(t1, t3 * speed);
      t2 = t2.get$body(displayObject).get$velocity();
      t3 = this._angle;
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      J.set$y$x(t2, Math.sin(t3) * speed);
      return this._angle;
    }, function(displayObject, destination) {
      return this.moveToObject$4(displayObject, destination, null, 0);
    }, "moveToObject$2", function(displayObject, destination, speed) {
      return this.moveToObject$4(displayObject, destination, speed, 0);
    }, "moveToObject$3", "call$4", "call$2", "call$3", "get$moveToObject", 4, 4, 1487, 32, 5, 805, [], 1105, [], 611, [], 1488, [], "moveToObject"],
    moveToPointer$4: [function(displayObject, speed, pointer, maxTime) {
      var t1, t2, t3;
      if (speed == null)
        speed = 60;
      if (pointer == null)
        pointer = this.game.get$input().get$activePointer();
      if (maxTime == null)
        maxTime = 0;
      this._angle = this.angleToPointer$2(displayObject, pointer);
      t1 = J.getInterceptor$n(maxTime);
      if (t1.$gt(maxTime, 0)) {
        if (pointer == null)
          pointer = this.game.get$input().get$activePointer();
        t2 = J.getInterceptor$x(displayObject);
        t3 = J.getInterceptor$x(pointer);
        this._Phaser$_dx = J.$sub$n(t2.get$x(displayObject), t3.get$x(pointer));
        this._Phaser$_dy = J.$sub$n(t2.get$y(displayObject), t3.get$y(pointer));
        t3 = this._Phaser$_dx;
        t3 = J.$mul$ns(t3, t3);
        t2 = this._Phaser$_dy;
        t2 = J.$add$ns(t3, J.$mul$ns(t2, t2));
        if (typeof t2 !== "number")
          H.throwExpression(P.ArgumentError$(t2));
        t2 = Math.sqrt(t2);
        t1 = t1.$div(maxTime, 1000);
        if (typeof t1 !== "number")
          return H.iae(t1);
        speed = t2 / t1;
      }
      t1 = J.getInterceptor$x(displayObject);
      t2 = t1.get$body(displayObject).get$velocity();
      t3 = this._angle;
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      t3 = Math.cos(t3);
      if (typeof speed !== "number")
        return H.iae(speed);
      J.set$x$x(t2, t3 * speed);
      t1 = t1.get$body(displayObject).get$velocity();
      t3 = this._angle;
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      J.set$y$x(t1, Math.sin(t3) * speed);
      return this._angle;
    }, function(displayObject) {
      return this.moveToPointer$4(displayObject, 60, null, 0);
    }, "moveToPointer$1", function(displayObject, speed) {
      return this.moveToPointer$4(displayObject, speed, null, 0);
    }, "moveToPointer$2", function(displayObject, speed, pointer) {
      return this.moveToPointer$4(displayObject, speed, pointer, 0);
    }, "moveToPointer$3", "call$4", "call$1", "call$2", "call$3", "get$moveToPointer", 2, 6, 1489, 213, 32, 5, 805, [], 611, [], 994, [], 1488, [], "moveToPointer"],
    moveToXY$5: [function(displayObject, x, y, speed, maxTime) {
      var t1, t2, t3, t4;
      t1 = J.getInterceptor$x(displayObject);
      t2 = J.$sub$n(y, t1.get$y(displayObject));
      t3 = J.$sub$n(x, t1.get$x(displayObject));
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      this._angle = Math.atan2(t2, t3);
      t2 = J.getInterceptor$n(maxTime);
      if (t2.$gt(maxTime, 0)) {
        this._Phaser$_dx = J.$sub$n(t1.get$x(displayObject), x);
        this._Phaser$_dy = J.$sub$n(t1.get$y(displayObject), y);
        t3 = this._Phaser$_dx;
        t3 = J.$mul$ns(t3, t3);
        t4 = this._Phaser$_dy;
        t4 = J.$add$ns(t3, J.$mul$ns(t4, t4));
        if (typeof t4 !== "number")
          H.throwExpression(P.ArgumentError$(t4));
        t3 = Math.sqrt(t4);
        t2 = t2.$div(maxTime, 1000);
        if (typeof t2 !== "number")
          return H.iae(t2);
        speed = t3 / t2;
      }
      t2 = t1.get$body(displayObject).get$velocity();
      t3 = this._angle;
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      t3 = Math.cos(t3);
      if (typeof speed !== "number")
        return H.iae(speed);
      J.set$x$x(t2, t3 * speed);
      t1 = t1.get$body(displayObject).get$velocity();
      t3 = this._angle;
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      J.set$y$x(t1, Math.sin(t3) * speed);
      return this._angle;
    }, function(displayObject, x, y) {
      return this.moveToXY$5(displayObject, x, y, 60, 0);
    }, "moveToXY$3", function(displayObject, x, y, speed) {
      return this.moveToXY$5(displayObject, x, y, speed, 0);
    }, "moveToXY$4", "call$5", "call$3", "call$4", "get$moveToXY", 6, 4, 1490, 213, 5, 805, [], 6, [], 7, [], 611, [], 1488, [], "moveToXY"],
    velocityFromAngle$3: [function(angle, speed, point) {
      var t1, t2;
      if (point == null) {
        point = new R.Point(null, null);
        point.x = 0;
        point.y = 0;
      }
      t1 = J.getInterceptor$ns(angle);
      t2 = t1.$mul(angle, 0.017453292519943295);
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      t2 = Math.cos(t2);
      if (typeof speed !== "number")
        return H.iae(speed);
      t1 = t1.$mul(angle, 0.017453292519943295);
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      return point.setTo$2(t2 * speed, Math.sin(t1) * speed);
    }, function(angle) {
      return this.velocityFromAngle$3(angle, 60, null);
    }, "velocityFromAngle$1", function(angle, speed) {
      return this.velocityFromAngle$3(angle, speed, null);
    }, "velocityFromAngle$2", "call$3", "call$1", "call$2", "get$velocityFromAngle", 2, 4, 1491, 213, 32, 373, [], 611, [], 433, [], "velocityFromAngle"],
    velocityFromRotation$3: [function(rotation, speed, point) {
      var t1, t2;
      if (point == null) {
        point = new R.Point(null, null);
        point.x = 0;
        point.y = 0;
      }
      t1 = typeof rotation !== "number";
      if (t1)
        H.throwExpression(P.ArgumentError$(rotation));
      t2 = Math.cos(rotation);
      if (typeof speed !== "number")
        return H.iae(speed);
      if (t1)
        H.throwExpression(P.ArgumentError$(rotation));
      return point.setTo$2(t2 * speed, Math.sin(rotation) * speed);
    }, function(rotation) {
      return this.velocityFromRotation$3(rotation, 60, null);
    }, "velocityFromRotation$1", function(rotation, speed) {
      return this.velocityFromRotation$3(rotation, speed, null);
    }, "velocityFromRotation$2", "call$3", "call$1", "call$2", "get$velocityFromRotation", 2, 4, 1491, 213, 32, 1492, [], 611, [], 433, [], "velocityFromRotation"],
    accelerationFromRotation$3: [function(rotation, speed, point) {
      var t1, t2;
      if (point == null) {
        point = new R.Point(null, null);
        point.x = 0;
        point.y = 0;
      }
      t1 = typeof rotation !== "number";
      if (t1)
        H.throwExpression(P.ArgumentError$(rotation));
      t2 = Math.cos(rotation);
      if (typeof speed !== "number")
        return H.iae(speed);
      if (t1)
        H.throwExpression(P.ArgumentError$(rotation));
      return point.setTo$2(t2 * speed, Math.sin(rotation) * speed);
    }, function(rotation) {
      return this.accelerationFromRotation$3(rotation, 60, null);
    }, "accelerationFromRotation$1", function(rotation, speed) {
      return this.accelerationFromRotation$3(rotation, speed, null);
    }, "accelerationFromRotation$2", "call$3", "call$1", "call$2", "get$accelerationFromRotation", 2, 4, 1491, 213, 32, 1492, [], 611, [], 433, [], "accelerationFromRotation"],
    accelerateToObject$5: [function(displayObject, destination, speed, xSpeedMax, ySpeedMax) {
      var t1, t2, t3, t4;
      t1 = J.getInterceptor$x(destination);
      t2 = J.getInterceptor$x(displayObject);
      this._Phaser$_dx = J.$sub$n(t1.get$x(destination), t2.get$x(displayObject));
      t1 = J.$sub$n(t1.get$y(destination), t2.get$y(displayObject));
      this._Phaser$_dy = t1;
      t3 = this._Phaser$_dx;
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      this._angle = Math.atan2(t1, t3);
      t1 = J.get$acceleration$x(t2.get$body(displayObject));
      t3 = this._angle;
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      t3 = Math.cos(t3);
      if (typeof speed !== "number")
        return H.iae(speed);
      t4 = this._angle;
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      t1.setTo$2(t3 * speed, Math.sin(t4) * speed);
      t2.get$body(displayObject).get$maxVelocity().setTo$2(xSpeedMax, ySpeedMax);
      return this._angle;
    }, function(displayObject, destination) {
      return this.accelerateToObject$5(displayObject, destination, 60, 500, 500);
    }, "accelerateToObject$2", function(displayObject, destination, speed) {
      return this.accelerateToObject$5(displayObject, destination, speed, 500, 500);
    }, "accelerateToObject$3", function(displayObject, destination, speed, xSpeedMax) {
      return this.accelerateToObject$5(displayObject, destination, speed, xSpeedMax, 500);
    }, "accelerateToObject$4", "call$5", "call$2", "call$3", "call$4", "get$accelerateToObject", 4, 6, 1493, 213, 1306, 1306, 805, [], 1105, [], 611, [], 1494, [], 1495, [], "accelerateToObject"],
    accelerateToPointer$5: [function(displayObject, pointer, speed, xSpeedMax, ySpeedMax) {
      var t1, t2, t3, t4;
      this._angle = this.angleToPointer$2(displayObject, pointer == null ? this.game.get$input().get$activePointer() : pointer);
      t1 = J.getInterceptor$x(displayObject);
      t2 = J.get$acceleration$x(t1.get$body(displayObject));
      t3 = this._angle;
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      t3 = Math.cos(t3);
      if (typeof speed !== "number")
        return H.iae(speed);
      t4 = this._angle;
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      t2.setTo$2(t3 * speed, Math.sin(t4) * speed);
      t1.get$body(displayObject).get$maxVelocity().setTo$2(xSpeedMax, ySpeedMax);
      return this._angle;
    }, function(displayObject) {
      return this.accelerateToPointer$5(displayObject, null, 60, 500, 500);
    }, "accelerateToPointer$1", function(displayObject, pointer) {
      return this.accelerateToPointer$5(displayObject, pointer, 60, 500, 500);
    }, "accelerateToPointer$2", function(displayObject, pointer, speed) {
      return this.accelerateToPointer$5(displayObject, pointer, speed, 500, 500);
    }, "accelerateToPointer$3", function(displayObject, pointer, speed, xSpeedMax) {
      return this.accelerateToPointer$5(displayObject, pointer, speed, xSpeedMax, 500);
    }, "accelerateToPointer$4", "call$5", "call$1", "call$2", "call$3", "call$4", "get$accelerateToPointer", 2, 8, 1496, 32, 213, 1306, 1306, 805, [], 994, [], 611, [], 1494, [], 1495, [], "accelerateToPointer"],
    accelerateToXY$6: [function(displayObject, x, y, speed, xSpeedMax, ySpeedMax) {
      var t1, t2, t3, t4;
      t1 = J.getInterceptor$x(displayObject);
      this._Phaser$_dx = J.$sub$n(x, t1.get$x(displayObject));
      t2 = J.$sub$n(y, t1.get$y(displayObject));
      this._Phaser$_dy = t2;
      t3 = this._Phaser$_dx;
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      this._angle = Math.atan2(t2, t3);
      t2 = J.get$acceleration$x(t1.get$body(displayObject));
      t3 = this._angle;
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      t3 = Math.cos(t3);
      if (typeof speed !== "number")
        return H.iae(speed);
      t4 = this._angle;
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      t2.setTo$2(t3 * speed, Math.sin(t4) * speed);
      t1.get$body(displayObject).get$maxVelocity().setTo$2(xSpeedMax, ySpeedMax);
      return this._angle;
    }, function(displayObject, x, y) {
      return this.accelerateToXY$6(displayObject, x, y, 60, 1000, 1000);
    }, "accelerateToXY$3", function(displayObject, x, y, speed) {
      return this.accelerateToXY$6(displayObject, x, y, speed, 1000, 1000);
    }, "accelerateToXY$4", function(displayObject, x, y, speed, xSpeedMax) {
      return this.accelerateToXY$6(displayObject, x, y, speed, xSpeedMax, 1000);
    }, "accelerateToXY$5", "call$6", "call$3", "call$4", "call$5", "get$accelerateToXY", 6, 6, 1497, 213, 1498, 1498, 805, [], 6, [], 7, [], 611, [], 1494, [], 1495, [], "accelerateToXY"],
    distanceBetween$2: [function(source, target) {
      var t1, t2;
      t1 = J.getInterceptor$x(source);
      t2 = J.getInterceptor$x(target);
      this._Phaser$_dx = J.$sub$n(t1.get$x(source), t2.get$x(target));
      this._Phaser$_dy = J.$sub$n(t1.get$y(source), t2.get$y(target));
      t2 = this._Phaser$_dx;
      t2 = J.$mul$ns(t2, t2);
      t1 = this._Phaser$_dy;
      t1 = J.$add$ns(t2, J.$mul$ns(t1, t1));
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      return Math.sqrt(t1);
    }, "call$2", "get$distanceBetween", 4, 0, 1499, 170, [], 58, [], "distanceBetween"],
    distanceToXY$3: [function(displayObject, x, y) {
      var t1, t2;
      t1 = J.getInterceptor$x(displayObject);
      this._Phaser$_dx = J.$sub$n(t1.get$x(displayObject), x);
      this._Phaser$_dy = J.$sub$n(t1.get$y(displayObject), y);
      t1 = this._Phaser$_dx;
      t1 = J.$mul$ns(t1, t1);
      t2 = this._Phaser$_dy;
      t2 = J.$add$ns(t1, J.$mul$ns(t2, t2));
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      return Math.sqrt(t2);
    }, "call$3", "get$distanceToXY", 6, 0, 1500, 805, [], 6, [], 7, [], "distanceToXY"],
    distanceToPointer$2: [function(displayObject, pointer) {
      var t1, t2;
      if (pointer == null)
        pointer = this.game.get$input().get$activePointer();
      t1 = J.getInterceptor$x(displayObject);
      t2 = J.getInterceptor$x(pointer);
      this._Phaser$_dx = J.$sub$n(t1.get$x(displayObject), t2.get$x(pointer));
      this._Phaser$_dy = J.$sub$n(t1.get$y(displayObject), t2.get$y(pointer));
      t2 = this._Phaser$_dx;
      t2 = J.$mul$ns(t2, t2);
      t1 = this._Phaser$_dy;
      t1 = J.$add$ns(t2, J.$mul$ns(t1, t1));
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      return Math.sqrt(t1);
    }, function(displayObject) {
      return this.distanceToPointer$2(displayObject, null);
    }, "distanceToPointer$1", "call$2", "call$1", "get$distanceToPointer", 2, 2, 1501, 32, 805, [], 994, [], "distanceToPointer"],
    angleBetween$2: [function(source, target) {
      var t1, t2;
      t1 = J.getInterceptor$x(target);
      t2 = J.getInterceptor$x(source);
      this._Phaser$_dx = J.$sub$n(t1.get$x(target), t2.get$x(source));
      t2 = J.$sub$n(t1.get$y(target), t2.get$y(source));
      this._Phaser$_dy = t2;
      t1 = this._Phaser$_dx;
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      return Math.atan2(t2, t1);
    }, "call$2", "get$angleBetween", 4, 0, 1499, 170, [], 58, [], "angleBetween"],
    angleToXY$3: [function(displayObject, x, y) {
      var t1, t2;
      t1 = J.getInterceptor$x(displayObject);
      this._Phaser$_dx = J.$sub$n(x, t1.get$x(displayObject));
      t1 = J.$sub$n(y, t1.get$y(displayObject));
      this._Phaser$_dy = t1;
      t2 = this._Phaser$_dx;
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      return Math.atan2(t1, t2);
    }, "call$3", "get$angleToXY", 6, 0, 1500, 805, [], 6, [], 7, [], "angleToXY"],
    angleToPointer$2: [function(displayObject, pointer) {
      var t1, t2;
      if (pointer == null)
        pointer = this.game.get$input().get$activePointer();
      t1 = J.getInterceptor$x(displayObject);
      this._Phaser$_dx = J.$sub$n(pointer.get$worldX(), t1.get$x(displayObject));
      t1 = J.$sub$n(pointer.get$worldY(), t1.get$y(displayObject));
      this._Phaser$_dy = t1;
      t2 = this._Phaser$_dx;
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      return Math.atan2(t1, t2);
    }, function(displayObject) {
      return this.angleToPointer$2(displayObject, null);
    }, "angleToPointer$1", "call$2", "call$1", "get$angleToPointer", 2, 2, 1501, 32, 805, [], 994, [], "angleToPointer"],
    Arcade$1: function(game) {
      var t1, t2, t3, t4, t5, t6, t7, t8;
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.gravity = t1;
      this.bounds = new R.Rectangle1(0, 0, J.get$width$x(this.game.get$world()), J.get$height$x(this.game.get$world()), 0, 0, 0, 0);
      t1 = R.CollisionInfo$(false, false, false, false);
      t1.up = true;
      t1.down = true;
      t1.left = true;
      t1.right = true;
      this.checkCollision = t1;
      this.maxObjects = 10;
      this.maxLevels = 4;
      this.OVERLAP_BIAS = 4;
      this.TILE_BIAS = 16;
      this.forceX = false;
      t1 = J.get$x$x(this.game.get$world().get$bounds());
      t2 = J.get$y$x(this.game.get$world().get$bounds());
      t3 = J.get$width$x(this.game.get$world().get$bounds());
      t4 = J.get$height$x(this.game.get$world().get$bounds());
      t5 = this.maxObjects;
      t6 = this.maxLevels;
      t7 = H.setRuntimeTypeInfo([], [R.Body0]);
      t8 = Array(4);
      t8.fixed$length = init;
      t8 = new R.QuadTree(10, 4, 0, null, t7, H.setRuntimeTypeInfo(t8, [R.QuadTree]));
      t8.reset$7(0, J.toInt$0$n(t1), J.toInt$0$n(t2), J.toInt$0$n(t3), J.toInt$0$n(t4), t5, t6, null);
      this.quadTree = t8;
      this._overlap = 0;
      this._maxOverlap = 0;
      this._velocity1 = 0;
      this._velocity2 = 0;
      this._newVelocity1 = 0;
      this._newVelocity2 = 0;
      this._average = 0;
      this._mapData = [];
      this._result = false;
      this._total = 0;
      this._angle = 0;
      this._Phaser$_dx = 0;
      this._Phaser$_dy = 0;
    },
    static: {Arcade$: [function(game) {
        var t1 = new R.Arcade0(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Arcade$1(game);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new Arcade"]}
  },
  "+Arcade": [632],
  CollisionInfo: {
    "^": "Object;up@-602,down@-602,left*-602,right*-602,none@-602,any*-602",
    any$1: function($receiver, arg0) {
      return this.any.call$1(arg0);
    },
    CollisionInfo$4$down$left$right$up: function(down, left, right, up) {
      var t1 = this.up;
      this.none = !(t1 === true || this.down === true || this.left === true || this.right === true);
      this.any = t1 === true || this.down === true || this.left === true || this.right === true;
    },
    static: {CollisionInfo$: [function(down, left, right, up) {
        var t1 = new R.CollisionInfo(up, down, left, right, null, null);
        t1.CollisionInfo$4$down$left$right$up(down, left, right, up);
        return t1;
      }, null, null, 0, 9, 416, 95, 95, 95, 95, 417, [], 418, [], 160, [], 419, [], "new CollisionInfo"]}
  },
  "+CollisionInfo": [632],
  Body0: {
    "^": "Rectangle1;game@-598,position*-600,tilePadding@-600,width:Phaser$Body0$width*-601,height:Phaser$Body0$height*-601,velocity@-600,acceleration*-600,maxVelocity@-600,collideWorldBounds@-602,bounce@-32,type*-599,angularVelocity@-601,gravity@-600,drag@-32,angularDrag@-601,immovable@-602,x:Phaser$Body0$x*-601,y:Phaser$Body0$y*-601,speed@-601,blocked@-603,angle@-601,moves@-602,phase@-599,_reset@-602,safeRemove@-602,touching@-603,Phaser$Rectangle1$x-601,Phaser$Rectangle1$y-601,Phaser$Rectangle1$width-601,Phaser$Rectangle1$height-601,x-601,y-601,width-601,height-601",
    angle$0: function() {
      return this.angle.call$0();
    },
    angle$2: function(arg0, arg1) {
      return this.angle.call$2(arg0, arg1);
    },
    $isBody0: true,
    static: {Body$1: [function() {
        return new R.Body0(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, 0, 0, 0, 0);
      }, null, null, 0, 0, 420, "new Body"]}
  },
  "+Body": [974],
  Ninja: {
    "^": "Object;game@-598,time@-1007,gravity@-601,bounds@-974,maxObjects@-601,maxLevels@-601,quadTree@-1449,_result@-602,_total@-599",
    quadTree$2: function(arg0, arg1) {
      return this.quadTree.call$2(arg0, arg1);
    },
    enableAABB$2: [function(object, children) {
      this.enable$5(0, object, 1, 0, 0, children);
    }, function(object) {
      return this.enableAABB$2(object, true);
    }, "enableAABB$1", "call$2", "call$1", "get$enableAABB", 2, 2, 943, 39, 541, [], 1450, [], "enableAABB"],
    enableCircle$3: [function(object, radius, children) {
      this.enable$5(0, object, 2, 0, radius, children);
    }, function(object, radius) {
      return this.enableCircle$3(object, radius, true);
    }, "enableCircle$2", "call$3", "call$2", "get$enableCircle", 4, 2, 1502, 39, 541, [], 8, [], 1450, [], "enableCircle"],
    enableTile$3: [function(object, id, children) {
      this.enable$5(0, object, 3, id, 0, children);
    }, function(object) {
      return this.enableTile$3(object, 1, true);
    }, "enableTile$1", function(object, id) {
      return this.enableTile$3(object, id, true);
    }, "enableTile$2", "call$3", "call$1", "call$2", "get$enableTile", 2, 4, 1503, 390, 39, 541, [], 183, [], 1450, [], "enableTile"],
    enable$5: [function(_, object, type, id, radius, children) {
      var t1, i, t2, t3, i0, t4;
      t1 = J.getInterceptor(object);
      if (!!t1.$isList) {
        i = t1.get$length(object);
        for (t2 = children === true; t3 = J.getInterceptor$n(i), i0 = t3.$sub(i, 1), t3.$gt(i, 0); i = i0)
          if (!!J.getInterceptor(t1.$index(object, i0)).$isGroup)
            this.enable$5(0, J.get$children$x(t1.$index(object, i0)), type, id, radius, children);
          else {
            t3 = t1.$index(object, i0);
            t4 = J.getInterceptor$x(t3);
            if (t4.get$body(t3) == null) {
              t4.set$body(t3, E.Body$0(this, t3, type, id, radius, 0, 0, 0, 0));
              t3.get$anchor().set$1(0.5);
            }
            if (t2 && !!J.getInterceptor(t1.$index(object, i0)).$isDisplayObjectContainer && J.$gt$n(J.get$length$asx(J.get$children$x(t1.$index(object, i0))), 0))
              this.enable$5(0, t1.$index(object, i0), type, id, radius, true);
          }
      } else if (!!t1.$isGroup)
        this.enable$5(0, t1.get$children(object), type, id, radius, children);
      else {
        if (t1.get$body(object) == null) {
          t1.set$body(object, E.Body$0(this, object, type, id, radius, 0, 0, 0, 0));
          object.get$anchor().set$1(0.5);
        }
        if (children === true && !!t1.$isDisplayObjectContainer && J.$gt$n(J.get$length$asx(t1.get$children(object)), 0))
          this.enable$5(0, t1.get$children(object), type, id, radius, true);
      }
    }, function($receiver, object, type) {
      return this.enable$5($receiver, object, type, 1, 0, true);
    }, "enable$2", function($receiver, object) {
      return this.enable$5($receiver, object, 1, 1, 0, true);
    }, "enable$1", function($receiver, object, type, id) {
      return this.enable$5($receiver, object, type, id, 0, true);
    }, "enable$3", function($receiver, object, type, id, radius) {
      return this.enable$5($receiver, object, type, id, radius, true);
    }, "enable$4", "call$5", "call$2", "call$1", "call$3", "call$4", "get$enable", 2, 8, 1504, 390, 390, 5, 39, 541, [], 99, [], 183, [], 8, [], 1450, [], "enable"],
    enableBody$4: [function(object, type, id, radius) {
      var t1 = J.getInterceptor$x(object);
      if (t1.get$body(object) == null) {
        t1.set$body(object, E.Body$0(this, object, type, id, radius, 0, 0, 0, 0));
        object.get$anchor().set$1(0.5);
      }
    }, function(object) {
      return this.enableBody$4(object, 1, 1, 0);
    }, "enableBody$1", function(object, type) {
      return this.enableBody$4(object, type, 1, 0);
    }, "enableBody$2", function(object, type, id) {
      return this.enableBody$4(object, type, id, 0);
    }, "enableBody$3", "call$4", "call$1", "call$2", "call$3", "get$enableBody", 2, 6, 1505, 390, 390, 5, 541, [], 99, [], 183, [], 8, [], "enableBody"],
    setBounds$4: [function(x, y, width, height) {
      this.bounds.setTo$4(x, y, width, height);
    }, "call$4", "get$setBounds", 8, 0, 306, 6, [], 7, [], 10, [], 11, [], "setBounds"],
    setBoundsToWorld$0: [function() {
      this.bounds.setTo$4(J.get$x$x(this.game.get$world().get$bounds()), J.get$y$x(this.game.get$world().get$bounds()), J.get$width$x(this.game.get$world().get$bounds()), J.get$height$x(this.game.get$world().get$bounds()));
    }, "call$0", "get$setBoundsToWorld", 0, 0, 13, "setBoundsToWorld"],
    clearTilemapLayerBodies$2: [function(map, layer) {
      var i, t1, i0;
      layer = map.getLayer$1(layer);
      i = J.get$length$asx(J.$index$asx(map.get$layers(), layer).get$bodies());
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(J.$index$asx(map.get$layers(), layer).get$bodies(), i0).destroy$0();
      J.clear$0$ax(J.$index$asx(map.get$layers(), layer).get$bodies());
    }, "call$2", "get$clearTilemapLayerBodies", 4, 0, 1506, 775, [], 452, [], "clearTilemapLayerBodies"],
    convertTilemap$3: [function(map, layer, slopeMap) {
      var h, t1, y, w, x, tile, t2, body;
      layer = map.getLayer$1(layer);
      this.clearTilemapLayerBodies$2(map, layer);
      h = J.get$height$x(J.$index$asx(map.get$layers(), layer));
      if (typeof h !== "number")
        return H.iae(h);
      t1 = J.getInterceptor$asx(slopeMap);
      y = 0;
      for (; y < h; ++y) {
        w = J.get$width$x(J.$index$asx(map.get$layers(), layer));
        if (typeof w !== "number")
          return H.iae(w);
        x = 0;
        for (; x < w; ++x) {
          tile = J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(map.get$layers(), layer)), y), x);
          if (tile != null && t1.containsKey$1(slopeMap, J.get$index$x(tile)) === true) {
            t2 = J.getInterceptor$x(tile);
            body = E.Body$0(this, null, 3, t1.$index(slopeMap, t2.get$index(tile)), 0, J.$add$ns(tile.get$worldX(), tile.get$centerX()), J.$add$ns(tile.get$worldY(), tile.get$centerY()), t2.get$width(tile), t2.get$height(tile));
            J.add$1$ax(J.$index$asx(map.get$layers(), layer).get$bodies(), body);
          }
        }
      }
      return J.$index$asx(map.get$layers(), layer).get$bodies();
    }, "call$3", "get$convertTilemap", 6, 0, 1507, 775, [], 452, [], 1508, [], "convertTilemap"],
    overlap$4: [function(object1, object2, overlapCallback, processCallback) {
      var t1, len, i;
      this._result = false;
      this._total = 0;
      t1 = J.getInterceptor(object2);
      if (!!t1.$isList) {
        len = t1.get$length(object2);
        if (typeof len !== "number")
          return H.iae(len);
        i = 0;
        for (; i < len; ++i)
          this.collideHandler$5(object1, t1.$index(object2, i), overlapCallback, processCallback, true);
      } else
        this.collideHandler$5(object1, object2, overlapCallback, processCallback, true);
      return J.$gt$n(this._total, 0);
    }, function(object1, object2) {
      return this.overlap$4(object1, object2, null, null);
    }, "overlap$2", function(object1, object2, overlapCallback) {
      return this.overlap$4(object1, object2, overlapCallback, null);
    }, "overlap$3", "call$4", "call$2", "call$3", "get$overlap", 4, 4, 1458, 32, 32, 1459, [], 1460, [], 1461, [], 1462, [], "overlap"],
    collide$4: [function(object1, object2, collideCallback, processCallback) {
      var t1, len, i;
      this._result = false;
      this._total = 0;
      t1 = J.getInterceptor(object2);
      if (!!t1.$isList) {
        len = t1.get$length(object2);
        if (typeof len !== "number")
          return H.iae(len);
        i = 0;
        for (; i < len; ++i)
          this.collideHandler$5(object1, t1.$index(object2, i), collideCallback, processCallback, false);
      } else
        this.collideHandler$5(object1, object2, collideCallback, processCallback, false);
      return J.$gt$n(this._total, 0);
    }, function(object1, object2) {
      return this.collide$4(object1, object2, null, null);
    }, "collide$2", function(object1, object2, collideCallback) {
      return this.collide$4(object1, object2, collideCallback, null);
    }, "collide$3", "call$4", "call$2", "call$3", "get$collide", 4, 4, 1458, 32, 32, 1459, [], 1460, [], 1463, [], 1462, [], "collide"],
    collideHandler$5: [function(object1, object2, collideCallback, processCallback, overlapOnly) {
      var t1, t2;
      t1 = object2 == null;
      if (t1) {
        t2 = J.getInterceptor$x(object1);
        t2 = J.$eq(t2.get$type(object1), 7) || J.$eq(t2.get$type(object1), 11);
      } else
        t2 = false;
      if (t2) {
        this.collideGroupVsSelf$4(object1, collideCallback, processCallback, overlapOnly);
        return;
      }
      if (object1 != null && !t1 && object1.get$exists() === true && object2.get$exists() === true) {
        t1 = J.getInterceptor$x(object1);
        if (J.$eq(t1.get$type(object1), 0) || J.$eq(t1.get$type(object1), 5)) {
          t2 = J.getInterceptor$x(object2);
          if (J.$eq(t2.get$type(object2), 0) || J.$eq(t2.get$type(object2), 5)) {
            if (this.separate$2(H.interceptedTypeCast(t1.get$body(object1), "$isBody2"), H.interceptedTypeCast(t2.get$body(object2), "$isBody2"))) {
              if (collideCallback != null)
                collideCallback.call$2(object1, object2);
              this._total = J.$add$ns(this._total, 1);
            }
          } else if (J.$eq(t2.get$type(object2), 7) || J.$eq(t2.get$type(object2), 11))
            this.collideSpriteVsGroup$5(object1, object2, collideCallback, processCallback, overlapOnly);
          else if (J.$eq(t2.get$type(object2), 10))
            throw H.wrapException(P.Expando$("Not implement yet!", null));
        } else if (J.$eq(t1.get$type(object1), 7)) {
          t1 = J.getInterceptor$x(object2);
          if (J.$eq(t1.get$type(object2), 0) || J.$eq(t1.get$type(object2), 5))
            this.collideSpriteVsGroup$5(object2, object1, collideCallback, processCallback, overlapOnly);
          else if (J.$eq(t1.get$type(object2), 7) || J.$eq(t1.get$type(object2), 11))
            this.collideGroupVsGroup$5(object1, object2, collideCallback, processCallback, overlapOnly);
          else if (J.$eq(t1.get$type(object2), 10))
            throw H.wrapException(P.Expando$("Not implement yet!", null));
        } else if (J.$eq(t1.get$type(object1), 10)) {
          t1 = J.getInterceptor$x(object2);
          if (J.$eq(t1.get$type(object2), 0) || J.$eq(t1.get$type(object2), 5))
            throw H.wrapException(P.Expando$("Not implement yet!", null));
          else if (J.$eq(t1.get$type(object2), 7) || J.$eq(t1.get$type(object2), 11))
            throw H.wrapException(P.Expando$("Not implement yet!", null));
        } else if (J.$eq(t1.get$type(object1), 11)) {
          t1 = J.getInterceptor$x(object2);
          if (J.$eq(t1.get$type(object2), 0) || J.$eq(t1.get$type(object2), 5))
            this.collideSpriteVsGroup$5(object2, object1, collideCallback, processCallback, overlapOnly);
          else if (J.$eq(t1.get$type(object2), 7) || J.$eq(t1.get$type(object2), 11))
            this.collideGroupVsGroup$5(object1, object2, collideCallback, processCallback, overlapOnly);
          else if (J.$eq(t1.get$type(object2), 10))
            throw H.wrapException(P.Expando$("Not implement yet!", null));
        }
      }
    }, function(object1, object2) {
      return this.collideHandler$5(object1, object2, null, null, null);
    }, "collideHandler$2", function(object1, object2, collideCallback) {
      return this.collideHandler$5(object1, object2, collideCallback, null, null);
    }, "collideHandler$3", function(object1, object2, collideCallback, processCallback) {
      return this.collideHandler$5(object1, object2, collideCallback, processCallback, null);
    }, "collideHandler$4", "call$5", "call$2", "call$3", "call$4", "get$collideHandler", 4, 6, 1509, 32, 32, 32, 1459, [], 1460, [], 1463, [], 1462, [], 1465, [], "collideHandler"],
    collideSpriteVsSprite$5: [function(sprite1, sprite2, collideCallback, processCallback, overlapOnly) {
      if (this.separate$2(H.interceptedTypeCast(J.get$body$x(sprite1), "$isBody2"), H.interceptedTypeCast(J.get$body$x(sprite2), "$isBody2"))) {
        if (collideCallback != null)
          collideCallback.call$2(sprite1, sprite2);
        this._total = J.$add$ns(this._total, 1);
      }
    }, "call$5", "get$collideSpriteVsSprite", 10, 0, 1510, 1467, [], 1468, [], 1463, [], 1462, [], 1465, [], "collideSpriteVsSprite"],
    collideSpriteVsGroup$5: [function(sprite, group, collideCallback, processCallback, overlapOnly) {
      var t1, len, t2, t3, i;
      t1 = J.getInterceptor$asx(group);
      if (J.$eq(t1.get$length(group), 0))
        return;
      len = J.get$length$asx(t1.get$children(group));
      if (typeof len !== "number")
        return H.iae(len);
      t2 = J.getInterceptor$x(sprite);
      t3 = collideCallback != null;
      i = 0;
      for (; i < len; ++i)
        if (J.$index$asx(t1.get$children(group), i).get$exists() === true && J.get$body$x(J.$index$asx(t1.get$children(group), i)) === true && this.separate$2(H.interceptedTypeCast(t2.get$body(sprite), "$isBody2"), H.interceptedTypeCast(J.get$body$x(J.$index$asx(t1.get$children(group), i)), "$isBody2"))) {
          if (t3)
            collideCallback.call$2(sprite, J.$index$asx(t1.get$children(group), i));
          this._total = J.$add$ns(this._total, 1);
        }
    }, "call$5", "get$collideSpriteVsGroup", 10, 0, 1511, 113, [], 253, [], 1463, [], 1462, [], 1465, [], "collideSpriteVsGroup"],
    collideGroupVsSelf$4: [function(group, collideCallback, processCallback, overlapOnly) {
      var t1, len, t2, i, j, j0, t3, t4;
      t1 = J.getInterceptor$asx(group);
      if (J.$eq(t1.get$length(group), 0))
        return;
      len = J.get$length$asx(t1.get$children(group));
      if (typeof len !== "number")
        return H.iae(len);
      t2 = collideCallback != null;
      i = 0;
      for (; i < len; i = j)
        for (j = i + 1, j0 = j; j0 <= len; ++j0)
          if (J.$index$asx(t1.get$children(group), i) === true && J.$index$asx(t1.get$children(group), j0) === true && J.$index$asx(t1.get$children(group), i).get$exists() === true && J.$index$asx(t1.get$children(group), j0).get$exists() === true) {
            t3 = J.$index$asx(t1.get$children(group), i);
            t4 = J.$index$asx(t1.get$children(group), j0);
            if (this.separate$2(H.interceptedTypeCast(J.get$body$x(t3), "$isBody2"), H.interceptedTypeCast(J.get$body$x(t4), "$isBody2"))) {
              if (t2)
                collideCallback.call$2(t3, t4);
              this._total = J.$add$ns(this._total, 1);
            }
          }
    }, "call$4", "get$collideGroupVsSelf", 8, 0, 1512, 253, [], 1463, [], 1462, [], 1465, [], "collideGroupVsSelf"],
    collideGroupVsGroup$5: [function(group1, group2, collideCallback, processCallback, overlapOnly) {
      var t1, len, i;
      t1 = J.getInterceptor$asx(group1);
      if (J.$eq(t1.get$length(group1), 0) || J.$eq(J.get$length$asx(group2), 0))
        return;
      len = J.get$length$asx(t1.get$children(group1));
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        if (J.$index$asx(t1.get$children(group1), i).get$exists() === true)
          this.collideSpriteVsGroup$5(J.$index$asx(t1.get$children(group1), i), group2, collideCallback, processCallback, overlapOnly);
    }, "call$5", "get$collideGroupVsGroup", 10, 0, 1513, 1472, [], 1473, [], 1463, [], 1462, [], 1465, [], "collideGroupVsGroup"],
    separate$2: [function(body1, body2) {
      if (!J.$eq(J.get$type$x(body1), 2) || !J.$eq(J.get$type$x(body2), 2))
        return false;
      if (body1.get$aabb() != null && body2.get$aabb() != null)
        return body1.get$aabb().collideAABBVsAABB$1(body2.get$aabb()) !== false;
      if (body1.get$aabb() != null && body2.get$tile() != null)
        return !J.$eq(body1.get$aabb().collideAABBVsTile$1(body2.get$tile()), false);
      if (body1.get$tile() != null && body2.get$aabb() != null)
        return !J.$eq(body2.get$aabb().collideAABBVsTile$1(body1.get$tile()), false);
      if (body1.get$circle() != null && body2.get$tile() != null)
        return !J.$eq(body1.get$circle().collideCircleVsTile$1(body2.get$tile()), false);
      if (body1.get$tile() != null && body2.get$circle() != null)
        return !J.$eq(body2.get$circle().collideCircleVsTile$1(body1.get$tile()), false);
      throw H.wrapException(P.Exception_Exception("Error!"));
    }, "call$2", "get$separate", 4, 0, 1514, 1478, [], 1479, [], "separate"],
    Ninja$1: function(game) {
      var t1, t2, t3, t4, t5, t6, t7, t8;
      this.game = game;
      this.time = game.get$time();
      this.gravity = 0.2;
      this.bounds = new R.Rectangle1(0, 0, J.get$width$x(game.get$world()), J.get$height$x(game.get$world()), 0, 0, 0, 0);
      this.maxObjects = 10;
      this.maxLevels = 4;
      t1 = J.get$x$x(this.game.get$world().get$bounds());
      t2 = J.get$y$x(this.game.get$world().get$bounds());
      t3 = J.get$width$x(this.game.get$world().get$bounds());
      t4 = J.get$height$x(this.game.get$world().get$bounds());
      t5 = this.maxObjects;
      t6 = this.maxLevels;
      t7 = H.setRuntimeTypeInfo([], [R.Body0]);
      t8 = Array(4);
      t8.fixed$length = init;
      t8 = new R.QuadTree(10, 4, 0, null, t7, H.setRuntimeTypeInfo(t8, [R.QuadTree]));
      t8.reset$7(0, J.toInt$0$n(t1), J.toInt$0$n(t2), J.toInt$0$n(t3), J.toInt$0$n(t4), t5, t6, null);
      this.quadTree = t8;
    },
    static: {Ninja$: [function(game) {
        var t1 = new R.Ninja(null, null, null, null, 10, 4, null, false, 0);
        t1.Ninja$1(game);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new Ninja"]}
  },
  "+Ninja": [632],
  P2: {
    "^": "Object;",
    static: {P2$: [function() {
        return new R.P2();
      }, null, null, 0, 0, 13, "new P2"]}
  },
  "+P2": [632],
  Physics: {
    "^": "Object;game@-598,config@-754,arcade@-1515,ninja@-1516,p2@-32,box2d@-32,chipmunk@-32",
    parseConfig$0: [function() {
      if (J.containsKey$1$x(this.config, "arcade") !== true || J.$eq(J.$index$asx(this.config, "arcade"), true)) {
        this.arcade = R.Arcade$(this.game);
        this.game.get$time().set$deltaCap(0.2);
      }
    }, "call$0", "get$parseConfig", 0, 0, 13, "parseConfig"],
    startSystem$1: [function(system) {
      var t1 = J.getInterceptor(system);
      if (t1.$eq(system, 0))
        this.arcade = R.Arcade$(this.game);
      if (t1.$eq(system, 2)) {
        t1 = new R.Ninja(null, null, null, null, 10, 4, null, false, 0);
        t1.Ninja$1(this.game);
        this.ninja = t1;
      }
      this.setBoundsToWorld$0();
    }, "call$1", "get$startSystem", 2, 0, 60, 1517, [], "startSystem"],
    enable$3: [function(_, object, system, debug) {
      var t1;
      if (system == null)
        system = 0;
      if (debug == null)
        debug = false;
      t1 = J.getInterceptor(system);
      if (t1.$eq(system, 0))
        J.enable$1$x(this.arcade, object);
      else if (t1.$eq(system, 1) && this.p2 != null)
        J.enable$2$x(this.p2, object, debug);
      else if (t1.$eq(system, 2) && this.ninja != null)
        this.ninja.enableAABB$1(object);
    }, function($receiver, object, system) {
      return this.enable$3($receiver, object, system, null);
    }, "enable$2", function($receiver, object) {
      return this.enable$3($receiver, object, null, null);
    }, "enable$1", "call$3", "call$2", "call$1", "get$enable", 2, 4, 1503, 32, 32, 541, [], 1517, [], 610, [], "enable"],
    preUpdate$0: [function() {
      var t1 = this.p2;
      if (t1 != null)
        t1.preUpdate$0();
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    update$0: [function() {
      var t1 = this.p2;
      if (t1 != null)
        t1.update$0();
    }, "call$0", "get$update", 0, 0, 13, "update"],
    setBoundsToWorld$0: [function() {
      var t1 = this.arcade;
      if (t1 != null)
        t1.setBoundsToWorld$0();
      t1 = this.ninja;
      if (t1 != null)
        t1.setBoundsToWorld$0();
      t1 = this.p2;
      if (t1 != null)
        t1.setBoundsToWorld$0();
    }, "call$0", "get$setBoundsToWorld", 0, 0, 13, "setBoundsToWorld"],
    clear$0: [function(_) {
      var t1 = this.p2;
      if (t1 != null)
        J.clear$0$ax(t1);
    }, "call$0", "get$clear", 0, 0, 13, "clear"],
    destroy$0: [function() {
      var t1 = this.p2;
      if (t1 != null)
        t1.destroy$0();
      this.arcade = null;
      this.ninja = null;
      this.p2 = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    Physics$2: function(game, config) {
      if (config == null)
        config = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this.game = game;
      this.config = config;
      this.arcade = null;
      if (J.containsKey$1$x(config, "arcade") !== true || J.$eq(J.$index$asx(this.config, "arcade"), true)) {
        this.arcade = R.Arcade$(this.game);
        this.game.get$time().set$deltaCap(0.2);
      }
    },
    static: {"^": "Physics_ARCADE<-599,Physics_P2JS<-599,Physics_NINJA<-599,Physics_BOX2D<-599,Physics_CHIPMUNK<-599", Physics$: [function(game, config) {
        var t1 = new R.Physics(null, null, null, null, null, null, null);
        t1.Physics$2(game, config);
        return t1;
      }, null, null, 2, 2, 421, 422, 214, [], 423, [], "new Physics"]}
  },
  "+Physics": [632],
  Marker: {
    "^": "Object;name*-639,start*-601,stop*-601,volume*-601,duration*-601,durationMS@-601,loop*-602",
    start$1: function($receiver, arg0) {
      return this.start.call$1(arg0);
    },
    start$0: function($receiver) {
      return this.start.call$0();
    },
    start$3: function($receiver, arg0, arg1, arg2) {
      return this.start.call$3(arg0, arg1, arg2);
    },
    start$2: function($receiver, arg0, arg1) {
      return this.start.call$2(arg0, arg1);
    },
    start$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.start.call$4(arg0, arg1, arg2, arg3);
    },
    start$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.start.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    stop$0: function($receiver) {
      return this.stop.call$0();
    },
    stop$1: function($receiver, arg0) {
      return this.stop.call$1(arg0);
    },
    stop$2: function($receiver, arg0, arg1) {
      return this.stop.call$2(arg0, arg1);
    },
    loop$0: function($receiver) {
      return this.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return this.loop.call$3(arg0, arg1, arg2);
    },
    static: {Marker$: [function() {
        return new R.Marker(null, null, null, null, null, null, null);
      }, null, null, 0, 0, 424, "new Marker"]}
  },
  "+Marker": [632],
  Sound: {
    "^": "Object;game@-598,name*-639,key*-639,markers@-1518,context*-1519,autoplay*-602,totalDuration@-629,startTime@-629,currentTime*-629,duration*-629,durationMS@-629,position*-599,stopTime@-629,paused*-602,pausedPosition@-629,pausedTime@-629,isPlaying@-602,currentMarker@-639,pendingPlayback@-602,override@-602,usingWebAudio@-602,usingAudioTag@-602,externalNode@-754,masterGainNode@-1520,gainNode@-1521,loop*-602,onDecoded@-1343,onPlay*-1343,onPause*-1343,onResume@-1343,onLoop@-1343,onStop@-1343,onMute@-1343,onMarkerComplete@-1343,_volume@-601,_Phaser$_buffer@-32,_muted@-602,_tempMarker@-639,_tempPosition@-599,_tempVolume@-629,_tempLoop@-602,_paused@-602,_onDecodedEventDispatched@-602,_muteVolume@-629,_sound@-32",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    paused$0: function($receiver) {
      return this.paused.call$0();
    },
    loop$0: function($receiver) {
      return this.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return this.loop.call$3(arg0, arg1, arg2);
    },
    get$isDecoding: [function() {
      return J.$index$asx(this.game.get$cache().getSound$1(this.key), "isDecoding");
    }, null, null, 1, 0, 209, "isDecoding"],
    get$isDecoded: [function() {
      return this.game.get$cache().isSoundDecoded$1(this.key);
    }, null, null, 1, 0, 209, "isDecoded"],
    get$mute: [function() {
      return this._muted === true || this.game.get$sound().get$mute() === true;
    }, null, null, 1, 0, 209, "mute"],
    set$mute: [function(value) {
      if (value === true) {
        this._muted = true;
        if (this.usingWebAudio === true) {
          this._muteVolume = J.get$gain$x(this.gainNode).value;
          J.get$gain$x(this.gainNode).value = 0;
        } else if (this.usingAudioTag === true && this._sound === true) {
          this._muteVolume = J.$index$asx(this._sound, "volume");
          J.$indexSet$ax(this._sound, "volume", 0);
        }
      } else {
        this._muted = false;
        if (this.usingWebAudio === true)
          J.get$gain$x(this.gainNode).value = this._muteVolume;
        else if (this.usingAudioTag === true && this._sound === true)
          J.$indexSet$ax(this._sound, "volume", this._muteVolume);
      }
      this.onMute.dispatch$1(this);
    }, null, null, 3, 0, 650, 100, [], "mute"],
    get$volume: [function(_) {
      return this._volume;
    }, null, null, 1, 0, 604, "volume"],
    set$volume: [function(_, value) {
      var t1;
      if (this.usingWebAudio === true) {
        this._volume = value;
        J.get$gain$x(this.gainNode).value = value;
      } else if (this.usingAudioTag === true && this._sound === true) {
        t1 = J.getInterceptor$n(value);
        if (t1.$ge(value, 0) && t1.$le(value, 1)) {
          this._volume = value;
          J.$indexSet$ax(this._sound, "volume", value);
        }
      }
    }, null, null, 3, 0, 605, 100, [], "volume"],
    soundHasUnlocked$1: [function(key) {
      var t1;
      if (J.$eq(key, this.key)) {
        t1 = this.game.get$cache().getSoundData$1(this.key);
        this._sound = t1;
        if (!!J.getInterceptor(t1).$isAudioElement)
          this.totalDuration = H.interceptedTypeCast(t1, "$isAudioElement").duration;
        else
          this.totalDuration = H.interceptedTypeCast(t1, "$isAudioBuffer").duration;
      }
    }, "call$1", "get$soundHasUnlocked", 2, 0, 63, 231, [], "soundHasUnlocked"],
    addMarker$5: [function($name, start, duration, volume, loop) {
      var t1, t2;
      if (volume == null)
        volume = 1;
      if (loop == null)
        loop = false;
      t1 = this.markers;
      t2 = new R.Marker(null, null, null, null, null, null, null);
      t2.name = $name;
      t2.start = start;
      t2.stop = J.$add$ns(start, duration);
      t2.volume = volume;
      t2.duration = duration;
      t2.durationMS = J.$mul$ns(duration, 1000);
      t2.loop = loop;
      J.$indexSet$ax(t1, $name, t2);
    }, function(name, start, duration) {
      return this.addMarker$5(name, start, duration, 1, false);
    }, "addMarker$3", function(name, start, duration, volume) {
      return this.addMarker$5(name, start, duration, volume, false);
    }, "addMarker$4", "call$5", "call$3", "call$4", "get$addMarker", 6, 4, 1522, 390, 95, 44, [], 223, [], 55, [], 426, [], 219, [], "addMarker"],
    removeMarker$1: [function($name) {
      J.remove$1$ax(this.markers, $name);
    }, "call$1", "get$removeMarker", 2, 0, 63, 44, [], "removeMarker"],
    update$0: [function() {
      if (this.game.get$cache().isSoundDecoded$1(this.key) === true && this._onDecodedEventDispatched !== true) {
        this.onDecoded.dispatch$1(this);
        this._onDecodedEventDispatched = true;
      }
      if (this.pendingPlayback === true && this.game.get$cache().isSoundReady$1(this.key)) {
        this.pendingPlayback = false;
        this.play$4(0, this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop);
      }
      if (this.isPlaying === true) {
        var t1 = J.$sub$n(this.game.get$time().get$now(), this.startTime);
        this.currentTime = t1;
        if (J.$ge$n(t1, this.durationMS))
          if (this.usingWebAudio === true)
            if (this.loop === true) {
              this.onLoop.dispatch$1(this);
              if (J.$eq(this.currentMarker, "")) {
                this.currentTime = 0;
                this.startTime = this.game.get$time().get$now();
              } else {
                this.onMarkerComplete.dispatch$1([this.currentMarker, this]);
                this.play$5(0, this.currentMarker, 0, this._volume, true, true);
              }
            } else
              this.stop$0(0);
          else if (this.loop === true) {
            this.onLoop.dispatch$1(this);
            this.play$5(0, this.currentMarker, 0, this._volume, true, true);
          } else
            this.stop$0(0);
      }
    }, "call$0", "get$update", 0, 0, 13, "update"],
    play$5: [function(_, marker, position, volume, loop, forceRestart) {
      var t1, t2, t3, t4;
      if (marker == null)
        marker = "";
      if (forceRestart == null)
        forceRestart = true;
      if (J.$eq(this.isPlaying, true) && J.$eq(forceRestart, false) && J.$eq(this.override, false))
        return this;
      if (this.isPlaying === true && this.override === true)
        if (this.usingWebAudio === true) {
          t1 = J.get$stop$x(this._sound);
          t2 = this._sound;
          if (t1 == null)
            J.noteOff$1$x(t2, 0);
          else
            J.stop$1$x(t2, 0);
        } else if (this.usingAudioTag === true) {
          J.pause$0$x(this._sound);
          J.set$currentTime$x(this._sound, 0);
        }
      this.currentMarker = marker;
      t1 = J.getInterceptor(marker);
      if (!t1.$eq(marker, ""))
        if (J.$index$asx(this.markers, marker) != null) {
          this.position = J.get$start$x(J.$index$asx(this.markers, marker));
          this.set$volume(0, J.get$volume$x(J.$index$asx(this.markers, marker)));
          this.loop = J.get$loop$x(J.$index$asx(this.markers, marker));
          this.duration = J.get$duration$x(J.$index$asx(this.markers, marker));
          this.durationMS = J.$index$asx(this.markers, marker).get$durationMS();
          if (volume != null)
            this.set$volume(0, volume);
          if (loop != null)
            this.loop = loop;
          this._tempMarker = marker;
          this._tempPosition = this.position;
          this._tempVolume = this._volume;
          this._tempLoop = this.loop;
        } else {
          window;
          t1 = C.JSString_methods.$add("Phaser.Sound.play: audio marker ", marker) + " doesn't exist";
          if (typeof console != "undefined")
            console.warn(t1);
          return this;
        }
      else {
        if (volume == null)
          volume = this._volume;
        if (loop == null)
          loop = this.loop;
        this.position = position;
        this.set$volume(0, volume);
        this.loop = loop;
        this.duration = 0;
        this.durationMS = 0;
        this._tempMarker = marker;
        this._tempPosition = position;
        this._tempVolume = volume;
        this._tempLoop = loop;
      }
      if (this.usingWebAudio === true)
        if (this.game.get$cache().isSoundDecoded$1(this.key) === true) {
          if (this._Phaser$_buffer == null)
            this._Phaser$_buffer = this.game.get$cache().getSoundData$1(this.key);
          t2 = J.createBufferSource$0$x(this.context);
          this._sound = t2;
          t2.buffer = this._Phaser$_buffer;
          t2 = this.externalNode;
          t3 = this._sound;
          if (t2 != null)
            J.connectNode$1$x(t3, t2);
          else
            J.connectNode$1$x(t3, this.gainNode);
          this.totalDuration = J.get$duration$x(J.get$buffer$x(this._sound));
          if (J.$eq(this.duration, 0)) {
            t2 = this.totalDuration;
            this.duration = t2;
            this.durationMS = J.$mul$ns(t2, 1000);
          }
          if (this.loop === true && t1.$eq(marker, ""))
            J.set$loop$x(this._sound, true);
          t1 = J.get$start$x(this._sound);
          t2 = this._sound;
          t3 = this.position;
          t4 = this.duration;
          if (t1 == null)
            J.noteGrainOn$3$x(t2, 0, t3, t4);
          else
            J.start$3$x(t2, 0, t3, t4);
          this.isPlaying = true;
          t1 = this.game.get$time().get$now();
          this.startTime = t1;
          this.currentTime = 0;
          this.stopTime = J.$add$ns(t1, this.durationMS);
          this.onPlay.dispatch$1(this);
        } else {
          this.pendingPlayback = true;
          if (this.game.get$cache().getSound$1(this.key) != null && J.$eq(J.$index$asx(this.game.get$cache().getSound$1(this.key), "isDecoding"), false))
            this.game.get$sound().decode$2(this.key, this);
        }
      else if (this.game.get$cache().getSound$1(this.key) != null && J.$index$asx(this.game.get$cache().getSound$1(this.key), "locked") === true) {
        this.game.get$cache().reloadSound$1(this.key);
        this.pendingPlayback = true;
      } else {
        if (this._sound != null)
          t1 = this.game.get$device().get$cocoonJS() === true || J.get$readyState$x(this._sound) === 4;
        else
          t1 = false;
        if (t1) {
          J.play$0$x(this._sound);
          this.totalDuration = J.get$duration$x(this._sound);
          if (J.$eq(this.duration, 0)) {
            t1 = this.totalDuration;
            this.duration = t1;
            this.durationMS = J.$mul$ns(t1, 1000);
          }
          J.set$currentTime$x(this._sound, this.position);
          J.set$muted$x(this._sound, this._muted);
          t1 = this._muted;
          t2 = this._sound;
          if (t1 === true)
            J.set$volume$x(t2, 0);
          else
            J.set$volume$x(t2, this._volume);
          this.isPlaying = true;
          t1 = this.game.get$time().get$now();
          this.startTime = t1;
          this.currentTime = 0;
          this.stopTime = J.$add$ns(t1, this.durationMS);
          this.onPlay.dispatch$1(this);
        } else
          this.pendingPlayback = true;
      }
      return this;
    }, function($receiver, marker) {
      return this.play$5($receiver, marker, 0, 1, false, true);
    }, "play$1", function($receiver) {
      return this.play$5($receiver, null, 0, 1, false, true);
    }, "play$0", function($receiver, marker, position, volume, loop) {
      return this.play$5($receiver, marker, position, volume, loop, true);
    }, "play$4", function($receiver, marker, position, volume) {
      return this.play$5($receiver, marker, position, volume, false, true);
    }, "play$3", function($receiver, marker, position) {
      return this.play$5($receiver, marker, position, 1, false, true);
    }, "play$2", "call$5", "call$1", "call$0", "call$4", "call$3", "call$2", "get$play", 0, 10, 1523, 32, 5, 390, 95, 39, 1130, [], 929, [], 426, [], 219, [], 1524, [], "play"],
    restart$4: [function(marker, position, volume, loop) {
      this.play$5(0, marker, position, volume, loop == null ? false : loop, true);
    }, function(marker, position, volume) {
      return this.restart$4(marker, position, volume, false);
    }, "restart$3", function() {
      return this.restart$4("", 0, 1, false);
    }, "restart$0", function(marker) {
      return this.restart$4(marker, 0, 1, false);
    }, "restart$1", function(marker, position) {
      return this.restart$4(marker, position, 1, false);
    }, "restart$2", "call$4", "call$3", "call$0", "call$1", "call$2", "get$restart", 0, 8, 1525, 221, 5, 390, 95, 1130, [], 929, [], 426, [], 219, [], "restart"],
    pause$0: [function(_) {
      if (this.isPlaying === true && this._sound != null) {
        this.paused = true;
        this.pausedPosition = this.currentTime;
        this.pausedTime = this.game.get$time().get$now();
        this.onPause.dispatch$1(this);
        this.stop$0(0);
      }
    }, "call$0", "get$pause", 0, 0, 13, "pause"],
    resume$0: [function() {
      var p, t1, t2, t3;
      if (this.paused === true && this._sound === true) {
        if (this.usingWebAudio === true) {
          p = J.$add$ns(this.position, J.$div$n(this.pausedPosition, 1000));
          t1 = J.createBufferSource$0$x(this.context);
          this._sound = t1;
          t1.buffer = this._Phaser$_buffer;
          t1 = this.externalNode;
          t2 = this._sound;
          if (t1 != null)
            J.connectNode$1$x(t2, t1);
          else
            J.connectNode$1$x(t2, this.gainNode);
          if (this.loop === true)
            J.set$loop$x(this._sound, true);
          t1 = J.get$start$x(this._sound);
          t2 = this._sound;
          t3 = this.duration;
          if (t1 == null)
            J.noteGrainOn$3$x(t2, 0, p, t3);
          else
            J.start$3$x(t2, 0, p, t3);
        } else
          J.play$0$x(this._sound);
        this.isPlaying = true;
        this.paused = false;
        this.startTime = J.$add$ns(this.startTime, J.$sub$n(this.game.get$time().get$now(), this.pausedTime));
        this.onResume.dispatch$1(this);
      }
    }, "call$0", "get$resume", 0, 0, 13, "resume"],
    stop$0: [function(_) {
      var exception, prevMarker;
      if (this.isPlaying === true && this._sound != null)
        if (this.usingWebAudio === true)
          if (J.get$stop$x(this._sound) == null)
            J.noteOff$1$x(this._sound, 0);
          else
            try {
              J.stop$1$x(this._sound, 0);
            } catch (exception) {
              H.unwrapException(exception);
            }

        else if (this.usingAudioTag === true) {
          J.pause$0$x(this._sound);
          J.set$currentTime$x(this._sound, 0);
        }
      this.isPlaying = false;
      prevMarker = this.currentMarker;
      if (!J.$eq(prevMarker, ""))
        this.onMarkerComplete.dispatch$1([this.currentMarker, this]);
      this.currentMarker = "";
      if (this.paused !== true)
        this.onStop.dispatch$1([this, prevMarker]);
    }, "call$0", "get$stop", 0, 0, 13, "stop"],
    destroy$1: [function(remove) {
      this.stop$0(0);
      if (remove === true)
        J.remove$1$ax(this.game.get$sound(), this);
      else {
        this.markers = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        this.context = null;
        this._Phaser$_buffer = null;
        this.externalNode = null;
        this.onDecoded.dispose$0();
        this.onPlay.dispose$0();
        this.onPause.dispose$0();
        this.onResume.dispose$0();
        this.onLoop.dispose$0();
        this.onStop.dispose$0();
        this.onMute.dispose$0();
        this.onMarkerComplete.dispose$0();
      }
    }, function() {
      return this.destroy$1(true);
    }, "destroy$0", "call$1", "call$0", "get$destroy", 0, 2, 932, 39, 1526, [], "destroy"],
    Sound$5: function(game, key, volume, loop, connect) {
      var t1, t2;
      if (connect == null)
        connect = this.game.get$sound().get$connectToMaster();
      this.name = key;
      this.key = key;
      this.markers = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this.context = null;
      this.autoplay = false;
      this.totalDuration = 0;
      this.startTime = 0;
      this.currentTime = 0;
      this.duration = 0;
      this.durationMS = 0;
      this.position = 0;
      this.stopTime = 0;
      this.paused = false;
      this.pausedPosition = 0;
      this.pausedTime = 0;
      this.isPlaying = false;
      this.currentMarker = "";
      this.pendingPlayback = false;
      this.override = false;
      this.usingWebAudio = this.game.get$sound().get$usingWebAudio();
      this.usingAudioTag = this.game.get$sound().get$usingAudioTag();
      this.externalNode = null;
      this.masterGainNode = null;
      this.gainNode = null;
      this.loop = loop;
      if (this.usingWebAudio === true) {
        this.context = J.get$context$x(this.game.get$sound());
        this.masterGainNode = this.game.get$sound().get$masterGain();
        t1 = J.createGain$0$x(this.context);
        this.gainNode = t1;
        t1.gain.value = J.$mul$ns(volume, J.get$volume$x(this.game.get$sound()));
        if (connect === true)
          J.connectNode$1$x(this.gainNode, this.masterGainNode);
      } else {
        t1 = this.game.get$cache().getSound$1(key) != null && this.game.get$cache().isSoundReady$1(key);
        t2 = this.game;
        if (t1) {
          t1 = t2.get$cache().getSoundData$1(key);
          this._sound = t1;
          this.totalDuration = 0;
          this.totalDuration = H.interceptedTypeCast(t1, "$isAudioElement").duration;
        } else
          J.add$1$ax(t2.get$cache().get$onSoundUnlock(), this.get$soundHasUnlocked());
      }
      this.onDecoded = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onPlay = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onPause = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onResume = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onLoop = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onStop = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onMute = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this.onMarkerComplete = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this._volume = volume;
      this._Phaser$_buffer = null;
      this._muted = false;
      this._tempMarker = "";
      this._tempPosition = 0;
      this._tempVolume = 0;
      this._tempLoop = false;
      this._paused = false;
      this._onDecodedEventDispatched = false;
    },
    static: {Sound$: [function(game, key, volume, loop, connect) {
        var t1 = new R.Sound(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false, null, null, null, null);
        t1.Sound$5(game, key, volume, loop, connect);
        return t1;
      }, null, null, 4, 6, 425, 390, 95, 32, 214, [], 231, [], 426, [], 219, [], 427, [], "new Sound"]}
  },
  "+Sound": [632],
  SoundManager: {
    "^": "Object;game@-598,onSoundDecode@-1343,_codeMuted@-602,_muted@-602,_volume@-629,_sounds@-1527,context*-1519,usingWebAudio@-602,usingAudioTag@-602,noAudio@-602,connectToMaster@-602,touchLocked@-602,channels@-599,masterGain@-1521,_unlockSource@-1528,_muteVolume@-601",
    get$mute: [function() {
      return this._muted;
    }, null, null, 1, 0, 209, "mute"],
    set$mute: [function(value) {
      if (value === true) {
        if (this._muted === true)
          return;
        this._codeMuted = true;
        this.setMute$0();
      } else {
        if (this._muted !== true)
          return;
        this._codeMuted = false;
        this.unsetMute$0();
      }
    }, null, null, 3, 0, 650, 100, [], "mute"],
    get$volume: [function(_) {
      if (this.usingWebAudio === true && this.masterGain != null)
        return J.get$gain$x(this.masterGain).value;
      else
        return this._volume;
    }, null, null, 1, 0, 1337, "volume"],
    set$volume: [function(_, value) {
      var i, t1;
      this._volume = value;
      if (this.usingWebAudio === true && this.masterGain != null)
        J.get$gain$x(this.masterGain).value = value;
      else {
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this._sounds);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$index$asx(this._sounds, i).get$usingAudioTag() === true)
            J.set$volume$x(J.$index$asx(this._sounds, i), J.$mul$ns(J.get$volume$x(J.$index$asx(this._sounds, i)), value));
          ++i;
        }
      }
    }, null, null, 3, 0, 1016, 100, [], "volume"],
    boot$0: [function() {
      var exception, t1;
      if (this.game.get$device().get$iOS() === true && J.$eq(this.game.get$device().get$webAudio(), false))
        this.channels = 1;
      if (this.game.get$device().get$cocoonJS() !== true && this.game.get$device().get$iOS() === true) {
        this.game.get$input().get$touch().set$touchStartCallback(this.get$unlock());
        this.game.get$input().get$mouse().set$mouseDownCallback(this.get$unlock());
        this.touchLocked = true;
      } else
        this.touchLocked = false;
      try {
        this.context = new (window.AudioContext || window.webkitAudioContext)();
      } catch (exception) {
        H.unwrapException(exception);
        this.context = null;
        this.usingWebAudio = false;
        this.noAudio = true;
      }

      if (this.game.get$device().get$audioData() === true && this.context == null) {
        this.usingWebAudio = false;
        this.usingAudioTag = true;
        this.noAudio = false;
      }
      t1 = this.context;
      if (t1 == null)
        return;
      t1 = J.createGain$0$x(t1);
      this.masterGain = t1;
      if (this.context == null)
        return;
      t1.gain.value = 1;
      J.connectNode$1$x(this.masterGain, J.get$destination$x(this.context));
    }, "call$0", "get$boot", 0, 0, 13, "boot"],
    unlock$0: [function() {
      var buffer, t1;
      if (J.$eq(this.touchLocked, false))
        return;
      if (J.$eq(this.game.get$device().get$webAudio(), false)) {
        this.touchLocked = false;
        this._unlockSource = null;
        this.game.get$input().get$touch().set$touchStartCallback(null);
        this.game.get$input().get$mouse().set$mouseDownCallback(null);
      } else {
        buffer = J.createBuffer$3$x(this.context, 1, 1, 22050);
        t1 = J.createBufferSource$0$x(this.context);
        this._unlockSource = t1;
        t1.buffer = buffer;
        J.connectNode$1$x(this._unlockSource, J.get$destination$x(this.context));
        J.noteOn$1$x(this._unlockSource, 0);
      }
    }, "call$0", "get$unlock", 0, 0, 13, "unlock"],
    stopAll$0: [function() {
      var i, t1;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._sounds);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(this._sounds, i) != null)
          J.stop$0$x(J.$index$asx(this._sounds, i));
        ++i;
      }
    }, "call$0", "get$stopAll", 0, 0, 13, "stopAll"],
    pauseAll$0: [function() {
      var i, t1;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._sounds);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(this._sounds, i) != null)
          J.pause$0$x(J.$index$asx(this._sounds, i));
        ++i;
      }
    }, "call$0", "get$pauseAll", 0, 0, 13, "pauseAll"],
    resumeAll$0: [function() {
      var i, t1;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._sounds);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(this._sounds, i) != null)
          J.$index$asx(this._sounds, i).resume$0();
        ++i;
      }
    }, "call$0", "get$resumeAll", 0, 0, 13, "resumeAll"],
    decode$2: [function(key, sound) {
      var soundData = this.game.get$cache().getSoundData$1(key);
      if (soundData != null)
        if (J.$eq(this.game.get$cache().isSoundDecoded$1(key), false)) {
          this.game.get$cache().updateSound$3(key, "isDecoding", true);
          J.decodeAudioData$1$x(this.context, soundData).then$1(new R.SoundManager_decode_closure(key, sound, this));
        }
    }, function(key) {
      return this.decode$2(key, null);
    }, "decode$1", "call$2", "call$1", "get$decode", 2, 2, 1529, 32, 231, [], 1129, [], "decode"],
    update$0: [function() {
      var i, t1;
      if (this.touchLocked === true)
        ;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._sounds);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$index$asx(this._sounds, i).update$0();
        ++i;
      }
    }, "call$0", "get$update", 0, 0, 13, "update"],
    add$4: [function(_, key, volume, loop, connect) {
      var t1, sound;
      if (connect == null)
        connect = this.connectToMaster;
      t1 = this.game;
      sound = new R.Sound(t1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false, null, null, null, null);
      sound.Sound$5(t1, key, volume, loop, connect);
      J.add$1$ax(this._sounds, sound);
      return sound;
    }, function($receiver, key, volume) {
      return this.add$4($receiver, key, volume, false, null);
    }, "add$2", function($receiver, key) {
      return this.add$4($receiver, key, 1, false, null);
    }, "add$1", function($receiver, key, volume, loop) {
      return this.add$4($receiver, key, volume, loop, null);
    }, "add$3", "call$4", "call$2", "call$1", "call$3", "get$add", 2, 6, 1530, 390, 95, 32, 231, [], 426, [], 219, [], 427, [], "add"],
    remove$1: [function(_, sound) {
      var i, i0;
      i = J.get$length$asx(this._sounds);
      for (; i0 = J.$sub$n(i, 1), i === true; i = i0)
        if (J.$eq(J.$index$asx(this._sounds, i0), sound)) {
          J.$index$asx(this._sounds, i0).destroy$1(false);
          J.removeAt$1$ax(this._sounds, i0);
          return true;
        }
      return false;
    }, "call$1", "get$remove", 2, 0, 1531, 1129, [], "remove"],
    removeByKey$1: [function(key) {
      var i, removed, t1, i0;
      i = J.get$length$asx(this._sounds);
      for (removed = 0; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        if (J.$eq(J.get$key$x(J.$index$asx(this._sounds, i0)), key)) {
          J.$index$asx(this._sounds, i0).destroy$1(false);
          J.removeAt$1$ax(this._sounds, i0);
          ++removed;
        }
      return removed;
    }, "call$1", "get$removeByKey", 2, 0, 514, 231, [], "removeByKey"],
    play$3: [function(_, key, volume, loop) {
      var sound = this.add$3(0, key, volume, loop);
      sound.play$0(0);
      return sound;
    }, function($receiver, key) {
      return this.play$3($receiver, key, 1, false);
    }, "play$1", function($receiver, key, volume) {
      return this.play$3($receiver, key, volume, false);
    }, "play$2", "call$3", "call$1", "call$2", "get$play", 2, 4, 1532, 390, 95, 231, [], 426, [], 219, [], "play"],
    setMute$0: [function() {
      var i, t1;
      if (this._muted === true)
        return;
      this._muted = true;
      if (this.usingWebAudio === true && this.masterGain != null) {
        this._muteVolume = J.get$gain$x(this.masterGain).value;
        J.get$gain$x(this.masterGain).value = 0;
      }
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._sounds);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(this._sounds, i).get$usingAudioTag() === true)
          J.$index$asx(this._sounds, i).set$mute(true);
        ++i;
      }
    }, "call$0", "get$setMute", 0, 0, 13, "setMute"],
    unsetMute$0: [function() {
      var i, t1;
      if (this._muted !== true || this._codeMuted === true)
        return;
      this._muted = false;
      if (this.usingWebAudio === true && this.masterGain != null)
        J.get$gain$x(this.masterGain).value = this._muteVolume;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._sounds);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(this._sounds, i).get$usingAudioTag() === true)
          J.$index$asx(this._sounds, i).set$mute(false);
        ++i;
      }
    }, "call$0", "get$unsetMute", 0, 0, 13, "unsetMute"],
    SoundManager$1: function(game) {
      this.onSoundDecode = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      this._codeMuted = false;
      this._muted = false;
      this._unlockSource = null;
      this._volume = 1;
      this._sounds = [];
      this.context = null;
      this.usingWebAudio = true;
      this.usingAudioTag = false;
      this.noAudio = false;
      this.connectToMaster = true;
      this.touchLocked = false;
      this.channels = 32;
    },
    static: {SoundManager$: [function(game) {
        var t1 = new R.SoundManager(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.SoundManager$1(game);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new SoundManager"]}
  },
  "+SoundManager": [632],
  SoundManager_decode_closure: {
    "^": "Closure:63;key_0,sound_1,that_2",
    call$1: [function(buffer) {
      var t1, t2, t3;
      t1 = this.that_2;
      t2 = this.key_0;
      t1.game.get$cache().decodedSound$2(t2, buffer);
      t3 = this.sound_1;
      if (t3 != null)
        t1.onSoundDecode.dispatch$1([t2, t3]);
    }, "call$1", null, 2, 0, 63, 860, [], "call"],
    $isFunction: true
  },
  Canvas: {
    "^": "Object;",
    static: {Canvas$: [function() {
        return new R.Canvas();
      }, null, null, 0, 0, 428, "new Canvas"], Canvas_create: [function(width, height, id, noCocoon) {
        var canvas, t1;
        canvas = W.CanvasElement_CanvasElement(null, null);
        if (id != null) {
          canvas.toString;
          canvas.setAttribute("data-" + new W._DataAttributeMap(new W._ElementAttributeMap(canvas))._toHyphenedName$1("id"), id);
        }
        t1 = J.getInterceptor$x(canvas);
        t1.set$width(canvas, J.toInt$0$n(width));
        t1.set$height(canvas, J.toInt$0$n(height));
        J.set$display$x(canvas.style, "block");
        return canvas;
      }, function() {
        return R.Canvas_create(256, 256, null, false);
      }, null, function(width) {
        return R.Canvas_create(width, 256, null, false);
      }, null, function(width, height) {
        return R.Canvas_create(width, height, null, false);
      }, null, function(width, height, id) {
        return R.Canvas_create(width, height, id, false);
      }, null, "call$4", "call$0", "call$1", "call$2", "call$3", "Canvas_create$closure", 0, 8, 429, 298, 298, 32, 95, 10, [], 11, [], 183, [], 430, [], "create"], Canvas_getOffset: [function(element, point) {
        var box, clientTop, clientLeft, scrollTop, scrollLeft, point0, t1, exception;
        if (point == null) {
          point0 = new R.Point(null, null);
          point0.x = 0;
          point0.y = 0;
          point = point0;
        }
        t1 = J.getInterceptor$x(element);
        box = t1.getBoundingClientRect$0(element);
        clientTop = t1.get$clientTop(element);
        clientLeft = t1.get$clientLeft(element);
        scrollTop = 0;
        scrollLeft = 0;
        scrollTop = window.pageYOffset;
        scrollLeft = window.pageXOffset;
        try {
          J.set$x$x(point, J.$sub$n(J.$add$ns(J.get$left$x(box), scrollLeft), clientLeft));
          J.set$y$x(point, J.$sub$n(J.$add$ns(J.get$top$x(box), scrollTop), clientTop));
        } catch (exception) {
          H.unwrapException(exception);
          J.set$x$x(point, J.$sub$n(scrollLeft, clientLeft));
          J.set$y$x(point, J.$sub$n(scrollTop, clientTop));
        }

        return point;
      }, function(element) {
        return R.Canvas_getOffset(element, null);
      }, null, "call$2", "call$1", "Canvas_getOffset$closure", 2, 2, 431, 32, 432, [], 433, [], "getOffset"], Canvas_getAspectRatio: [function(canvas) {
        var t1 = J.getInterceptor$x(canvas);
        return J.$div$n(t1.get$width(canvas), t1.get$height(canvas));
      }, "call$1", "Canvas_getAspectRatio$closure", 2, 0, 434, 116, [], "getAspectRatio"], Canvas_setBackgroundColor: [function(canvas, color) {
        J.set$backgroundColor$x(J.get$style$x(canvas), color);
        return canvas;
      }, function(canvas) {
        return R.Canvas_setBackgroundColor(canvas, "rgb(0,0,0)");
      }, null, "call$2", "call$1", "Canvas_setBackgroundColor$closure", 2, 2, 435, 436, 116, [], 114, [], "setBackgroundColor"], Canvas_setUserSelect: [function(canvas, value) {
        var t1 = J.getInterceptor$x(canvas);
        J.set$userSelect$x(t1.get$style(canvas), value);
        J.set$tapHighlightColor$x(t1.get$style(canvas), "rgba(0, 0, 0, 0)");
        return canvas;
      }, function(canvas) {
        return R.Canvas_setUserSelect(canvas, "none");
      }, null, "call$2", "call$1", "Canvas_setUserSelect$closure", 2, 2, 435, 437, 116, [], 100, [], "setUserSelect"], Canvas_addToDOM: [function(canvas, $parent, overflowHidden) {
        var target;
        if ($parent != null)
          if (typeof $parent === "string")
            target = document.getElementById($parent);
          else
            target = !!J.getInterceptor($parent).$isHtmlElement ? $parent : null;
        else
          target = null;
        if (target == null)
          target = document.body;
        if (overflowHidden === true)
          J.set$overflow$x(J.get$style$x(target), "hidden");
        J.append$1$x(target, canvas);
        return canvas;
      }, function(canvas) {
        return R.Canvas_addToDOM(canvas, null, true);
      }, null, function(canvas, parent) {
        return R.Canvas_addToDOM(canvas, parent, true);
      }, null, "call$3", "call$1", "call$2", "Canvas_addToDOM$closure", 2, 4, 438, 32, 39, 116, [], 45, [], 439, [], "addToDOM"], Canvas_setTransform: [function(context, translateX, translateY, scaleX, scaleY, skewX, skewY) {
        J.setTransform$6$x(context, scaleX, skewX, skewY, scaleY, translateX, translateY);
        return context;
      }, "call$7", "Canvas_setTransform$closure", 14, 0, 440, 104, [], 441, [], 442, [], 443, [], 444, [], 445, [], 446, [], "setTransform"], Canvas_setSmoothingEnabled: [function(context, value) {
        J.set$imageSmoothingEnabled$x(context, value);
        return context;
      }, function(context) {
        return R.Canvas_setSmoothingEnabled(context, false);
      }, null, "call$2", "call$1", "Canvas_setSmoothingEnabled$closure", 2, 2, 447, 95, 104, [], 100, [], "setSmoothingEnabled"], Canvas_setImageRenderingCrisp: [function(canvas) {
        J.set$imageRendering$x(J.get$style$x(canvas), "optimize-contrast");
        return canvas;
      }, "call$1", "Canvas_setImageRenderingCrisp$closure", 2, 0, 448, 116, [], "setImageRenderingCrisp"], Canvas_setImageRenderingBicubic: [function(canvas) {
        J.set$imageRendering$x(J.get$style$x(canvas), "auto");
        return canvas;
      }, "call$1", "Canvas_setImageRenderingBicubic$closure", 2, 0, 448, 116, [], "setImageRenderingBicubic"]}
  },
  "+Canvas": [632],
  Device: {
    "^": "Object;game@-598,desktop@-602,iOS@-602,cocoonJS@-602,ejecta@-602,crosswalk@-602,android@-602,chromeOS@-602,linux@-602,macOS@-602,windows@-602,windowsPhone@-602,canvas*-602,file@-602,fileSystem@-602,localStorage*-602,webGL@-602,worker@-602,touch@-602,mspointer@-602,css3D@-602,pointerLock@-602,typedArray@-602,vibration@-602,getUserMedia*-602,quirksMode@-602,arora@-602,chrome@-602,epiphany@-602,firefox@-602,ie@-602,ieVersion@-601,trident@-602,tridentVersion@-601,mobileSafari@-602,midori@-602,opera@-602,safari@-602,webApp@-602,silk@-602,audioData@-602,webAudio@-602,ogg@-602,opus@-602,mp3@-602,wav@-602,m4a@-602,webm@-602,iPhone@-602,iPhone4@-602,iPad@-602,pixelRatio@-629,littleEndian@-602,support32bit@-602,fullscreen@-602,requestFullscreen*-639,cancelFullscreen@-639,fullscreenKeyboard@-602",
    _checkOS$0: [function() {
      var ua, t1;
      ua = window.navigator.userAgent;
      if (J.getInterceptor$asx(ua).contains$1(ua, "Android"))
        this.android = true;
      else if (C.JSString_methods.contains$1(ua, "CrOS"))
        this.chromeOS = true;
      else if (C.JSString_methods.contains$1(ua, "iPad") || C.JSString_methods.contains$1(ua, "iPod") || C.JSString_methods.contains$1(ua, "iPhone"))
        this.iOS = true;
      else if (C.JSString_methods.contains$1(ua, "Linux"))
        this.linux = true;
      else if (C.JSString_methods.contains$1(ua, "Map OS"))
        this.macOS = true;
      else if (C.JSString_methods.contains$1(ua, "Windows")) {
        this.windows = true;
        if (C.JSString_methods.contains$1(ua, "Windows Phone"))
          this.windowsPhone = true;
      }
      if (this.windows !== true)
        if (this.macOS !== true)
          t1 = this.linux === true && J.$eq(this.silk, false);
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        this.desktop = true;
      if (this.windowsPhone !== true)
        t1 = C.JSString_methods.contains$1(ua, "Windows NT") && C.JSString_methods.contains$1(ua, "Touch");
      else
        t1 = true;
      if (t1)
        this.desktop = false;
    }, "call$0", "get$_checkOS", 0, 0, 13, "_checkOS"],
    _checkFeatures$0: [function() {
      var exception, t1;
      this.canvas = J.getContext$1$x(W.CanvasElement_CanvasElement(null, null), "2d") != null || this.cocoonJS === true;
      try {
        this.localStorage = window.localStorage != null;
      } catch (exception) {
        H.unwrapException(exception);
        this.localStorage = false;
      }

      this.webGL = true;
      P.print("check Touch");
      P.print(window.navigator.maxTouchPoints);
      this.touch = true;
      if (window.navigator.maxTouchPoints != null) {
        t1 = window.navigator.maxTouchPoints;
        if (typeof t1 !== "number")
          return t1.$ge();
        t1 = t1 >= 1;
      } else
        t1 = false;
      if (t1)
        this.touch = true;
      this.pointerLock = true;
      this.getUserMedia = true;
    }, "call$0", "get$_checkFeatures", 0, 0, 13, "_checkFeatures"],
    checkFullScreenSupport$0: [function() {
      this.fullscreen = true;
      this.cancelFullscreen = "cancelFullScreen";
      this.fullscreenKeyboard = true;
    }, "call$0", "get$checkFullScreenSupport", 0, 0, 13, "checkFullScreenSupport"],
    _checkBrowser$0: [function() {
      var ua = window.navigator.userAgent;
      if (J.getInterceptor$asx(ua).contains$1(ua, "Arora"))
        this.arora = true;
      else if (C.JSString_methods.contains$1(ua, "Chrome"))
        this.chrome = true;
      else if (C.JSString_methods.contains$1(ua, "Epiphany"))
        this.epiphany = true;
      else if (C.JSString_methods.contains$1(ua, "Firefox"))
        this.firefox = true;
      else if (C.JSString_methods.contains$1(ua, "AppleWebKit") && this.iOS === true)
        this.mobileSafari = true;
      else if (C.JSString_methods.contains$1(ua, "MSIE")) {
        this.ie = true;
        this.ieVersion = 10;
      } else if (C.JSString_methods.contains$1(ua, "Midori"))
        this.midori = true;
      else if (C.JSString_methods.contains$1(ua, "Opera"))
        this.opera = true;
      else if (C.JSString_methods.contains$1(ua, "Safari"))
        this.safari = true;
      else if (C.JSString_methods.contains$1(ua, "Trident")) {
        this.ie = true;
        this.trident = true;
        this.tridentVersion = 10;
        this.ieVersion = 10;
      }
      if (C.JSString_methods.contains$1(ua, "Silk"))
        this.silk = true;
      if (J.contains$1$asx(window.navigator.appVersion, "CocoonJS"))
        this.cocoonJS = true;
      if (C.JSString_methods.contains$1(ua, "Crosswalk"))
        this.crosswalk = true;
    }, "call$0", "get$_checkBrowser", 0, 0, 13, "_checkBrowser"],
    _checkAudio$0: [function() {
      var audio = W.AudioElement_AudioElement(null);
      this.audioData = true;
      this.webAudio = true;
      if (audio.canPlayType("audio/ogg") !== "")
        this.ogg = true;
      if (audio.canPlayType("audio/opus") !== "")
        this.opus = true;
      if (audio.canPlayType("audio/mp3") !== "")
        this.mp3 = true;
      if (audio.canPlayType("audio/wav") !== "")
        this.wav = true;
      if (audio.canPlayType("audio/m4a") !== "")
        this.m4a = true;
      if (audio.canPlayType("audio/webm") !== "")
        this.webm = true;
    }, "call$0", "get$_checkAudio", 0, 0, 13, "_checkAudio"],
    _checkDevice$0: [function() {
      this.pixelRatio = window.devicePixelRatio;
      var t1 = window.navigator.userAgent;
      t1.toString;
      this.iPhone = C.JSString_methods.indexOf$1(t1.toLowerCase(), "iphone") !== -1;
      this.iPhone4 = J.$eq(this.pixelRatio, 2) && this.iPhone === true;
      t1 = window.navigator.userAgent;
      t1.toString;
      this.iPad = C.JSString_methods.indexOf$1(t1.toLowerCase(), "ipad") !== -1;
      this.typedArray = true;
      this.littleEndian = false;
      $.Device_LITTLE_ENDIAN = false;
      this.support32bit = true;
      this.vibration = true;
    }, "call$0", "get$_checkDevice", 0, 0, 13, "_checkDevice"],
    _checkIsLittleEndian$0: [function() {
      return false;
    }, "call$0", "get$_checkIsLittleEndian", 0, 0, 13, "_checkIsLittleEndian"],
    _checkIsUint8ClampedImageData$0: [function() {
      return true;
    }, "call$0", "get$_checkIsUint8ClampedImageData", 0, 0, 13, "_checkIsUint8ClampedImageData"],
    _checkCSS3D$0: [function() {
      return true;
    }, "call$0", "get$_checkCSS3D", 0, 0, 13, "_checkCSS3D"],
    canPlayAudio$1: [function(type) {
      var t1, t2;
      t1 = J.getInterceptor(type);
      if (t1.$eq(type, "mp3") && this.mp3 === true)
        return true;
      else {
        if (t1.$eq(type, "ogg"))
          t2 = this.ogg === true || this.opus === true;
        else
          t2 = false;
        if (t2)
          return true;
        else if (t1.$eq(type, "m4a") && this.m4a === true)
          return true;
        else if (t1.$eq(type, "wav") && this.wav === true)
          return true;
        else if (t1.$eq(type, "webm") && this.webm === true)
          return true;
      }
      return false;
    }, "call$1", "get$canPlayAudio", 2, 0, 1367, 99, [], "canPlayAudio"],
    isConsoleOpen$0: [function() {
      return false;
    }, "call$0", "get$isConsoleOpen", 0, 0, 13, "isConsoleOpen"],
    Device$1: function(game) {
      var ua, t1, audio;
      this.desktop = false;
      this.iOS = false;
      this.cocoonJS = false;
      this.ejecta = false;
      this.crosswalk = false;
      this.android = false;
      this.chromeOS = false;
      this.linux = false;
      this.macOS = false;
      this.windows = false;
      this.windowsPhone = false;
      this.canvas = false;
      this.file = false;
      this.fileSystem = false;
      this.localStorage = false;
      this.webGL = false;
      this.worker = false;
      this.touch = false;
      this.mspointer = false;
      this.css3D = false;
      this.pointerLock = false;
      this.typedArray = false;
      this.vibration = false;
      this.getUserMedia = false;
      this.quirksMode = false;
      this.arora = false;
      this.chrome = false;
      this.epiphany = false;
      this.firefox = false;
      this.ie = false;
      this.ieVersion = 0;
      this.trident = false;
      this.tridentVersion = 0;
      this.mobileSafari = false;
      this.midori = false;
      this.opera = false;
      this.safari = false;
      this.webApp = false;
      this.silk = false;
      this.audioData = false;
      this.webAudio = false;
      this.ogg = false;
      this.opus = false;
      this.mp3 = false;
      this.wav = false;
      this.m4a = false;
      this.webm = false;
      this.iPhone = false;
      this.iPhone4 = false;
      this.iPad = false;
      this.pixelRatio = 0;
      this.littleEndian = false;
      this.support32bit = false;
      this.fullscreen = false;
      this.requestFullscreen = "";
      this.cancelFullscreen = "";
      this.fullscreenKeyboard = false;
      ua = window.navigator.userAgent;
      if (J.getInterceptor$asx(ua).contains$1(ua, "Android"))
        this.android = true;
      else if (C.JSString_methods.contains$1(ua, "CrOS"))
        this.chromeOS = true;
      else if (C.JSString_methods.contains$1(ua, "iPad") || C.JSString_methods.contains$1(ua, "iPod") || C.JSString_methods.contains$1(ua, "iPhone"))
        this.iOS = true;
      else if (C.JSString_methods.contains$1(ua, "Linux"))
        this.linux = true;
      else if (C.JSString_methods.contains$1(ua, "Map OS"))
        this.macOS = true;
      else if (C.JSString_methods.contains$1(ua, "Windows")) {
        this.windows = true;
        if (C.JSString_methods.contains$1(ua, "Windows Phone"))
          this.windowsPhone = true;
      }
      if (this.windows !== true)
        if (this.macOS !== true)
          t1 = this.linux === true && J.$eq(this.silk, false);
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        this.desktop = true;
      if (this.windowsPhone !== true)
        t1 = C.JSString_methods.contains$1(ua, "Windows NT") && C.JSString_methods.contains$1(ua, "Touch");
      else
        t1 = true;
      if (t1)
        this.desktop = false;
      audio = W.AudioElement_AudioElement(null);
      this.audioData = true;
      this.webAudio = true;
      if (audio.canPlayType("audio/ogg") !== "")
        this.ogg = true;
      if (audio.canPlayType("audio/opus") !== "")
        this.opus = true;
      if (audio.canPlayType("audio/mp3") !== "")
        this.mp3 = true;
      if (audio.canPlayType("audio/wav") !== "")
        this.wav = true;
      if (audio.canPlayType("audio/m4a") !== "")
        this.m4a = true;
      if (audio.canPlayType("audio/webm") !== "")
        this.webm = true;
      ua = window.navigator.userAgent;
      if (J.getInterceptor$asx(ua).contains$1(ua, "Arora"))
        this.arora = true;
      else if (C.JSString_methods.contains$1(ua, "Chrome"))
        this.chrome = true;
      else if (C.JSString_methods.contains$1(ua, "Epiphany"))
        this.epiphany = true;
      else if (C.JSString_methods.contains$1(ua, "Firefox"))
        this.firefox = true;
      else if (C.JSString_methods.contains$1(ua, "AppleWebKit") && this.iOS === true)
        this.mobileSafari = true;
      else if (C.JSString_methods.contains$1(ua, "MSIE")) {
        this.ie = true;
        this.ieVersion = 10;
      } else if (C.JSString_methods.contains$1(ua, "Midori"))
        this.midori = true;
      else if (C.JSString_methods.contains$1(ua, "Opera"))
        this.opera = true;
      else if (C.JSString_methods.contains$1(ua, "Safari"))
        this.safari = true;
      else if (C.JSString_methods.contains$1(ua, "Trident")) {
        this.ie = true;
        this.trident = true;
        this.tridentVersion = 10;
        this.ieVersion = 10;
      }
      if (C.JSString_methods.contains$1(ua, "Silk"))
        this.silk = true;
      if (J.contains$1$asx(window.navigator.appVersion, "CocoonJS"))
        this.cocoonJS = true;
      if (C.JSString_methods.contains$1(ua, "Crosswalk"))
        this.crosswalk = true;
      this.pixelRatio = window.devicePixelRatio;
      t1 = window.navigator.userAgent;
      t1.toString;
      this.iPhone = C.JSString_methods.indexOf$1(t1.toLowerCase(), "iphone") !== -1;
      this.iPhone4 = J.$eq(this.pixelRatio, 2) && this.iPhone === true;
      t1 = window.navigator.userAgent;
      t1.toString;
      this.iPad = C.JSString_methods.indexOf$1(t1.toLowerCase(), "ipad") !== -1;
      this.typedArray = true;
      this.littleEndian = false;
      $.Device_LITTLE_ENDIAN = false;
      this.support32bit = true;
      this.vibration = true;
      this._checkFeatures$0();
    },
    static: {"^": "Device_LITTLE_ENDIAN@-602", Device$: [function(game) {
        var t1 = new R.Device(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Device$1(game);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new Device"]}
  },
  "+Device": [632],
  RequestAnimationFrame: {
    "^": "Object;game@-598,isRunning@-602,forceSetTimeOut@-602,_isSetTimeOut@-602,_onLoop@-0,_timeOutID@-599",
    start$0: [function(_) {
      var t1, t2;
      this.isRunning = true;
      this._isSetTimeOut = false;
      t1 = this.get$updateRAF();
      this._onLoop = t1;
      t2 = window;
      C.Window_methods._ensureRequestAnimationFrame$0(t2);
      this._timeOutID = C.Window_methods._requestAnimationFrame$1(t2, W._wrapZone(t1));
    }, "call$0", "get$start", 0, 0, 13, "start"],
    updateRAF$1: [function(time) {
      var t1, t2;
      t1 = this.game;
      t2 = Date.now();
      new P.DateTime(t2, false).DateTime$_now$0();
      t1.update$1(t2);
      t2 = window;
      t1 = this._onLoop;
      C.Window_methods._ensureRequestAnimationFrame$0(t2);
      this._timeOutID = C.Window_methods._requestAnimationFrame$1(t2, W._wrapZone(t1));
    }, "call$1", "get$updateRAF", 2, 0, 1016, 568, [], "updateRAF"],
    stop$0: [function(_) {
      var t1, t2;
      t1 = window;
      t2 = this._timeOutID;
      C.Window_methods._ensureRequestAnimationFrame$0(t1);
      t1.cancelAnimationFrame(t2);
      this.isRunning = false;
    }, "call$0", "get$stop", 0, 0, 13, "stop"],
    isSetTimeOut$0: [function() {
      return this._isSetTimeOut;
    }, "call$0", "get$isSetTimeOut", 0, 0, 13, "isSetTimeOut"],
    isRAF$0: [function() {
      return J.$eq(this._isSetTimeOut, false);
    }, "call$0", "get$isRAF", 0, 0, 13, "isRAF"],
    RequestAnimationFrame$2: function(game, forceSetTimeOut) {
      this.isRunning = false;
      this.forceSetTimeOut = forceSetTimeOut;
      this._isSetTimeOut = false;
      this._onLoop = null;
      this._timeOutID = null;
    },
    static: {RequestAnimationFrame$: [function(game, forceSetTimeOut) {
        var t1 = new R.RequestAnimationFrame(game, null, null, null, null, null);
        t1.RequestAnimationFrame$2(game, forceSetTimeOut);
        return t1;
      }, null, null, 2, 2, 449, 95, 214, [], 450, [], "new RequestAnimationFrame"]}
  },
  "+RequestAnimationFrame": [632],
  Tile: {
    "^": "Object;layer*-1533,index*-599,x*-601,y*-601,worldX@-601,worldY@-601,width*-601,height*-601,centerX@-601,centerY@-601,alpha*-601,properties@-1534,scanned@-602,faceTop@-602,faceBottom@-602,faceLeft@-602,faceRight@-602,collideLeft@-602,collideRight@-602,collideUp@-602,collideDown@-602,collides@-602,debug@-602,collisionCallback@-0",
    collisionCallback$3: function(arg0, arg1, arg2) {
      return this.collisionCallback.call$3(arg0, arg1, arg2);
    },
    get$canCollide: [function() {
      return this.collideLeft != null || this.collideRight != null || this.collideUp != null || this.collideDown != null || this.collisionCallback != null;
    }, null, null, 1, 0, 13, "canCollide"],
    get$left: [function(_) {
      return this.worldX;
    }, null, null, 1, 0, 604, "left"],
    get$right: [function(_) {
      return J.$add$ns(this.worldX, this.width);
    }, null, null, 1, 0, 604, "right"],
    get$top: [function(_) {
      return this.worldY;
    }, null, null, 1, 0, 604, "top"],
    get$bottom: [function(_) {
      return J.$add$ns(this.worldY, this.height);
    }, null, null, 1, 0, 604, "bottom"],
    containsPoint$2: [function(_, x, y) {
      var t1, t2;
      t1 = J.getInterceptor$n(x);
      if (!t1.$lt(x, this.worldX)) {
        t2 = J.getInterceptor$n(y);
        t1 = t2.$lt(y, this.worldY) || t1.$gt(x, J.$add$ns(this.worldX, this.width)) || t2.$gt(y, J.$add$ns(this.worldY, this.height));
      } else
        t1 = true;
      return !t1;
    }, "call$2", "get$containsPoint", 4, 0, 625, 6, [], 7, [], "containsPoint"],
    intersects$4: [function(_, x, y, right, bottom) {
      if (J.$le$n(right, this.worldX))
        return false;
      if (J.$le$n(bottom, this.worldY))
        return false;
      if (J.$ge$n(x, J.$add$ns(this.worldX, this.width)))
        return false;
      if (J.$ge$n(y, J.$add$ns(this.worldY, this.height)))
        return false;
      return true;
    }, "call$4", "get$intersects", 8, 0, 306, 6, [], 7, [], 419, [], 1269, [], "intersects"],
    destroy$0: [function() {
      this.collisionCallback = null;
      this.properties = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    setCollision$4: [function(left, right, up, down) {
      this.collideLeft = left;
      this.collideRight = right;
      this.collideUp = up;
      this.collideDown = down;
    }, "call$4", "get$setCollision", 8, 0, 1535, 160, [], 419, [], 417, [], 418, [], "setCollision"],
    resetCollision$0: [function() {
      this.collideLeft = false;
      this.collideRight = false;
      this.collideUp = false;
      this.collideDown = false;
      this.faceTop = false;
      this.faceBottom = false;
      this.faceLeft = false;
      this.faceRight = false;
    }, "call$0", "get$resetCollision", 0, 0, 13, "resetCollision"],
    isInteresting$2: [function(collides, faces) {
      var t1 = collides === true;
      if (t1 && faces === true)
        return this.collideLeft === true || this.collideRight === true || this.collideUp === true || this.collideDown === true || this.faceTop === true || this.faceBottom === true || this.faceLeft === true || this.faceRight === true || this.collisionCallback != null;
      else if (t1)
        return this.collideLeft === true || this.collideRight === true || this.collideUp === true || this.collideDown === true;
      else if (faces === true)
        return this.faceTop === true || this.faceBottom === true || this.faceLeft === true || this.faceRight === true;
      return false;
    }, "call$2", "get$isInteresting", 4, 0, 1536, 1537, [], 1538, [], "isInteresting"],
    copy$1: [function(tile) {
      var t1 = J.getInterceptor$x(tile);
      this.index = t1.get$index(tile);
      this.alpha = t1.get$alpha(tile);
      this.properties = tile.get$properties();
      this.collideUp = tile.get$collideUp();
      this.collideDown = tile.get$collideDown();
      this.collideLeft = tile.get$collideLeft();
      this.collideRight = tile.get$collideRight();
      this.collisionCallback = tile.get$collisionCallback();
    }, "call$1", "get$copy", 2, 0, 1539, 1483, [], "copy"],
    Tile$6: function(layer, index, x, y, width, height) {
      this.layer = layer;
      this.index = index;
      this.x = x;
      this.y = y;
      this.worldX = J.$mul$ns(x, width);
      this.worldY = J.$mul$ns(y, height);
      this.width = width;
      this.height = height;
      this.centerX = J.abs$0$n(J.$div$n(width, 2));
      this.centerY = J.abs$0$n(J.$div$n(height, 2));
      this.alpha = 1;
      this.properties = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this.scanned = false;
      this.faceTop = false;
      this.faceBottom = false;
      this.faceLeft = false;
      this.faceRight = false;
      this.collideLeft = false;
      this.collideRight = false;
      this.collideUp = false;
      this.collideDown = false;
      this.collisionCallback = null;
    },
    $isTile: true,
    static: {Tile$: [function(layer, index, x, y, width, height) {
        var t1 = new R.Tile(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false, false, null);
        t1.Tile$6(layer, index, x, y, width, height);
        return t1;
      }, null, null, 12, 0, 451, 452, [], 243, [], 6, [], 7, [], 10, [], 11, [], "new Tile"]}
  },
  "+Tile": [632],
  TilemapData: {
    "^": "Object;name*-639,width*-601,height*-601,tileWidth@-601,tileHeight@-601,orientation*-639,objects@-1540,collision@-1540,images@-1541,format*-601,version*-599,properties@-754,widthInPixels@-601,heightInPixels@-601,layers@-1542,tilesets@-1543,tiles@-1544",
    static: {TilemapData$: [function() {
        return new R.TilemapData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      }, null, null, 0, 0, 453, "new TilemapData"]}
  },
  "+TilemapData": [632],
  Tilemap: {
    "^": "Object;game@-598,key*-639,width*-601,height*-601,tileWidth@-601,tileHeight@-601,orientation*-639,format*-601,version*-601,properties@-754,widthInPixels@-601,heightInPixels@-601,layers@-1542,tilesets@-1543,tiles@-1544,objects@-1540,collision@-1540,collideIndexes@-715,images@-1541,currentLayer@-599,debugMap@-1545,_results@-720,_tempA@-601,_tempB@-601,preventingRecalculate@-602,needToRecalculate@-754,data*-720",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.key.call$4(arg0, arg1, arg2, arg3);
    },
    get$layer: [function(_) {
      return this.getLayer$0();
    }, null, null, 1, 0, 367, "layer"],
    set$layer: [function(_, value) {
      var layer;
      if (!J.$eq(value, this.currentLayer)) {
        layer = this.getLayer$1(value);
        if (J.$index$asx(this.layers, layer) != null)
          this.currentLayer = layer;
      }
    }, null, null, 3, 0, 60, 100, [], "layer"],
    create$6: [function($name, width, height, tileWidth, tileHeight, group) {
      if (group == null)
        group = this.game.get$world();
      this.width = width;
      this.height = height;
      this.tileWidth = tileWidth;
      this.tileHeight = tileHeight;
      this.widthInPixels = J.$mul$ns(width, tileWidth);
      this.heightInPixels = J.$mul$ns(this.height, tileHeight);
      J.set$length$asx(this.layers, 0);
      return this.createBlankLayer$6($name, width, height, tileWidth, tileHeight, group);
    }, function(name, width, height, tileWidth, tileHeight) {
      return this.create$6(name, width, height, tileWidth, tileHeight, null);
    }, "create$5", "call$6", "call$5", "get$create", 10, 2, 1546, 32, 44, [], 10, [], 11, [], 455, [], 456, [], 253, [], "create"],
    setTileSize$2: [function(tileWidth, tileHeight) {
      this.tileWidth = tileWidth;
      this.tileHeight = tileHeight;
      this.widthInPixels = J.$mul$ns(this.width, tileWidth);
      this.heightInPixels = J.$mul$ns(this.height, tileHeight);
    }, "call$2", "get$setTileSize", 4, 0, 111, 455, [], 456, [], "setTileSize"],
    addTilesetImage$7: [function(tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid) {
      var t1, newSet, i, t2, t3, t, y, x, count, countX, countY, t4, t5, t6;
      if (tileWidth == null)
        tileWidth = this.tileWidth;
      if (tileHeight == null)
        tileHeight = this.tileHeight;
      if (tileMargin == null)
        tileMargin = 0;
      if (tileSpacing == null)
        tileSpacing = 0;
      if (gid == null)
        gid = 0;
      if (J.$eq(tileWidth, 0))
        tileWidth = 32;
      if (J.$eq(tileHeight, 0))
        tileHeight = 32;
      if (key == null) {
        if (typeof tileset === "string")
          this.game.get$cache().checkImageKey$1(tileset);
        else
          return;
        key = tileset;
      }
      if (typeof tileset === "string") {
        tileset = this.getIndex$2(this.tilesets, tileset);
        if (tileset == null && J.$eq(this.format, 1)) {
          window;
          t1 = C.JSString_methods.$add("Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: \"", key) + "\"";
          if (typeof console != "undefined")
            console.warn(t1);
          return;
        }
      }
      if (tileset != null && J.$index$asx(this.tilesets, tileset) != null) {
        J.$index$asx(this.tilesets, tileset).setImage$1(this.game.get$cache().getImage$1(key));
        return J.$index$asx(this.tilesets, tileset);
      } else {
        newSet = R.Tileset$(key, gid, tileWidth, tileHeight, tileMargin, tileSpacing, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
        newSet.setImage$1(this.game.get$cache().getImage$1(key));
        J.add$1$ax(this.tilesets, newSet);
        i = J.$sub$n(J.get$length$asx(this.tilesets), 1);
        for (t1 = J.getInterceptor$ns(gid), t2 = J.getInterceptor$ns(tileWidth), t3 = J.getInterceptor$ns(tileHeight), t = gid, y = tileMargin, x = y, count = 0, countX = 0, countY = 0; t4 = J.getInterceptor$n(t), t4.$lt(t, t1.$add(gid, newSet.total)); t = t4.$add(t, 1)) {
          t5 = J.$gt$n(J.get$length$asx(this.tiles), t);
          t6 = this.tiles;
          if (t5)
            J.$indexSet$ax(t6, t, [x, y, i]);
          else
            J.add$1$ax(t6, [x, y, i]);
          x = J.$add$ns(x, t2.$add(tileWidth, tileSpacing));
          ++count;
          if (count === newSet.total)
            break;
          ++countX;
          if (countX === newSet.columns) {
            y = J.$add$ns(y, t3.$add(tileHeight, tileSpacing));
            ++countY;
            if (countY === newSet.rows)
              break;
            x = tileMargin;
            countX = 0;
          }
        }
        return newSet;
      }
    }, function(tileset) {
      return this.addTilesetImage$7(tileset, null, null, null, null, null, null);
    }, "addTilesetImage$1", function(tileset, key) {
      return this.addTilesetImage$7(tileset, key, null, null, null, null, null);
    }, "addTilesetImage$2", function(tileset, key, tileWidth) {
      return this.addTilesetImage$7(tileset, key, tileWidth, null, null, null, null);
    }, "addTilesetImage$3", function(tileset, key, tileWidth, tileHeight) {
      return this.addTilesetImage$7(tileset, key, tileWidth, tileHeight, null, null, null);
    }, "addTilesetImage$4", function(tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing) {
      return this.addTilesetImage$7(tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing, null);
    }, "addTilesetImage$6", function(tileset, key, tileWidth, tileHeight, tileMargin) {
      return this.addTilesetImage$7(tileset, key, tileWidth, tileHeight, tileMargin, null, null);
    }, "addTilesetImage$5", "call$7", "call$1", "call$2", "call$3", "call$4", "call$6", "call$5", "get$addTilesetImage", 2, 12, 1547, 32, 32, 32, 32, 32, 32, 1548, [], 231, [], 455, [], 456, [], 1549, [], 1550, [], 1551, [], "addTilesetImage"],
    createFromObjects$9: [function($name, gid, key, frame, exists, autoCull, group, CustomClass, adjustY) {
      var t1, len, sprite, i;
      if (exists == null)
        ;
      if (autoCull == null)
        ;
      if (group == null)
        this.game.get$world();
      if (CustomClass == null)
        ;
      if (adjustY == null)
        ;
      if (J.$index$asx(this.objects, $name) == null) {
        window;
        t1 = C.JSString_methods.$add("Tilemap.createFromObjects: Invalid objectgroup name given: ", $name);
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      len = J.get$length$asx(J.$index$asx(this.objects, $name));
      if (typeof len !== "number")
        return H.iae(len);
      sprite = null;
      i = 0;
      for (; i < len; ++i)
        J.$index$asx(J.$index$asx(this.objects, $name), i).get$gid();
    }, function(name, gid, key) {
      return this.createFromObjects$9(name, gid, key, null, null, null, null, null, null);
    }, "createFromObjects$3", function(name, gid, key, frame) {
      return this.createFromObjects$9(name, gid, key, frame, null, null, null, null, null);
    }, "createFromObjects$4", function(name, gid, key, frame, exists, autoCull) {
      return this.createFromObjects$9(name, gid, key, frame, exists, autoCull, null, null, null);
    }, "createFromObjects$6", function(name, gid, key, frame, exists) {
      return this.createFromObjects$9(name, gid, key, frame, exists, null, null, null, null);
    }, "createFromObjects$5", function(name, gid, key, frame, exists, autoCull, group) {
      return this.createFromObjects$9(name, gid, key, frame, exists, autoCull, group, null, null);
    }, "createFromObjects$7", function(name, gid, key, frame, exists, autoCull, group, CustomClass) {
      return this.createFromObjects$9(name, gid, key, frame, exists, autoCull, group, CustomClass, null);
    }, "createFromObjects$8", "call$9", "call$3", "call$4", "call$6", "call$5", "call$7", "call$8", "get$createFromObjects", 6, 12, 1552, 32, 32, 32, 32, 32, 32, 44, [], 1551, [], 231, [], 178, [], 1022, [], 1553, [], 253, [], 1554, [], 1555, [], "createFromObjects"],
    createLayer$4: [function(layer, width, height, group) {
      var index, t1;
      if (width == null)
        width = J.get$width$x(this.game);
      if (height == null)
        height = J.get$height$x(this.game);
      if (group == null)
        group = this.game.get$world();
      index = typeof layer === "string" ? this.getIndex$2(this.layers, layer) : layer;
      if (index == null || J.$gt$n(index, J.get$length$asx(this.layers))) {
        window;
        t1 = C.JSString_methods.$add("Tilemap.createLayer: Invalid layer ID given: ", index);
        if (typeof console != "undefined")
          console.warn(t1);
        return;
      }
      return J.add$1$ax(group, R.TilemapLayer$(this.game, this, index, width, height));
    }, function(layer) {
      return this.createLayer$4(layer, null, null, null);
    }, "createLayer$1", function(layer, width) {
      return this.createLayer$4(layer, width, null, null);
    }, "createLayer$2", function(layer, width, height) {
      return this.createLayer$4(layer, width, height, null);
    }, "createLayer$3", "call$4", "call$1", "call$2", "call$3", "get$createLayer", 2, 6, 1556, 32, 32, 32, 452, [], 10, [], 11, [], 253, [], "createLayer"],
    createBlankLayer$6: [function($name, width, height, tileWidth, tileHeight, group) {
      var layer, output, y, row, x, w, h, outputLayer;
      if (group == null)
        group = this.game.get$world();
      if (this.getIndex$2(this.layers, $name) != null) {
        window;
        if (typeof console != "undefined")
          console.warn("Tilemap.createBlankLayer: Layer with matching name already exists");
        return;
      }
      layer = new R.TilemapLayerData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);
      layer.name = $name;
      layer.x = 0;
      layer.y = 0;
      layer.width = width;
      layer.height = height;
      layer.widthInPixels = J.$mul$ns(width, tileWidth);
      layer.heightInPixels = J.$mul$ns(height, tileHeight);
      layer.alpha = 1;
      layer.visible = true;
      layer.properties = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      layer.indexes = [];
      layer.callbacks = [];
      layer.bodies = [];
      layer.data = null;
      output = [];
      if (typeof height !== "number")
        return H.iae(height);
      y = 0;
      for (; y < height; ++y) {
        row = [];
        if (typeof width !== "number")
          return H.iae(width);
        x = 0;
        for (; x < width; ++x)
          row.push(R.Tile$(layer, -1, x, y, tileWidth, tileHeight));
        output.push(row);
      }
      layer.data = output;
      J.add$1$ax(this.layers, layer);
      this.currentLayer = J.$sub$n(J.get$length$asx(this.layers), 1);
      w = layer.widthInPixels;
      h = layer.heightInPixels;
      if (J.$gt$n(w, J.get$width$x(this.game)))
        w = J.get$width$x(this.game);
      if (J.$gt$n(h, J.get$height$x(this.game)))
        h = J.get$height$x(this.game);
      outputLayer = R.TilemapLayer$(this.game, this, J.$sub$n(J.get$length$asx(this.layers), 1), w, h);
      outputLayer.Phaser$TilemapLayer$name = $name;
      return J.add$1$ax(group, outputLayer);
    }, function(name, width, height, tileWidth, tileHeight) {
      return this.createBlankLayer$6(name, width, height, tileWidth, tileHeight, null);
    }, "createBlankLayer$5", "call$6", "call$5", "get$createBlankLayer", 10, 2, 1546, 32, 44, [], 10, [], 11, [], 455, [], 456, [], 253, [], "createBlankLayer"],
    getIndex$2: [function($location, $name) {
      var t1, i, t2;
      t1 = J.getInterceptor$asx($location);
      i = 0;
      while (true) {
        t2 = t1.get$length($location);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        if (J.$eq(J.get$name$x(t1.$index($location, i)), $name))
          return i;
        ++i;
      }
      return;
    }, "call$2", "get$getIndex", 4, 0, 1557, 585, [], 44, [], "getIndex"],
    getLayerIndex$1: [function($name) {
      return this.getIndex$2(this.layers, $name);
    }, "call$1", "get$getLayerIndex", 2, 0, 514, 44, [], "getLayerIndex"],
    getTilesetIndex$1: [function($name) {
      return this.getIndex$2(this.tilesets, $name);
    }, "call$1", "get$getTilesetIndex", 2, 0, 514, 44, [], "getTilesetIndex"],
    getImageIndex$1: [function($name) {
      return this.getIndex$2(this.images, $name);
    }, "call$1", "get$getImageIndex", 2, 0, 514, 44, [], "getImageIndex"],
    getObjectIndex$1: [function($name) {
      return this.getIndex$2(J.get$values$x(this.objects), $name);
    }, "call$1", "get$getObjectIndex", 2, 0, 514, 44, [], "getObjectIndex"],
    setTileIndexCallback$3: [function(indexes, callback, layer) {
      var t1, len, i;
      layer = this.getLayer$1(layer);
      if (typeof indexes === "number" && Math.floor(indexes) === indexes)
        J.$indexSet$ax(J.$index$asx(this.layers, layer).get$callbacks(), indexes, callback);
      else {
        t1 = J.getInterceptor$asx(indexes);
        len = t1.get$length(indexes);
        if (typeof len !== "number")
          return H.iae(len);
        i = 0;
        for (; i < len; ++i)
          J.$indexSet$ax(J.$index$asx(this.layers, layer).get$callbacks(), t1.$index(indexes, i), callback);
      }
    }, function(indexes, callback) {
      return this.setTileIndexCallback$3(indexes, callback, null);
    }, "setTileIndexCallback$2", "call$3", "call$2", "get$setTileIndexCallback", 4, 2, 1558, 32, 1559, [], 272, [], 452, [], "setTileIndexCallback"],
    setTileLocationCallback$6: [function(x, y, width, height, callback, layer) {
      var i, t1;
      this.copy$5(x, y, width, height, this.getLayer$1(layer));
      if (J.$lt$n(J.get$length$asx(this._results), 2))
        return;
      i = 1;
      while (true) {
        t1 = J.get$length$asx(this._results);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$index$asx(this._results, i).setCollisionCallback$1(callback);
        ++i;
      }
    }, function(x, y, width, height, callback) {
      return this.setTileLocationCallback$6(x, y, width, height, callback, null);
    }, "setTileLocationCallback$5", "call$6", "call$5", "get$setTileLocationCallback", 10, 2, 1560, 32, 6, [], 7, [], 10, [], 11, [], 272, [], 452, [], "setTileLocationCallback"],
    setCollision$4: [function(indexes, collides, layer, recalculate) {
      var t1, len, i;
      if (collides == null)
        collides = true;
      if (recalculate == null)
        recalculate = true;
      layer = this.getLayer$1(layer);
      if (typeof indexes === "number" && Math.floor(indexes) === indexes)
        return this.setCollisionByIndex$4(indexes, collides, layer, true);
      else {
        t1 = J.getInterceptor$asx(indexes);
        len = t1.get$length(indexes);
        if (typeof len !== "number")
          return H.iae(len);
        i = 0;
        for (; i < len; ++i)
          this.setCollisionByIndex$4(t1.$index(indexes, i), collides, layer, false);
        if (recalculate === true)
          this.calculateFaces$1(layer);
      }
    }, function(indexes) {
      return this.setCollision$4(indexes, true, null, true);
    }, "setCollision$1", function(indexes, collides) {
      return this.setCollision$4(indexes, collides, null, true);
    }, "setCollision$2", function(indexes, collides, layer) {
      return this.setCollision$4(indexes, collides, layer, true);
    }, "setCollision$3", "call$4", "call$1", "call$2", "call$3", "get$setCollision", 2, 6, 1561, 39, 32, 39, 1559, [], 1537, [], 452, [], 1562, [], "setCollision"],
    setCollisionBetween$5: [function(start, $stop, collides, layer, recalculate) {
      var index, t1;
      if (collides == null)
        collides = true;
      if (recalculate == null)
        recalculate = true;
      layer = this.getLayer$1(layer);
      if (J.$gt$n(start, $stop))
        return;
      for (index = start; t1 = J.getInterceptor$n(index), t1.$le(index, $stop); index = t1.$add(index, 1))
        this.setCollisionByIndex$4(index, collides, layer, false);
      if (recalculate === true)
        this.calculateFaces$1(layer);
    }, function(start, stop) {
      return this.setCollisionBetween$5(start, stop, true, null, true);
    }, "setCollisionBetween$2", function(start, stop, collides) {
      return this.setCollisionBetween$5(start, stop, collides, null, true);
    }, "setCollisionBetween$3", function(start, stop, collides, layer) {
      return this.setCollisionBetween$5(start, stop, collides, layer, true);
    }, "setCollisionBetween$4", "call$5", "call$2", "call$3", "call$4", "get$setCollisionBetween", 4, 6, 1563, 39, 32, 39, 223, [], 224, [], 1537, [], 452, [], 1562, [], "setCollisionBetween"],
    setCollisionByExclusion$4: [function(indexes, collides, layer, recalculate) {
      var len, t1, i;
      if (collides == null)
        collides = true;
      if (recalculate == null)
        recalculate = true;
      layer = this.getLayer$1(layer);
      len = J.get$length$asx(this.tiles);
      if (typeof len !== "number")
        return H.iae(len);
      t1 = J.getInterceptor$asx(indexes);
      i = 0;
      for (; i < len; ++i)
        if (J.$eq(t1.indexOf$1(indexes, i), -1))
          this.setCollisionByIndex$4(i, collides, layer, false);
      if (recalculate === true)
        this.calculateFaces$1(layer);
    }, function(indexes) {
      return this.setCollisionByExclusion$4(indexes, null, null, null);
    }, "setCollisionByExclusion$1", function(indexes, collides) {
      return this.setCollisionByExclusion$4(indexes, collides, null, null);
    }, "setCollisionByExclusion$2", function(indexes, collides, layer) {
      return this.setCollisionByExclusion$4(indexes, collides, layer, null);
    }, "setCollisionByExclusion$3", "call$4", "call$1", "call$2", "call$3", "get$setCollisionByExclusion", 2, 6, 1564, 32, 32, 32, 1559, [], 1537, [], 452, [], 1562, [], "setCollisionByExclusion"],
    setCollisionByIndex$4: [function(index, collides, layer, recalculate) {
      var t1, t2, i, y, x, tile;
      if (layer == null)
        layer = this.currentLayer;
      if (collides == null)
        collides = true;
      if (recalculate == null)
        recalculate = true;
      t1 = collides === true;
      t2 = this.collideIndexes;
      if (t1)
        J.add$1$ax(t2, index);
      else {
        i = J.indexOf$1$asx(t2, index);
        if (J.$gt$n(i, -1))
          J.removeAt$1$ax(this.collideIndexes, i);
      }
      y = 0;
      while (true) {
        t2 = J.get$height$x(J.$index$asx(this.layers, layer));
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(y < t2))
          break;
        x = 0;
        while (true) {
          t2 = J.get$width$x(J.$index$asx(this.layers, layer));
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(x < t2))
            break;
          tile = J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
          if (tile != null && J.$eq(J.get$index$x(tile), index)) {
            if (t1)
              tile.setCollision$4(true, true, true, true);
            else
              tile.resetCollision$0();
            tile.set$faceTop(collides);
            tile.set$faceBottom(collides);
            tile.set$faceLeft(collides);
            tile.set$faceRight(collides);
          }
          ++x;
        }
        ++y;
      }
      if (recalculate === true)
        this.calculateFaces$1(layer);
      return layer;
    }, function(index) {
      return this.setCollisionByIndex$4(index, null, null, null);
    }, "setCollisionByIndex$1", function(index, collides) {
      return this.setCollisionByIndex$4(index, collides, null, null);
    }, "setCollisionByIndex$2", function(index, collides, layer) {
      return this.setCollisionByIndex$4(index, collides, layer, null);
    }, "setCollisionByIndex$3", "call$4", "call$1", "call$2", "call$3", "get$setCollisionByIndex", 2, 6, 1565, 32, 32, 32, 243, [], 1537, [], 452, [], 1562, [], "setCollisionByIndex"],
    getLayer$1: [function(layer) {
      if (layer == null)
        layer = this.currentLayer;
      else if (typeof layer === "string")
        layer = this.getIndex$2(this.layers, layer);
      else if (!!J.getInterceptor(layer).$isTilemapLayer)
        layer = layer.index;
      return layer;
    }, function() {
      return this.getLayer$1(null);
    }, "getLayer$0", "call$1", "call$0", "get$getLayer", 0, 2, 1566, 32, 452, [], "getLayer"],
    setPreventRecalculate$1: [function(value) {
      var t1 = J.getInterceptor(value);
      if (t1.$eq(value, true) && !J.$eq(this.preventingRecalculate, true)) {
        this.preventingRecalculate = true;
        this.needToRecalculate = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      }
      if (t1.$eq(value, false) && J.$eq(this.preventingRecalculate, true)) {
        this.preventingRecalculate = false;
        for (t1 = J.get$iterator$ax(J.get$keys$x(this.needToRecalculate)); t1.moveNext$0();)
          this.calculateFaces$1(t1.get$current());
        J.clear$0$ax(this.needToRecalculate);
      }
    }, "call$1", "get$setPreventRecalculate", 2, 0, 650, 100, [], "setPreventRecalculate"],
    calculateFaces$1: [function(layer) {
      var h, above, below, left, right, y, w, x, tile;
      if (J.$eq(this.preventingRecalculate, true)) {
        J.$indexSet$ax(this.needToRecalculate, layer, true);
        return;
      }
      h = J.get$height$x(J.$index$asx(this.layers, layer));
      if (typeof h !== "number")
        return H.iae(h);
      above = null;
      below = null;
      left = null;
      right = null;
      y = 0;
      for (; y < h; ++y) {
        w = J.get$width$x(J.$index$asx(this.layers, layer));
        if (typeof w !== "number")
          return H.iae(w);
        x = 0;
        for (; x < w; ++x) {
          tile = J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
          if (tile != null) {
            above = this.getTileAbove$3(layer, x, y);
            below = this.getTileBelow$3(layer, x, y);
            left = this.getTileLeft$3(layer, x, y);
            right = this.getTileRight$3(layer, x, y);
            if (tile.get$collides() != null) {
              tile.set$faceTop(true);
              tile.set$faceBottom(true);
              tile.set$faceLeft(true);
              tile.set$faceRight(true);
            }
            if (above != null && above.get$collides() === true)
              tile.set$faceTop(false);
            if (below != null && below.get$collides() === true)
              tile.set$faceBottom(false);
            if (left != null && left.get$collides() === true)
              tile.set$faceLeft(false);
            if (right != null && right.get$collides() === true)
              tile.set$faceRight(false);
          }
        }
      }
    }, "call$1", "get$calculateFaces", 2, 0, 60, 452, [], "calculateFaces"],
    getTileAbove$3: [function(layer, x, y) {
      var t1 = J.getInterceptor$n(y);
      if (t1.$gt(y, 0))
        return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), t1.$sub(y, 1)), x);
      return;
    }, "call$3", "get$getTileAbove", 6, 0, 1567, 452, [], 6, [], 7, [], "getTileAbove"],
    getTileBelow$3: [function(layer, x, y) {
      var t1 = J.getInterceptor$n(y);
      if (t1.$lt(y, J.$sub$n(J.get$height$x(J.$index$asx(this.layers, layer)), 1)))
        return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), t1.$add(y, 1)), x);
      return;
    }, "call$3", "get$getTileBelow", 6, 0, 1567, 452, [], 6, [], 7, [], "getTileBelow"],
    getTileLeft$3: [function(layer, x, y) {
      var t1 = J.getInterceptor$n(x);
      if (t1.$gt(x, 0))
        return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), t1.$sub(x, 1));
      return;
    }, "call$3", "get$getTileLeft", 6, 0, 1567, 452, [], 6, [], 7, [], "getTileLeft"],
    getTileRight$3: [function(layer, x, y) {
      var t1 = J.getInterceptor$n(x);
      if (t1.$lt(x, J.$sub$n(J.get$width$x(J.$index$asx(this.layers, layer)), 1)))
        return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), t1.$add(x, 1));
      return;
    }, "call$3", "get$getTileRight", 6, 0, 1567, 452, [], 6, [], 7, [], "getTileRight"],
    setLayer$1: [function(layer) {
      layer = this.getLayer$1(layer);
      if (J.$index$asx(this.layers, layer) != null)
        this.currentLayer = layer;
    }, "call$1", "get$setLayer", 2, 0, 63, 452, [], "setLayer"],
    hasTile$3: [function(x, y, layer) {
      layer = this.getLayer$1(layer);
      return J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y) != null && J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x) != null;
    }, "call$3", "get$hasTile", 6, 0, 1568, 6, [], 7, [], 452, [], "hasTile"],
    removeTile$3: [function(x, y, layer) {
      var t1, tile;
      layer = this.getLayer$1(layer);
      t1 = J.getInterceptor$n(x);
      if (t1.$ge(x, 0))
        if (t1.$lt(x, J.get$width$x(J.$index$asx(this.layers, layer)))) {
          t1 = J.getInterceptor$n(y);
          t1 = t1.$ge(y, 0) && t1.$lt(y, J.get$height$x(J.$index$asx(this.layers, layer)));
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        if (this.hasTile$3(x, y, layer)) {
          tile = J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
          J.$indexSet$ax(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x, R.Tile$(J.$index$asx(this.layers, layer), -1, x, y, this.tileWidth, this.tileHeight));
          J.$index$asx(this.layers, layer).set$dirty(true);
          this.calculateFaces$1(layer);
          return tile;
        }
      return;
    }, "call$3", "get$removeTile", 6, 0, 1569, 6, [], 7, [], 452, [], "removeTile"],
    removeTileWorldXY$5: [function(x, y, tileWidth, tileHeight, layer) {
      layer = this.getLayer$1(layer);
      return this.removeTile$3(J.$div$n(R.Math_snapToFloor(x, tileWidth, 0), tileWidth), J.$div$n(R.Math_snapToFloor(y, tileHeight, 0), tileHeight), layer);
    }, "call$5", "get$removeTileWorldXY", 10, 0, 1570, 6, [], 7, [], 455, [], 456, [], 452, [], "removeTileWorldXY"],
    putTile$4: [function(tile, x, y, layer) {
      var t1, index, t2;
      if (tile == null)
        return this.removeTile$3(x, y, layer);
      layer = this.getLayer$1(layer);
      t1 = J.getInterceptor$n(x);
      if (t1.$ge(x, 0))
        if (t1.$lt(x, J.get$width$x(J.$index$asx(this.layers, layer)))) {
          t1 = J.getInterceptor$n(y);
          t1 = t1.$ge(y, 0) && t1.$lt(y, J.get$height$x(J.$index$asx(this.layers, layer)));
        } else
          t1 = false;
      else
        t1 = false;
      if (t1) {
        if (!!J.getInterceptor(tile).$isTile) {
          index = tile.index;
          t1 = this.hasTile$3(x, y, layer);
          t2 = this.layers;
          if (t1)
            J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(t2, layer)), y), x).copy$1(tile);
          else
            J.$indexSet$ax(J.$index$asx(J.get$data$x(J.$index$asx(t2, layer)), y), x, R.Tile$(J.$index$asx(this.layers, layer), index, x, y, tile.width, tile.height));
        } else {
          t1 = this.hasTile$3(x, y, layer);
          t2 = this.layers;
          if (t1)
            J.set$index$x(J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(t2, layer)), y), x), tile);
          else
            J.$indexSet$ax(J.$index$asx(J.get$data$x(J.$index$asx(t2, layer)), y), x, R.Tile$(J.$index$asx(this.layers, layer), tile, x, y, this.tileWidth, this.tileHeight));
          index = tile;
        }
        t1 = J.$gt$n(J.indexOf$1$asx(this.collideIndexes, index), -1);
        t2 = this.layers;
        if (t1)
          J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(t2, layer)), y), x).setCollision$4(true, true, true, true);
        else
          J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(t2, layer)), y), x).resetCollision$0();
        J.$index$asx(this.layers, layer).set$dirty(true);
        this.calculateFaces$1(layer);
        return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
      }
      return;
    }, function(tile, x, y) {
      return this.putTile$4(tile, x, y, null);
    }, "putTile$3", "call$4", "call$3", "get$putTile", 6, 2, 1571, 32, 1483, [], 6, [], 7, [], 452, [], "putTile"],
    putTileWorldXY$6: [function(tile, x, y, tileWidth, tileHeight, layer) {
      layer = this.getLayer$1(layer);
      return this.putTile$4(tile, J.$div$n(R.Math_snapToFloor(x, tileWidth, 0), tileWidth), J.$div$n(R.Math_snapToFloor(y, tileHeight, 0), tileHeight), layer);
    }, function(tile, x, y, tileWidth, tileHeight) {
      return this.putTileWorldXY$6(tile, x, y, tileWidth, tileHeight, null);
    }, "putTileWorldXY$5", "call$6", "call$5", "get$putTileWorldXY", 10, 2, 1572, 32, 1483, [], 6, [], 7, [], 455, [], 456, [], 452, [], "putTileWorldXY"],
    searchTileIndex$4: [function(index, skip, reverse, layer) {
      var y, c, t1, x, t2;
      if (skip == null)
        skip = 0;
      if (reverse == null)
        reverse = false;
      layer = this.getLayer$1(layer);
      if (reverse === true) {
        for (y = J.$sub$n(J.get$height$x(J.$index$asx(this.layers, layer)), 1), c = 0; t1 = J.getInterceptor$n(y), t1.$ge(y, 0); y = t1.$sub(y, 1))
          for (x = J.$sub$n(J.get$width$x(J.$index$asx(this.layers, layer)), 1); t2 = J.getInterceptor$n(x), t2.$ge(x, 0); x = t2.$sub(x, 1))
            if (J.$eq(J.get$index$x(J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x)), index))
              if (c === skip)
                return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
              else
                ++c;
      } else {
        c = 0;
        y = 0;
        while (true) {
          t1 = J.get$height$x(J.$index$asx(this.layers, layer));
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(y < t1))
            break;
          x = 0;
          while (true) {
            t1 = J.get$width$x(J.$index$asx(this.layers, layer));
            if (typeof t1 !== "number")
              return H.iae(t1);
            if (!(x < t1))
              break;
            if (J.$eq(J.get$index$x(J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x)), index))
              if (c === skip)
                return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
              else
                ++c;
            ++x;
          }
          ++y;
        }
      }
      return;
    }, function(index) {
      return this.searchTileIndex$4(index, 0, false, null);
    }, "searchTileIndex$1", function(index, skip) {
      return this.searchTileIndex$4(index, skip, false, null);
    }, "searchTileIndex$2", function(index, skip, reverse) {
      return this.searchTileIndex$4(index, skip, reverse, null);
    }, "searchTileIndex$3", "call$4", "call$1", "call$2", "call$3", "get$searchTileIndex", 2, 6, 1573, 5, 95, 32, 243, [], 1574, [], 1575, [], 452, [], "searchTileIndex"],
    getTile$4: [function(x, y, layer, nonNull) {
      var t1;
      if (nonNull == null)
        nonNull = false;
      layer = this.getLayer$1(layer);
      t1 = J.getInterceptor$n(x);
      if (t1.$ge(x, 0))
        if (t1.$lt(x, J.get$width$x(J.$index$asx(this.layers, layer)))) {
          t1 = J.getInterceptor$n(y);
          t1 = t1.$ge(y, 0) && t1.$lt(y, J.get$height$x(J.$index$asx(this.layers, layer)));
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        if (J.$eq(J.get$index$x(J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x)), -1))
          if (nonNull === true)
            return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
          else
            return;
        else
          return J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), y), x);
      else
        return;
    }, function(x, y, layer) {
      return this.getTile$4(x, y, layer, null);
    }, "getTile$3", function(x, y) {
      return this.getTile$4(x, y, null, null);
    }, "getTile$2", "call$4", "call$3", "call$2", "get$getTile", 4, 4, 1576, 32, 32, 6, [], 7, [], 452, [], 1577, [], "getTile"],
    getTileWorldXY$5: [function(x, y, tileWidth, tileHeight, layer) {
      if (tileWidth == null)
        tileWidth = this.tileWidth;
      if (tileHeight == null)
        tileHeight = this.tileHeight;
      layer = this.getLayer$1(layer);
      return this.getTile$3(J.$div$n(R.Math_snapToFloor(x, tileWidth, 0), tileWidth), J.$div$n(R.Math_snapToFloor(y, tileHeight, 0), tileHeight), layer);
    }, function(x, y) {
      return this.getTileWorldXY$5(x, y, null, null, null);
    }, "getTileWorldXY$2", function(x, y, tileWidth) {
      return this.getTileWorldXY$5(x, y, tileWidth, null, null);
    }, "getTileWorldXY$3", function(x, y, tileWidth, tileHeight) {
      return this.getTileWorldXY$5(x, y, tileWidth, tileHeight, null);
    }, "getTileWorldXY$4", "call$5", "call$2", "call$3", "call$4", "get$getTileWorldXY", 4, 6, 1578, 32, 32, 32, 6, [], 7, [], 455, [], 456, [], 452, [], "getTileWorldXY"],
    copy$5: [function(x, y, width, height, layer) {
      var t1, t2, ty, t3, tx, t4;
      layer = this.getLayer$1(layer);
      if (J.$index$asx(this.layers, layer) == null) {
        J.clear$0$ax(this._results);
        return;
      }
      if (x == null)
        x = 0;
      if (y == null)
        y = 0;
      if (width == null)
        width = J.get$width$x(J.$index$asx(this.layers, layer));
      if (height == null)
        height = J.get$height$x(J.$index$asx(this.layers, layer));
      if (J.$lt$n(x, 0))
        x = 0;
      if (J.$lt$n(y, 0))
        y = 0;
      if (J.$gt$n(width, J.get$width$x(J.$index$asx(this.layers, layer))))
        width = J.get$width$x(J.$index$asx(this.layers, layer));
      if (J.$gt$n(height, J.get$height$x(J.$index$asx(this.layers, layer))))
        height = J.get$height$x(J.$index$asx(this.layers, layer));
      J.set$length$asx(this._results, 0);
      J.add$1$ax(this._results, P.LinkedHashMap_LinkedHashMap$_literal(["x", x, "y", y, "width", width, "height", height, "layer", layer], null, null));
      for (t1 = J.getInterceptor$ns(y), t2 = J.getInterceptor$ns(x), ty = y; t3 = J.getInterceptor$n(ty), t3.$lt(ty, t1.$add(y, height)); ty = t3.$add(ty, 1))
        for (tx = x; t4 = J.getInterceptor$n(tx), t4.$lt(tx, t2.$add(x, width)); tx = t4.$add(tx, 1))
          J.add$1$ax(this._results, J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), ty), tx));
      return this._results;
    }, function(x, y, width, height) {
      return this.copy$5(x, y, width, height, null);
    }, "copy$4", "call$5", "call$4", "get$copy", 8, 2, 1579, 32, 6, [], 7, [], 10, [], 11, [], 452, [], "copy"],
    paste$4: [function(x, y, tileblock, layer) {
      var t1, diffX, diffY, t2, t3, i, t4;
      if (x == null)
        x = 0;
      if (y == null)
        y = 0;
      layer = this.getLayer$1(layer);
      if (tileblock == null || J.$lt$n(J.get$length$asx(tileblock), 2))
        return;
      t1 = J.getInterceptor$asx(tileblock);
      diffX = J.$sub$n(J.get$x$x(t1.$index(tileblock, 1)), x);
      diffY = J.$sub$n(J.get$y$x(t1.$index(tileblock, 1)), y);
      t2 = J.getInterceptor$ns(diffY);
      t3 = J.getInterceptor$ns(diffX);
      i = 1;
      while (true) {
        t4 = t1.get$length(tileblock);
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (!(i < t4))
          break;
        J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, layer)), t2.$add(diffY, J.get$y$x(t1.$index(tileblock, i)))), t3.$add(diffX, J.get$x$x(t1.$index(tileblock, i)))).copy$1(t1.$index(tileblock, i));
        ++i;
      }
      J.$index$asx(this.layers, layer).set$dirty(true);
      this.calculateFaces$1(layer);
    }, function() {
      return this.paste$4(null, null, null, null);
    }, "paste$0", function(x) {
      return this.paste$4(x, null, null, null);
    }, "paste$1", function(x, y) {
      return this.paste$4(x, y, null, null);
    }, "paste$2", function(x, y, tileblock) {
      return this.paste$4(x, y, tileblock, null);
    }, "paste$3", "call$4", "call$0", "call$1", "call$2", "call$3", "get$paste", 0, 8, 1580, 32, 32, 32, 32, 6, [], 7, [], 1581, [], 452, [], "paste"],
    swap$7: [function(tileA, tileB, x, y, width, height, layer) {
      layer = this.getLayer$1(layer);
      this.copy$5(x, y, width, height, layer);
      if (J.$lt$n(J.get$length$asx(this._results), 2))
        return;
      this._tempA = tileA;
      this._tempB = tileB;
      J.forEach$1$ax(this._results, this.get$swapHandler());
      this.paste$4(x, y, this._results, layer);
    }, function(tileA, tileB, x, y, width, height) {
      return this.swap$7(tileA, tileB, x, y, width, height, null);
    }, "swap$6", "call$7", "call$6", "get$swap", 12, 2, 1582, 32, 1583, [], 1584, [], 6, [], 7, [], 10, [], 11, [], 452, [], "swap"],
    swapHandler$1: [function(value) {
      var t1 = J.getInterceptor$x(value);
      if (J.$eq(t1.get$index(value), this._tempA))
        t1.set$index(value, this._tempB);
      else if (J.$eq(t1.get$index(value), this._tempB))
        t1.set$index(value, this._tempA);
    }, "call$1", "get$swapHandler", 2, 0, 1539, 100, [], "swapHandler"],
    forEach$6: [function(_, callback, x, y, width, height, layer) {
      layer = this.getLayer$1(layer);
      this.copy$5(x, y, width, height, layer);
      if (J.$lt$n(J.get$length$asx(this._results), 2))
        return;
      J.forEach$1$ax(this._results, callback);
      this.paste$4(x, y, this._results, layer);
    }, function($receiver, callback, x, y, width, height) {
      return this.forEach$6($receiver, callback, x, y, width, height, null);
    }, "forEach$5", "call$6", "call$5", "get$forEach", 10, 2, 1585, 32, 272, [], 6, [], 7, [], 10, [], 11, [], 452, [], "forEach"],
    replace$7: [function(_, source, dest, x, y, width, height, layer) {
      var i, t1;
      layer = this.getLayer$1(layer);
      this.copy$5(x, y, width, height, layer);
      if (J.$lt$n(J.get$length$asx(this._results), 2))
        return;
      i = 1;
      while (true) {
        t1 = J.get$length$asx(this._results);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$eq(J.get$index$x(J.$index$asx(this._results, i)), source))
          J.set$index$x(J.$index$asx(this._results, i), dest);
        ++i;
      }
      this.paste$4(x, y, this._results, layer);
    }, function($receiver, source, dest, x, y, width, height) {
      return this.replace$7($receiver, source, dest, x, y, width, height, null);
    }, "replace$6", "call$7", "call$6", "get$replace", 12, 2, 1582, 32, 170, [], 1221, [], 6, [], 7, [], 10, [], 11, [], 452, [], "replace"],
    random$5: [function(x, y, width, height, layer) {
      var indexes, t, t1, idx, i;
      layer = this.getLayer$1(layer);
      this.copy$5(x, y, width, height, layer);
      if (J.$lt$n(J.get$length$asx(this._results), 2))
        return;
      indexes = [];
      t = 1;
      while (true) {
        t1 = J.get$length$asx(this._results);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(t < t1))
          break;
        if (J.get$index$x(J.$index$asx(this._results, t)) === true) {
          idx = J.get$index$x(J.$index$asx(this._results, t));
          if (J.$eq(H.Lists_indexOf(indexes, idx, 0, indexes.length), -1))
            indexes.push(idx);
        }
        ++t;
      }
      i = 1;
      while (true) {
        t1 = J.get$length$asx(this._results);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.set$index$x(J.$index$asx(this._results, i), this.game.get$rnd().pick$1(indexes));
        ++i;
      }
      this.paste$4(x, y, this._results, layer);
    }, function(x, y, width, height) {
      return this.random$5(x, y, width, height, null);
    }, "random$4", "call$5", "call$4", "get$random", 8, 2, 1586, 32, 6, [], 7, [], 10, [], 11, [], 452, [], "random"],
    shuffle$5: [function(_, x, y, width, height, layer) {
      var indexes, t, t1, i, t2;
      layer = this.getLayer$1(layer);
      this.copy$5(x, y, width, height, layer);
      if (J.$lt$n(J.get$length$asx(this._results), 2))
        return;
      indexes = [];
      t = 1;
      while (true) {
        t1 = J.get$length$asx(this._results);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(t < t1))
          break;
        if (J.get$index$x(J.$index$asx(this._results, t)) === true)
          indexes.push(J.get$index$x(J.$index$asx(this._results, t)));
        ++t;
      }
      H.IterableMixinWorkaround_shuffleList(indexes, null);
      i = 1;
      while (true) {
        t1 = J.get$length$asx(this._results);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        t1 = J.$index$asx(this._results, i);
        t2 = i - 1;
        if (t2 >= indexes.length)
          return H.ioore(indexes, t2);
        J.set$index$x(t1, indexes[t2]);
        ++i;
      }
      this.paste$4(x, y, this._results, layer);
    }, function($receiver, x, y, width, height) {
      return this.shuffle$5($receiver, x, y, width, height, null);
    }, "shuffle$4", "call$5", "call$4", "get$shuffle", 8, 2, 1586, 32, 6, [], 7, [], 10, [], 11, [], 452, [], "shuffle"],
    fill$6: [function(_, index, x, y, width, height, layer) {
      var i, t1;
      layer = this.getLayer$1(layer);
      this.copy$5(x, y, width, height, layer);
      if (J.$lt$n(J.get$length$asx(this._results), 2))
        return;
      i = 1;
      while (true) {
        t1 = J.get$length$asx(this._results);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.set$index$x(J.$index$asx(this._results, i), index);
        ++i;
      }
      this.paste$4(x, y, this._results, layer);
    }, function($receiver, index, x, y, width, height) {
      return this.fill$6($receiver, index, x, y, width, height, null);
    }, "fill$5", "call$6", "call$5", "get$fill", 10, 2, 1587, 32, 243, [], 6, [], 7, [], 10, [], 11, [], 452, [], "fill"],
    removeAllLayers$0: [function() {
      J.set$length$asx(this.layers, 0);
      this.currentLayer = 0;
    }, "call$0", "get$removeAllLayers", 0, 0, 13, "removeAllLayers"],
    dump$0: [function() {
      var args, txt, y, t1, x;
      args = [""];
      txt = "";
      y = 0;
      while (true) {
        t1 = J.get$height$x(J.$index$asx(this.layers, this.currentLayer));
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(y < t1))
          break;
        x = 0;
        while (true) {
          t1 = J.get$width$x(J.$index$asx(this.layers, this.currentLayer));
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(x < t1))
            break;
          txt += "%c  ";
          if (J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, this.currentLayer)), y), x) != null)
            if (J.$index$asx(this.debugMap, J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, this.currentLayer)), y), x)) != null)
              args.push("background: " + H.S(J.$index$asx(this.debugMap, J.$index$asx(J.$index$asx(J.get$data$x(J.$index$asx(this.layers, this.currentLayer)), y), x))));
            else
              args.push("background: #ffffff");
          else
            args.push("background: rgb(0, 0, 0)");
          ++x;
        }
        txt += "\n";
        ++y;
      }
      if (0 >= args.length)
        return H.ioore(args, 0);
      args[0] = txt;
      window;
      if (typeof console != "undefined")
        console.log(args);
    }, "call$0", "get$dump", 0, 0, 13, "dump"],
    destroy$0: [function() {
      J.set$length$asx(this.layers, 0);
      this.currentLayer = 0;
      this.data = [];
      this.game = null;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    Tilemap$6: function(game, key, tileWidth, tileHeight, width, height) {
      var data;
      this.game = game;
      this.key = key;
      data = R.TilemapParser_parse(game, key, tileWidth, tileHeight, width, height);
      if (data == null)
        return;
      this.width = data.width;
      this.height = data.height;
      this.tileWidth = data.tileWidth;
      this.tileHeight = data.tileHeight;
      this.orientation = data.orientation;
      this.format = data.format;
      this.version = data.version;
      this.properties = data.properties;
      this.widthInPixels = data.widthInPixels;
      this.heightInPixels = data.heightInPixels;
      this.layers = data.layers;
      this.tilesets = data.tilesets;
      this.tiles = data.tiles;
      this.objects = data.objects;
      this.collideIndexes = [];
      this.collision = data.collision;
      this.images = data.images;
      this.currentLayer = 0;
      this.debugMap = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this._results = [];
      this._tempA = 0;
      this._tempB = 0;
    },
    static: {"^": "Tilemap_CSV<-599,Tilemap_TILED_JSON<-599,Tilemap_Format<-921,Tilemap_NORTH<-599,Tilemap_EAST<-599,Tilemap_SOUTH<-599,Tilemap_WEST<-599", Tilemap$: [function(game, key, tileWidth, tileHeight, width, height) {
        var t1 = new R.Tilemap(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null);
        t1.Tilemap$6(game, key, tileWidth, tileHeight, width, height);
        return t1;
      }, null, null, 2, 10, 454, 32, 269, 269, 348, 348, 214, [], 231, [], 455, [], 456, [], 10, [], 11, [], "new Tilemap"]}
  },
  "+Tilemap": [632],
  MapCache: {
    "^": "Object;cw@-601,ch@-601,ga@-601,dx*-601,dy*-601,dw@-601,dh@-601,tx@-601,ty@-601,tw@-601,th*-601,tl@-601,maxX@-601,maxY@-601,startX@-601,startY@-601,x*-601,y*-601,prevX@-601,prevY@-601",
    static: {MapCache$: [function() {
        return new R.MapCache(null, null, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }, null, null, 0, 0, 457, "new MapCache"]}
  },
  "+MapCache": [632],
  TilemapLayerData: {
    "^": "Object;name*-639,x*-601,y*-601,width*-601,height*-601,widthInPixels@-601,heightInPixels@-601,alpha*-601,visible@-602,properties@-754,indexes@-715,callbacks@-1588,bodies@-1411,data*-1589,dirty@-602",
    static: {TilemapLayerData$: [function() {
        return new R.TilemapLayerData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);
      }, null, null, 0, 0, 458, "new TilemapLayerData"]}
  },
  "+TilemapLayerData": [632],
  TilemapLayer: {
    "^": "Image;game:Phaser$TilemapLayer$game@-598,map*-1590,index*-599,layer*-1533,canvas*-808,context*-850,baseTexture@-826,texture:Phaser$TilemapLayer$texture@-670,textureFrame@-939,name:Phaser$TilemapLayer$name*-639,type:Phaser$TilemapLayer$type*-599,cameraOffset:Phaser$TilemapLayer$cameraOffset@-600,tileColor@-639,debug@-602,debugAlpha@-601,debugColor@-639,debugFill@-602,debugFillColor@-639,debugCallbackColor@-639,scrollFactorX@-601,scrollFactorY@-601,dirty@-602,rayStepRate@-601,wrap*-602,_mc@-1591,_results@-720,_column@-1592,game-598,exists-602,name-639,type-599,z-599,events-1018,key-32,world-600,autoCull-602,input-1111,body-1117,cameraOffset-600,Phaser$Image$anchor-600,cropRect-974,_cache-720,_crop-974,_frame-599,_Phaser$_bounds-974,_Phaser$_dirty-602,_frameName-639,alive-602,Phaser$Image$children-1058,_Phaser$_currentBounds-974,anchor-634,texture-670,updateFrame-602,PIXI$Sprite$_width-601,PIXI$Sprite$_height-601,_uvs-671,tintedTexture-672,buffer-673,tint-599,cachedTint-599,blendMode-674,children-657,interactiveChildren-602,_width-601,_height-601,position-634,scale-634,pivot-634,rotation-601,alpha-601,visible-602,hitArea-627,buttonMode-602,renderable-602,_parent-635,__hit-602,__isOver-602,__mouseIsDown-602,__isDown-602,_dirty-602,click-636,mousemove-636,mousedown-636,mouseout-636,mouseover-636,mouseup-636,mouseupoutside-636,touchmove-636,touchstart-636,touchend-636,tap-636,touchendoutside-636,__touchData-637,_stage-638,_worldAlpha-601,_interactive-602,defaultCursor-639,_worldTransform-640,_sr-601,_cr-601,filterArea-641,_bounds-641,_currentBounds-641,_mask-642,_cacheAsBitmap-602,_cachedSprite-643,_cacheIsDirty-602,_filterBlock-644,_filters-645,_rotationCache-601",
    map$1: function($receiver, arg0) {
      return this.map.call$1(arg0);
    },
    wrap$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.wrap.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    get$scrollX: [function(_) {
      return J.get$x$x(this._mc);
    }, null, null, 1, 0, 604, "scrollX"],
    set$scrollX: [function(_, value) {
      var t1;
      if (!J.$eq(value, J.get$x$x(this._mc))) {
        J.set$x$x(this._mc, value);
        t1 = this._mc;
        t1.set$startX(J.floor$0$n(J.$div$n(J.get$x$x(t1), this.map.get$tileWidth())));
        this.dirty = true;
      }
    }, null, null, 3, 0, 605, 100, [], "scrollX"],
    get$scrollY: [function(_) {
      return J.get$y$x(this._mc);
    }, null, null, 1, 0, 604, "scrollY"],
    set$scrollY: [function(_, value) {
      var t1;
      if (!J.$eq(value, J.get$y$x(this._mc))) {
        J.set$y$x(this._mc, value);
        t1 = this._mc;
        t1.set$startY(J.floor$0$n(J.$div$n(J.get$y$x(t1), this.map.get$tileHeight())));
        this.dirty = true;
      }
    }, null, null, 3, 0, 605, 100, [], "scrollY"],
    get$collisionWidth: [function() {
      return this._mc.get$cw();
    }, null, null, 1, 0, 604, "collisionWidth"],
    set$collisionWidth: [function(value) {
      this._mc.set$cw(value);
      this.dirty = true;
    }, null, null, 3, 0, 605, 100, [], "collisionWidth"],
    get$collisionHeight: [function() {
      return this._mc.get$ch();
    }, null, null, 1, 0, 604, "collisionHeight"],
    set$collisionHeight: [function(value) {
      this._mc.set$ch(value);
      this.dirty = true;
    }, null, null, 3, 0, 605, 100, [], "collisionHeight"],
    postUpdate$0: [function() {
      R.Image.prototype.postUpdate$0.call(this);
      var t1 = J.$mul$ns(J.get$x$x(this.Phaser$TilemapLayer$game.get$camera()), this.scrollFactorX);
      if (!J.$eq(t1, J.get$x$x(this._mc))) {
        J.set$x$x(this._mc, t1);
        t1 = this._mc;
        t1.set$startX(J.floor$0$n(J.$div$n(J.get$x$x(t1), this.map.get$tileWidth())));
        this.dirty = true;
      }
      t1 = J.$mul$ns(J.get$y$x(this.Phaser$TilemapLayer$game.get$camera()), this.scrollFactorY);
      if (!J.$eq(t1, J.get$y$x(this._mc))) {
        J.set$y$x(this._mc, t1);
        t1 = this._mc;
        t1.set$startY(J.floor$0$n(J.$div$n(J.get$y$x(t1), this.map.get$tileHeight())));
        this.dirty = true;
      }
      this.render$0();
      if (J.$eq(J.$index$asx(this._cache, 7), 1)) {
        J.set$x$x(this.position, J.$div$n(J.$add$ns(J.get$x$x(J.get$view$x(this.Phaser$TilemapLayer$game.get$camera())), J.get$x$x(this.Phaser$TilemapLayer$cameraOffset)), J.get$x$x(J.get$scale$x(this.Phaser$TilemapLayer$game.get$camera()))));
        J.set$y$x(this.position, J.$div$n(J.$add$ns(J.get$y$x(J.get$view$x(this.Phaser$TilemapLayer$game.get$camera())), J.get$y$x(this.Phaser$TilemapLayer$cameraOffset)), J.get$y$x(J.get$scale$x(this.Phaser$TilemapLayer$game.get$camera()))));
      }
    }, "call$0", "get$postUpdate", 0, 0, 13, "postUpdate"],
    resizeWorld$0: [function() {
      this.Phaser$TilemapLayer$game.get$world().setBounds$4(0, 0, this.layer.get$widthInPixels(), this.layer.get$heightInPixels());
    }, "call$0", "get$resizeWorld", 0, 0, 13, "resizeWorld"],
    _fixX$1: [function(x) {
      if (J.$lt$n(x, 0))
        x = 0;
      if (J.$eq(this.scrollFactorX, 1))
        return x;
      return J.$add$ns(J.get$x$x(this._mc), J.$sub$n(x, J.$div$n(J.get$x$x(this._mc), this.scrollFactorX)));
    }, "call$1", "get$_fixX", 2, 0, 331, 6, [], "_fixX"],
    _unfixX$1: [function(x) {
      if (J.$eq(this.scrollFactorX, 1))
        return x;
      return J.$add$ns(J.$div$n(J.get$x$x(this._mc), this.scrollFactorX), J.$sub$n(x, J.get$x$x(this._mc)));
    }, "call$1", "get$_unfixX", 2, 0, 331, 6, [], "_unfixX"],
    _fixY$1: [function(y) {
      if (J.$lt$n(y, 0))
        y = 0;
      if (J.$eq(this.scrollFactorY, 1))
        return y;
      return J.$add$ns(J.get$y$x(this._mc), J.$sub$n(y, J.$div$n(J.get$y$x(this._mc), this.scrollFactorY)));
    }, "call$1", "get$_fixY", 2, 0, 331, 7, [], "_fixY"],
    _unfixY$1: [function(y) {
      if (J.$eq(this.scrollFactorY, 1))
        return y;
      return J.$add$ns(J.$div$n(J.get$y$x(this._mc), this.scrollFactorY), J.$sub$n(y, J.get$y$x(this._mc)));
    }, "call$1", "get$_unfixY", 2, 0, 331, 7, [], "_unfixY"],
    getTileX$1: [function(x) {
      return J.$tdiv$n(R.Math_snapToFloor(this._fixX$1(x), this.map.get$tileWidth(), 0), this.map.get$tileWidth());
    }, "call$1", "get$getTileX", 2, 0, 339, 6, [], "getTileX"],
    getTileY$1: [function(y) {
      return J.$tdiv$n(R.Math_snapToFloor(this._fixY$1(y), this.map.get$tileHeight(), 0), this.map.get$tileHeight());
    }, "call$1", "get$getTileY", 2, 0, 339, 7, [], "getTileY"],
    getTileXY$3: [function(x, y, point) {
      var t1 = J.getInterceptor$x(point);
      t1.set$x(point, J.$tdiv$n(R.Math_snapToFloor(this._fixX$1(x), this.map.get$tileWidth(), 0), this.map.get$tileWidth()));
      t1.set$y(point, J.$tdiv$n(R.Math_snapToFloor(this._fixY$1(y), this.map.get$tileHeight(), 0), this.map.get$tileHeight()));
      return point;
    }, "call$3", "get$getTileXY", 6, 0, 1593, 6, [], 7, [], 433, [], "getTileXY"],
    getRayCastTiles$4: [function(line, stepRate, collides, interestingFace) {
      var t1, tiles, coords, t2, total, results, i, t3, t;
      if (stepRate == null)
        stepRate = this.rayStepRate;
      t1 = J.getInterceptor$x(line);
      tiles = this.getTiles$6(t1.get$x(line), t1.get$y(line), t1.get$width(line), t1.get$height(line), collides, interestingFace);
      t1 = J.getInterceptor$asx(tiles);
      if (J.$eq(t1.get$length(tiles), 0))
        return [];
      coords = line.coordinatesOnLine$1(stepRate);
      t2 = J.getInterceptor$asx(coords);
      total = t2.get$length(coords);
      results = [];
      i = 0;
      while (true) {
        t3 = t1.get$length(tiles);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        if (typeof total !== "number")
          return H.iae(total);
        t = 0;
        for (; t < total; ++t)
          if (J.containsPoint$2$x(t1.$index(tiles, i), J.$index$asx(t2.$index(coords, t), 0), J.$index$asx(t2.$index(coords, t), 1))) {
            results.push(t1.$index(tiles, i));
            break;
          }
        ++i;
      }
      return results;
    }, function(line) {
      return this.getRayCastTiles$4(line, null, false, false);
    }, "getRayCastTiles$1", function(line, stepRate) {
      return this.getRayCastTiles$4(line, stepRate, false, false);
    }, "getRayCastTiles$2", function(line, stepRate, collides) {
      return this.getRayCastTiles$4(line, stepRate, collides, false);
    }, "getRayCastTiles$3", "call$4", "call$1", "call$2", "call$3", "get$getRayCastTiles", 2, 6, 1594, 32, 95, 95, 1197, [], 1242, [], 1537, [], 1595, [], "getRayCastTiles"],
    getTiles$6: [function(x, y, width, height, collides, interestingFace) {
      var t1, wy, t2, t3, wx, t4;
      x = this._fixX$1(x);
      y = this._fixY$1(y);
      if (J.$gt$n(width, this.layer.get$widthInPixels()))
        width = this.layer.get$widthInPixels();
      if (J.$gt$n(height, this.layer.get$heightInPixels()))
        height = this.layer.get$heightInPixels();
      t1 = this._mc;
      t1.set$tx(J.$tdiv$n(R.Math_snapToFloor(x, t1.get$cw(), 0), this._mc.get$cw()));
      t1 = this._mc;
      t1.set$ty(J.$tdiv$n(R.Math_snapToFloor(y, t1.get$ch(), 0), this._mc.get$ch()));
      t1 = this._mc;
      t1.set$tw(J.$tdiv$n(J.$add$ns(R.Math_snapToCeil(width, t1.get$cw(), 0), this._mc.get$cw()), this._mc.get$cw()));
      t1 = this._mc;
      J.set$th$x(t1, J.$tdiv$n(J.$add$ns(R.Math_snapToCeil(height, t1.get$ch(), 0), this._mc.get$ch()), this._mc.get$ch()));
      J.clear$0$ax(this._results);
      for (wy = this._mc.get$ty(), t1 = collides !== true, t2 = interestingFace !== true; t3 = J.getInterceptor$n(wy), t3.$lt(wy, J.$add$ns(this._mc.get$ty(), J.get$th$x(this._mc))); wy = t3.$add(wy, 1))
        for (wx = this._mc.get$tx(); t4 = J.getInterceptor$n(wx), t4.$lt(wx, J.$add$ns(this._mc.get$tx(), this._mc.get$tw())); wx = t4.$add(wx, 1))
          if (J.$gt$n(J.get$length$asx(J.get$data$x(this.layer)), wy) && J.$gt$n(J.get$length$asx(J.$index$asx(J.get$data$x(this.layer), wy)), wx))
            if (t1 && t2 || J.$index$asx(J.$index$asx(J.get$data$x(this.layer), wy), wx).isInteresting$2(collides, interestingFace))
              J.add$1$ax(this._results, J.$index$asx(J.$index$asx(J.get$data$x(this.layer), wy), wx));
      return this._results;
    }, function(x, y, width, height) {
      return this.getTiles$6(x, y, width, height, false, false);
    }, "getTiles$4", function(x, y, width, height, collides) {
      return this.getTiles$6(x, y, width, height, collides, false);
    }, "getTiles$5", "call$6", "call$4", "call$5", "get$getTiles", 8, 4, 1596, 95, 95, 6, [], 7, [], 10, [], 11, [], 1537, [], 1595, [], "getTiles"],
    updateMax$0: [function() {
      this._mc.set$maxX(J.ceil$0$n(J.$div$n(J.get$width$x(this.canvas), this.map.get$tileWidth())) + 1);
      this._mc.set$maxY(J.ceil$0$n(J.$div$n(J.get$height$x(this.canvas), this.map.get$tileHeight())) + 1);
      this.dirty = true;
    }, "call$0", "get$updateMax", 0, 0, 13, "updateMax"],
    render$0: [function() {
      var t1, t2, y, lenY, tile, set, x, lenX, t3;
      if (this.layer.get$dirty() === true)
        this.dirty = true;
      if (this.dirty !== true || this.visible !== true)
        return false;
      t1 = this._mc;
      t1.set$prevX(J.get$dx$x(t1));
      t1 = this._mc;
      t1.set$prevY(J.get$dy$x(t1));
      t1 = this._mc;
      t2 = J.getInterceptor$x(t1);
      t2.set$dx(t1, J.$negate$n(J.$sub$n(t2.get$x(t1), J.$mul$ns(this._mc.get$startX(), this.map.get$tileWidth()))));
      t1 = this._mc;
      t2 = J.getInterceptor$x(t1);
      t2.set$dy(t1, J.$negate$n(J.$sub$n(t2.get$y(t1), J.$mul$ns(this._mc.get$startY(), this.map.get$tileHeight()))));
      t1 = this._mc;
      t1.set$tx(J.get$dx$x(t1));
      t1 = this._mc;
      t1.set$ty(J.get$dy$x(t1));
      J.clearRect$4$x(this.context, 0, 0, J.get$width$x(this.canvas), J.get$height$x(this.canvas));
      J.set$fillStyle$x(this.context, this.tileColor);
      if (this.debug === true)
        J.set$globalAlpha$x(this.context, this.debugAlpha);
      for (y = this._mc.get$startY(), lenY = J.$add$ns(this._mc.get$startY(), this._mc.get$maxY()), tile = null, set = null; t1 = J.getInterceptor$n(y), t1.$lt(y, lenY); y = t1.$add(y, 1)) {
        this._column = null;
        if (t1.$lt(y, 0) && this.wrap === true)
          this._column = J.$index$asx(J.get$data$x(this.layer), t1.$add(y, J.get$height$x(this.map)));
        else if (t1.$ge(y, J.get$height$x(this.map)) && this.wrap === true)
          this._column = J.$index$asx(J.get$data$x(this.layer), t1.$sub(y, J.get$height$x(this.map)));
        else if (J.$gt$n(J.get$length$asx(J.get$data$x(this.layer)), y))
          this._column = J.$index$asx(J.get$data$x(this.layer), y);
        if (this._column != null)
          for (x = this._mc.get$startX(), lenX = J.$add$ns(this._mc.get$startX(), this._mc.get$maxX()); t2 = J.getInterceptor$n(x), t2.$lt(x, lenX); x = t2.$add(x, 1)) {
            if (t2.$lt(x, 0) && this.wrap === true)
              tile = J.$index$asx(this._column, t2.$add(x, J.get$width$x(this.map)));
            else if (t2.$ge(x, J.get$width$x(this.map)) && this.wrap === true)
              tile = J.$index$asx(this._column, t2.$sub(x, J.get$width$x(this.map)));
            else
              tile = J.$gt$n(J.get$length$asx(this._column), x) ? J.$index$asx(this._column, x) : null;
            if (tile != null) {
              t3 = J.getInterceptor$x(tile);
              t3 = J.$gt$n(t3.get$index(tile), -1) && J.$lt$n(t3.get$index(tile), J.get$length$asx(this.map.get$tiles()));
            } else
              t3 = false;
            if (t3) {
              t3 = J.getInterceptor$x(tile);
              set = J.$index$asx(this.map.get$tilesets(), J.$index$asx(J.$index$asx(this.map.get$tiles(), J.toInt$0$n(t3.get$index(tile))), 2));
              if (J.$eq(this.debug, false) && !J.$eq(t3.get$alpha(tile), J.get$globalAlpha$x(this.context)))
                J.set$globalAlpha$x(this.context, t3.get$alpha(tile));
              set.draw$4(this.context, J.floor$0$n(this._mc.get$tx()), J.floor$0$n(this._mc.get$ty()), J.toInt$0$n(t3.get$index(tile)));
              if (tile.get$debug() === true) {
                J.set$fillStyle$x(this.context, "rgba(0, 255, 0, 0.4)");
                J.fillRect$4$x(this.context, J.floor$0$n(this._mc.get$tx()), J.floor$0$n(this._mc.get$ty()), this.map.get$tileWidth(), this.map.get$tileHeight());
              }
            }
            t3 = this._mc;
            t3.set$tx(J.$add$ns(t3.get$tx(), this.map.get$tileWidth()));
          }
        t2 = this._mc;
        t2.set$tx(J.get$dx$x(t2));
        t2 = this._mc;
        t2.set$ty(J.$add$ns(t2.get$ty(), this.map.get$tileHeight()));
      }
      if (this.debug === true) {
        J.set$globalAlpha$x(this.context, 1);
        this.renderDebug$0();
      }
      if (J.$eq(this.Phaser$TilemapLayer$game.get$renderType(), 2))
        M.updateWebGLTexture(this.baseTexture, this.Phaser$TilemapLayer$game.get$renderer().get$gl());
      this.dirty = false;
      this.layer.set$dirty(false);
      return true;
    }, "call$0", "get$render", 0, 0, 13, "render"],
    renderDebug$0: [function() {
      var t1, y, lenY, x, lenX, t2, tile, t3;
      t1 = this._mc;
      t1.set$tx(J.get$dx$x(t1));
      t1 = this._mc;
      t1.set$ty(J.get$dy$x(t1));
      J.set$strokeStyle$x(this.context, this.debugColor);
      J.set$fillStyle$x(this.context, this.debugFillColor);
      for (y = this._mc.get$startY(), lenY = J.$add$ns(this._mc.get$startY(), this._mc.get$maxY()); t1 = J.getInterceptor$n(y), t1.$lt(y, lenY); y = t1.$add(y, 1)) {
        this._column = null;
        if (t1.$lt(y, 0) && this.wrap === true)
          this._column = J.$index$asx(J.get$data$x(this.layer), t1.$add(y, J.get$height$x(this.map)));
        else if (t1.$ge(y, J.get$height$x(this.map)) && this.wrap === true)
          this._column = J.$index$asx(J.get$data$x(this.layer), t1.$sub(y, J.get$height$x(this.map)));
        else if (J.$gt$n(J.get$length$asx(J.get$data$x(this.layer)), y))
          this._column = J.$index$asx(J.get$data$x(this.layer), y);
        if (this._column != null)
          for (x = this._mc.get$startX(), lenX = J.$add$ns(this._mc.get$startX(), this._mc.get$maxX()); t2 = J.getInterceptor$n(x), t2.$lt(x, lenX); x = t2.$add(x, 1)) {
            if (t2.$lt(x, 0) && this.wrap === true)
              tile = J.$index$asx(this._column, t2.$add(x, J.get$width$x(this.map)));
            else if (t2.$ge(x, J.get$width$x(this.map)) && this.wrap === true)
              tile = J.$index$asx(this._column, t2.$sub(x, J.get$width$x(this.map)));
            else
              tile = J.$gt$n(J.get$length$asx(this._column), x) ? J.$index$asx(this._column, x) : null;
            if (tile != null)
              t3 = tile.get$faceTop() === true || tile.get$faceBottom() === true || tile.get$faceLeft() === true || tile.get$faceRight() === true;
            else
              t3 = false;
            if (t3) {
              t3 = this._mc;
              t3.set$tx(J.floor$0$n(t3.get$tx()));
              if (this.debugFill === true)
                J.fillRect$4$x(this.context, this._mc.get$tx(), this._mc.get$ty(), this._mc.get$cw(), this._mc.get$ch());
              J.beginPath$0$x(this.context);
              if (tile.get$faceTop() === true) {
                J.moveTo$2$x(this.context, this._mc.get$tx(), this._mc.get$ty());
                J.lineTo$2$x(this.context, J.$add$ns(this._mc.get$tx(), this._mc.get$cw()), this._mc.get$ty());
              }
              if (tile.get$faceBottom() === true) {
                J.moveTo$2$x(this.context, this._mc.get$tx(), J.$add$ns(this._mc.get$ty(), this._mc.get$ch()));
                J.lineTo$2$x(this.context, J.$add$ns(this._mc.get$tx(), this._mc.get$cw()), J.$add$ns(this._mc.get$ty(), this._mc.get$ch()));
              }
              if (tile.get$faceLeft() === true) {
                J.moveTo$2$x(this.context, this._mc.get$tx(), this._mc.get$ty());
                J.lineTo$2$x(this.context, this._mc.get$tx(), J.$add$ns(this._mc.get$ty(), this._mc.get$ch()));
              }
              if (tile.get$faceRight() === true) {
                J.moveTo$2$x(this.context, J.$add$ns(this._mc.get$tx(), this._mc.get$cw()), this._mc.get$ty());
                J.lineTo$2$x(this.context, J.$add$ns(this._mc.get$tx(), this._mc.get$cw()), J.$add$ns(this._mc.get$ty(), this._mc.get$ch()));
              }
              J.stroke$0$x(this.context);
            }
            t3 = this._mc;
            t3.set$tx(J.$add$ns(t3.get$tx(), this.map.get$tileWidth()));
          }
        t2 = this._mc;
        t2.set$tx(J.get$dx$x(t2));
        t2 = this._mc;
        t2.set$ty(J.$add$ns(t2.get$ty(), this.map.get$tileHeight()));
      }
    }, "call$0", "get$renderDebug", 0, 0, 13, "renderDebug"],
    TilemapLayer$5: function(game, tilemap, index, width, height) {
      var t1;
      this.Phaser$TilemapLayer$game = game;
      this.map = tilemap;
      this.index = index;
      this.layer = J.$index$asx(tilemap.get$layers(), index);
      t1 = R.Canvas_create(width, height, "", true);
      this.canvas = t1;
      this.context = J.getContext$1$x(t1, "2d");
      t1 = M.BaseTexture$(this.canvas, C.scaleModes_0);
      this.baseTexture = t1;
      this.Phaser$TilemapLayer$texture = M.Texture$(t1, null);
      this.textureFrame = R.Frame$(0, 0, 0, width, height, "tilemapLayer", game.get$rnd().uuid$0());
      this.Phaser$TilemapLayer$name = "";
      this.Phaser$TilemapLayer$type = 10;
      this.set$fixedToCamera(true);
      t1 = new R.Point(null, null);
      t1.x = 0;
      t1.y = 0;
      this.Phaser$TilemapLayer$cameraOffset = t1;
      this.tileColor = "rgb(255, 255, 255)";
      this.debug = false;
      this.debugAlpha = 0.5;
      this.debugColor = "rgba(0, 255, 0, 1)";
      this.debugFill = false;
      this.debugFillColor = "rgba(0, 255, 0, 0.2)";
      this.debugCallbackColor = "rgba(255, 0, 0, 1)";
      this.scrollFactorX = 1;
      this.scrollFactorY = 1;
      this.dirty = true;
      this.rayStepRate = 4;
      this.wrap = false;
      t1 = new R.MapCache(null, null, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      t1.cw = tilemap.get$tileWidth();
      t1.ch = tilemap.get$tileHeight();
      this._mc = t1;
      this._results = [];
      t1.maxX = J.ceil$0$n(J.$div$n(J.get$width$x(this.canvas), this.map.get$tileWidth())) + 1;
      this._mc.set$maxY(J.ceil$0$n(J.$div$n(J.get$height$x(this.canvas), this.map.get$tileHeight())) + 1);
      this.dirty = true;
    },
    $isTilemapLayer: true,
    static: {TilemapLayer$: [function(game, tilemap, index, width, height) {
        var t1, t2, t3, t4, t5, t6;
        t1 = J.$index$asx($.get$TextureCache(), "__default");
        t2 = new M.Point0(null, null);
        t2.x = 0;
        t2.y = 0;
        t3 = new M.Point0(null, null);
        t3.x = 0;
        t3.y = 0;
        t4 = new M.Point0(null, null);
        t4.x = 1;
        t4.y = 1;
        t5 = new M.Point0(null, null);
        t5.x = 0;
        t5.y = 0;
        t6 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t2 = new R.TilemapLayer(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, [], null, t2, null, false, 0, 0, null, null, null, 16777215, null, C.BlendModes_0, [], false, 0, 0, t3, t4, t5, 0, 1, true, null, false, false, null, false, false, false, false, false, null, null, null, null, null, null, null, null, null, null, null, null, t6, null, 1, false, "pointer", new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9)), 0, 1, null, new M.Rectangle0(0, 0, 1, 1), null, null, false, null, false, new M.FilterBlock(true, true, null, null, null, [], null), null, 0);
        t2.Phaser$TilemapLayer$texture = t1;
        t2._setupTexture$0();
        t2.Image$5(game, 0, 0, null, null);
        t2.TilemapLayer$5(game, tilemap, index, width, height);
        return t2;
      }, null, null, 2, 8, 459, 32, 32, 32, 32, 214, [], 460, [], 243, [], 10, [], 11, [], "new TilemapLayer"]}
  },
  "+TilemapLayer": [1135],
  TilemapImageData: {
    "^": "Object;name*-639,image@-639,x*-601,y*-601,alpha*-601,visible@-602,properties@-754",
    image$2: function(arg0, arg1) {
      return this.image.call$2(arg0, arg1);
    },
    image$4: function(arg0, arg1, arg2, arg3) {
      return this.image.call$4(arg0, arg1, arg2, arg3);
    },
    image$3: function(arg0, arg1, arg2) {
      return this.image.call$3(arg0, arg1, arg2);
    },
    image$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.image.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    static: {TilemapImageData$: [function() {
        return new R.TilemapImageData(null, null, null, null, null, null, null);
      }, null, null, 0, 0, 461, "new TilemapImageData"]}
  },
  "+TilemapImageData": [632],
  TilemapParser: {
    "^": "Object;",
    static: {TilemapParser$: [function() {
        return new R.TilemapParser();
      }, null, null, 0, 0, 462, "new TilemapParser"], TilemapParser_parse: [function(game, key, tileWidth, tileHeight, width, height) {
        var map, t1;
        if (tileWidth == null)
          tileWidth = 32;
        if (tileHeight == null)
          tileHeight = 32;
        if (width == null)
          ;
        if (height == null)
          ;
        if (key == null)
          return R.TilemapParser_getEmptyData(null, null, null, null);
        map = game.get$cache().getTilemapData$1(key);
        if (map != null) {
          t1 = J.getInterceptor$asx(map);
          if (J.$eq(t1.$index(map, "format"), 0))
            return R.TilemapParser_parseCSV(key, t1.$index(map, "data"), tileWidth, tileHeight);
          else if (t1.$index(map, "format") == null || J.$eq(t1.$index(map, "format"), 1))
            return R.TilemapParser_parseTiledJSON(t1.$index(map, "data"));
        } else {
          window;
          t1 = C.JSString_methods.$add("Phaser.TilemapParser.parse - No map data found for key ", key);
          if (typeof console != "undefined")
            console.warn(t1);
        }
        return;
      }, function(game) {
        return R.TilemapParser_parse(game, null, null, null, null, null);
      }, null, function(game, key) {
        return R.TilemapParser_parse(game, key, null, null, null, null);
      }, null, function(game, key, tileWidth) {
        return R.TilemapParser_parse(game, key, tileWidth, null, null, null);
      }, null, function(game, key, tileWidth, tileHeight) {
        return R.TilemapParser_parse(game, key, tileWidth, tileHeight, null, null);
      }, null, function(game, key, tileWidth, tileHeight, width) {
        return R.TilemapParser_parse(game, key, tileWidth, tileHeight, width, null);
      }, null, "call$6", "call$1", "call$2", "call$3", "call$4", "call$5", "TilemapParser_parse$closure", 2, 10, 463, 32, 32, 32, 32, 32, 214, [], 231, [], 455, [], 456, [], 10, [], 11, [], "parse"], TilemapParser_parseCSV: [function(key, data, tileWidth, tileHeight) {
        var map, output, rows, height, width, y, column, x, width0, t1, t2;
        map = R.TilemapParser_getEmptyData(null, null, null, null);
        output = [];
        rows = J.split$1$s(J.trim$0$s(data), "\n");
        height = rows.length;
        for (width = 0, y = 0; y < rows.length; ++y) {
          if (y >= output.length)
            return H.ioore(output, y);
          output[y] = [];
          column = J.split$1$s(rows[y], ",");
          for (x = 0; width0 = column.length, x < width0; ++x) {
            if (y >= output.length)
              return H.ioore(output, y);
            t1 = output[y];
            t2 = J.$index$asx(map.layers, 0);
            if (x >= column.length)
              return H.ioore(column, x);
            J.$indexSet$ax(t1, x, R.Tile$(t2, H.Primitives_parseInt(column[x], null, null), x, y, tileWidth, tileHeight));
          }
          if (width === 0)
            width = width0;
        }
        map.format = 0;
        map.name = key;
        map.width = width;
        map.height = height;
        map.tileWidth = tileWidth;
        map.tileHeight = tileHeight;
        if (typeof tileWidth !== "number")
          return H.iae(tileWidth);
        map.widthInPixels = width * tileWidth;
        if (typeof tileHeight !== "number")
          return H.iae(tileHeight);
        map.heightInPixels = height * tileHeight;
        J.set$width$x(J.$index$asx(map.layers, 0), width);
        J.set$height$x(J.$index$asx(map.layers, 0), height);
        J.$index$asx(map.layers, 0).set$widthInPixels(map.widthInPixels);
        J.$index$asx(map.layers, 0).set$heightInPixels(map.heightInPixels);
        J.set$data$x(J.$index$asx(map.layers, 0), output);
        return map;
      }, function(key, data) {
        return R.TilemapParser_parseCSV(key, data, 32, 32);
      }, null, function(key, data, tileWidth) {
        return R.TilemapParser_parseCSV(key, data, tileWidth, 32);
      }, null, "call$4", "call$2", "call$3", "TilemapParser_parseCSV$closure", 4, 4, 464, 269, 269, 231, [], 48, [], 455, [], 456, [], "parseCSV"], TilemapParser_getEmptyData: [function(tileWidth, tileHeight, width, height) {
        var map, layers, layer;
        map = new R.TilemapData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        map.width = 0;
        map.height = 0;
        map.tileWidth = 0;
        map.tileHeight = 0;
        if (tileWidth != null)
          map.tileWidth = tileWidth;
        if (tileHeight != null)
          map.tileHeight = tileHeight;
        if (width != null)
          map.width = width;
        if (height != null)
          map.height = height;
        map.orientation = "orthogonal";
        map.version = 1;
        map.properties = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        map.widthInPixels = 0;
        map.heightInPixels = 0;
        layers = [];
        layer = new R.TilemapLayerData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);
        layer.name = "layer";
        layer.x = 0;
        layer.y = 0;
        layer.width = 0;
        layer.height = 0;
        layer.widthInPixels = 0;
        layer.heightInPixels = 0;
        layer.alpha = 1;
        layer.visible = true;
        layer.properties = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        layer.indexes = [];
        layer.callbacks = [];
        layer.data = [];
        layers.push(layer);
        map.layers = layers;
        map.images = [];
        map.objects = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        map.collision = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        map.tilesets = [];
        map.tiles = [];
        return map;
      }, function() {
        return R.TilemapParser_getEmptyData(null, null, null, null);
      }, null, function(tileWidth) {
        return R.TilemapParser_getEmptyData(tileWidth, null, null, null);
      }, null, function(tileWidth, tileHeight) {
        return R.TilemapParser_getEmptyData(tileWidth, tileHeight, null, null);
      }, null, function(tileWidth, tileHeight, width) {
        return R.TilemapParser_getEmptyData(tileWidth, tileHeight, width, null);
      }, null, "call$4", "call$0", "call$1", "call$2", "call$3", "TilemapParser_getEmptyData$closure", 0, 8, 465, 32, 32, 32, 32, 455, [], 456, [], 10, [], 11, [], "getEmptyData"], TilemapParser_parseTiledJSON: [function(json) {
        var t1, map, t2, t3, t4, t5, layers, i, layer, row, output, len, x, t, images, image, tilesets, set, newSet, objects, collision, v, object, p, y, count, countX, countY;
        t1 = J.getInterceptor$asx(json);
        if (!J.$eq(t1.$index(json, "orientation"), "orthogonal")) {
          window;
          if (typeof console != "undefined")
            console.warn("TilemapParser.parseTiledJSON: Only orthogonal map types are supported in this version of Phaser");
          return;
        }
        map = new R.TilemapData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t2 = t1.$index(json, "width");
        map.width = t2;
        t3 = t1.$index(json, "height");
        map.height = t3;
        t4 = t1.$index(json, "tilewidth");
        map.tileWidth = t4;
        t5 = t1.$index(json, "tileheight");
        map.tileHeight = t5;
        map.orientation = t1.$index(json, "orientation");
        map.format = 1;
        map.version = t1.$index(json, "version");
        map.properties = t1.$index(json, "properties");
        map.widthInPixels = J.$mul$ns(t2, t4);
        map.heightInPixels = J.$mul$ns(t3, t5);
        layers = [];
        i = 0;
        while (true) {
          t2 = J.get$length$asx(t1.$index(json, "layers"));
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          c$0: {
            if (!J.$eq(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "type"), "tilelayer"))
              break c$0;
            layer = new R.TilemapLayerData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);
            layer.name = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name");
            layer.x = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "x");
            layer.y = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "y");
            layer.width = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "width");
            layer.height = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "height");
            layer.widthInPixels = J.$mul$ns(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "width"), t1.$index(json, "tilewidth"));
            layer.heightInPixels = J.$mul$ns(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "height"), t1.$index(json, "tileheight"));
            layer.alpha = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "opacity");
            layer.visible = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "visible");
            layer.properties = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
            layer.indexes = [];
            layer.callbacks = [];
            layer.bodies = [];
            if (J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "properties") != null)
              layer.properties = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "properties");
            row = [];
            output = [];
            len = J.get$length$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "data"));
            if (typeof len !== "number")
              return H.iae(len);
            x = 0;
            t = 0;
            for (; t < len; ++t) {
              if (J.$gt$n(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "data"), t), 0))
                row.push(R.Tile$(layer, J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "data"), t), x, output.length, t1.$index(json, "tilewidth"), t1.$index(json, "tileheight")));
              else
                row.push(R.Tile$(layer, -1, x, output.length, t1.$index(json, "tilewidth"), t1.$index(json, "tileheight")));
              ++x;
              if (x === J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "width")) {
                output.push(row);
                row = [];
                x = 0;
              }
            }
            layer.data = output;
            layers.push(layer);
          }
          ++i;
        }
        map.layers = layers;
        images = [];
        i = 0;
        while (true) {
          t2 = J.get$length$asx(t1.$index(json, "layers"));
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          c$0: {
            if (!J.$eq(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "type"), "imagelayer"))
              break c$0;
            image = new R.TilemapImageData(null, null, null, null, null, null, null);
            image.name = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name");
            image.image = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "image");
            image.x = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "x");
            image.y = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "y");
            image.alpha = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "opacity");
            image.visible = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "visible");
            image.properties = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
            if (J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "properties") != null)
              image.properties = J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "properties");
            images.push(image);
          }
          ++i;
        }
        map.images = images;
        tilesets = [];
        i = 0;
        while (true) {
          t2 = J.get$length$asx(t1.$index(json, "tilesets"));
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          set = J.$index$asx(t1.$index(json, "tilesets"), i);
          t2 = J.getInterceptor$asx(set);
          newSet = R.Tileset$(t2.$index(set, "name"), t2.$index(set, "firstgid"), t2.$index(set, "tilewidth"), t2.$index(set, "tileheight"), t2.$index(set, "margin"), t2.$index(set, "spacing"), t2.$index(set, "properties"));
          if (t2.$index(set, "tileproperties") != null)
            newSet.tileProperties = t2.$index(set, "tileproperties");
          newSet.rows = J.round$0$n(J.$div$n(J.$sub$n(t2.$index(set, "imageheight"), t2.$index(set, "margin")), J.$add$ns(t2.$index(set, "tileheight"), t2.$index(set, "spacing"))));
          t2 = J.round$0$n(J.$div$n(J.$sub$n(t2.$index(set, "imagewidth"), t2.$index(set, "margin")), J.$add$ns(t2.$index(set, "tilewidth"), t2.$index(set, "spacing"))));
          newSet.columns = t2;
          newSet.total = J.$mul$ns(newSet.rows, t2);
          if (J.$mod$n(newSet.rows, 1) !== 0 || J.$mod$n(newSet.columns, 1) !== 0) {
            window;
            if (typeof console != "undefined")
              console.warn("TileSet image dimensions do not match expected dimensions. Tileset width/height must be evenly divisible by Tilemap tile width/height.");
          } else
            tilesets.push(newSet);
          ++i;
        }
        map.tilesets = tilesets;
        objects = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        collision = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t2 = new R.TilemapParser_parseTiledJSON_slice();
        i = 0;
        while (true) {
          t3 = J.get$length$asx(t1.$index(json, "layers"));
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          c$0: {
            if (!J.$eq(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "type"), "objectgroup"))
              break c$0;
            objects.$indexSet(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name"), []);
            collision.$indexSet(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name"), []);
            len = J.get$length$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"));
            if (typeof len !== "number")
              return H.iae(len);
            v = 0;
            for (; v < len; ++v)
              if (J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "gid") != null) {
                object = P.LinkedHashMap_LinkedHashMap$_literal([["gid"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "gid"), ["name"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "name"), ["x"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "x"), ["y"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "y"), ["visible"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "visible"), ["properties"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "properties")], null, null);
                J.add$1$ax(objects.$index(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name")), object);
              } else if (J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polyline") != null) {
                object = P.LinkedHashMap_LinkedHashMap$_literal([["name"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "name"), ["x"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "x"), ["y"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "y"), ["width"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "width"), ["height"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "height"), ["visible"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "visible"), ["properties"], J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "properties")], null, null);
                object.$indexSet(0, "polyline", []);
                p = 0;
                while (true) {
                  t3 = J.get$length$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polyline"));
                  if (typeof t3 !== "number")
                    return H.iae(t3);
                  if (!(p < t3))
                    break;
                  J.add$1$ax(object.$index(0, "polyline"), [J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polyline"), p), "x"), J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polyline"), p), "y")]);
                  ++p;
                }
                J.add$1$ax(collision.$index(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name")), object);
              } else if (J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polygon") != null) {
                object = t2.call$2(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), ["name", "x", "y", "visible", "properties"]);
                t3 = J.getInterceptor$ax(object);
                t3.$indexSet(object, "polygon", []);
                p = 0;
                while (true) {
                  t4 = J.get$length$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polygon"));
                  if (typeof t4 !== "number")
                    return H.iae(t4);
                  if (!(p < t4))
                    break;
                  J.add$1$ax(t3.$index(object, "polygon"), [J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polygon"), p), "x"), J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "polygon"), p), "y")]);
                  ++p;
                }
                J.add$1$ax(objects.$index(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name")), object);
              } else if (J.$index$asx(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), "ellipse") === true) {
                object = t2.call$2(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), ["name", "ellipse", "x", "y", "width", "height", "visible", "properties"]);
                J.add$1$ax(objects.$index(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name")), object);
              } else {
                object = t2.call$2(J.$index$asx(J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "objects"), v), ["name", "x", "y", "width", "height", "visible", "properties"]);
                J.$indexSet$ax(object, "rectangle", true);
                J.add$1$ax(objects.$index(0, J.$index$asx(J.$index$asx(t1.$index(json, "layers"), i), "name")), object);
              }
          }
          ++i;
        }
        map.objects = objects;
        map.collision = collision;
        map.tiles = H.setRuntimeTypeInfo([], [[P.List, P.$int]]);
        i = 0;
        while (true) {
          t1 = J.get$length$asx(map.tilesets);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          set = J.$index$asx(map.tilesets, i);
          x = set.get$tileMargin();
          y = set.get$tileMargin();
          for (t = set.get$firstgid(), t1 = J.getInterceptor$x(set), count = 0, countX = 0, countY = 0; t2 = J.getInterceptor$n(t), t2.$lt(t, J.$add$ns(set.get$firstgid(), t1.get$total(set))); t = t2.$add(t, 1)) {
            t3 = t2.$ge(t, J.get$length$asx(map.tiles));
            t4 = map.tiles;
            if (t3)
              J.add$1$ax(t4, [x, y, i]);
            else
              J.$indexSet$ax(t4, t, [x, y, i]);
            x = J.$add$ns(x, J.$add$ns(set.get$tileWidth(), set.get$tileSpacing()));
            ++count;
            if (count === t1.get$total(set))
              break;
            ++countX;
            if (countX === t1.get$columns(set)) {
              x = set.get$tileMargin();
              y = J.$add$ns(y, J.$add$ns(set.get$tileHeight(), set.get$tileSpacing()));
              ++countY;
              if (countY === t1.get$rows(set))
                break;
              countX = 0;
            }
          }
          ++i;
        }
        return map;
      }, "call$1", "TilemapParser_parseTiledJSON$closure", 2, 0, 466, 238, [], "parseTiledJSON"]}
  },
  "+TilemapParser": [632],
  TilemapParser_parseTiledJSON_slice: {
    "^": "Closure:1597;",
    call$2: [function(obj, fields) {
      var sliced, t1, t2, k;
      sliced = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      for (t1 = J.get$iterator$ax(fields), t2 = J.getInterceptor$asx(obj); t1.moveNext$0();) {
        k = t1.get$current();
        sliced.$indexSet(0, k, t2.$index(obj, k));
      }
      return sliced;
    }, "call$2", null, 4, 0, 1597, 617, [], 1598, [], "call"],
    $isFunction: true
  },
  Tileset: {
    "^": "Object;name*-639,firstgid@-599,tileWidth@-601,tileHeight@-601,tileMargin@-601,tileSpacing@-601,properties@-754,tileProperties@-754,image@-32,rows*-601,columns*-601,total*-601,drawCoords@-1599",
    image$2: function(arg0, arg1) {
      return this.image.call$2(arg0, arg1);
    },
    image$4: function(arg0, arg1, arg2, arg3) {
      return this.image.call$4(arg0, arg1, arg2, arg3);
    },
    image$3: function(arg0, arg1, arg2) {
      return this.image.call$3(arg0, arg1, arg2);
    },
    image$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.image.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    draw$4: [function(context, x, y, index) {
      var t1, t2, t3, t4, t5;
      if (this.image == null || J.$index$asx(this.drawCoords, J.toInt$0$n(index)) == null)
        return;
      t1 = this.image;
      t2 = J.$index$asx(J.$index$asx(this.drawCoords, index), 0);
      t3 = J.$index$asx(J.$index$asx(this.drawCoords, index), 1);
      t4 = this.tileWidth;
      t5 = this.tileHeight;
      J.drawImageScaledFromSource$9$x(context, t1, t2, t3, t4, t5, x, y, t4, t5);
    }, "call$4", "get$draw", 8, 0, 1600, 104, [], 6, [], 7, [], 243, [], "draw"],
    setImage$1: [function(image) {
      var t1, tx, i, ty, y, x;
      this.image = image;
      t1 = J.getInterceptor$x(image);
      this.rows = J.round$0$n(J.$div$n(J.$sub$n(t1.get$height(image), this.tileMargin), J.$add$ns(this.tileHeight, this.tileSpacing)));
      t1 = J.round$0$n(J.$div$n(J.$sub$n(t1.get$width(image), this.tileMargin), J.$add$ns(this.tileWidth, this.tileSpacing)));
      this.columns = t1;
      this.total = J.$mul$ns(this.rows, t1);
      t1 = J.$add$ns(J.$mul$ns(this.rows, this.columns), 1);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = Array(t1);
      t1.fixed$length = init;
      this.drawCoords = H.setRuntimeTypeInfo(t1, [P.List]);
      tx = this.tileMargin;
      i = this.firstgid;
      ty = tx;
      y = 0;
      while (true) {
        t1 = this.rows;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(y < t1))
          break;
        x = 0;
        while (true) {
          t1 = this.columns;
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(x < t1))
            break;
          J.$indexSet$ax(this.drawCoords, i, [tx, ty]);
          tx = J.$add$ns(tx, J.$add$ns(this.tileWidth, this.tileSpacing));
          i = J.$add$ns(i, 1);
          ++x;
        }
        tx = this.tileMargin;
        ty = J.$add$ns(ty, J.$add$ns(this.tileHeight, this.tileSpacing));
        ++y;
      }
    }, "call$1", "get$setImage", 2, 0, 63, 1601, [], "setImage"],
    setSpacing$2: [function(margin, spacing) {
      this.tileMargin = margin;
      this.tileSpacing = spacing;
      this.setImage$1(this.image);
    }, function() {
      return this.setSpacing$2(0, 0);
    }, "setSpacing$0", function(margin) {
      return this.setSpacing$2(margin, 0);
    }, "setSpacing$1", "call$2", "call$0", "call$1", "get$setSpacing", 0, 4, 16, 5, 5, 235, [], 236, [], "setSpacing"],
    Tileset$7: function($name, firstgid, width, height, margin, spacing, properties) {
      if (width == null || J.$le$n(width, 0))
        width = 32;
      if (height == null || J.$le$n(height, 0))
        height = 32;
      if (margin == null)
        margin = 0;
      if (spacing == null)
        spacing = 0;
      this.name = $name;
      this.firstgid = firstgid;
      this.tileWidth = width;
      this.tileHeight = height;
      this.tileMargin = margin;
      this.tileSpacing = spacing;
      this.properties = properties;
      this.image = null;
      this.rows = 0;
      this.columns = 0;
      this.total = 0;
      this.drawCoords = [];
    },
    static: {Tileset$: [function($name, firstgid, width, height, margin, spacing, properties) {
        var t1 = new R.Tileset(null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Tileset$7($name, firstgid, width, height, margin, spacing, properties);
        return t1;
      }, null, null, 4, 10, 467, 269, 269, 5, 5, 32, 44, [], 468, [], 10, [], 11, [], 235, [], 236, [], 469, [], "new Tileset"]}
  },
  "+Tileset": [632],
  Time: {
    "^": "Object;game@-598,time@-601,now@-601,elapsed@-601,pausedTime@-601,advancedTiming@-602,fps@-601,fpsMin@-601,fpsMax@-601,msMin@-601,msMax@-601,physicsElapsed@-601,deltaCap@-629,timeCap@-599,frames@-599,pauseDuration@-629,timeToCall@-629,lastTime@-629,events@-1602,_started@-629,_timeLastSecond@-629,_pauseStarted@-629,_justResumed@-602,_timers@-1603,_len@-599,_i@-599",
    boot$0: [function() {
      var t1 = Date.now();
      new P.DateTime(t1, false).DateTime$_now$0();
      this._started = t1;
      J.start$0$x(this.events);
    }, "call$0", "get$boot", 0, 0, 13, "boot"],
    add$1: [function(_, timer) {
      J.add$1$ax(this._timers, timer);
      return timer;
    }, "call$1", "get$add", 2, 0, 1604, 472, [], "add"],
    create$1: [function(autoDestroy) {
      var t1, t2, t3, timer;
      t1 = this.game;
      t2 = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
      t3 = Date.now();
      new P.DateTime(t3, false).DateTime$_now$0();
      timer = new R.Timer(t1, true, false, false, 0, [], t2, 0, 1000, false, false, 0, 0, 0, t3, 0, 0, 0, 0, 0);
      J.add$1$ax(this._timers, timer);
      return timer;
    }, function() {
      return this.create$1(true);
    }, "create$0", "call$1", "call$0", "get$create", 0, 2, 1605, 39, 470, [], "create"],
    removeAll$0: [function() {
      var i, t1;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this._timers);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$index$asx(this._timers, i).destroy$0();
        ++i;
      }
      this._timers = [];
      this.events.removeAll$0();
    }, "call$0", "get$removeAll", 0, 0, 13, "removeAll"],
    update$1: [function(time) {
      var t1, t2;
      this.now = time;
      t1 = J.getInterceptor$n(time);
      t2 = t1.$sub(time, this.lastTime);
      if (typeof t2 !== "number")
        return H.iae(t2);
      this.timeToCall = C.JSNumber_methods.toDouble$0(P.max(0, 16 - t2));
      t2 = J.$sub$n(this.now, this.time);
      this.elapsed = t2;
      if (J.$gt$n(t2, this.timeCap))
        this.elapsed = 0.016666666666666666;
      t2 = J.$div$n(this.elapsed, 1000);
      this.physicsElapsed = t2;
      if (J.$eq(t2, 0))
        this.physicsElapsed = 0.016666666666666666;
      if (J.$gt$n(this.deltaCap, 0) && J.$gt$n(this.physicsElapsed, this.deltaCap))
        this.physicsElapsed = this.deltaCap;
      if (this.advancedTiming === true) {
        this.msMin = P.min(this.msMin, this.elapsed);
        this.msMax = P.max(this.msMax, this.elapsed);
        this.frames = J.$add$ns(this.frames, 1);
        if (J.$gt$n(this.now, J.$add$ns(this._timeLastSecond, 1000))) {
          t2 = J.round$0$n(J.$div$n(J.$mul$ns(this.frames, 1000), J.$sub$n(this.now, this._timeLastSecond)));
          this.fps = t2;
          this.fpsMin = P.min(this.fpsMin, t2);
          this.fpsMax = P.max(this.fpsMax, this.fps);
          this._timeLastSecond = this.now;
          this.frames = 0;
        }
      }
      this.time = this.now;
      this.lastTime = t1.$add(time, this.timeToCall);
      if (J.get$paused$x(this.game) !== true) {
        this.events.update$1(this.now);
        this._i = 0;
        this._len = J.get$length$asx(this._timers);
        for (; J.$lt$n(this._i, this._len);) {
          t1 = J.$index$asx(this._timers, this._i).update$1(this.now);
          t2 = this._i;
          if (t1 === true)
            this._i = J.$add$ns(t2, 1);
          else {
            J.removeAt$1$ax(this._timers, t2);
            this._len = J.$sub$n(this._len, 1);
          }
        }
      }
    }, "call$1", "get$update", 2, 0, 1016, 568, [], "update"],
    gamePaused$0: [function() {
      var i, t1, i0;
      this._pauseStarted = this.now;
      J.pause$0$x(this.events);
      i = J.get$length$asx(this._timers);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this._timers, i0)._pause$0();
    }, "call$0", "get$gamePaused", 0, 0, 13, "gamePaused"],
    gameResumed$0: [function() {
      var t1, t2, i, i0;
      t1 = Date.now();
      new P.DateTime(t1, false).DateTime$_now$0();
      this.now = t1;
      this.time = t1;
      t2 = this._pauseStarted;
      if (typeof t2 !== "number")
        return H.iae(t2);
      this.pauseDuration = t1 - t2;
      this.events.resume$0();
      i = J.get$length$asx(this._timers);
      for (; t1 = J.getInterceptor$n(i), i0 = t1.$sub(i, 1), t1.$gt(i, 0); i = i0)
        J.$index$asx(this._timers, i0)._resume$0();
    }, "call$0", "get$gameResumed", 0, 0, 13, "gameResumed"],
    totalElapsedSeconds$0: [function() {
      return J.$mul$ns(J.$sub$n(this.now, this._started), 0.001);
    }, "call$0", "get$totalElapsedSeconds", 0, 0, 13, "totalElapsedSeconds"],
    elapsedSince$1: [function(since) {
      return J.$sub$n(this.now, since);
    }, "call$1", "get$elapsedSince", 2, 0, 63, 1606, [], "elapsedSince"],
    elapsedSecondsSince$1: [function(since) {
      return J.$mul$ns(J.$sub$n(this.now, since), 0.001);
    }, "call$1", "get$elapsedSecondsSince", 2, 0, 63, 1606, [], "elapsedSecondsSince"],
    reset$0: [function(_) {
      this._started = this.now;
      this.removeAll$0();
    }, "call$0", "get$reset", 0, 0, 13, "reset"],
    static: {Time$: [function(game) {
        var t1, t2, t3;
        t1 = new R.Time(game, 0, 0, 0, 0, false, 0, 1000, 0, 1000, 0, 0, 0, 1000, 0, 0, 0, 0, null, 0, 0, 0, false, [], 0, 0);
        t2 = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
        t3 = Date.now();
        new P.DateTime(t3, false).DateTime$_now$0();
        t1.events = new R.Timer(game, true, false, false, 0, [], t2, 0, 1000, false, false, 0, 0, 0, t3, 0, 0, 0, 0, 0);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new Time"]}
  },
  "+Time": [632],
  Timer: {
    "^": "Object;game@-598,autoDestroy@-602,running@-602,expired@-602,elapsed@-629,events@-1607,onComplete*-1608,nextTick@-629,timeCap@-599,paused*-602,_codePaused@-602,_started@-629,_pauseStarted@-629,_pauseTotal@-629,_now@-629,_len@-599,_marked@-599,_i@-599,_diff@-599,_newTick@-629",
    paused$0: function($receiver) {
      return this.paused.call$0();
    },
    get$next: [function() {
      return this.nextTick;
    }, null, null, 1, 0, 1337, "next"],
    next$0: function() {
      return this.get$next().call$0();
    },
    next$1: function(arg0) {
      return this.get$next().call$1(arg0);
    },
    get$duration: [function(_) {
      if (this.running === true && J.$gt$n(this.nextTick, this._now))
        return J.$sub$n(this.nextTick, this._now);
      else
        return 0;
    }, null, null, 1, 0, 1337, "duration"],
    get$length: [function(_) {
      return J.get$length$asx(this.events);
    }, null, null, 1, 0, 367, "length"],
    get$ms: [function() {
      if (this.running === true)
        return J.$sub$n(J.$sub$n(this._now, this._started), this._pauseTotal);
      else
        return 0;
    }, null, null, 1, 0, 1337, "ms"],
    get$second: [function() {
      if (this.running === true)
        return J.$mul$ns(this.get$ms(), 0.001);
      else
        return 0;
    }, null, null, 1, 0, 604, "second"],
    create$5: [function(delay, loop, repeatCount, callback, args) {
      var t1, tick, $event;
      t1 = J.getInterceptor$ns(delay);
      tick = J.$eq(this._now, 0) ? t1.$add(delay, this.game.get$time().get$now()) : t1.$add(delay, this._now);
      $event = new R.TimerEvent(null, null, null, null, null, null, null, null);
      $event.TimerEvent$7(this, delay, tick, repeatCount, loop, callback, args);
      J.add$1$ax(this.events, $event);
      this.order$0(0);
      this.expired = false;
      return $event;
    }, "call$5", "get$create", 10, 0, 1609, 473, [], 219, [], 475, [], 272, [], 338, [], "create"],
    add$3: [function(_, delay, callback, args) {
      return this.create$5(delay, false, 0, callback, args);
    }, function($receiver, delay, callback) {
      return this.add$3($receiver, delay, callback, null);
    }, "add$2", "call$3", "call$2", "get$add", 4, 2, 1610, 32, 473, [], 272, [], 338, [], "add"],
    repeat$4: [function(_, delay, repeatCount, callback, args) {
      return this.create$5(delay, false, repeatCount, callback, args);
    }, "call$4", "get$repeat", 8, 0, 1611, 473, [], 475, [], 272, [], 338, [], "repeat"],
    loop$3: [function(_, delay, callback, args) {
      return this.create$5(delay, true, 0, callback, args);
    }, "call$3", "get$loop", 6, 0, 1612, 473, [], 272, [], 338, [], "loop"],
    start$1: [function(_, delay) {
      var i, t1;
      if (this.running === true)
        return;
      this._started = J.$add$ns(this.game.get$time().get$now(), delay);
      this.running = true;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.events);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        J.$index$asx(this.events, i).set$tick(J.$add$ns(J.$index$asx(this.events, i).get$delay(), this._started));
        ++i;
      }
    }, function($receiver) {
      return this.start$1($receiver, 0);
    }, "start$0", "call$1", "call$0", "get$start", 0, 2, 948, 5, 473, [], "start"],
    stop$1: [function(_, clearEvents) {
      this.running = false;
      if (clearEvents === true)
        J.set$length$asx(this.events, 0);
    }, function($receiver) {
      return this.stop$1($receiver, true);
    }, "stop$0", "call$1", "call$0", "get$stop", 0, 2, 932, 39, 1613, [], "stop"],
    remove$1: [function(_, $event) {
      var i, t1;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.events);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$eq(J.$index$asx(this.events, i), $event)) {
          J.$index$asx(this.events, i).set$pendingDelete(true);
          return true;
        }
        ++i;
      }
      return false;
    }, "call$1", "get$remove", 2, 0, 63, 815, [], "remove"],
    order$0: [function(_) {
      if (J.$gt$n(J.get$length$asx(this.events), 0)) {
        J.sort$1$ax(this.events, this.get$sortHandler());
        this.nextTick = J.$index$asx(this.events, 0).get$tick();
      }
    }, "call$0", "get$order", 0, 0, 13, "order"],
    sortHandler$2: [function(a, b) {
      if (J.$lt$n(a.get$tick(), b.get$tick()))
        return -1;
      else if (J.$gt$n(a.get$tick(), b.get$tick()))
        return 1;
      return 0;
    }, "call$2", "get$sortHandler", 4, 0, 935, 304, [], 305, [], "sortHandler"],
    clearPendingEvents$0: [function() {
      var t1, t2;
      this._i = J.get$length$asx(this.events);
      for (; t1 = this._i, t2 = J.getInterceptor$n(t1), this._i = t2.$sub(t1, 1), t2.$gt(t1, 0);)
        if (J.$index$asx(this.events, this._i).get$pendingDelete() === true)
          J.removeAt$1$ax(this.events, this._i);
      this._len = J.get$length$asx(this.events);
      this._i = 0;
    }, "call$0", "get$clearPendingEvents", 0, 0, 13, "clearPendingEvents"],
    callback$1: [function(events) {
      if (events.get$args() == null)
        events.callback$0();
      else
        events.callback$1(J.$index$asx(this.events, this._i).get$args());
    }, "call$1", "get$callback", 2, 0, 1614, 1615, [], "callback"],
    update$1: [function(time) {
      var t1, t2;
      if (this.paused === true)
        return true;
      t1 = J.getInterceptor$n(time);
      t2 = t1.$sub(time, this._now);
      this.elapsed = t2;
      this._now = time;
      if (J.$gt$n(t2, this.timeCap))
        this.adjustEvents$1(t1.$sub(time, this.elapsed));
      this._marked = 0;
      this.clearPendingEvents$0();
      if (this.running === true && J.$ge$n(this._now, this.nextTick) && J.$gt$n(this._len, 0)) {
        while (true) {
          if (!(J.$lt$n(this._i, this._len) && this.running === true))
            break;
          if (J.$ge$n(this._now, J.$index$asx(this.events, this._i).get$tick())) {
            t1 = J.$sub$n(J.$add$ns(this._now, J.$index$asx(this.events, this._i).get$delay()), J.$sub$n(this._now, J.$index$asx(this.events, this._i).get$tick()));
            this._newTick = t1;
            if (J.$lt$n(t1, 0))
              this._newTick = J.$add$ns(this._now, J.$index$asx(this.events, this._i).get$delay());
            if (J.$eq(J.get$loop$x(J.$index$asx(this.events, this._i)), true)) {
              J.$index$asx(this.events, this._i).set$tick(this._newTick);
              t1 = J.$index$asx(this.events, this._i);
              if (t1.get$args() == null)
                t1.callback$0();
              else
                t1.callback$1(J.$index$asx(this.events, this._i).get$args());
            } else if (J.$gt$n(J.$index$asx(this.events, this._i).get$repeatCount(), 0)) {
              t1 = J.$index$asx(this.events, this._i);
              t1.set$repeatCount(J.$sub$n(t1.get$repeatCount(), 1));
              J.$index$asx(this.events, this._i).set$tick(this._newTick);
              t1 = J.$index$asx(this.events, this._i);
              if (t1.get$args() == null)
                t1.callback$0();
              else
                t1.callback$1(J.$index$asx(this.events, this._i).get$args());
            } else {
              this._marked = J.$add$ns(this._marked, 1);
              J.$index$asx(this.events, this._i).set$pendingDelete(true);
              t1 = J.$index$asx(this.events, this._i);
              if (t1.get$args() == null)
                t1.callback$0();
              else
                t1.callback$1(J.$index$asx(this.events, this._i).get$args());
            }
            this._i = J.$add$ns(this._i, 1);
          } else
            break;
        }
        if (J.$gt$n(J.get$length$asx(this.events), this._marked))
          this.order$0(0);
        else {
          this.expired = true;
          this.onComplete.dispatch$1(this);
        }
      }
      if (this.expired === true && this.autoDestroy === true)
        return false;
      else
        return true;
    }, "call$1", "get$update", 2, 0, 63, 568, [], "update"],
    pause$0: [function(_) {
      if (this.running !== true)
        return;
      this._codePaused = true;
      if (this.paused === true)
        return;
      this._pauseStarted = this.game.get$time().get$now();
      this.paused = true;
    }, "call$0", "get$pause", 0, 0, 13, "pause"],
    _pause$0: [function() {
      if (this.paused === true || this.running !== true)
        return;
      this._pauseStarted = this.game.get$time().get$now();
      this.paused = true;
    }, "call$0", "get$_pause", 0, 0, 13, "_pause"],
    adjustEvents$1: [function(baseTime) {
      var i, t1, t, d, t2;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.events);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$index$asx(this.events, i).get$pendingDelete() !== true) {
          t = J.$sub$n(J.$index$asx(this.events, i).get$tick(), baseTime);
          if (J.$lt$n(t, 0))
            t = 0;
          J.$index$asx(this.events, i).set$tick(J.$add$ns(this._now, t));
        }
        ++i;
      }
      d = J.$sub$n(this.nextTick, baseTime);
      t1 = J.$lt$n(d, 0);
      t2 = this._now;
      if (t1)
        this.nextTick = t2;
      else
        this.nextTick = J.$add$ns(t2, d);
    }, "call$1", "get$adjustEvents", 2, 0, 63, 1616, [], "adjustEvents"],
    resume$0: [function() {
      if (this.paused !== true)
        return;
      var now = this.game.get$time().get$now();
      this._pauseTotal = J.$add$ns(this._pauseTotal, J.$sub$n(now, this._now));
      this._now = now;
      this.adjustEvents$1(this._pauseStarted);
      this.paused = false;
      this._codePaused = false;
    }, "call$0", "get$resume", 0, 0, 13, "resume"],
    _resume$0: [function() {
      if (this._codePaused === true)
        return;
      else
        this.resume$0();
    }, "call$0", "get$_resume", 0, 0, 13, "_resume"],
    removeAll$0: [function() {
      this.onComplete.removeAll$0();
      J.set$length$asx(this.events, 0);
      this._len = 0;
      this._i = 0;
    }, "call$0", "get$removeAll", 0, 0, 13, "removeAll"],
    destroy$0: [function() {
      this.onComplete.removeAll$0();
      this.running = false;
      this.events = [];
      this._len = 0;
      this._i = 0;
    }, "call$0", "get$destroy", 0, 0, 13, "destroy"],
    static: {"^": "Timer_MINUTE<-629,Timer_SECOND<-629,Timer_HALF<-629,Timer_QUARTER<-629", Timer$: [function(game, autoDestroy) {
        var t1, t2;
        t1 = H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]);
        t2 = Date.now();
        new P.DateTime(t2, false).DateTime$_now$0();
        return new R.Timer(game, true, false, false, 0, [], t1, 0, 1000, false, false, 0, 0, 0, t2, 0, 0, 0, 0, 0);
      }, null, null, 2, 2, 449, 39, 214, [], 470, [], "new Timer"]}
  },
  "+Timer": [632],
  TimerEvent: {
    "^": "Object;timer@-1602,delay@-601,tick@-601,repeatCount@-599,loop*-602,callback@-0,args@-720,pendingDelete@-602",
    timer$4: function(arg0, arg1, arg2, arg3) {
      return this.timer.call$4(arg0, arg1, arg2, arg3);
    },
    delay$1: function(arg0) {
      return this.delay.call$1(arg0);
    },
    loop$0: function($receiver) {
      return this.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return this.loop.call$3(arg0, arg1, arg2);
    },
    callback$0: function() {
      return this.callback.call$0();
    },
    callback$3: function(arg0, arg1, arg2) {
      return this.callback.call$3(arg0, arg1, arg2);
    },
    callback$1: function(arg0) {
      return this.callback.call$1(arg0);
    },
    TimerEvent$7: function(timer, delay, tick, repeatCount, loop, callback, args) {
      this.timer = timer;
      this.delay = delay;
      this.tick = tick;
      this.repeatCount = J.$sub$n(repeatCount, 1);
      this.loop = loop;
      this.callback = callback;
      this.args = args;
      this.pendingDelete = false;
    },
    static: {TimerEvent$: [function(timer, delay, tick, repeatCount, loop, callback, args) {
        var t1 = new R.TimerEvent(null, null, null, null, null, null, null, null);
        t1.TimerEvent$7(timer, delay, tick, repeatCount, loop, callback, args);
        return t1;
      }, null, null, 14, 0, 471, 472, [], 473, [], 474, [], 475, [], 219, [], 272, [], 338, [], "new TimerEvent"]}
  },
  "+TimerEvent": [632],
  Linears: {
    "^": "Object;",
    get$None: [function() {
      return $.get$Linear_INOUT().compute;
    }, null, null, 1, 0, 1617, "None"],
    static: {Linears$: [function() {
        return new R.Linears();
      }, null, null, 0, 0, 476, "new Linears"]}
  },
  "+Linears": [632],
  Quads: {
    "^": "Object;",
    get$In: [function() {
      return $.get$Quad_IN().compute;
    }, null, null, 1, 0, 1617, "In"],
    get$InOut: [function() {
      return $.get$Quad_INOUT().compute;
    }, null, null, 1, 0, 1617, "InOut"],
    get$Out: [function() {
      return $.get$Quad_OUT().compute;
    }, null, null, 1, 0, 1617, "Out"],
    static: {Quads$: [function() {
        return new R.Quads();
      }, null, null, 0, 0, 477, "new Quads"]}
  },
  "+Quads": [632],
  Cubics: {
    "^": "Object;",
    get$In: [function() {
      return $.get$Quad_IN().compute;
    }, null, null, 1, 0, 1617, "In"],
    get$InOut: [function() {
      return $.get$Quad_INOUT().compute;
    }, null, null, 1, 0, 1617, "InOut"],
    get$Out: [function() {
      return $.get$Quad_OUT().compute;
    }, null, null, 1, 0, 1617, "Out"],
    static: {Cubics$: [function() {
        return new R.Cubics();
      }, null, null, 0, 0, 478, "new Cubics"]}
  },
  "+Cubics": [632],
  Quarts: {
    "^": "Object;",
    get$In: [function() {
      return $.get$Quart_IN().compute;
    }, null, null, 1, 0, 1617, "In"],
    get$InOut: [function() {
      return $.get$Quart_INOUT().compute;
    }, null, null, 1, 0, 1617, "InOut"],
    get$Out: [function() {
      return $.get$Quart_OUT().compute;
    }, null, null, 1, 0, 1617, "Out"],
    static: {Quarts$: [function() {
        return new R.Quarts();
      }, null, null, 0, 0, 479, "new Quarts"]}
  },
  "+Quarts": [632],
  Circs: {
    "^": "Object;",
    get$In: [function() {
      return $.get$Circ_IN().compute;
    }, null, null, 1, 0, 1617, "In"],
    get$InOut: [function() {
      return $.get$Circ_INOUT().compute;
    }, null, null, 1, 0, 1617, "InOut"],
    get$Out: [function() {
      return $.get$Circ_OUT().compute;
    }, null, null, 1, 0, 1617, "Out"],
    static: {Circs$: [function() {
        return new R.Circs();
      }, null, null, 0, 0, 480, "new Circs"]}
  },
  "+Circs": [632],
  Sines: {
    "^": "Object;",
    get$In: [function() {
      return $.get$Sine_IN().compute;
    }, null, null, 1, 0, 1617, "In"],
    get$InOut: [function() {
      return $.get$Sine_INOUT().compute;
    }, null, null, 1, 0, 1617, "InOut"],
    get$Out: [function() {
      return $.get$Sine_OUT().compute;
    }, null, null, 1, 0, 1617, "Out"],
    static: {Sines$: [function() {
        return new R.Sines();
      }, null, null, 0, 0, 481, "new Sines"]}
  },
  "+Sines": [632],
  Expos: {
    "^": "Object;",
    get$In: [function() {
      return $.get$Expo_IN().compute;
    }, null, null, 1, 0, 1617, "In"],
    get$InOut: [function() {
      return $.get$Expo_INOUT().compute;
    }, null, null, 1, 0, 1617, "InOut"],
    get$Out: [function() {
      return $.get$Expo_OUT().compute;
    }, null, null, 1, 0, 1617, "Out"],
    static: {Expos$: [function() {
        return new R.Expos();
      }, null, null, 0, 0, 482, "new Expos"]}
  },
  "+Expos": [632],
  Backs: {
    "^": "Object;",
    get$In: [function() {
      return $.get$Back_IN().compute;
    }, null, null, 1, 0, 1617, "In"],
    get$InOut: [function() {
      return $.get$Back_INOUT().compute;
    }, null, null, 1, 0, 1617, "InOut"],
    get$Out: [function() {
      return $.get$Back_OUT().compute;
    }, null, null, 1, 0, 1617, "Out"],
    static: {Backs$: [function() {
        return new R.Backs();
      }, null, null, 0, 0, 483, "new Backs"]}
  },
  "+Backs": [632],
  Bounces: {
    "^": "Object;",
    get$In: [function() {
      return $.get$Bounce_IN().compute;
    }, null, null, 1, 0, 1617, "In"],
    get$InOut: [function() {
      return $.get$Bounce_INOUT().compute;
    }, null, null, 1, 0, 1617, "InOut"],
    get$Out: [function() {
      return $.get$Bounce_OUT().compute;
    }, null, null, 1, 0, 1617, "Out"],
    static: {Bounces$: [function() {
        return new R.Bounces();
      }, null, null, 0, 0, 484, "new Bounces"]}
  },
  "+Bounces": [632],
  Elastics: {
    "^": "Object;",
    get$In: [function() {
      return $.get$Elastic_IN().compute;
    }, null, null, 1, 0, 1617, "In"],
    get$InOut: [function() {
      return $.get$Elastic_INOUT().compute;
    }, null, null, 1, 0, 1617, "InOut"],
    get$Out: [function() {
      return $.get$Elastic_OUT().compute;
    }, null, null, 1, 0, 1617, "Out"],
    static: {Elastics$: [function() {
        return new R.Elastics();
      }, null, null, 0, 0, 485, "new Elastics"]}
  },
  "+Elastics": [632],
  Quints: {
    "^": "Object;",
    get$In: [function() {
      return $.get$Quint_IN().compute;
    }, null, null, 1, 0, 1617, "In"],
    get$InOut: [function() {
      return $.get$Quint_INOUT().compute;
    }, null, null, 1, 0, 1617, "InOut"],
    get$Out: [function() {
      return $.get$Quint_OUT().compute;
    }, null, null, 1, 0, 1617, "Out"],
    static: {Quints$: [function() {
        return new R.Quints();
      }, null, null, 0, 0, 486, "new Quints"]}
  },
  "+Quints": [632],
  Easing: {
    "^": "Object;",
    static: {"^": "Easing_Linear<-1618,Easing_Quadratic<-1619,Easing_Cubic<-1620,Easing_Quartic<-1621,Easing_Circ<-1622,Easing_Quintic<-1623,Easing_Sinusoidal<-1624,Easing_Exponential<-1625,Easing_Back<-1626,Easing_Bounce<-1627,Easing_Elastic<-1628", Easing$: [function() {
        return new R.Easing();
      }, null, null, 0, 0, 487, "new Easing"]}
  },
  "+Easing": [632],
  Tween: {
    "^": "Object;_object<-32,game<-598,_manager@-1009,_valuesStart@-754,_valuesEnd@-754,_valuesStartRepeat@-754,_Phaser$_duration@-629,_repeat@-599,_yoyo@-602,_reversed@-602,_delayTime@-601,_startTime@-629,_easingFunction@-1629,_interpolationFunction@-0,_chainedTweens@-1630,_onStartCallbackFired@-602,_onUpdateCallback@-0,_onUpdateCallbackContext@-32,_paused@-602,_pausedTime@-629,_codePaused@-602,pendingDelete@-602,onStart@-1137,onLoop@-1137,onComplete*-1137,isRunning@-602,_Phaser$_parent@-1631,_lastChild@-1631",
    _easingFunction$1: function(arg0) {
      return this._easingFunction.call$1(arg0);
    },
    _interpolationFunction$2: function(arg0, arg1) {
      return this._interpolationFunction.call$2(arg0, arg1);
    },
    to$7: [function(properties, duration, ease, autoStart, delay, repeat, yoyo) {
      var $self;
      if (yoyo === true && J.$eq(repeat, 0))
        repeat = 1;
      if (this._Phaser$_parent != null) {
        $self = this._manager.create$1(this._object);
        this._lastChild.chain$1($self);
        this._lastChild = $self;
      } else {
        this._Phaser$_parent = this;
        this._lastChild = this;
        $self = this;
      }
      $self.set$_repeat(repeat);
      $self.set$_Phaser$_duration(J.toDouble$0$n(duration));
      $self.set$_valuesEnd(properties);
      if (ease != null)
        $self.set$_easingFunction(ease);
      if (J.$gt$n(delay, 0))
        $self.set$_delayTime(delay);
      $self.set$_yoyo(yoyo);
      if (autoStart === true)
        return this.start$0(0);
      else
        return this;
    }, function(properties, duration, ease) {
      return this.to$7(properties, duration, ease, false, 0, 0, false);
    }, "to$3", function(properties) {
      return this.to$7(properties, 1000, null, false, 0, 0, false);
    }, "to$1", function(properties, duration) {
      return this.to$7(properties, duration, null, false, 0, 0, false);
    }, "to$2", function(properties, duration, ease, autoStart) {
      return this.to$7(properties, duration, ease, autoStart, 0, 0, false);
    }, "to$4", function(properties, duration, ease, autoStart, delay, repeat) {
      return this.to$7(properties, duration, ease, autoStart, delay, repeat, false);
    }, "to$6", function(properties, duration, ease, autoStart, delay) {
      return this.to$7(properties, duration, ease, autoStart, delay, 0, false);
    }, "to$5", "call$7", "call$3", "call$1", "call$2", "call$4", "call$6", "call$5", "get$to", 2, 12, 1632, 1498, 32, 95, 5, 5, 95, 469, [], 55, [], 1439, [], 1064, [], 473, [], 1633, [], 1440, [], "to"],
    from$7: [function(properties, duration, ease, autoStart, delay, repeat, yoyo) {
      var _cache, instance, t1, t2, prop, t3, t4;
      _cache = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      instance = H.reflect(this._object);
      for (t1 = J.getInterceptor$x(properties), t2 = J.get$iterator$ax(t1.get$keys(properties)); t2.moveNext$0();) {
        prop = t2.get$current();
        t3 = H.Symbol_validatePublicSymbol(prop);
        _cache.$indexSet(0, prop, instance.getField$1(new H.Symbol(H.Symbol_validatePublicSymbol(prop))).get$reflectee());
        t4 = t1.$index(properties, prop);
        instance._invoke$4(new H.Symbol(t3), 2, [t4], C.Map_empty);
        H.reflect(t4);
      }
      return this.to$7(_cache, duration, ease, autoStart, delay, repeat, yoyo);
    }, function(properties) {
      return this.from$7(properties, 1000, null, false, 0, 0, false);
    }, "from$1", function(properties, duration) {
      return this.from$7(properties, duration, null, false, 0, 0, false);
    }, "from$2", function(properties, duration, ease) {
      return this.from$7(properties, duration, ease, false, 0, 0, false);
    }, "from$3", function(properties, duration, ease, autoStart) {
      return this.from$7(properties, duration, ease, autoStart, 0, 0, false);
    }, "from$4", function(properties, duration, ease, autoStart, delay, repeat) {
      return this.from$7(properties, duration, ease, autoStart, delay, repeat, false);
    }, "from$6", function(properties, duration, ease, autoStart, delay) {
      return this.from$7(properties, duration, ease, autoStart, delay, 0, false);
    }, "from$5", "call$7", "call$1", "call$2", "call$3", "call$4", "call$6", "call$5", "get$from", 2, 12, 1634, 1498, 32, 95, 5, 5, 95, 469, [], 55, [], 1439, [], 1064, [], 473, [], 1633, [], 1440, [], "from"],
    start$0: [function(_) {
      var t1, instance, t2, t3, property, t4, t5;
      t1 = this.game;
      if (t1 == null || this._object == null)
        return;
      J.add$1$ax(this._manager, this);
      this.isRunning = true;
      this._onStartCallbackFired = false;
      this._startTime = J.$add$ns(t1.get$time().get$now(), this._delayTime);
      t1 = this._object;
      instance = H.reflect(t1);
      for (t2 = J.get$iterator$ax(J.get$keys$x(this._valuesEnd)), t3 = J.getInterceptor$asx(t1); t2.moveNext$0();) {
        property = t2.get$current();
        if (!!J.getInterceptor(J.$index$asx(this._valuesEnd, property)).$isList) {
          if (J.$eq(J.get$length$asx(J.$index$asx(this._valuesEnd, property)), 0))
            continue;
          C.JSArray_methods.addAll$1([t3.$index(t1, property)], J.$index$asx(this._valuesEnd, property));
        }
        t4 = H.Symbol_validatePublicSymbol(property);
        J.$indexSet$ax(this._valuesStart, property, instance.getField$1(new H.Symbol(t4)).get$reflectee());
        if (!J.getInterceptor(J.$index$asx(this._valuesStart, property)).$isList) {
          t4 = this._valuesStart;
          t5 = J.getInterceptor$asx(t4);
          t5.$indexSet(t4, property, J.$mul$ns(t5.$index(t4, property), 1));
        }
        J.$indexSet$ax(this._valuesStartRepeat, property, J.$index$asx(this._valuesStart, property));
      }
      return this;
    }, "call$0", "get$start", 0, 0, 13, "start"],
    generateData$2: [function(frameRate, data) {
      var t1, t2, t3, property, t4, t5, total, tick, output, time, total0, elapsed, value, blob, start, end;
      if (this.game == null || this._object == null)
        return;
      this._startTime = 0;
      for (t1 = J.get$iterator$ax(J.get$keys$x(this._valuesEnd)), t2 = this._object, t3 = J.getInterceptor$asx(t2); t1.moveNext$0();) {
        property = t1.get$current();
        if (!!J.getInterceptor(J.$index$asx(this._valuesEnd, property)).$isList) {
          if (J.$eq(J.get$length$asx(J.$index$asx(this._valuesEnd, property)), 0))
            continue;
          C.JSArray_methods.addAll$1([t3.$index(t2, property)], J.$index$asx(this._valuesEnd, property));
        }
        J.$indexSet$ax(this._valuesStart, property, t3.$index(t2, property));
        if (!J.getInterceptor(J.$index$asx(this._valuesStart, property)).$isList) {
          t4 = this._valuesStart;
          t5 = J.getInterceptor$asx(t4);
          t5.$indexSet(t4, property, J.$mul$ns(t5.$index(t4, property), 1));
        }
        J.$indexSet$ax(this._valuesStartRepeat, property, J.$index$asx(this._valuesStart, property));
      }
      total = J.floor$0$n(J.$mul$ns(frameRate, J.$div$n(this._Phaser$_duration, 1000)));
      tick = J.$div$n(this._Phaser$_duration, total);
      output = [];
      time = 0;
      while (true) {
        if (typeof total !== "number")
          return total.$sub();
        total0 = total - 1;
        if (!(total >= 0))
          break;
        t1 = this._startTime;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = this._Phaser$_duration;
        if (typeof t2 !== "number")
          return H.iae(t2);
        elapsed = (time - t1) / t2;
        value = this._easingFunction$1(elapsed > 1 ? 1 : elapsed);
        blob = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        for (t1 = J.get$iterator$ax(J.get$keys$x(this._valuesEnd)); t1.moveNext$0();) {
          property = t1.get$current();
          start = J.$index$asx(this._valuesStart, property);
          end = J.$index$asx(this._valuesEnd, property);
          if (!!J.getInterceptor(end).$isList)
            blob.$indexSet(0, property, this._interpolationFunction$2(end, value));
          else {
            if (typeof end === "string")
              end = J.$add$ns(start, H.Primitives_parseDouble(end, null));
            if (typeof end === "number") {
              if (typeof start !== "number")
                return H.iae(start);
              if (typeof value !== "number")
                return H.iae(value);
              blob.$indexSet(0, property, start + (end - start) * value);
            }
          }
        }
        output.push(blob);
        if (typeof tick !== "number")
          return H.iae(tick);
        time += tick;
        total = total0;
      }
      if (this._yoyo === true)
        C.JSArray_methods.addAll$1(output, H.setRuntimeTypeInfo(new H.ReversedListIterable(output), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(output, 0)]), 0)]));
      if (data != null) {
        J.addAll$1$ax(data, output);
        return data;
      } else
        return output;
    }, function(frameRate) {
      return this.generateData$2(frameRate, null);
    }, "generateData$1", function() {
      return this.generateData$2(60, null);
    }, "generateData$0", "call$2", "call$1", "call$0", "get$generateData", 0, 4, 1635, 213, 32, 218, [], 48, [], "generateData"],
    stop$0: [function(_) {
      this.isRunning = false;
      this._onUpdateCallback = null;
      J.remove$1$ax(this._manager, this);
      return this;
    }, "call$0", "get$stop", 0, 0, 13, "stop"],
    delay$1: [function(amount) {
      this._delayTime = amount;
      return this;
    }, "call$1", "get$delay", 2, 0, 63, 366, [], "delay"],
    repeat$1: [function(_, times) {
      this._repeat = times;
      return this;
    }, "call$1", "get$repeat", 2, 0, 63, 1636, [], "repeat"],
    yoyo$1: [function(yoyo) {
      this._yoyo = yoyo;
      if (yoyo === true && J.$eq(this._repeat, 0))
        this._repeat = 1;
      return this;
    }, "call$1", "get$yoyo", 2, 0, 63, 1440, [], "yoyo"],
    easing$1: [function(easing) {
      this._easingFunction = easing;
      return this;
    }, "call$1", "get$easing", 2, 0, 63, 1637, [], "easing"],
    interpolation$1: [function(interpolation) {
      this._interpolationFunction = interpolation;
      return this;
    }, "call$1", "get$interpolation", 2, 0, 63, 1638, [], "interpolation"],
    chainTweens$1: [function(tweens) {
      this._chainedTweens = tweens;
      return this;
    }, "call$1", "get$chainTweens", 2, 0, 1639, 1640, [], "chainTweens"],
    chain$1: [function(tween) {
      this._chainedTweens = [tween];
      return this;
    }, "call$1", "get$chain", 2, 0, 1641, 1642, [], "chain"],
    loop$0: [function(_) {
      this._lastChild.chain$1(this);
      return this;
    }, "call$0", "get$loop", 0, 0, 13, "loop"],
    onUpdateCallback$2: [function(callback, callbackContext) {
      this._onUpdateCallback = callback;
      this._onUpdateCallbackContext = callbackContext;
      return this;
    }, "call$2", "get$onUpdateCallback", 4, 0, 935, 272, [], 1280, [], "onUpdateCallback"],
    pause$0: [function(_) {
      this._codePaused = true;
      this._paused = true;
      this._pausedTime = this.game.get$time().get$now();
    }, "call$0", "get$pause", 0, 0, 13, "pause"],
    _pause$0: [function() {
      if (this._codePaused !== true) {
        this._paused = true;
        this._pausedTime = this.game.get$time().get$now();
      }
    }, "call$0", "get$_pause", 0, 0, 13, "_pause"],
    resume$0: [function() {
      if (this._paused === true) {
        this._paused = false;
        this._codePaused = false;
        this._startTime = J.$add$ns(this._startTime, J.$sub$n(this.game.get$time().get$now(), this._pausedTime));
      }
    }, "call$0", "get$resume", 0, 0, 13, "resume"],
    _resume$0: [function() {
      if (this._codePaused === true)
        return;
      else {
        this._startTime = J.$add$ns(this._startTime, this.game.get$time().get$pauseDuration());
        this._paused = false;
      }
    }, "call$0", "get$_resume", 0, 0, 13, "_resume"],
    update$1: [function(time) {
      var t1, elapsed, value, t2, t3, t4, property, start, end, instance, t5, t6, tmp, numChainedTweens, i;
      if (this.pendingDelete === true)
        return false;
      if (this._paused === true || J.$lt$n(time, this._startTime))
        return true;
      t1 = J.getInterceptor$n(time);
      if (t1.$lt(time, this._startTime))
        return true;
      if (J.$eq(this._onStartCallbackFired, false)) {
        this.onStart.dispatch$1(this._object);
        this._onStartCallbackFired = true;
      }
      elapsed = J.$div$n(t1.$sub(time, this._startTime), this._Phaser$_duration);
      if (J.$gt$n(elapsed, 1))
        elapsed = 1;
      value = this._easingFunction$1(elapsed);
      for (t2 = J.get$iterator$ax(J.get$keys$x(this._valuesEnd)), t3 = this._object, t4 = J.getInterceptor$ax(t3); t2.moveNext$0();) {
        property = t2.get$current();
        start = J.$index$asx(this._valuesStart, property);
        end = J.$index$asx(this._valuesEnd, property);
        if (!!J.getInterceptor(end).$isList)
          t4.$indexSet(t3, property, this._interpolationFunction$2(end, value));
        else {
          if (typeof end === "string")
            end = J.$add$ns(start, H.Primitives_parseDouble(end, null));
          if (typeof end === "number") {
            instance = H.reflect(t3);
            t5 = H.Symbol_validatePublicSymbol(property);
            if (typeof start !== "number")
              return H.iae(start);
            if (typeof value !== "number")
              return H.iae(value);
            t6 = start + (end - start) * value;
            instance._invoke$4(new H.Symbol(t5), 2, [t6], C.Map_empty);
            H.reflect(t6);
          }
        }
      }
      t2 = this._onUpdateCallback;
      if (t2 != null) {
        t2.call$3(this._onUpdateCallbackContext, this, value);
        if (this.isRunning !== true)
          return false;
      }
      if (J.$eq(elapsed, 1))
        if (J.$gt$n(this._repeat, 0)) {
          this._repeat = J.$sub$n(this._repeat, 1);
          for (t2 = J.get$iterator$ax(J.get$keys$x(this._valuesStartRepeat)); t2.moveNext$0();) {
            property = t2.get$current();
            t4 = J.$index$asx(this._valuesEnd, property);
            if (typeof t4 === "string") {
              t4 = this._valuesStartRepeat;
              t5 = J.getInterceptor$asx(t4);
              t5.$indexSet(t4, property, J.$add$ns(t5.$index(t4, property), H.Primitives_parseDouble(J.$index$asx(this._valuesEnd, property), null)));
            }
            if (this._yoyo === true) {
              tmp = J.$index$asx(this._valuesStartRepeat, property);
              J.$indexSet$ax(this._valuesStartRepeat, property, J.$index$asx(this._valuesEnd, property));
              J.$indexSet$ax(this._valuesEnd, property, tmp);
            }
            J.$indexSet$ax(this._valuesStart, property, J.$index$asx(this._valuesStartRepeat, property));
          }
          if (this._yoyo === true)
            this._reversed = this._reversed !== true;
          this._startTime = t1.$add(time, this._delayTime);
          this.onLoop.dispatch$1(t3);
          return true;
        } else {
          this.isRunning = false;
          this.onComplete.dispatch$1(t3);
          numChainedTweens = J.get$length$asx(this._chainedTweens);
          if (typeof numChainedTweens !== "number")
            return H.iae(numChainedTweens);
          i = 0;
          for (; i < numChainedTweens; ++i)
            J.start$0$x(J.$index$asx(this._chainedTweens, i));
          return false;
        }
      return true;
    }, "call$1", "get$update", 2, 0, 1643, 568, [], "update"],
    static: {Tween$: [function(_object, game, _manager) {
        var t1, t2, t3;
        t1 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t2 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t3 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        $.get$Easing_Linear().toString;
        return new R.Tween(_object, game, _manager, t1, t2, t3, 1000, 0, false, false, 0, null, $.get$Linear_INOUT().compute, R.Math_linearInterpolation$closure(), [], false, null, null, false, 0, false, false, H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), false, null, null);
      }, null, null, 4, 2, 488, 32, 489, [], 214, [], 490, [], "new Tween"]}
  },
  "+Tween": [632],
  TweenManager: {
    "^": "Object;game<-598,_tweens<-1630,_Phaser$_add<-1630",
    getAll$0: [function() {
      return this._tweens;
    }, "call$0", "get$getAll", 0, 0, 13, "getAll"],
    removeAll$0: [function() {
      var t1, t2, i, t3;
      t1 = this._tweens;
      t2 = J.getInterceptor$asx(t1);
      i = 0;
      while (true) {
        t3 = t2.get$length(t1);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        t2.$index(t1, i).set$pendingDelete(true);
        ++i;
      }
      J.clear$0$ax(this._Phaser$_add);
    }, "call$0", "get$removeAll", 0, 0, 13, "removeAll"],
    add$1: [function(_, tween) {
      tween.set$_manager(this);
      J.add$1$ax(this._Phaser$_add, tween);
      return tween;
    }, "call$1", "get$add", 2, 0, 1641, 1642, [], "add"],
    create$1: [function(object) {
      var t1, t2, t3;
      t1 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      t3 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      $.get$Easing_Linear().toString;
      return new R.Tween(object, this.game, this, t1, t2, t3, 1000, 0, false, false, 0, null, $.get$Linear_INOUT().compute, R.Math_linearInterpolation$closure(), [], false, null, null, false, 0, false, false, H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), H.setRuntimeTypeInfo(new R.Signal(H.setRuntimeTypeInfo([], [R.SignalBinding]), null, false, true, true), [null]), false, null, null);
    }, "call$1", "get$create", 2, 0, 1142, 541, [], "create"],
    remove$1: [function(_, tween) {
      var t1, t2, i;
      t1 = this._tweens;
      t2 = J.getInterceptor$asx(t1);
      i = t2.indexOf$1(t1, tween);
      if (!J.$eq(i, -1))
        t2.$index(t1, i).set$pendingDelete(true);
    }, "call$1", "get$remove", 2, 0, 1644, 1642, [], "remove"],
    update$0: [function() {
      var t1, t2, numTweens, t3, i, t4;
      t1 = this._tweens;
      t2 = J.getInterceptor$asx(t1);
      if (J.$eq(t2.get$length(t1), 0) && J.$eq(J.get$length$asx(this._Phaser$_add), 0))
        return false;
      numTweens = t2.get$length(t1);
      t3 = this.game;
      i = 0;
      while (true) {
        if (typeof numTweens !== "number")
          return H.iae(numTweens);
        if (!(i < numTweens))
          break;
        if (t2.$index(t1, i).update$1(t3.get$time().get$now()) === true)
          ++i;
        else {
          t2.removeAt$1(t1, i);
          --numTweens;
        }
      }
      t3 = this._Phaser$_add;
      t4 = J.getInterceptor$asx(t3);
      if (J.$gt$n(t4.get$length(t3), 0)) {
        t2.addAll$1(t1, t3);
        t4.set$length(t3, 0);
      }
      return true;
    }, "call$0", "get$update", 0, 0, 209, "update"],
    isTweening$1: [function(object) {
      return J.any$1$ax(this._tweens, new R.TweenManager_isTweening_closure(object));
    }, "call$1", "get$isTweening", 2, 0, 979, 541, [], "isTweening"],
    _pauseAll$0: [function() {
      var t1, t2, i, t3;
      for (t1 = this._tweens, t2 = J.getInterceptor$asx(t1), i = J.$sub$n(t2.get$length(t1), 1); t3 = J.getInterceptor$n(i), t3.$ge(i, 0); i = t3.$sub(i, 1))
        t2.$index(t1, i)._pause$0();
    }, "call$0", "get$_pauseAll", 0, 0, 13, "_pauseAll"],
    _resumeAll$0: [function() {
      var t1, t2, i, t3;
      for (t1 = this._tweens, t2 = J.getInterceptor$asx(t1), i = J.$sub$n(t2.get$length(t1), 1); t3 = J.getInterceptor$n(i), t3.$ge(i, 0); i = t3.$sub(i, 1))
        t2.$index(t1, i)._resume$0();
    }, "call$0", "get$_resumeAll", 0, 0, 13, "_resumeAll"],
    pauseAll$0: [function() {
      var t1, t2, i, t3;
      for (t1 = this._tweens, t2 = J.getInterceptor$asx(t1), i = J.$sub$n(t2.get$length(t1), 1); t3 = J.getInterceptor$n(i), t3.$ge(i, 0); i = t3.$sub(i, 1))
        J.pause$0$x(t2.$index(t1, i));
    }, "call$0", "get$pauseAll", 0, 0, 13, "pauseAll"],
    resumeAll$0: [function() {
      var t1, t2, i, t3;
      for (t1 = this._tweens, t2 = J.getInterceptor$asx(t1), i = J.$sub$n(t2.get$length(t1), 1); t3 = J.getInterceptor$n(i), t3.$ge(i, 0); i = t3.$sub(i, 1))
        t2.$index(t1, i).resume$0();
    }, "call$0", "get$resumeAll", 0, 0, 13, "resumeAll"],
    TweenManager$1: function(game) {
      var t1 = this.game;
      J.add$1$ax(J.get$onPause$x(t1), this.get$_pauseAll());
      J.add$1$ax(t1.get$onResume(), this.get$_resumeAll());
    },
    static: {TweenManager$: [function(game) {
        var t1 = new R.TweenManager(game, [], []);
        t1.TweenManager$1(game);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new TweenManager"]}
  },
  "+TweenManager": [632],
  TweenManager_isTweening_closure: {
    "^": "Closure:1644;object_0",
    call$1: [function(tween) {
      return J.$eq(tween.get$_object(), this.object_0);
    }, "call$1", null, 2, 0, 1644, 1642, [], "call"],
    $isFunction: true
  },
  Color: {
    "^": "Object;r*-599,g@-599,b@-599,a*-599,red@-599,green@-599,blue@-599,alpha*-599,color*-599,rgba@-639,h@-629,s@-629,l@-629,v@-629",
    $isColor: true,
    static: {Color$: [function() {
        return new R.Color(null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      }, null, null, 0, 0, 491, "new Color"], Color_packPixel: [function(r, g, b, a) {
        var t1, t2, t3;
        t1 = J.getInterceptor$n(g);
        t2 = J.getInterceptor$n(b);
        if ($.Device_LITTLE_ENDIAN === true) {
          t3 = J.$shl$n(a, 24);
          t2 = t2.$shl(b, 16);
          t1 = t1.$shl(g, 8);
          if (typeof r !== "number")
            return H.iae(r);
          return (t3 | t2 | t1 | r) >>> 0;
        } else {
          t3 = J.$shl$n(r, 24);
          t1 = t1.$shl(g, 16);
          t2 = t2.$shl(b, 8);
          if (typeof a !== "number")
            return H.iae(a);
          return (t3 | t1 | t2 | a) >>> 0;
        }
      }, "call$4", "Color_packPixel$closure", 8, 0, 492, 302, [], 493, [], 305, [], 304, [], "packPixel"], Color_unpackPixel: [function(rgba, out, hsl, hsv) {
        var t1, t2, t3, t4, out0, dr, dg, db, min, max, d, r, g, b;
        if (out == null)
          out = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
        t1 = J.getInterceptor$n(rgba);
        t2 = J.getInterceptor$x(out);
        if ($.Device_LITTLE_ENDIAN === true) {
          t2.set$a(out, t1.$and(rgba, 4278190080) >>> 24);
          out.set$b(t1.$and(rgba, 16711680) >>> 16);
          out.set$g(t1.$and(rgba, 65280) >>> 8);
          t2.set$r(out, t1.$and(rgba, 255));
        } else {
          t2.set$r(out, t1.$and(rgba, 4278190080) >>> 24);
          out.set$g(t1.$and(rgba, 16711680) >>> 16);
          out.set$b(t1.$and(rgba, 65280) >>> 8);
          t2.set$a(out, t1.$and(rgba, 255));
        }
        t1 = J.getInterceptor$x(out);
        t1.set$color(out, rgba);
        out.set$rgba(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("rgba(", J.toString$0(t1.get$r(out))) + ",", J.toString$0(out.get$g())) + ",", J.toString$0(out.get$b())) + "," + J.toString$0(J.$div$n(t1.get$a(out), 255)) + ")");
        if (hsl === true) {
          t2 = t1.get$r(out);
          t3 = out.get$g();
          t4 = out.get$b();
          out0 = out == null ? R.Color_createColor(t2, t3, t4, 255, 0, 0, 0, 0) : out;
          dr = J.$div$n(t2, 255);
          dg = J.$div$n(t3, 255);
          db = J.$div$n(t4, 255);
          min = R.Math_minList([dr, dg, db]);
          max = R.Math_maxList([dr, dg, db]);
          out0.set$h(0);
          out0.set$s(0);
          t2 = J.getInterceptor$ns(max);
          out0.set$l(J.$div$n(t2.$add(max, min), 2));
          if (!t2.$eq(max, min)) {
            d = t2.$sub(max, min);
            t3 = J.getInterceptor$n(d);
            if (J.$gt$n(out0.get$l(), 0.5)) {
              if (typeof max !== "number")
                return H.iae(max);
              if (typeof min !== "number")
                return H.iae(min);
              t3 = t3.$div(d, 2 - max - min);
            } else
              t3 = t3.$div(d, t2.$add(max, min));
            out0.set$s(t3);
            if (t2.$eq(max, dr)) {
              t2 = J.getInterceptor$n(dg);
              t3 = J.$div$n(t2.$sub(dg, db), d);
              out0.set$h(J.$add$ns(t3, t2.$lt(dg, db) ? 6 : 0));
            } else if (t2.$eq(max, dg))
              out0.set$h(J.$add$ns(J.$div$n(J.$sub$n(db, dr), d), 2));
            else if (t2.$eq(max, db))
              out0.set$h(J.$add$ns(J.$div$n(J.$sub$n(dr, dg), d), 4));
            out0.set$h(J.$div$n(out0.get$h(), 6));
          }
        }
        if (hsv === true) {
          t1 = t1.get$r(out);
          t2 = out.get$g();
          t3 = out.get$b();
          out0 = out == null ? R.Color_createColor(t1, t2, t3, 255, 0, 0, 0, 0) : out;
          r = J.$tdiv$n(t1, 255);
          g = J.$tdiv$n(t2, 255);
          b = J.$tdiv$n(t3, 255);
          min = R.Math_minList([r, g, b]);
          max = R.Math_maxList([r, g, b]);
          t1 = J.getInterceptor$n(max);
          d = t1.$sub(max, min);
          out0.set$h(0);
          out0.set$s(t1.$eq(max, 0) ? 0 : J.$div$n(d, max));
          out0.set$v(max);
          if (!t1.$eq(max, min)) {
            if (t1.$eq(max, r)) {
              t1 = J.getInterceptor$n(g);
              t2 = J.$div$n(t1.$sub(g, b), d);
              out0.set$h(t2 + (t1.$lt(g, b) ? 6 : 0));
            } else if (t1.$eq(max, g))
              out0.set$h(J.$div$n(J.$sub$n(b, r), d) + 2);
            else if (t1.$eq(max, b))
              out0.set$h(J.$div$n(J.$sub$n(r, g), d) + 4);
            out0.set$h(J.$div$n(out0.get$h(), 6));
          }
        }
        return out;
      }, function(rgba) {
        return R.Color_unpackPixel(rgba, null, false, false);
      }, null, function(rgba, out) {
        return R.Color_unpackPixel(rgba, out, false, false);
      }, null, function(rgba, out, hsl) {
        return R.Color_unpackPixel(rgba, out, hsl, false);
      }, null, "call$4", "call$1", "call$2", "call$3", "Color_unpackPixel$closure", 2, 6, 494, 32, 95, 95, 495, [], 317, [], 496, [], 497, [], "unpackPixel"], Color_fromRGBA: [function(rgba, out) {
        var t1, t2;
        if (out == null)
          out = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
        t1 = J.getInterceptor$n(rgba);
        t2 = J.getInterceptor$x(out);
        t2.set$r(out, t1.$and(rgba, 4278190080) >>> 24);
        out.set$g(t1.$and(rgba, 16711680) >>> 16);
        out.set$b(t1.$and(rgba, 65280) >>> 8);
        t2.set$a(out, t1.$and(rgba, 255));
        out.set$rgba(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("rgba(", J.toString$0(t2.get$r(out))) + ",", J.toString$0(out.get$g())) + ",", J.toString$0(out.get$b())) + ",", J.toString$0(t2.get$a(out))) + ")");
        return out;
      }, "call$2", "Color_fromRGBA$closure", 4, 0, 498, 495, [], 317, [], "fromRGBA"], Color_toRGBA: [function(r, g, b, a) {
        var t1, t2, t3;
        t1 = J.$shl$n(r, 24);
        t2 = J.$shl$n(g, 16);
        t3 = J.$shl$n(b, 8);
        if (typeof a !== "number")
          return H.iae(a);
        return (t1 | t2 | t3 | a) >>> 0;
      }, "call$4", "Color_toRGBA$closure", 8, 0, 492, 302, [], 493, [], 305, [], 304, [], "toRGBA"], Color_RGBtoHSL: [function(r, g, b, out) {
        var dr, dg, db, min, max, t1, d, t2;
        if (out == null)
          out = R.Color_createColor(r, g, b, 255, 0, 0, 0, 0);
        dr = J.$div$n(r, 255);
        dg = J.$div$n(g, 255);
        db = J.$div$n(b, 255);
        min = R.Math_minList([dr, dg, db]);
        max = R.Math_maxList([dr, dg, db]);
        out.set$h(0);
        out.set$s(0);
        t1 = J.getInterceptor$ns(max);
        out.set$l(J.$div$n(t1.$add(max, min), 2));
        if (!t1.$eq(max, min)) {
          d = t1.$sub(max, min);
          t2 = J.getInterceptor$n(d);
          if (J.$gt$n(out.get$l(), 0.5)) {
            if (typeof max !== "number")
              return H.iae(max);
            if (typeof min !== "number")
              return H.iae(min);
            t2 = t2.$div(d, 2 - max - min);
          } else
            t2 = t2.$div(d, t1.$add(max, min));
          out.set$s(t2);
          if (t1.$eq(max, dr)) {
            t1 = J.getInterceptor$n(dg);
            t2 = J.$div$n(t1.$sub(dg, db), d);
            out.set$h(J.$add$ns(t2, t1.$lt(dg, db) ? 6 : 0));
          } else if (t1.$eq(max, dg))
            out.set$h(J.$add$ns(J.$div$n(J.$sub$n(db, dr), d), 2));
          else if (t1.$eq(max, db))
            out.set$h(J.$add$ns(J.$div$n(J.$sub$n(dr, dg), d), 4));
          out.set$h(J.$div$n(out.get$h(), 6));
        }
        return out;
      }, function(r, g, b) {
        return R.Color_RGBtoHSL(r, g, b, null);
      }, null, "call$4", "call$3", "Color_RGBtoHSL$closure", 6, 2, 499, 32, 302, [], 493, [], 305, [], 317, [], "RGBtoHSL"], Color_HSLtoRGB: [function(h, s, l, out) {
        var t1, q, p, dr, dg, db;
        if (out == null)
          out = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
        if (!J.$eq(s, 0)) {
          t1 = J.getInterceptor$n(l);
          if (t1.$lt(l, 0.5)) {
            if (typeof s !== "number")
              return H.iae(s);
            q = t1.$mul(l, 1 + s);
          } else
            q = J.$sub$n(t1.$add(l, s), t1.$mul(l, s));
          if (typeof l !== "number")
            return H.iae(l);
          if (typeof q !== "number")
            return H.iae(q);
          p = 2 * l - q;
          t1 = J.getInterceptor$ns(h);
          dr = R.Color_hueToColor(p, q, t1.$add(h, 0.3333333333333333));
          dg = R.Color_hueToColor(p, q, h);
          db = R.Color_hueToColor(p, q, t1.$sub(h, 0.3333333333333333));
        } else {
          db = l;
          dg = db;
          dr = dg;
        }
        J.set$r$x(out, J.floor$0$n(J.$mul$ns(dr, 255)));
        out.set$g(J.floor$0$n(J.$mul$ns(dg, 255)));
        out.set$b(J.floor$0$n(J.$mul$ns(db, 255)));
        R.Color_updateColor(out);
        return out;
      }, function(h, s, l) {
        return R.Color_HSLtoRGB(h, s, l, null);
      }, null, "call$4", "call$3", "Color_HSLtoRGB$closure", 6, 2, 500, 32, 501, [], 502, [], 503, [], 317, [], "HSLtoRGB"], Color_RGBtoHSV: [function(r, g, b, out) {
        var min, max, t1, d, t2;
        if (out == null)
          out = R.Color_createColor(r, g, b, 255, 0, 0, 0, 0);
        r = J.$tdiv$n(r, 255);
        g = J.$tdiv$n(g, 255);
        b = J.$tdiv$n(b, 255);
        min = R.Math_minList([r, g, b]);
        max = R.Math_maxList([r, g, b]);
        t1 = J.getInterceptor$n(max);
        d = t1.$sub(max, min);
        out.set$h(0);
        out.set$s(t1.$eq(max, 0) ? 0 : J.$div$n(d, max));
        out.set$v(max);
        if (!t1.$eq(max, min)) {
          if (t1.$eq(max, r)) {
            t1 = J.getInterceptor$n(g);
            t2 = J.$div$n(t1.$sub(g, b), d);
            out.set$h(t2 + (t1.$lt(g, b) ? 6 : 0));
          } else if (t1.$eq(max, g))
            out.set$h(J.$div$n(J.$sub$n(b, r), d) + 2);
          else if (t1.$eq(max, b))
            out.set$h(J.$div$n(J.$sub$n(r, g), d) + 4);
          out.set$h(J.$div$n(out.get$h(), 6));
        }
        return out;
      }, "call$4", "Color_RGBtoHSV$closure", 8, 0, 504, 302, [], 493, [], 305, [], 317, [], "RGBtoHSV"], Color_HSVtoRGB: [function(h, s, v, out) {
        var t1, i, f, p, t2, q, t, b, g, r;
        if (out == null)
          out = R.Color_createColor(0, 0, 0, 255, h, s, 0, v);
        t1 = J.getInterceptor$ns(h);
        i = J.floor$0$n(t1.$mul(h, 6));
        f = J.$sub$n(t1.$mul(h, 6), i);
        if (typeof s !== "number")
          return H.iae(s);
        t1 = J.getInterceptor$ns(v);
        p = t1.$mul(v, 1 - s);
        t2 = J.$mul$ns(f, s);
        if (typeof t2 !== "number")
          return H.iae(t2);
        q = t1.$mul(v, 1 - t2);
        if (typeof f !== "number")
          return H.iae(f);
        t = t1.$mul(v, 1 - (1 - f) * s);
        if (typeof i !== "number")
          return i.$mod();
        switch (C.JSInt_methods.$mod(i, 6)) {
          case 0:
            b = p;
            g = t;
            r = v;
            break;
          case 1:
            b = p;
            g = v;
            r = q;
            break;
          case 2:
            b = t;
            g = v;
            r = p;
            break;
          case 3:
            b = v;
            g = q;
            r = p;
            break;
          case 4:
            b = v;
            g = p;
            r = t;
            break;
          case 5:
            b = q;
            g = p;
            r = v;
            break;
          default:
            r = null;
            g = null;
            b = null;
        }
        J.set$r$x(out, J.floor$0$n(J.$mul$ns(r, 255)));
        out.set$g(J.floor$0$n(J.$mul$ns(g, 255)));
        out.set$b(J.floor$0$n(J.$mul$ns(b, 255)));
        R.Color_updateColor(out);
        return out;
      }, function(h, s, v) {
        return R.Color_HSVtoRGB(h, s, v, null);
      }, null, "call$4", "call$3", "Color_HSVtoRGB$closure", 6, 2, 500, 32, 501, [], 502, [], 376, [], 317, [], "HSVtoRGB"], Color_hueToColor: [function(p, q, t) {
        var t1 = J.getInterceptor$n(t);
        if (t1.$lt(t, 0))
          t = t1.$add(t, 1);
        t1 = J.getInterceptor$n(t);
        if (t1.$gt(t, 1))
          t = t1.$sub(t, 1);
        t1 = J.getInterceptor$n(t);
        if (t1.$lt(t, 0.16666666666666666))
          return J.$add$ns(p, J.$mul$ns(J.$mul$ns(J.$sub$n(q, p), 6), t));
        if (t1.$lt(t, 0.5))
          return q;
        if (t1.$lt(t, 0.6666666666666666)) {
          t1 = J.$sub$n(q, p);
          if (typeof t !== "number")
            return H.iae(t);
          return J.$add$ns(p, J.$mul$ns(J.$mul$ns(t1, 0.6666666666666666 - t), 6));
        }
        return p;
      }, "call$3", "Color_hueToColor$closure", 6, 0, 505, 192, [], 506, [], 380, [], "hueToColor"], Color_createColor: [function(r, g, b, a, h, s, l, v) {
        var out = new R.Color(null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        out.r = r;
        out.g = g;
        out.b = b;
        out.a = a;
        out.h = h;
        out.s = s;
        out.l = l;
        out.v = v;
        out.rgba = C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("rgba(", J.toString$0(r)) + ",", J.toString$0(g)) + ",", J.toString$0(b)) + ",", J.toString$0(a)) + ")";
        return out;
      }, function() {
        return R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
      }, null, function(r) {
        return R.Color_createColor(r, 0, 0, 255, 0, 0, 0, 0);
      }, null, function(r, g) {
        return R.Color_createColor(r, g, 0, 255, 0, 0, 0, 0);
      }, null, function(r, g, b) {
        return R.Color_createColor(r, g, b, 255, 0, 0, 0, 0);
      }, null, function(r, g, b, a) {
        return R.Color_createColor(r, g, b, a, 0, 0, 0, 0);
      }, null, function(r, g, b, a, h, s) {
        return R.Color_createColor(r, g, b, a, h, s, 0, 0);
      }, null, function(r, g, b, a, h) {
        return R.Color_createColor(r, g, b, a, h, 0, 0, 0);
      }, null, function(r, g, b, a, h, s, l) {
        return R.Color_createColor(r, g, b, a, h, s, l, 0);
      }, null, "call$8", "call$0", "call$1", "call$2", "call$3", "call$4", "call$6", "call$5", "call$7", "Color_createColor$closure", 0, 16, 507, 5, 5, 5, 508, 5, 5, 5, 5, 302, [], 493, [], 305, [], 304, [], 501, [], 502, [], 503, [], 376, [], "createColor"], Color_updateColor: [function(out) {
        var t1 = J.getInterceptor$x(out);
        out.set$rgba(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("rgba(", J.toString$0(t1.get$r(out))) + ",", J.toString$0(out.get$g())) + ",", J.toString$0(out.get$b())) + ",", J.toString$0(t1.get$a(out))) + ")");
        return out;
      }, "call$1", "Color_updateColor$closure", 2, 0, 509, 317, [], "updateColor"], Color_getColor32: [function(a, r, g, b) {
        var t1, t2, t3;
        t1 = J.$shl$n(a, 24);
        t2 = J.$shl$n(r, 16);
        t3 = J.$shl$n(g, 8);
        if (typeof b !== "number")
          return H.iae(b);
        return (t1 | t2 | t3 | b) >>> 0;
      }, "call$4", "Color_getColor32$closure", 8, 0, 510, 304, [], 302, [], 493, [], 305, [], "getColor32"], Color_getColor: [function(r, g, b) {
        var t1, t2;
        t1 = J.$shl$n(r, 16);
        t2 = J.$shl$n(g, 8);
        if (typeof b !== "number")
          return H.iae(b);
        return (t1 | t2 | b) >>> 0;
      }, "call$3", "Color_getColor$closure", 6, 0, 511, 302, [], 493, [], 305, [], "getColor"], Color_RGBtoString: [function(r, g, b, a, prefix) {
        var t1, t2;
        if (J.$eq(prefix, "#")) {
          t1 = J.$shl$n(r, 16);
          t2 = J.$shl$n(g, 8);
          if (typeof b !== "number")
            return H.iae(b);
          return "#" + C.JSString_methods.substring$1(C.JSInt_methods.toRadixString$1(C.JSNumber_methods.toInt$0(16777216 + t1 + t2 + b), 16), 1);
        } else
          return "0x" + R.Color_componentToHex(a) + R.Color_componentToHex(r) + R.Color_componentToHex(g) + R.Color_componentToHex(b);
      }, function(r, g, b) {
        return R.Color_RGBtoString(r, g, b, 255, "#");
      }, null, function(r, g, b, a) {
        return R.Color_RGBtoString(r, g, b, a, "#");
      }, null, "call$5", "call$3", "call$4", "Color_RGBtoString$closure", 6, 4, 512, 508, 513, 302, [], 493, [], 305, [], 304, [], 222, [], "RGBtoString"], Color_hexToRGB: [function(hex) {
        var rgb, t1;
        rgb = R.Color_hexToColor(hex, null);
        if (rgb != null) {
          t1 = J.getInterceptor$x(rgb);
          return R.Color_getColor32(t1.get$a(rgb), t1.get$r(rgb), rgb.get$g(), rgb.get$b());
        }
        return;
      }, "call$1", "Color_hexToRGB$closure", 2, 0, 514, 205, [], "hexToRGB"], Color_hexToColor: [function(hex, out) {
        if (out == null)
          out = R.Color_createColor(0, 0, 0, 255, 0, 0, 0, 0);
        hex = J.replaceFirst$2$s(hex, new H.JSSyntaxRegExp("^#?([a-fd])([a-fd])([a-fd])$", H.JSSyntaxRegExp_makeNative("^#?([a-fd])([a-fd])([a-fd])$", false, true, false), null, null), "$1$1$2$2$3$3");
        new H.JSSyntaxRegExp("^#?([a-fd]{2})([a-fd]{2})([a-fd]{2})$", H.JSSyntaxRegExp_makeNative("^#?([a-fd]{2})([a-fd]{2})([a-fd]{2})$", false, true, false), null, null).firstMatch$1(hex);
        return out;
      }, function(hex) {
        return R.Color_hexToColor(hex, null);
      }, null, "call$2", "call$1", "Color_hexToColor$closure", 2, 2, 515, 32, 205, [], 317, [], "hexToColor"], Color_componentToHex: [function(color) {
        var hex = J.toRadixString$1$n(color, 16);
        return hex.length === 1 ? "0" + hex : hex;
      }, "call$1", "Color_componentToHex$closure", 2, 0, 516, 114, [], "componentToHex"], Color_HSVColorWheel: [function(s, v) {
        var colors, t1, c, t2, out, i, f, p, q, t, b, g, r;
        colors = [];
        for (t1 = J.getInterceptor$ns(v), c = 0; c <= 359; ++c) {
          t2 = c / 359;
          out = R.Color_createColor(0, 0, 0, 255, t2, s, 0, v);
          t2 *= 6;
          i = C.JSInt_methods.floor$0(t2);
          f = t2 - i;
          if (typeof s !== "number")
            return H.iae(s);
          p = t1.$mul(v, 1 - s);
          q = t1.$mul(v, 1 - f * s);
          t = t1.$mul(v, 1 - (1 - f) * s);
          switch (C.JSInt_methods.$mod(i, 6)) {
            case 0:
              b = p;
              g = t;
              r = v;
              break;
            case 1:
              b = p;
              g = v;
              r = q;
              break;
            case 2:
              b = t;
              g = v;
              r = p;
              break;
            case 3:
              b = v;
              g = q;
              r = p;
              break;
            case 4:
              b = v;
              g = p;
              r = t;
              break;
            case 5:
              b = q;
              g = p;
              r = v;
              break;
          }
          out.r = J.floor$0$n(J.$mul$ns(r, 255));
          out.g = J.floor$0$n(J.$mul$ns(g, 255));
          out.b = J.floor$0$n(J.$mul$ns(b, 255));
          R.Color_updateColor(out);
          colors.push(out);
        }
        return colors;
      }, function() {
        return R.Color_HSVColorWheel(1, 1);
      }, null, function(s) {
        return R.Color_HSVColorWheel(s, 1);
      }, null, "call$2", "call$0", "call$1", "Color_HSVColorWheel$closure", 0, 4, 517, 390, 390, 502, [], 376, [], "HSVColorWheel"], Color_HSLColorWheel: [function(s, l) {
        var colors, c;
        colors = [];
        for (c = 0; c <= 359; ++c)
          colors.push(R.Color_HSLtoRGB(c / 359, s, l, null));
        return colors;
      }, function() {
        return R.Color_HSLColorWheel(0.5, 0.5);
      }, null, function(s) {
        return R.Color_HSLColorWheel(s, 0.5);
      }, null, "call$2", "call$0", "call$1", "Color_HSLColorWheel$closure", 0, 4, 517, 518, 518, 502, [], 503, [], "HSLColorWheel"], Color_interpolateColor: [function(color1, color2, steps, currentStep, alpha) {
        var src1, src2;
        src1 = R.Color_getRGB(color1);
        src2 = R.Color_getRGB(color2);
        return R.Color_getColor32(alpha, J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(src2.red, src1.red), currentStep), steps), src1.red), J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(src2.green, src1.green), currentStep), steps), src1.green), J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(src2.blue, src1.blue), currentStep), steps), src1.blue));
      }, function(color1, color2, steps, currentStep) {
        return R.Color_interpolateColor(color1, color2, steps, currentStep, 255);
      }, null, "call$5", "call$4", "Color_interpolateColor$closure", 8, 2, 519, 508, 520, [], 521, [], 522, [], 523, [], 524, [], "interpolateColor"], Color_interpolateColorWithRGB: [function(color, r, g, b, steps, currentStep) {
        var src, or, og, ob, t1, t2;
        src = R.Color_getRGB(color);
        or = J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(r, src.red), currentStep), steps), src.red);
        og = J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(g, src.green), currentStep), steps), src.green);
        ob = J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(b, src.blue), currentStep), steps), src.blue);
        t1 = J.$shl$n(or, 16);
        t2 = J.$shl$n(og, 8);
        if (typeof ob !== "number")
          return H.iae(ob);
        return (t1 | t2 | ob) >>> 0;
      }, "call$6", "Color_interpolateColorWithRGB$closure", 12, 0, 525, 114, [], 302, [], 493, [], 305, [], 522, [], 523, [], "interpolateColorWithRGB"], Color_interpolateRGB: [function(r1, g1, b1, r2, g2, b2, steps, currentStep) {
        var r, g, b, t1, t2;
        r = J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(r2, r1), currentStep), steps), r1);
        g = J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(g2, g1), currentStep), steps), g1);
        b = J.$add$ns(J.$div$n(J.$mul$ns(J.$sub$n(b2, b1), currentStep), steps), b1);
        t1 = J.$shl$n(r, 16);
        t2 = J.$shl$n(g, 8);
        if (typeof b !== "number")
          return H.iae(b);
        return (t1 | t2 | b) >>> 0;
      }, "call$8", "Color_interpolateRGB$closure", 16, 0, 526, 527, [], 528, [], 404, [], 529, [], 530, [], 405, [], 522, [], 523, [], "interpolateRGB"], Color_getRandomColor: [function(min, max, alpha) {
        var t1, t2, t3;
        t1 = J.getInterceptor$n(max);
        if (t1.$gt(max, 255) || J.$gt$n(min, max))
          return 16777215;
        t2 = $.get$Math_random();
        t3 = J.getInterceptor$ns(min);
        return R.Color_getColor32(alpha, t3.$add(min, J.round$0$n(J.$mul$ns(t2.call$0(), t1.$sub(max, min)))), t3.$add(min, J.round$0$n(J.$mul$ns(t2.call$0(), t1.$sub(max, min)))), t3.$add(min, J.round$0$n(J.$mul$ns(t2.call$0(), t1.$sub(max, min)))));
      }, function() {
        return R.Color_getRandomColor(0, 255, 255);
      }, null, function(min) {
        return R.Color_getRandomColor(min, 255, 255);
      }, null, function(min, max) {
        return R.Color_getRandomColor(min, max, 255);
      }, null, "call$3", "call$0", "call$1", "call$2", "Color_getRandomColor$closure", 0, 6, 531, 5, 508, 508, 364, [], 365, [], 524, [], "getRandomColor"], Color_getRGB: [function(color) {
        var c, t1, t2, t3, t4;
        c = new R.Color(null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1 = J.getInterceptor$n(color);
        if (t1.$gt(color, 16777215)) {
          t2 = t1.$shr(color, 24);
          c.a = t2;
          t3 = t1.$shr(color, 16) & 255;
          c.r = t3;
          t4 = t1.$shr(color, 8) & 255;
          c.g = t4;
          t1 = t1.$and(color, 255);
          c.b = t1;
          c.alpha = t2;
          c.red = t3;
          c.green = t4;
          c.blue = t1;
        } else {
          c.a = 255;
          t2 = t1.$shr(color, 16) & 255;
          c.r = t2;
          t3 = t1.$shr(color, 8) & 255;
          c.g = t3;
          t1 = t1.$and(color, 255);
          c.b = t1;
          c.alpha = 255;
          c.red = t2;
          c.green = t3;
          c.blue = t1;
        }
        return c;
      }, "call$1", "Color_getRGB$closure", 2, 0, 532, 114, [], "getRGB"], Color_getWebRGB: [function(color) {
        var rgb;
        if (!!J.getInterceptor(color).$isColor)
          return C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("rgba(", J.toString$0(color.r)) + ",", J.toString$0(color.g)) + ",", J.toString$0(color.b)) + "," + J.toString$0(J.$div$n(color.a, 255)) + ")";
        else {
          rgb = R.Color_getRGB(color);
          return C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("rgba(", J.toString$0(rgb.r)) + ",", J.toString$0(rgb.g)) + ",", J.toString$0(rgb.b)) + "," + J.toString$0(J.$div$n(rgb.a, 255)) + ")";
        }
      }, "call$1", "Color_getWebRGB$closure", 2, 0, 533, 114, [], "getWebRGB"], Color_getAlpha: [function(color) {
        return J.$shr$n(color, 24);
      }, "call$1", "Color_getAlpha$closure", 2, 0, 210, 114, [], "getAlpha"], Color_getAlphaFloat: [function(color) {
        return J.$shr$n(color, 24) / 255;
      }, "call$1", "Color_getAlphaFloat$closure", 2, 0, 534, 114, [], "getAlphaFloat"], Color_getRed: [function(color) {
        return J.$shr$n(color, 16) & 255;
      }, "call$1", "Color_getRed$closure", 2, 0, 210, 114, [], "getRed"], Color_getGreen: [function(color) {
        return J.$shr$n(color, 8) & 255;
      }, "call$1", "Color_getGreen$closure", 2, 0, 210, 114, [], "getGreen"], Color_getBlue: [function(color) {
        return J.$and$n(color, 255);
      }, "call$1", "Color_getBlue$closure", 2, 0, 210, 114, [], "getBlue"], Color_getColorInfo: [function(color) {
        var argb, argb0;
        argb = R.Color_getRGB(color);
        argb0 = R.Color_getRGB(color);
        return "0x" + R.Color_colorToHexstring(argb0.alpha) + R.Color_colorToHexstring(argb0.red) + R.Color_colorToHexstring(argb0.green) + R.Color_colorToHexstring(argb0.blue) + "\n" + ("Alpha: " + H.S(argb.alpha) + " Red: " + H.S(argb.red) + " Green: " + H.S(argb.green) + " Blue: " + H.S(argb.blue) + " \n");
      }, "call$1", "Color_getColorInfo$closure", 2, 0, 516, 114, [], "getColorInfo"], Color_RGBtoHexstring: [function(color) {
        var argb = R.Color_getRGB(color);
        return "0x" + R.Color_colorToHexstring(argb.alpha) + R.Color_colorToHexstring(argb.red) + R.Color_colorToHexstring(argb.green) + R.Color_colorToHexstring(argb.blue);
      }, "call$1", "Color_RGBtoHexstring$closure", 2, 0, 516, 114, [], "RGBtoHexstring"], Color_RGBtoWebstring: [function(color) {
        var argb = R.Color_getRGB(color);
        return "#" + R.Color_colorToHexstring(argb.red) + R.Color_colorToHexstring(argb.green) + R.Color_colorToHexstring(argb.blue);
      }, "call$1", "Color_RGBtoWebstring$closure", 2, 0, 516, 114, [], "RGBtoWebstring"], Color_colorToHexstring: [function(color) {
        var t1, lsd;
        t1 = J.getInterceptor$n(color);
        lsd = t1.$mod(color, 16);
        return C.JSInt_methods.toString$0(C.JSString_methods.indexOf$1("0123456789ABCDEF", J.toString$0(J.$tdiv$n(t1.$sub(color, lsd), 16))) + C.JSString_methods.indexOf$1("0123456789ABCDEF", C.JSNumber_methods.toString$0(lsd)));
      }, "call$1", "Color_colorToHexstring$closure", 2, 0, 516, 114, [], "colorToHexstring"]}
  },
  "+Color": [632],
  Debug: {
    "^": "Object;game@-598,sprite@-643,canvas*-808,baseTexture@-826,texture@-670,textureFrame@-939,context*-850,font*-639,columnWidth*-601,lineHeight*-601,renderShadow@-602,currentX@-601,currentY@-601,currentAlpha@-629,dirty@-602,currentColor@-639",
    sprite$3: function(arg0, arg1, arg2) {
      return this.sprite.call$3(arg0, arg1, arg2);
    },
    sprite$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.sprite.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    sprite$4: function(arg0, arg1, arg2, arg3) {
      return this.sprite.call$4(arg0, arg1, arg2, arg3);
    },
    boot$0: [function() {
      var t1, t2;
      t1 = J.$eq(this.game.get$renderType(), 1);
      t2 = this.game;
      if (t1)
        this.context = J.get$context$x(t2);
      else {
        R.RenderTexture$(t2, J.get$width$x(t2), J.get$height$x(this.game), null, null);
        t1 = R.Canvas_create(J.get$width$x(this.game), J.get$height$x(this.game), "", true);
        this.canvas = t1;
        this.context = J.getContext$1$x(t1, "2d");
        t1 = M.BaseTexture$(this.canvas, C.scaleModes_0);
        this.baseTexture = t1;
        this.texture = M.Texture$(t1, null);
        this.textureFrame = R.Frame$(0, 0, 0, J.get$width$x(this.game), J.get$height$x(this.game), "debug", this.game.get$rnd().uuid$0());
        this.sprite = this.game.get$make().image$4(0, 0, this.texture, this.textureFrame);
        this.game.get$stage().addChild$1(this.sprite);
      }
    }, "call$0", "get$boot", 0, 0, 13, "boot"],
    preUpdate$0: [function() {
      if (this.dirty === true && this.sprite != null) {
        J.clearRect$4$x(this.context, 0, 0, J.get$width$x(this.game), J.get$height$x(this.game));
        this.dirty = false;
      }
    }, "call$0", "get$preUpdate", 0, 0, 13, "preUpdate"],
    start$4: [function(_, x, y, color, columnWidth) {
      this.currentX = x;
      this.currentY = y;
      this.currentColor = color;
      this.currentAlpha = J.get$globalAlpha$x(this.context);
      this.columnWidth = columnWidth;
      if (this.sprite != null)
        this.dirty = true;
      J.save$0$x(this.context);
      J.setTransform$6$x(this.context, 1, 0, 0, 1, 0, 0);
      J.set$strokeStyle$x(this.context, color);
      J.set$fillStyle$x(this.context, color);
      J.set$font$x(this.context, this.font);
      J.set$globalAlpha$x(this.context, 1);
      J.set$lineWidth$x(this.context, 1);
    }, function($receiver, x) {
      return this.start$4($receiver, x, 0, "rgb(255,255,255)", 0);
    }, "start$1", function($receiver) {
      return this.start$4($receiver, 0, 0, "rgb(255,255,255)", 0);
    }, "start$0", function($receiver, x, y, color) {
      return this.start$4($receiver, x, y, color, 0);
    }, "start$3", function($receiver, x, y) {
      return this.start$4($receiver, x, y, "rgb(255,255,255)", 0);
    }, "start$2", "call$4", "call$1", "call$0", "call$3", "call$2", "get$start", 0, 8, 1211, 5, 5, 1645, 5, 6, [], 7, [], 114, [], 1646, [], "start"],
    stop$0: [function(_) {
      J.restore$0$x(this.context);
      J.set$globalAlpha$x(this.context, this.currentAlpha);
      if (this.sprite != null)
        M.updateWebGLTexture(this.baseTexture, this.game.get$renderer().get$gl());
    }, "call$0", "get$stop", 0, 0, 13, "stop"],
    line$1: [function(strs) {
      var $arguments, x, t1, i, t2;
      $arguments = typeof strs === "string" ? [strs] : strs;
      x = this.currentX;
      t1 = J.getInterceptor$asx($arguments);
      i = 0;
      while (true) {
        t2 = t1.get$length($arguments);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        if (this.renderShadow === true) {
          J.set$fillStyle$x(this.context, "rgb(0,0,0)");
          J.fillText$3$x(this.context, t1.$index($arguments, i), J.$add$ns(x, 1), J.$add$ns(this.currentY, 1));
          J.set$fillStyle$x(this.context, this.currentColor);
        }
        J.fillText$3$x(this.context, t1.$index($arguments, i), x, this.currentY);
        x = J.$add$ns(x, this.columnWidth);
        ++i;
      }
      this.currentY = J.$add$ns(this.currentY, this.lineHeight);
    }, "call$1", "get$line", 2, 0, 63, 1647, [], "line"],
    soundInfo$4: [function(sound, x, y, color) {
      var t1;
      this.start$3(0, x, y, color);
      t1 = J.getInterceptor$x(sound);
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Sound: ", t1.get$key(sound)) + " Locked: ", J.toString$0(sound.get$game().get$sound().get$touchLocked())));
      this.line$1(C.JSString_methods.$add("Is Ready?: " + String(this.game.get$cache().isSoundReady$1(t1.get$key(sound))) + " Pending Playback: ", J.toString$0(sound.get$pendingPlayback())));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Decoded: ", J.toString$0(sound.get$isDecoded())) + " Decoding: ", J.toString$0(sound.get$isDecoding())));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Total Duration: ", J.toString$0(sound.get$totalDuration())) + " Playing: ", J.toString$0(sound.get$isPlaying())));
      this.line$1(C.JSString_methods.$add("Time: ", J.toString$0(t1.get$currentTime(sound))));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Volume: ", J.toString$0(t1.get$volume(sound))) + " Muted: ", J.toString$0(sound.get$mute())));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("WebAudio: ", J.toString$0(sound.get$usingWebAudio())) + " Audio: ", J.toString$0(sound.get$usingAudioTag())));
      if (!J.$eq(sound.get$currentMarker(), "")) {
        this.line$1(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("Marker: ", sound.get$currentMarker()) + " Duration: ", J.toString$0(t1.get$duration(sound))) + " (ms: ", J.toString$0(sound.get$durationMS())) + ")");
        this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Start: ", J.toString$0(J.get$start$x(J.$index$asx(sound.get$markers(), sound.get$currentMarker())))) + " Stop: ", J.toString$0(J.get$stop$x(J.$index$asx(sound.get$markers(), sound.get$currentMarker())))));
        this.line$1(C.JSString_methods.$add("Position: ", J.toString$0(t1.get$position(sound))));
      }
      this.stop$0(0);
    }, function(sound, x, y) {
      return this.soundInfo$4(sound, x, y, "rgb(255,255,255)");
    }, "soundInfo$3", "call$4", "call$3", "get$soundInfo", 6, 2, 1648, 1645, 1129, [], 6, [], 7, [], 114, [], "soundInfo"],
    cameraInfo$4: [function(camera, x, y, color) {
      var t1;
      this.start$3(0, x, y, color);
      t1 = J.getInterceptor$x(camera);
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Camera (", J.toString$0(t1.get$width(camera))) + " x ", J.toString$0(t1.get$height(camera))) + ")");
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("X: ", J.toString$0(t1.get$x(camera))) + " Y: ", J.toString$0(t1.get$y(camera))));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("Bounds x: ", J.toString$0(J.get$x$x(camera.get$bounds()))) + " Y: ", J.toString$0(J.get$y$x(camera.get$bounds()))) + " w: ", J.toString$0(J.get$width$x(camera.get$bounds()))) + " h: ", J.toString$0(J.get$height$x(camera.get$bounds()))));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add(C.JSString_methods.$add("View x: ", J.toString$0(J.get$x$x(t1.get$view(camera)))) + " Y: ", J.toString$0(J.get$y$x(t1.get$view(camera)))) + " w: ", J.toString$0(J.get$width$x(t1.get$view(camera)))) + " h: ", J.toString$0(J.get$height$x(t1.get$view(camera)))));
      this.stop$0(0);
    }, function(camera, x, y) {
      return this.cameraInfo$4(camera, x, y, "rgb(255,255,255)");
    }, "cameraInfo$3", "call$4", "call$3", "get$cameraInfo", 6, 2, 1649, 1645, 1650, [], 6, [], 7, [], 114, [], "cameraInfo"],
    timer$4: [function(timer, x, y, color) {
      var t1;
      this.start$3(0, x, y, color);
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Timer (running: ", J.toString$0(timer.get$running())) + " expired: ", J.toString$0(timer.get$expired())) + ")");
      t1 = J.getInterceptor$x(timer);
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Next Tick: ", J.toString$0(timer.get$next())) + " Duration: ", J.toString$0(t1.get$duration(timer))));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Paused: ", J.toString$0(t1.get$paused(timer))) + " Length: ", J.toString$0(t1.get$length(timer))));
      this.stop$0(0);
    }, function(timer, x, y) {
      return this.timer$4(timer, x, y, "rgb(255,255,255)");
    }, "timer$3", "call$4", "call$3", "get$timer", 6, 2, 1651, 1645, 472, [], 6, [], 7, [], 114, [], "timer"],
    pointer$5: [function(pointer, hideIfUp, downColor, upColor, color) {
      var t1, t2, t3;
      if (pointer == null)
        return;
      if (J.$eq(hideIfUp, true) && J.$eq(pointer.get$isUp(), true))
        return;
      t1 = J.getInterceptor$x(pointer);
      this.start$3(0, t1.get$x(pointer), J.$sub$n(t1.get$y(pointer), 100), color);
      J.beginPath$0$x(this.context);
      J.arc$5$x(this.context, t1.get$x(pointer), t1.get$y(pointer), pointer.get$circle().get$radius(), 0, 6.283185307179586);
      t2 = pointer.get$active();
      t3 = this.context;
      if (t2 === true)
        J.set$fillStyle$x(t3, downColor);
      else
        J.set$fillStyle$x(t3, upColor);
      J.fill$0$x(this.context);
      J.closePath$0$x(this.context);
      J.beginPath$0$x(this.context);
      J.moveTo$2$x(this.context, J.get$x$x(pointer.get$positionDown()), J.get$y$x(pointer.get$positionDown()));
      J.lineTo$2$x(this.context, J.get$x$x(t1.get$position(pointer)), J.get$y$x(t1.get$position(pointer)));
      J.set$lineWidth$x(this.context, 2);
      J.stroke$0$x(this.context);
      J.closePath$0$x(this.context);
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("ID: ", J.toString$0(t1.get$id(pointer))) + " Active: ", J.toString$0(pointer.get$active())));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("World X: ", J.toString$0(pointer.get$worldX())) + " World Y: ", J.toString$0(pointer.get$worldY())));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Screen X: ", J.toString$0(t1.get$x(pointer))) + " Screen Y: ", J.toString$0(t1.get$y(pointer))));
      this.line$1(C.JSString_methods.$add("Duration: ", J.toString$0(t1.get$duration(pointer))) + " ms");
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("is Down: ", J.toString$0(pointer.get$isDown())) + " is Up: ", J.toString$0(pointer.get$isUp())));
      this.stop$0(0);
    }, function(pointer) {
      return this.pointer$5(pointer, false, "rgba(0,255,0,0.5)", "rgba(255,0,0,0.5)", "rgb(255,255,255)");
    }, "pointer$1", function(pointer, hideIfUp) {
      return this.pointer$5(pointer, hideIfUp, "rgba(0,255,0,0.5)", "rgba(255,0,0,0.5)", "rgb(255,255,255)");
    }, "pointer$2", function(pointer, hideIfUp, downColor) {
      return this.pointer$5(pointer, hideIfUp, downColor, "rgba(255,0,0,0.5)", "rgb(255,255,255)");
    }, "pointer$3", function(pointer, hideIfUp, downColor, upColor) {
      return this.pointer$5(pointer, hideIfUp, downColor, upColor, "rgb(255,255,255)");
    }, "pointer$4", "call$5", "call$1", "call$2", "call$3", "call$4", "get$pointer", 2, 8, 1652, 95, 1653, 1654, 1645, 994, [], 1655, [], 1656, [], 1657, [], 114, [], "pointer"],
    spriteInputInfo$4: [function(sprite, x, y, color) {
      var t1;
      this.start$3(0, x, y, color);
      t1 = J.getInterceptor$x(sprite);
      this.line$1(["Sprite Input: (" + H.S(t1.get$width(sprite)) + " x " + H.S(t1.get$height(sprite)) + ")"]);
      this.line$1("x: " + J.toStringAsFixed$1$n(sprite.get$input().pointerX$0(), 1) + "  y: " + J.toStringAsFixed$1$n(sprite.get$input().pointerY$0(), 1));
      this.line$1(["over: " + H.S(sprite.get$input().pointerOver$0()) + " duration: " + J.toStringAsFixed$1$n(sprite.get$input().overDuration$0(), 0)]);
      this.line$1(["down: " + H.S(sprite.get$input().pointerDown$0()) + " duration: " + J.toStringAsFixed$1$n(sprite.get$input().downDuration$0(), 0)]);
      this.line$1(["just over: " + sprite.get$input().justOver$0() + " just out: " + sprite.get$input().justOut$0()]);
      this.stop$0(0);
    }, function(sprite, x, y) {
      return this.spriteInputInfo$4(sprite, x, y, "rgb(255,255,255)");
    }, "spriteInputInfo$3", "call$4", "call$3", "get$spriteInputInfo", 6, 2, 1658, 1645, 113, [], 6, [], 7, [], 114, [], "spriteInputInfo"],
    key$4: [function(_, key, x, y, color) {
      var t1;
      this.start$4(0, x, y, color, 150);
      t1 = J.getInterceptor$x(key);
      this.line$1(["Key:", t1.get$keyCode(key), "isDown:", key.get$isDown()]);
      this.line$1(["justPressed:", String(key.justPressed$0()), "justReleased:", String(key.justReleased$0())]);
      this.line$1(["Time Down:", J.toStringAsFixed$1$n(key.get$timeDown(), 0), "duration:", J.toStringAsFixed$1$n(t1.get$duration(key), 0)]);
      this.stop$0(0);
    }, function($receiver, key, x, y) {
      return this.key$4($receiver, key, x, y, "rgb(255,255,255)");
    }, "key$3", "call$4", "call$3", "get$key", 6, 2, 1659, 1645, 231, [], 6, [], 7, [], 114, [], "key"],
    inputInfo$3: [function(x, y, color) {
      this.start$3(0, x, y, color);
      this.line$1("Input");
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("X: ", J.toString$0(J.get$x$x(this.game.get$input()))) + " Y: ", J.toString$0(J.get$y$x(this.game.get$input()))));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("World X: ", J.toString$0(this.game.get$input().get$worldX())) + " World Y: ", J.toString$0(this.game.get$input().get$worldY())));
      this.line$1("Scale X: " + J.toStringAsFixed$1$n(J.get$x$x(J.get$scale$x(this.game.get$input())), 1) + " Scale Y: " + J.toStringAsFixed$1$n(J.get$x$x(J.get$scale$x(this.game.get$input())), 1));
      this.line$1(C.JSString_methods.$add(C.JSString_methods.$add("Screen X: ", J.toString$0(J.get$screenX$x(this.game.get$input().get$activePointer()))) + " Screen Y: ", J.toString$0(J.get$screenY$x(this.game.get$input().get$activePointer()))));
      this.stop$0(0);
    }, function(x, y) {
      return this.inputInfo$3(x, y, "rgb(255,255,255)");
    }, "inputInfo$2", "call$3", "call$2", "get$inputInfo", 4, 2, 1660, 1645, 6, [], 7, [], 114, [], "inputInfo"],
    spriteBounds$3: [function(sprite, color, filled) {
      var bounds, t1, t2;
      bounds = sprite.getBounds$0();
      t1 = J.getInterceptor$x(bounds);
      t1.set$x(bounds, J.$add$ns(t1.get$x(bounds), J.get$x$x(this.game.get$camera())));
      t1.set$y(bounds, J.$add$ns(t1.get$y(bounds), J.get$y$x(this.game.get$camera())));
      this.start$0(0);
      t2 = this.context;
      if (filled === true) {
        J.set$fillStyle$x(t2, color);
        J.fillRect$4$x(this.context, J.$sub$n(t1.get$x(bounds), J.get$x$x(this.game.get$camera())), J.$sub$n(t1.get$y(bounds), J.get$y$x(this.game.get$camera())), t1.get$width(bounds), t1.get$height(bounds));
      } else {
        J.set$strokeStyle$x(t2, color);
        J.strokeRect$4$x(this.context, J.$sub$n(t1.get$x(bounds), J.get$x$x(this.game.get$camera())), J.$sub$n(t1.get$y(bounds), J.get$y$x(this.game.get$camera())), t1.get$width(bounds), t1.get$height(bounds));
      }
      this.stop$0(0);
    }, function(sprite) {
      return this.spriteBounds$3(sprite, "rgba(255,255,255,0.2)", true);
    }, "spriteBounds$1", function(sprite, color) {
      return this.spriteBounds$3(sprite, color, true);
    }, "spriteBounds$2", "call$3", "call$1", "call$2", "get$spriteBounds", 2, 4, 606, 1661, 39, 113, [], 114, [], 608, [], "spriteBounds"],
    spriteInfo$4: [function(sprite, x, y, color) {
      var t1;
      this.start$3(0, x, y, color);
      t1 = J.getInterceptor$x(sprite);
      this.line$1("Sprite: " + (" (" + H.S(t1.get$width(sprite)) + " x " + H.S(t1.get$height(sprite)) + ") anchor: " + H.S(J.get$x$x(sprite.get$anchor())) + " x " + H.S(J.get$y$x(sprite.get$anchor()))));
      this.line$1("x: " + J.toStringAsFixed$1$n(t1.get$x(sprite), 1) + " y: " + J.toStringAsFixed$1$n(t1.get$y(sprite), 1));
      this.line$1("angle: " + J.toStringAsFixed$1$n(sprite.get$angle(), 1) + " rotation: " + J.toStringAsFixed$1$n(sprite.get$rotation(), 1));
      this.line$1("visible: " + H.S(sprite.get$visible()) + " in camera: " + H.S(sprite.get$inCamera()));
      this.stop$0(0);
    }, function(sprite, x, y) {
      return this.spriteInfo$4(sprite, x, y, "rgb(255,255,255)");
    }, "spriteInfo$3", "call$4", "call$3", "get$spriteInfo", 6, 2, 1662, 1645, 113, [], 6, [], 7, [], 114, [], "spriteInfo"],
    spriteCoords$4: [function(sprite, x, y, color) {
      var t1;
      this.start$4(0, x, y, color, 100);
      t1 = J.getInterceptor$x(sprite);
      if (t1.get$name(sprite) != null)
        this.line$1(t1.get$name(sprite));
      this.line$1(["x:", J.toStringAsFixed$1$n(t1.get$x(sprite), 2), "y:", J.toStringAsFixed$1$n(t1.get$y(sprite), 2)]);
      this.line$1(["pos x:", J.toStringAsFixed$1$n(J.get$x$x(t1.get$position(sprite)), 2), "pos y:", J.toStringAsFixed$1$n(J.get$y$x(t1.get$position(sprite)), 2)]);
      this.line$1(["world x:", J.toStringAsFixed$1$n(J.get$x$x(sprite.get$world()), 2), "world y:", J.toStringAsFixed$1$n(J.get$y$x(sprite.get$world()), 2)]);
      this.stop$0(0);
    }, function(sprite, x, y) {
      return this.spriteCoords$4(sprite, x, y, "rgb(255,255,255)");
    }, "spriteCoords$3", "call$4", "call$3", "get$spriteCoords", 6, 2, 1658, 1645, 113, [], 6, [], 7, [], 114, [], "spriteCoords"],
    lineInfo$4: [function(line, x, y, color) {
      var t1;
      this.start$4(0, x, y, color, 80);
      t1 = J.getInterceptor$x(line);
      this.line$1(["start.x:", J.toStringAsFixed$1$n(J.get$x$x(t1.get$start(line)), 2), "start.y:", J.toStringAsFixed$1$n(J.get$y$x(t1.get$start(line)), 2)]);
      this.line$1(["end.x:", J.toStringAsFixed$1$n(J.get$x$x(line.get$end()), 2), "end.y:", J.toStringAsFixed$1$n(J.get$y$x(line.get$end()), 2)]);
      this.line$1(["length:", J.toStringAsFixed$1$n(t1.get$length(line), 2), "angle:", line.get$angle()]);
      this.stop$0(0);
    }, function(line, x, y) {
      return this.lineInfo$4(line, x, y, "rgb(255,255,255)");
    }, "lineInfo$3", "call$4", "call$3", "get$lineInfo", 6, 2, 1663, 1645, 1197, [], 6, [], 7, [], 114, [], "lineInfo"],
    pixel$4: [function(x, y, color, size) {
      this.start$0(0);
      J.set$fillStyle$x(this.context, color);
      J.fillRect$4$x(this.context, x, y, size, size);
      this.stop$0(0);
    }, function(x, y) {
      return this.pixel$4(x, y, "rgba(0,255,0,0.4)", 2);
    }, "pixel$2", function(x, y, color) {
      return this.pixel$4(x, y, color, 2);
    }, "pixel$3", "call$4", "call$2", "call$3", "get$pixel", 4, 4, 1664, 607, 398, 6, [], 7, [], 114, [], 270, [], "pixel"],
    geom$4: [function(object, color, filled, forceType) {
      var t1, t2;
      this.start$0(0);
      J.set$fillStyle$x(this.context, color);
      J.set$strokeStyle$x(this.context, color);
      t1 = J.getInterceptor(object);
      if (!!t1.$isRectangle1 || J.$eq(forceType, 1)) {
        t2 = this.context;
        if (filled === true)
          J.fillRect$4$x(t2, J.$sub$n(t1.get$x(object), J.get$x$x(this.game.get$camera())), J.$sub$n(t1.get$y(object), J.get$y$x(this.game.get$camera())), t1.get$width(object), t1.get$height(object));
        else
          J.strokeRect$4$x(t2, J.$sub$n(t1.get$x(object), J.get$x$x(this.game.get$camera())), J.$sub$n(t1.get$y(object), J.get$y$x(this.game.get$camera())), t1.get$width(object), t1.get$height(object));
      } else if (!!t1.$isCircle0 || J.$eq(forceType, 2)) {
        J.beginPath$0$x(this.context);
        J.arc$6$x(this.context, J.$sub$n(t1.get$x(object), J.get$x$x(this.game.get$camera())), J.$sub$n(t1.get$y(object), J.get$y$x(this.game.get$camera())), object.get$radius(), 0, 6.283185307179586, false);
        J.closePath$0$x(this.context);
        t1 = this.context;
        if (filled === true)
          J.fill$0$x(t1);
        else
          J.stroke$0$x(t1);
      } else if (!!t1.$isPoint || J.$eq(forceType, 3))
        J.fillRect$4$x(this.context, J.$sub$n(t1.get$x(object), J.get$x$x(this.game.get$camera())), J.$sub$n(t1.get$y(object), J.get$y$x(this.game.get$camera())), 4, 4);
      else if (!!t1.$isLine || J.$eq(forceType, 4)) {
        J.set$lineWidth$x(this.context, 1);
        J.beginPath$0$x(this.context);
        J.moveTo$2$x(this.context, J.$sub$n(J.$add$ns(J.get$x$x(t1.get$start(object)), 0.5), J.get$x$x(this.game.get$camera())), J.$sub$n(J.$add$ns(J.get$y$x(t1.get$start(object)), 0.5), J.get$y$x(this.game.get$camera())));
        J.lineTo$2$x(this.context, J.$sub$n(J.$add$ns(J.get$x$x(object.get$end()), 0.5), J.get$x$x(this.game.get$camera())), J.$sub$n(J.$add$ns(J.get$y$x(object.get$end()), 0.5), J.get$y$x(this.game.get$camera())));
        J.closePath$0$x(this.context);
        J.stroke$0$x(this.context);
      }
      this.stop$0(0);
    }, function(object) {
      return this.geom$4(object, "rgba(0,255,0,0.4)", true, 0);
    }, "geom$1", function(object, color) {
      return this.geom$4(object, color, true, 0);
    }, "geom$2", function(object, color, filled) {
      return this.geom$4(object, color, filled, 0);
    }, "geom$3", "call$4", "call$1", "call$2", "call$3", "get$geom", 2, 6, 1665, 607, 39, 5, 541, [], 114, [], 608, [], 1666, [], "geom"],
    rectangle$3: [function(object, color, filled) {
      var t1, t2;
      this.start$0(0);
      t1 = this.context;
      t2 = J.getInterceptor$x(object);
      if (filled === true) {
        J.set$fillStyle$x(t1, color);
        J.fillRect$4$x(this.context, J.$sub$n(t2.get$x(object), J.get$x$x(this.game.get$camera())), J.$sub$n(t2.get$y(object), J.get$y$x(this.game.get$camera())), t2.get$width(object), t2.get$height(object));
      } else {
        J.set$strokeStyle$x(t1, color);
        J.strokeRect$4$x(this.context, J.$sub$n(t2.get$x(object), J.get$x$x(this.game.get$camera())), J.$sub$n(t2.get$y(object), J.get$y$x(this.game.get$camera())), t2.get$width(object), t2.get$height(object));
      }
      this.stop$0(0);
    }, function(object) {
      return this.rectangle$3(object, "rgba(0, 255, 0, 0.4)", true);
    }, "rectangle$1", function(object, color) {
      return this.rectangle$3(object, color, true);
    }, "rectangle$2", "call$3", "call$1", "call$2", "get$rectangle", 2, 4, 1667, 1668, 39, 541, [], 114, [], 608, [], "rectangle"],
    text$5: [function(_, text, x, y, color, font) {
      this.start$0(0);
      J.set$font$x(this.context, font);
      if (this.renderShadow === true) {
        J.set$fillStyle$x(this.context, "rgb(0,0,0)");
        J.fillText$3$x(this.context, text, J.$add$ns(x, 1), J.$add$ns(y, 1));
      }
      J.set$fillStyle$x(this.context, color);
      J.fillText$3$x(this.context, text, x, y);
      this.stop$0(0);
    }, function($receiver, text, x, y, color) {
      return this.text$5($receiver, text, x, y, color, "16px Courier");
    }, "text$4", function($receiver, text, x, y) {
      return this.text$5($receiver, text, x, y, "rgb(255,255,255)", "16px Courier");
    }, "text$3", "call$5", "call$4", "call$3", "get$text", 6, 4, 1669, 1645, 1670, 85, [], 6, [], 7, [], 114, [], 163, [], "text"],
    quadTree$2: [function(quadtree, color) {
      var bounds, t1, i, t2;
      this.start$0(0);
      bounds = quadtree.get$bounds();
      t1 = J.getInterceptor$x(quadtree);
      if (J.$index$asx(t1.get$nodes(quadtree), 0) == null) {
        J.set$strokeStyle$x(this.context, color);
        t1 = J.getInterceptor$x(bounds);
        J.strokeRect$4$x(this.context, t1.get$x(bounds), t1.get$y(bounds), t1.get$width(bounds), t1.get$height(bounds));
        this.text$5(0, C.JSString_methods.$add("size: ", J.toString$0(J.get$length$asx(quadtree.get$objects()))), J.$add$ns(t1.get$x(bounds), 4), J.$add$ns(t1.get$y(bounds), 16), "rgb(0,200,0)", "12px Courier");
        J.set$strokeStyle$x(this.context, "rgb(0,255,0)");
        i = 0;
        while (true) {
          t1 = J.get$length$asx(quadtree.get$objects());
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          J.strokeRect$4$x(this.context, J.get$x$x(J.$index$asx(quadtree.get$objects(), i)), J.get$y$x(J.$index$asx(quadtree.get$objects(), i)), J.get$width$x(J.$index$asx(quadtree.get$objects(), i)), J.get$height$x(J.$index$asx(quadtree.get$objects(), i)));
          ++i;
        }
      } else {
        i = 0;
        while (true) {
          t2 = J.get$length$asx(t1.get$nodes(quadtree));
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          this.quadTree$1(J.$index$asx(t1.get$nodes(quadtree), i));
          ++i;
        }
      }
      this.stop$0(0);
    }, function(quadtree) {
      return this.quadTree$2(quadtree, "rgba(255,0,0,0.3)");
    }, "quadTree$1", "call$2", "call$1", "get$quadTree", 2, 2, 1671, 1672, 1673, [], 114, [], "quadTree"],
    body$3: [function(_, sprite, color, filled) {
      var t1 = J.getInterceptor$x(sprite);
      if (t1.get$body(sprite) != null)
        if (J.$eq(J.get$type$x(t1.get$body(sprite)), 0) || J.$eq(J.get$type$x(t1.get$body(sprite)), 2)) {
          this.start$0(0);
          t1.get$body(sprite).render$3(this.context, color, filled);
          this.stop$0(0);
        }
    }, function($receiver, sprite) {
      return this.body$3($receiver, sprite, "rgba(0,255,0,0.4)", true);
    }, "body$1", function($receiver, sprite, color) {
      return this.body$3($receiver, sprite, color, true);
    }, "body$2", "call$3", "call$1", "call$2", "get$body", 2, 4, 1674, 607, 39, 113, [], 114, [], 608, [], "body"],
    bodyInfo$4: [function(sprite, x, y, color) {
      var t1 = J.getInterceptor$x(sprite);
      if (t1.get$body(sprite) != null)
        if (J.$eq(J.get$type$x(t1.get$body(sprite)), 0)) {
          this.start$4(0, x, y, color, 210);
          t1.get$body(sprite).renderBodyInfo$1(this);
          this.stop$0(0);
        }
    }, "call$4", "get$bodyInfo", 8, 0, 1675, 113, [], 6, [], 7, [], 114, [], "bodyInfo"],
    Debug$1: function(game) {
      this.sprite = null;
      this.canvas = null;
      this.baseTexture = null;
      this.texture = null;
      this.textureFrame = null;
      this.context = null;
      this.font = "14px Courier";
      this.columnWidth = 100;
      this.lineHeight = 16;
      this.renderShadow = true;
      this.currentX = 0;
      this.currentY = 0;
      this.currentAlpha = 1;
      this.dirty = false;
    },
    static: {Debug$: [function(game) {
        var t1 = new R.Debug(game, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1.Debug$1(game);
        return t1;
      }, null, null, 2, 0, 258, 214, [], "new Debug"]}
  },
  "+Debug": [632],
  Utils: {
    "^": "Object;",
    static: {Utils$: [function() {
        return new R.Utils();
      }, null, null, 0, 0, 13, "new Utils"], Utils_transposeArray: [function(array) {
        var t1, t2, result, i, t3, j;
        t1 = J.getInterceptor$asx(array);
        t2 = J.get$length$asx(t1.$index(array, 0));
        if (typeof t2 !== "number")
          return H.iae(t2);
        result = Array(t2);
        result.fixed$length = init;
        t2 = result.length;
        i = 0;
        while (true) {
          t3 = J.get$length$asx(t1.$index(array, 0));
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          t3 = J.$sub$n(t1.get$length(array), 1);
          if (typeof t3 !== "number")
            return H.iae(t3);
          t3 = Array(t3);
          t3.fixed$length = init;
          if (i >= t2)
            return H.ioore(result, i);
          result[i] = t3;
          for (j = J.$sub$n(t1.get$length(array), 1); t3 = J.getInterceptor$n(j), t3.$gt(j, -1); j = t3.$sub(j, 1))
            J.$indexSet$ax(result[i], j, J.$index$asx(t1.$index(array, j), i));
          ++i;
        }
        return result;
      }, "call$1", "Utils_transposeArray$closure", 2, 0, 535, 15, [], "transposeArray"], Utils_rotateArray: [function(matrix, direction) {
        var t1, i, t2;
        if (typeof direction !== "string")
          direction = C.JSNumber_methods.$mod(J.$mod$n(direction, 360) + 360, 360);
        t1 = J.getInterceptor(direction);
        if (t1.$eq(direction, 90) || t1.$eq(direction, -270) || t1.$eq(direction, "rotateLeft")) {
          matrix = R.Utils_transposeArray(matrix);
          matrix = H.setRuntimeTypeInfo(new H.ReversedListIterable(matrix), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(matrix, 0)]), 0)]).toList$0(0);
        } else if (t1.$eq(direction, -90) || t1.$eq(direction, 270) || t1.$eq(direction, "rotateRight"))
          matrix = R.Utils_transposeArray(J.toList$0$ax(J.get$reversed$ax(matrix)));
        else if (J.$eq(t1.abs$0(direction), 180) || t1.$eq(direction, "rotate180")) {
          t1 = J.getInterceptor$asx(matrix);
          i = 0;
          while (true) {
            t2 = t1.get$length(matrix);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            J.toList$0$ax(J.get$reversed$ax(t1.$index(matrix, i)));
            ++i;
          }
          matrix = J.toList$0$ax(t1.get$reversed(matrix));
        }
        return matrix;
      }, "call$2", "Utils_rotateArray$closure", 4, 0, 536, 537, [], 538, [], "rotateArray"], Utils_parseDimension: [function(size, dimension) {
        var f, t1, px;
        if (typeof size === "string")
          if (C.JSString_methods.substring$1(size, size.length - 1) === "%") {
            f = J.$div$n(H.Primitives_parseInt(size, null, null), 100);
            if (J.$eq(dimension, 0)) {
              t1 = window.innerWidth;
              if (typeof t1 !== "number")
                return t1.$mul();
              if (typeof f !== "number")
                return H.iae(f);
              px = t1 * f;
            } else {
              t1 = window.innerHeight;
              if (typeof t1 !== "number")
                return t1.$mul();
              if (typeof f !== "number")
                return H.iae(f);
              px = t1 * f;
            }
          } else
            px = H.Primitives_parseInt(size, null, null);
        else
          px = size;
        return px;
      }, "call$2", "Utils_parseDimension$closure", 4, 0, 539, 270, [], 540, [], "parseDimension"], Utils_shuffle: [function(array) {
        var t1 = P.List_List$from(array, true, null);
        H.IterableMixinWorkaround_shuffleList(t1, null);
        return t1;
      }, "call$1", "Utils_shuffle$closure", 2, 0, 396, 15, [], "shuffle"]}
  },
  "+Utils": [632],
  "^": "POINTER<-599,RETROFONT<-599,SPRITEBATCH<-599,ELLIPSE<-599,WEBGL_FILTER<-599,CANVAS_FILTER<-599,BITMAPDATA<-599,POLYGON<-599,EMITTER<-599,TILEMAPLAYER<-599,TILEMAP<-599,RENDERTEXTURE<-599,GROUP<-599,BITMAPTEXT<-599,TILESPRITE<-599,TEXT<-599,GRAPHICS<-599,IMAGE<-599,BUTTON<-599,SPRITE<-599,DOWN<-599,UP<-599,RIGHT<-599,LEFT<-599,NONE<-599,HEADLESS<-599,WEBGL<-599,CANVAS<-599,AUTO<-599,GAMES<-1714,VERSION0<-639",
  Creator: {"^": ":281;"},
  "+Creator": "",
  SelectWhere: {"^": ":979;"},
  "+SelectWhere": "",
  ScreenFunc: {"^": ":1715;"},
  "+ScreenFunc": "",
  ResizeFunc: {"^": ":570;"},
  "+ResizeFunc": "",
  GameFunc: {"^": ":550;"},
  "+GameFunc": "",
  GameObjectFunc: {"^": ":1716;"},
  "+GameObjectFunc": "",
  InputFunc: {"^": ":1717;"},
  "+InputFunc": "",
  InputUpFunc: {"^": ":1718;"},
  "+InputUpFunc": "",
  GroupFunc: {"^": ":1719;"},
  "+GroupFunc": "",
  AnimationFunc: {"^": ":1720;"},
  "+AnimationFunc": "",
  PointerFunc: {"^": ":1721;"},
  "+PointerFunc": "",
  KeyFunc: {"^": ":1722;"},
  "+KeyFunc": "",
  LoaderStartFunc: {"^": ":583;"},
  "+LoaderStartFunc": "",
  FileStartFunc: {"^": ":1723;"},
  "+FileStartFunc": "",
  FileCompleteFunc: {"^": ":1724;"},
  "+FileCompleteFunc": "",
  FileError0: {"^": ":1725;"},
  "+FileError": "",
  PackCompleteFunc: {"^": ":1726;"},
  "+PackCompleteFunc": "",
  doubleFunc: {"^": ":1337;"},
  "+doubleFunc": "",
  CollideFunc: {"^": ":1727;"},
  "+CollideFunc": "",
  ProcessFunc: {"^": ":1728;"},
  "+ProcessFunc": "",
  SoundFunc: {"^": ":1729;"},
  "+SoundFunc": "",
  TimerFunc: {"^": ":1730;"},
  "+TimerFunc": "",
  EasingFunction: {"^": ":1629;"},
  "+EasingFunction": ""
}],
["_foreign_helper", "dart:_foreign_helper", , H, {
  "^": "",
  JS_CONST: {
    "^": "Object;code"
  }
}],
["_interceptors", "dart:_interceptors", , J, {
  "^": "",
  getInterceptor: function(object) {
    return void 0;
  },
  makeDispatchRecord: function(interceptor, proto, extension, indexability) {
    return {i: interceptor, p: proto, e: extension, x: indexability};
  },
  getNativeInterceptor: function(object) {
    var record, proto, objectProto, interceptor;
    record = object[init.dispatchPropertyName];
    if (record == null)
      if ($.initNativeDispatchFlag == null) {
        H.initNativeDispatch();
        record = object[init.dispatchPropertyName];
      }
    if (record != null) {
      proto = record.p;
      if (false === proto)
        return record.i;
      if (true === proto)
        return object;
      objectProto = Object.getPrototypeOf(object);
      if (proto === objectProto)
        return record.i;
      if (record.e === objectProto)
        throw H.wrapException(P.UnimplementedError$("Return interceptor for " + H.S(proto(object, record))));
    }
    interceptor = H.lookupAndCacheInterceptor(object);
    if (interceptor == null) {
      proto = Object.getPrototypeOf(object);
      if (proto == null || proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      else
        return C.UnknownJavaScriptObject_methods;
    }
    return interceptor;
  },
  Interceptor: {
    "^": "Object;",
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: function(receiver) {
      return H.Primitives_objectToString(receiver);
    },
    noSuchMethod$1: [function(receiver, invocation) {
      throw H.wrapException(P.NoSuchMethodError$(receiver, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments(), null));
    }, "call$1", "get$noSuchMethod", 2, 0, null, 1676, []],
    get$runtimeType: function(receiver) {
      return new H.TypeImpl(H.getRuntimeTypeString(receiver), null);
    },
    "%": "CanvasGradient|CanvasPattern|MediaError|MediaKeyError|PositionError|SQLError|SVGAnimatedEnumeration|SVGAnimatedLength|SVGAnimatedLengthList|SVGAnimatedNumber|SVGAnimatedNumberList|SVGAnimatedString|SVGAnimatedTransformList|WebGLBuffer|WebGLFramebuffer|WebGLProgram|WebGLRenderbuffer|WebGLShader|WebGLTexture"
  },
  JSBool: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    },
    get$runtimeType: function(receiver) {
      return C.Type_EsU;
    },
    $isbool: true
  },
  JSNull: {
    "^": "Interceptor;",
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    },
    get$runtimeType: function(receiver) {
      return C.Type_eZO;
    },
    noSuchMethod$1: [function(receiver, invocation) {
      return J.Interceptor.prototype.noSuchMethod$1.call(this, receiver, invocation);
    }, "call$1", "get$noSuchMethod", 2, 0, null, 1676, []]
  },
  JavaScriptObject: {
    "^": "Interceptor;",
    get$hashCode: function(_) {
      return 0;
    },
    get$runtimeType: function(_) {
      return C.Type_XXD;
    }
  },
  PlainJavaScriptObject: {
    "^": "JavaScriptObject;"
  },
  UnknownJavaScriptObject: {
    "^": "JavaScriptObject;",
    toString$0: function(receiver) {
      return String(receiver);
    }
  },
  JSArray: {
    "^": "Interceptor;",
    add$1: [function(receiver, value) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("add"));
      receiver.push(value);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E", void: true, args: [E]};
      }, this.$receiver, "JSArray");
    }, 100, []],
    removeAt$1: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index < 0 || index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeAt"));
      return receiver.splice(index, 1)[0];
    },
    insert$2: function(receiver, index, value) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index < 0 || index > receiver.length)
        throw H.wrapException(P.RangeError$value(index));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("insert"));
      receiver.splice(index, 0, value);
    },
    removeLast$0: function(receiver) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeLast"));
      if (receiver.length === 0)
        throw H.wrapException(P.RangeError$value(-1));
      return receiver.pop();
    },
    remove$1: function(receiver, element) {
      var i;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("remove"));
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    where$1: function(receiver, f) {
      return H.setRuntimeTypeInfo(new H.WhereIterable(receiver, f), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(receiver, 0)]), 0)]);
    },
    addAll$1: function(receiver, collection) {
      var t1;
      for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
        this.add$1(receiver, t1.get$current());
    },
    clear$0: function(receiver) {
      this.set$length(receiver, 0);
    },
    forEach$1: function(receiver, f) {
      return H.IterableMixinWorkaround_forEach(receiver, f);
    },
    map$1: [function(receiver, f) {
      return H.setRuntimeTypeInfo(new H.MappedListIterable(receiver, f), [null, null]);
    }, "call$1", "get$map", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "Iterable__dynamic__E", ret: P.Iterable, args: [{func: "dynamic__E", args: [E]}]};
      }, this.$receiver, "JSArray");
    }],
    join$1: function(receiver, separator) {
      var t1, list, i, t2;
      t1 = receiver.length;
      list = Array(t1);
      list.fixed$length = init;
      for (i = 0; i < receiver.length; ++i) {
        t2 = H.S(receiver[i]);
        if (i >= t1)
          return H.ioore(list, i);
        list[i] = t2;
      }
      return list.join(separator);
    },
    fold$2: function(receiver, initialValue, combine) {
      return H.IterableMixinWorkaround_fold(receiver, initialValue, combine);
    },
    firstWhere$2$orElse: function(receiver, test, orElse) {
      return H.IterableMixinWorkaround_firstWhere(receiver, test, orElse);
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      if (start == null)
        H.throwExpression(P.ArgumentError$(null));
      if (typeof start !== "number" || Math.floor(start) !== start)
        throw H.wrapException(P.ArgumentError$(start));
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length));
      if (end == null)
        end = receiver.length;
      else {
        if (typeof end !== "number" || Math.floor(end) !== end)
          throw H.wrapException(P.ArgumentError$(end));
        if (end < start || end > receiver.length)
          throw H.wrapException(P.RangeError$range(end, start, receiver.length));
      }
      if (start === end)
        return H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
      return H.setRuntimeTypeInfo(receiver.slice(start, end), [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    getRange$2: function(receiver, start, end) {
      var t1 = H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(receiver, 0)]);
      H.IterableMixinWorkaround__rangeCheck(receiver, start, end);
      return H.SubListIterable$(receiver, start, end, H.getTypeArgumentByIndex(t1, 0));
    },
    get$last: function(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return receiver[t1 - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    removeRange$2: function(receiver, start, end) {
      var receiverLength, t1;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeRange"));
      receiverLength = receiver.length;
      t1 = J.getInterceptor$n(start);
      if (t1.$lt(start, 0) || t1.$gt(start, receiverLength))
        throw H.wrapException(P.RangeError$range(start, 0, receiverLength));
      t1 = J.getInterceptor$n(end);
      if (t1.$lt(end, start) || t1.$gt(end, receiverLength))
        throw H.wrapException(P.RangeError$range(end, start, receiverLength));
      if (typeof end !== "number")
        return H.iae(end);
      H.Lists_copy(receiver, end, receiver, start, receiverLength - end);
      if (typeof start !== "number")
        return H.iae(start);
      this.set$length(receiver, receiverLength - (end - start));
    },
    any$1: [function(receiver, f) {
      return H.IterableMixinWorkaround_any(receiver, f);
    }, "call$1", "get$any", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__bool__E", ret: P.bool, args: [{func: "bool__E", ret: P.bool, args: [E]}]};
      }, this.$receiver, "JSArray");
    }],
    get$reversed: function(receiver) {
      return H.setRuntimeTypeInfo(new H.ReversedListIterable(receiver), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(receiver, 0)]), 0)]);
    },
    sort$1: function(receiver, compare) {
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("sort"));
      if (compare == null)
        compare = P.Comparable_compare$closure();
      H.Sort__doSort(receiver, 0, receiver.length - 1, compare);
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    indexOf$2: function(receiver, element, start) {
      return H.Lists_indexOf(receiver, element, start, receiver.length);
    },
    indexOf$1: function($receiver, element) {
      return this.indexOf$2($receiver, element, 0);
    },
    contains$1: [function(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], other))
          return true;
      return false;
    }, "call$1", "get$contains", 2, 0, 1677],
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    toList$1$growable: function(receiver, growable) {
      var t1;
      if (growable)
        return H.setRuntimeTypeInfo(receiver.slice(), [H.getTypeArgumentByIndex(receiver, 0)]);
      else {
        t1 = H.setRuntimeTypeInfo(receiver.slice(), [H.getTypeArgumentByIndex(receiver, 0)]);
        t1.fixed$length = init;
        return t1;
      }
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$iterator: function(receiver) {
      return H.setRuntimeTypeInfo(new H.ListIterator(receiver, receiver.length, 0, null), [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    set$length: function(receiver, newLength) {
      if (typeof newLength !== "number" || Math.floor(newLength) !== newLength)
        throw H.wrapException(P.ArgumentError$(newLength));
      if (newLength < 0)
        throw H.wrapException(P.RangeError$value(newLength));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("set length"));
      receiver.length = newLength;
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("indexed set"));
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      receiver[index] = value;
    },
    $isJSArray: true,
    $isJSIndexable: true,
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  JSMutableArray: {
    "^": "JSArray;",
    $isJSMutableArray: true,
    $isJSIndexable: true
  },
  JSFixedArray: {
    "^": "JSMutableArray;"
  },
  JSExtendableArray: {
    "^": "JSMutableArray;",
    $isJSExtendableArray: true
  },
  JSNumber: {
    "^": "Interceptor;",
    compareTo$1: function(receiver, b) {
      var bIsNegative;
      if (typeof b !== "number")
        throw H.wrapException(P.ArgumentError$(b));
      if (receiver < b)
        return -1;
      else if (receiver > b)
        return 1;
      else if (receiver === b) {
        if (receiver === 0) {
          bIsNegative = this.get$isNegative(b);
          if (this.get$isNegative(receiver) === bIsNegative)
            return 0;
          if (this.get$isNegative(receiver))
            return -1;
          return 1;
        }
        return 0;
      } else if (isNaN(receiver)) {
        if (this.get$isNaN(b))
          return 0;
        return 1;
      } else
        return -1;
    },
    get$isNegative: function(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    get$isNaN: function(receiver) {
      return isNaN(receiver);
    },
    remainder$1: function(receiver, b) {
      if (b == null)
        H.throwExpression(P.ArgumentError$(null));
      if (typeof b !== "number")
        throw H.wrapException(P.ArgumentError$(b));
      return receiver % b;
    },
    abs$0: function(receiver) {
      return Math.abs(receiver);
    },
    get$sign: function(receiver) {
      var t1;
      if (receiver > 0)
        t1 = 1;
      else
        t1 = receiver < 0 ? -1 : receiver;
      return t1;
    },
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$('' + receiver));
    },
    ceil$0: function(receiver) {
      return this.toInt$0(Math.ceil(receiver));
    },
    floor$0: function(receiver) {
      return this.toInt$0(Math.floor(receiver));
    },
    round$0: function(receiver) {
      return this.toInt$0(this.roundToDouble$0(receiver));
    },
    roundToDouble$0: function(receiver) {
      if (receiver < 0)
        return -Math.round(-receiver);
      else
        return Math.round(receiver);
    },
    clamp$2: function(receiver, lowerLimit, upperLimit) {
      lowerLimit.compareTo$1(0, upperLimit).$gt(0, 0);
      if (this.compareTo$1(receiver, lowerLimit) < 0)
        return lowerLimit;
      if (this.compareTo$1(receiver, upperLimit) > 0)
        return upperLimit;
      return receiver;
    },
    toDouble$0: function(receiver) {
      return receiver;
    },
    toStringAsFixed$1: function(receiver, fractionDigits) {
      var result;
      if (fractionDigits > 20)
        throw H.wrapException(P.RangeError$(fractionDigits));
      result = receiver.toFixed(fractionDigits);
      if (receiver === 0 && this.get$isNegative(receiver))
        return "-" + result;
      return result;
    },
    toRadixString$1: function(receiver, radix) {
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$(radix));
      return receiver.toString(radix);
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      return receiver & 0x1FFFFFFF;
    },
    $negate: function(receiver) {
      return -receiver;
    },
    $add: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    $sub: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver - other;
    },
    $div: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver / other;
    },
    $mul: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver * other;
    },
    $mod: function(receiver, other) {
      var result;
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      result = receiver % other;
      if (result === 0)
        return 0;
      if (result > 0)
        return result;
      if (other < 0)
        return result - other;
      else
        return result + other;
    },
    $tdiv: function(receiver, other) {
      if ((receiver | 0) === receiver && (other | 0) === other && 0 !== other && -1 !== other)
        return receiver / other | 0;
      else {
        if (typeof other !== "number")
          H.throwExpression(P.ArgumentError$(other));
        return this.toInt$0(receiver / other);
      }
    },
    _tdivFast$1: function(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this.toInt$0(receiver / other);
    },
    $shl: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    _shlPositive$1: function(receiver, other) {
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    $shr: function(receiver, other) {
      var t1;
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrOtherPositive$1: function(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrReceiverPositive$1: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      return other > 31 ? 0 : receiver >>> other;
    },
    $and: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver & other) >>> 0;
    },
    $or: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver | other) >>> 0;
    },
    $xor: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver ^ other) >>> 0;
    },
    $lt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver < other;
    },
    $gt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver > other;
    },
    $le: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver <= other;
    },
    $ge: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver >= other;
    },
    get$runtimeType: function(receiver) {
      return C.Type_xM7;
    },
    $isnum: true,
    static: {"^": "JSNumber__MIN_INT32,JSNumber__MAX_INT32"}
  },
  JSInt: {
    "^": "JSNumber;",
    get$runtimeType: function(receiver) {
      return C.Type_SnA;
    },
    $not: function(receiver) {
      return ~receiver >>> 0;
    },
    $is$double: true,
    $isnum: true,
    $is$int: true
  },
  JSDouble: {
    "^": "JSNumber;",
    get$runtimeType: function(receiver) {
      return C.Type_qq1;
    },
    $is$double: true,
    $isnum: true
  },
  JSPositiveInt: {
    "^": "JSInt;"
  },
  JSUInt32: {
    "^": "JSPositiveInt;"
  },
  JSUInt31: {
    "^": "JSUInt32;"
  },
  JSString: {
    "^": "Interceptor;",
    codeUnitAt$1: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index < 0)
        throw H.wrapException(P.RangeError$value(index));
      if (index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index));
      return receiver.charCodeAt(index);
    },
    allMatches$2: function(receiver, string, start) {
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length));
      return H.allMatchesInStringUnchecked(receiver, string, start);
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    matchAsPrefix$2: function(receiver, string, start) {
      var t1, t2, i, t3;
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length));
      t1 = receiver.length;
      t2 = string.length;
      if (start + t1 > t2)
        return;
      for (i = 0; i < t1; ++i) {
        t3 = start + i;
        if (t3 < 0)
          H.throwExpression(P.RangeError$value(t3));
        if (t3 >= t2)
          H.throwExpression(P.RangeError$value(t3));
        t3 = string.charCodeAt(t3);
        if (i >= t1)
          H.throwExpression(P.RangeError$value(i));
        if (t3 !== receiver.charCodeAt(i))
          return;
      }
      return new H.StringMatch(start, string, receiver);
    },
    $add: function(receiver, other) {
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    endsWith$1: function(receiver, other) {
      var otherLength, t1;
      otherLength = other.length;
      t1 = receiver.length;
      if (otherLength > t1)
        return false;
      return other === this.substring$1(receiver, t1 - otherLength);
    },
    replaceAll$2: function(receiver, from, to) {
      return H.stringReplaceAllUnchecked(receiver, from, to);
    },
    replaceFirst$2: function(receiver, from, to) {
      if (typeof to !== "string")
        H.throwExpression(P.ArgumentError$(to));
      return H.stringReplaceFirstUnchecked(receiver, from, to);
    },
    split$1: function(receiver, pattern) {
      if (pattern == null)
        H.throwExpression(P.ArgumentError$(null));
      if (typeof pattern === "string")
        return receiver.split(pattern);
      else if (!!J.getInterceptor(pattern).$isJSSyntaxRegExp)
        return receiver.split(pattern._nativeRegExp);
      else
        throw H.wrapException("String.split(Pattern) UNIMPLEMENTED");
    },
    startsWith$2: function(receiver, pattern, index) {
      var endIndex;
      if (index > receiver.length)
        throw H.wrapException(P.RangeError$range(index, 0, receiver.length));
      endIndex = index + pattern.length;
      if (endIndex > receiver.length)
        return false;
      return pattern === receiver.substring(index, endIndex);
    },
    startsWith$1: function($receiver, pattern) {
      return this.startsWith$2($receiver, pattern, 0);
    },
    substring$2: function(receiver, startIndex, endIndex) {
      var t1;
      if (typeof startIndex !== "number" || Math.floor(startIndex) !== startIndex)
        H.throwExpression(P.ArgumentError$(startIndex));
      if (endIndex == null)
        endIndex = receiver.length;
      if (typeof endIndex !== "number" || Math.floor(endIndex) !== endIndex)
        H.throwExpression(P.ArgumentError$(endIndex));
      t1 = J.getInterceptor$n(startIndex);
      if (t1.$lt(startIndex, 0))
        throw H.wrapException(P.RangeError$value(startIndex));
      if (t1.$gt(startIndex, endIndex))
        throw H.wrapException(P.RangeError$value(startIndex));
      if (J.$gt$n(endIndex, receiver.length))
        throw H.wrapException(P.RangeError$value(endIndex));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    toLowerCase$0: function(receiver) {
      return receiver.toLowerCase();
    },
    toUpperCase$0: function(receiver) {
      return receiver.toUpperCase();
    },
    trim$0: [function(receiver) {
      var result, endIndex, startIndex, t1, endIndex0;
      result = receiver.trim();
      endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (this.codeUnitAt$1(result, 0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    }, "call$0", "get$trim", 0, 0, 782],
    $mul: function(receiver, times) {
      var s, result;
      if (typeof times !== "number")
        return H.iae(times);
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw H.wrapException(C.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    padLeft$2: function(receiver, width, padding) {
      var delta = width - receiver.length;
      if (delta <= 0)
        return receiver;
      return this.$mul(padding, delta) + receiver;
    },
    indexOf$2: function(receiver, pattern, start) {
      var t1, match, t2, i;
      if (pattern == null)
        H.throwExpression(P.ArgumentError$(null));
      if (typeof start !== "number" || Math.floor(start) !== start)
        throw H.wrapException(P.ArgumentError$(start));
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length));
      if (typeof pattern === "string")
        return receiver.indexOf(pattern, start);
      t1 = J.getInterceptor(pattern);
      if (!!t1.$isJSSyntaxRegExp) {
        match = pattern._execGlobal$2(receiver, start);
        return match == null ? -1 : match._match.index;
      }
      for (t2 = receiver.length, i = start; i <= t2; ++i)
        if (t1.matchAsPrefix$2(pattern, receiver, i) != null)
          return i;
      return -1;
    },
    indexOf$1: function($receiver, pattern) {
      return this.indexOf$2($receiver, pattern, 0);
    },
    contains$2: [function(receiver, other, startIndex) {
      var t1;
      if (other == null)
        H.throwExpression(P.ArgumentError$(null));
      t1 = J.getInterceptor$n(startIndex);
      if (t1.$lt(startIndex, 0) || t1.$gt(startIndex, receiver.length))
        throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length));
      return H.stringContainsUnchecked(receiver, other, startIndex);
    }, function($receiver, other) {
      return this.contains$2($receiver, other, 0);
    }, "contains$1", "call$2", "call$1", "get$contains", 2, 2, 1678, 5],
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    compareTo$1: function(receiver, other) {
      var t1;
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      if (receiver === other)
        t1 = 0;
      else
        t1 = receiver < other ? -1 : 1;
      return t1;
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
    },
    get$runtimeType: function(receiver) {
      return C.Type_Ejg;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      return receiver[index];
    },
    $isJSIndexable: true,
    $isString: true,
    static: {JSString__isWhitespace: function(codeUnit) {
        if (codeUnit < 256)
          switch (codeUnit) {
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 32:
            case 133:
            case 160:
              return true;
            default:
              return false;
          }
        switch (codeUnit) {
          case 5760:
          case 6158:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8232:
          case 8233:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }, JSString__skipLeadingWhitespace: function(string, index) {
        var t1, codeUnit;
        for (t1 = string.length; index < t1;) {
          if (index >= t1)
            H.throwExpression(P.RangeError$value(index));
          codeUnit = string.charCodeAt(index);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
          ++index;
        }
        return index;
      }, JSString__skipTrailingWhitespace: function(string, index) {
        var t1, index0, codeUnit;
        for (t1 = string.length; index > 0; index = index0) {
          index0 = index - 1;
          if (index0 >= t1)
            H.throwExpression(P.RangeError$value(index0));
          codeUnit = string.charCodeAt(index0);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
        }
        return index;
      }}
  },
  _CodeUnits: {
    "^": "UnmodifiableListBase;__interceptors$_string",
    get$length: function(_) {
      return this.__interceptors$_string.length;
    },
    $index: function(_, i) {
      var t1, t2;
      t1 = this.__interceptors$_string;
      if (typeof i !== "number" || Math.floor(i) !== i)
        H.throwExpression(P.ArgumentError$(i));
      t2 = J.getInterceptor$n(i);
      if (t2.$lt(i, 0))
        H.throwExpression(P.RangeError$value(i));
      if (t2.$ge(i, t1.length))
        H.throwExpression(P.RangeError$value(i));
      return t1.charCodeAt(i);
    },
    $asUnmodifiableListBase: function() {
      return [P.$int];
    },
    $asListBase: function() {
      return [P.$int];
    },
    $asObject_ListMixin: function() {
      return [P.$int];
    },
    $asList: function() {
      return [P.$int];
    }
  }
}],
["_isolate_helper", "dart:_isolate_helper", , H, {
  "^": "",
  _callInIsolate: function(isolate, $function) {
    var result = isolate.eval$1($function);
    init.globalState.topEventLoop.run$0();
    return result;
  },
  leaveJsAsync: function() {
    --init.globalState.topEventLoop._activeJsAsyncCount;
  },
  startRootIsolate: function(entry, args) {
    var t1, t2, t3, t4, t5, rootContext;
    t1 = {};
    t1.args_0 = args;
    args = args;
    t1.args_0 = args;
    if (args == null) {
      args = [];
      t1.args_0 = args;
      t2 = args;
    } else
      t2 = args;
    if (!J.getInterceptor(t2).$isList)
      throw H.wrapException(P.ArgumentError$("Arguments to main must be a List: " + H.S(t2)));
    t2 = new H._Manager(0, 0, 1, null, null, null, null, null, null, null, null, null, entry);
    t2._Manager$1(entry);
    init.globalState = t2;
    if (init.globalState.isWorker === true)
      return;
    t2 = init.globalState.nextIsolateId++;
    t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl);
    t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
    t5 = new H.RawReceivePortImpl(0, null, false);
    rootContext = new H._IsolateContext(t2, t3, t4, new Isolate(), t5, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
    t4.add$1(0, 0);
    rootContext._addRegistration$2(0, t5);
    init.globalState.rootContext = rootContext;
    init.globalState.currentContext = rootContext;
    t2 = H.getDynamicRuntimeType();
    t3 = H.buildFunctionType(t2, [t2])._isTest$1(entry);
    if (t3)
      rootContext.eval$1(new H.startRootIsolate_closure(t1, entry));
    else {
      t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(entry);
      if (t2)
        rootContext.eval$1(new H.startRootIsolate_closure0(t1, entry));
      else
        rootContext.eval$1(entry);
    }
    init.globalState.topEventLoop.run$0();
  },
  IsolateNatives_computeThisScript: function() {
    var currentScript = init.currentScript;
    if (currentScript != null)
      return String(currentScript.src);
    if (typeof version == "function" && typeof os == "object" && "system" in os)
      return H.IsolateNatives_computeThisScriptFromTrace();
    if (typeof version == "function" && typeof system == "function")
      return thisFilename();
    if (init.globalState.isWorker === true)
      return H.IsolateNatives_computeThisScriptFromTrace();
    return;
  },
  IsolateNatives_computeThisScriptFromTrace: function() {
    var stack, matches;
    stack = new Error().stack;
    if (stack == null) {
      stack = function() {
        try {
          throw new Error();
        } catch (e) {
          return e.stack;
        }

      }();
      if (stack == null)
        throw H.wrapException(P.UnsupportedError$("No stack trace"));
    }
    matches = stack.match(new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "m"));
    if (matches != null)
      return matches[1];
    matches = stack.match(new RegExp("^[^@]*@(.*):[0-9]*$", "m"));
    if (matches != null)
      return matches[1];
    throw H.wrapException(P.UnsupportedError$("Cannot extract URI from \"" + H.S(stack) + "\""));
  },
  IsolateNatives__processWorkerMessage: [function(sender, e) {
    var msg, t1, functionName, entryPoint, args, message, isSpawnUri, startPaused, replyTo, t2, t3, t4, context;
    msg = H._deserializeMessage(e.data);
    t1 = J.getInterceptor$asx(msg);
    switch (t1.$index(msg, "command")) {
      case "start":
        init.globalState.currentManagerId = t1.$index(msg, "id");
        functionName = t1.$index(msg, "functionName");
        entryPoint = functionName == null ? init.globalState.entry : init.globalFunctions[functionName]();
        args = t1.$index(msg, "args");
        message = H._deserializeMessage(t1.$index(msg, "msg"));
        isSpawnUri = t1.$index(msg, "isSpawnUri");
        startPaused = t1.$index(msg, "startPaused");
        replyTo = H._deserializeMessage(t1.$index(msg, "replyTo"));
        t1 = init.globalState.nextIsolateId++;
        t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl);
        t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
        t4 = new H.RawReceivePortImpl(0, null, false);
        context = new H._IsolateContext(t1, t2, t3, new Isolate(), t4, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
        t3.add$1(0, 0);
        context._addRegistration$2(0, t4);
        init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(context, new H.IsolateNatives__processWorkerMessage_closure(entryPoint, args, message, isSpawnUri, startPaused, replyTo), "worker-start"));
        init.globalState.currentContext = context;
        init.globalState.topEventLoop.run$0();
        break;
      case "spawn-worker":
        break;
      case "message":
        if (t1.$index(msg, "port") != null)
          J.send$1$x(t1.$index(msg, "port"), t1.$index(msg, "msg"));
        init.globalState.topEventLoop.run$0();
        break;
      case "close":
        init.globalState.managers.remove$1(0, $.get$IsolateNatives_workerIds().$index(0, sender));
        sender.terminate();
        init.globalState.topEventLoop.run$0();
        break;
      case "log":
        H.IsolateNatives__log(t1.$index(msg, "msg"));
        break;
      case "print":
        if (init.globalState.isWorker === true) {
          t1 = init.globalState.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", msg], null, null));
          t1.toString;
          self.postMessage(t2);
        } else
          P.print(t1.$index(msg, "msg"));
        break;
      case "error":
        throw H.wrapException(t1.$index(msg, "msg"));
    }
  }, "call$2", "IsolateNatives__processWorkerMessage$closure", 4, 0, null, 542, [], 312, []],
  IsolateNatives__log: function(msg) {
    var trace, t1, t2, exception;
    if (init.globalState.isWorker === true) {
      t1 = init.globalState.mainManager;
      t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "log", "msg", msg], null, null));
      t1.toString;
      self.postMessage(t2);
    } else
      try {
        self.console.log(msg);
      } catch (exception) {
        H.unwrapException(exception);
        trace = new H._StackTrace(exception, null);
        throw H.wrapException(P.Exception_Exception(trace));
      }

  },
  IsolateNatives__startIsolate: function(topLevel, args, message, isSpawnUri, startPaused, replyTo) {
    var context, t1, t2, t3;
    context = init.globalState.currentContext;
    t1 = context.id;
    $.Primitives_mirrorFunctionCacheName = $.Primitives_mirrorFunctionCacheName + ("_" + t1);
    $.Primitives_mirrorInvokeCacheName = $.Primitives_mirrorInvokeCacheName + ("_" + t1);
    t1 = context.controlPort;
    t2 = init.globalState.currentContext.id;
    t3 = context.pauseCapability;
    J.send$1$x(replyTo, ["spawned", new H._NativeJsSendPort(t1, t2), t3, context.terminateCapability]);
    t2 = new H.IsolateNatives__startIsolate_runStartFunction(topLevel, args, message, isSpawnUri, context);
    if (startPaused === true) {
      context.addPause$2(t3, t3);
      init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(context, t2, "start isolate"));
    } else
      t2.call$0();
  },
  _serializeMessage: function(message) {
    var t1;
    if (init.globalState.supportsWorkers === true) {
      t1 = new H._JsSerializer(0, new H._MessageTraverserVisitedMap());
      t1._visited = new H._JsVisitedMap(null);
      return t1.traverse$1(message);
    } else {
      t1 = new H._JsCopier(new H._MessageTraverserVisitedMap());
      t1._visited = new H._JsVisitedMap(null);
      return t1.traverse$1(message);
    }
  },
  _deserializeMessage: function(message) {
    if (init.globalState.supportsWorkers === true)
      return new H._JsDeserializer(null).deserialize$1(message);
    else
      return message;
  },
  _MessageTraverser_isPrimitive: function(x) {
    return x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  },
  _Deserializer_isPrimitive: function(x) {
    return x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  },
  startRootIsolate_closure: {
    "^": "Closure:13;box_0,entry_1",
    call$0: function() {
      this.entry_1.call$1(this.box_0.args_0);
    },
    $isFunction: true
  },
  startRootIsolate_closure0: {
    "^": "Closure:13;box_0,entry_2",
    call$0: function() {
      this.entry_2.call$2(this.box_0.args_0, null);
    },
    $isFunction: true
  },
  _Manager: {
    "^": "Object;nextIsolateId,currentManagerId,nextManagerId,currentContext,rootContext,topEventLoop,fromCommandLine,isWorker,supportsWorkers,isolates,mainManager,managers,entry",
    _Manager$1: function(entry) {
      var t1, t2, t3;
      t1 = self.window == null;
      t2 = self.Worker;
      t3 = t1 && !!self.postMessage;
      this.isWorker = t3;
      if (!t3)
        t2 = t2 != null && $.get$IsolateNatives_thisScript() != null;
      else
        t2 = true;
      this.supportsWorkers = t2;
      this.fromCommandLine = t1 && !t3;
      t2 = H._IsolateEvent;
      t3 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [t2]);
      t3.ListQueue$1(null, t2);
      this.topEventLoop = new H._EventLoop(t3, 0);
      this.isolates = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H._IsolateContext);
      this.managers = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, null);
      if (this.isWorker === true) {
        t1 = new H._MainManagerStub();
        this.mainManager = t1;
        self.onmessage = function(f, a) {
          return function(e) {
            f(a, e);
          };
        }(H.IsolateNatives__processWorkerMessage, t1);
        self.dartPrint = self.dartPrint || function(serialize) {
          return function(object) {
            if (self.console && self.console.log) {
              self.console.log(object);
            } else {
              self.postMessage(serialize(object));
            }
          };
        }(H._Manager__serializePrintMessage);
      }
    },
    static: {_Manager__serializePrintMessage: [function(object) {
        return H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", object], null, null));
      }, "call$1", "_Manager__serializePrintMessage$closure", 2, 0, null, 541, []]}
  },
  _IsolateContext: {
    "^": "Object;id>,ports,weakPorts,isolateStatics<,controlPort<,pauseCapability,terminateCapability,initialized?,isPaused<,delayedEvents<,pauseTokens,doneHandlers,_scheduledControlEvents,_isExecutingEvent,errorsAreFatal,errorPorts",
    addPause$2: function(authentification, resume) {
      if (!this.pauseCapability.$eq(0, authentification))
        return;
      if (this.pauseTokens.add$1(0, resume) && !this.isPaused)
        this.isPaused = true;
      this._updateGlobalState$0();
    },
    removePause$1: function(resume) {
      var t1, t2, $event, t3, t4, t5;
      if (!this.isPaused)
        return;
      t1 = this.pauseTokens;
      t1.remove$1(0, resume);
      if (t1._collection$_length === 0) {
        for (t1 = this.delayedEvents; t2 = t1.length, t2 !== 0;) {
          if (0 >= t2)
            return H.ioore(t1, 0);
          $event = t1.pop();
          t2 = init.globalState.topEventLoop.events;
          t3 = t2._head;
          t4 = t2._table;
          t5 = t4.length;
          t3 = (t3 - 1 & t5 - 1) >>> 0;
          t2._head = t3;
          if (t3 < 0 || t3 >= t5)
            return H.ioore(t4, t3);
          t4[t3] = $event;
          if (t3 === t2._tail)
            t2._grow$0();
          ++t2._modificationCount;
        }
        this.isPaused = false;
      }
      this._updateGlobalState$0();
    },
    addDoneListener$1: function(responsePort) {
      var t1 = this.doneHandlers;
      if (t1 == null) {
        t1 = [];
        this.doneHandlers = t1;
      }
      if (J.contains$1$asx(t1, responsePort))
        return;
      this.doneHandlers.push(responsePort);
    },
    removeDoneListener$1: function(responsePort) {
      var t1 = this.doneHandlers;
      if (t1 == null)
        return;
      J.remove$1$ax(t1, responsePort);
    },
    setErrorsFatal$2: function(authentification, errorsAreFatal) {
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      this.errorsAreFatal = errorsAreFatal;
    },
    handlePing$2: function(responsePort, pingType) {
      var t1, t2;
      t1 = J.getInterceptor(pingType);
      if (!t1.$eq(pingType, 0))
        t2 = t1.$eq(pingType, 1) && !this._isExecutingEvent;
      else
        t2 = true;
      if (t2) {
        J.send$1$x(responsePort, null);
        return;
      }
      t2 = new H._IsolateContext_handlePing_respond(responsePort);
      if (t1.$eq(pingType, 2)) {
        init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(this, t2, "ping"));
        return;
      }
      t1 = this._scheduledControlEvents;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [null]);
        t1.ListQueue$1(null, null);
        this._scheduledControlEvents = t1;
      }
      t1._add$1(t2);
    },
    handleKill$2: function(authentification, priority) {
      var t1, t2;
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      t1 = J.getInterceptor(priority);
      if (!t1.$eq(priority, 0))
        t2 = t1.$eq(priority, 1) && !this._isExecutingEvent;
      else
        t2 = true;
      if (t2) {
        this.kill$0();
        return;
      }
      if (t1.$eq(priority, 2)) {
        t1 = init.globalState.topEventLoop;
        t2 = this.get$kill();
        t1.events._add$1(new H._IsolateEvent(this, t2, "kill"));
        return;
      }
      t1 = this._scheduledControlEvents;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [null]);
        t1.ListQueue$1(null, null);
        this._scheduledControlEvents = t1;
      }
      t1._add$1(this.get$kill());
    },
    handleUncaughtError$2: function(error, stackTrace) {
      var t1, message;
      t1 = this.errorPorts;
      if (t1._collection$_length === 0) {
        if (this.errorsAreFatal === true && this === init.globalState.rootContext)
          return;
        if (self.console && self.console.error)
          self.console.error(error, stackTrace);
        else {
          P.print(error);
          if (stackTrace != null)
            P.print(stackTrace);
        }
        return;
      }
      message = Array(2);
      message.fixed$length = init;
      message[0] = J.toString$0(error);
      message[1] = stackTrace == null ? null : J.toString$0(stackTrace);
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._set._first; t1.moveNext$0();)
        J.send$1$x(t1._collection$_current, message);
    },
    eval$1: function(code) {
      var old, result, e, s, exception, t1;
      old = init.globalState.currentContext;
      init.globalState.currentContext = this;
      $ = this.isolateStatics;
      result = null;
      this._isExecutingEvent = true;
      try {
        result = code.call$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.handleUncaughtError$2(e, s);
        if (this.errorsAreFatal === true) {
          this.kill$0();
          if (this === init.globalState.rootContext)
            throw exception;
        }
      }
 finally {
        this._isExecutingEvent = false;
        init.globalState.currentContext = old;
        if (old != null)
          $ = old.get$isolateStatics();
        if (this._scheduledControlEvents != null)
          for (; t1 = this._scheduledControlEvents, !t1.get$isEmpty(t1);)
            this._scheduledControlEvents.removeFirst$0().call$0();
      }
      return result;
    },
    handleControlMessage$1: function(message) {
      var t1 = J.getInterceptor$asx(message);
      switch (t1.$index(message, 0)) {
        case "pause":
          this.addPause$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "resume":
          this.removePause$1(t1.$index(message, 1));
          break;
        case "add-ondone":
          this.addDoneListener$1(t1.$index(message, 1));
          break;
        case "remove-ondone":
          this.removeDoneListener$1(t1.$index(message, 1));
          break;
        case "set-errors-fatal":
          this.setErrorsFatal$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "ping":
          this.handlePing$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "kill":
          this.handleKill$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "getErrors":
          this.errorPorts.add$1(0, t1.$index(message, 1));
          break;
        case "stopErrors":
          this.errorPorts.remove$1(0, t1.$index(message, 1));
          break;
      }
    },
    lookup$1: function(portId) {
      return this.ports.$index(0, portId);
    },
    _addRegistration$2: function(portId, port) {
      var t1 = this.ports;
      if (t1.containsKey$1(0, portId))
        throw H.wrapException(P.Exception_Exception("Registry: ports must be registered only once."));
      t1.$indexSet(0, portId, port);
    },
    _updateGlobalState$0: function() {
      if (this.ports._collection$_length - this.weakPorts._collection$_length > 0 || this.isPaused || !this.initialized)
        init.globalState.isolates.$indexSet(0, this.id, this);
      else
        this.kill$0();
    },
    kill$0: [function() {
      var t1, t2;
      t1 = this._scheduledControlEvents;
      if (t1 != null)
        t1.clear$0(0);
      for (t1 = this.ports, t2 = t1.get$values(t1), t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t2._iterable), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();)
        t2._current.__isolate_helper$_close$0();
      t1.clear$0(0);
      this.weakPorts.clear$0(0);
      init.globalState.isolates.remove$1(0, this.id);
      this.errorPorts.clear$0(0);
      t1 = this.doneHandlers;
      if (t1 != null) {
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
          J.send$1$x(t1._current, null);
        this.doneHandlers = null;
      }
    }, "call$0", "get$kill", 0, 0, 550],
    $is_IsolateContext: true
  },
  _IsolateContext_handlePing_respond: {
    "^": "Closure:550;responsePort_0",
    call$0: [function() {
      J.send$1$x(this.responsePort_0, null);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _EventLoop: {
    "^": "Object;events<,_activeJsAsyncCount",
    dequeue$0: function() {
      var t1 = this.events;
      if (t1._head === t1._tail)
        return;
      return t1.removeFirst$0();
    },
    runIteration$0: function() {
      var $event, t1, t2;
      $event = this.dequeue$0();
      if ($event == null) {
        if (init.globalState.rootContext != null && init.globalState.isolates.containsKey$1(0, init.globalState.rootContext.id) && init.globalState.fromCommandLine === true && init.globalState.rootContext.ports._collection$_length === 0)
          H.throwExpression(P.Exception_Exception("Program exited with open ReceivePorts."));
        t1 = init.globalState;
        if (t1.isWorker === true && t1.isolates._collection$_length === 0 && t1.topEventLoop._activeJsAsyncCount === 0) {
          t1 = t1.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "close"], null, null));
          t1.toString;
          self.postMessage(t2);
        }
        return false;
      }
      $event.process$0();
      return true;
    },
    _runHelper$0: function() {
      if (self.window != null)
        new H._EventLoop__runHelper_next(this).call$0();
      else
        for (; this.runIteration$0();)
          ;
    },
    run$0: function() {
      var e, trace, exception, t1, t2;
      if (init.globalState.isWorker !== true)
        this._runHelper$0();
      else
        try {
          this._runHelper$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          trace = new H._StackTrace(exception, null);
          t1 = init.globalState.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "error", "msg", H.S(e) + "\n" + H.S(trace)], null, null));
          t1.toString;
          self.postMessage(t2);
        }

    }
  },
  _EventLoop__runHelper_next: {
    "^": "Closure:550;this_0",
    call$0: function() {
      if (!this.this_0.runIteration$0())
        return;
      P.Timer_Timer(C.Duration_0, this);
    },
    $isFunction: true
  },
  _IsolateEvent: {
    "^": "Object;isolate,fn,message",
    process$0: function() {
      var t1 = this.isolate;
      if (t1.get$isPaused()) {
        t1.get$delayedEvents().push(this);
        return;
      }
      t1.eval$1(this.fn);
    },
    $is_IsolateEvent: true
  },
  _MainManagerStub: {
    "^": "Object;"
  },
  IsolateNatives__processWorkerMessage_closure: {
    "^": "Closure:13;entryPoint_0,args_1,message_2,isSpawnUri_3,startPaused_4,replyTo_5",
    call$0: [function() {
      H.IsolateNatives__startIsolate(this.entryPoint_0, this.args_1, this.message_2, this.isSpawnUri_3, this.startPaused_4, this.replyTo_5);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  IsolateNatives__startIsolate_runStartFunction: {
    "^": "Closure:550;topLevel_0,args_1,message_2,isSpawnUri_3,context_4",
    call$0: [function() {
      var t1, t2, t3;
      this.context_4.set$initialized(true);
      if (this.isSpawnUri_3 !== true)
        this.topLevel_0.call$1(this.message_2);
      else {
        t1 = this.topLevel_0;
        t2 = H.getDynamicRuntimeType();
        t3 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
        if (t3)
          t1.call$2(this.args_1, this.message_2);
        else {
          t2 = H.buildFunctionType(t2, [t2])._isTest$1(t1);
          if (t2)
            t1.call$1(this.args_1);
          else
            t1.call$0();
        }
      }
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _BaseSendPort: {
    "^": "Object;",
    $isSendPort: true,
    $isCapability: true
  },
  _NativeJsSendPort: {
    "^": "_BaseSendPort;_receivePort,_isolateId",
    send$1: function(_, message) {
      var t1, t2, isolate, t3, shouldSerialize;
      t1 = {};
      t2 = this._isolateId;
      isolate = init.globalState.isolates.$index(0, t2);
      if (isolate == null)
        return;
      t3 = this._receivePort;
      if (t3.get$_isClosed())
        return;
      shouldSerialize = init.globalState.currentContext != null && init.globalState.currentContext.id !== t2;
      t1.msg_0 = message;
      if (shouldSerialize)
        t1.msg_0 = H._serializeMessage(message);
      if (isolate.get$controlPort() === t3) {
        isolate.handleControlMessage$1(t1.msg_0);
        return;
      }
      t2 = init.globalState.topEventLoop;
      t3 = "receive " + H.S(message);
      t2.events._add$1(new H._IsolateEvent(isolate, new H._NativeJsSendPort_send_closure(t1, this, shouldSerialize), t3));
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$is_NativeJsSendPort && J.$eq(this._receivePort, other._receivePort);
    },
    get$hashCode: function(_) {
      return this._receivePort.get$_id();
    },
    $is_NativeJsSendPort: true,
    $isSendPort: true,
    $isCapability: true
  },
  _NativeJsSendPort_send_closure: {
    "^": "Closure:13;box_0,this_1,shouldSerialize_2",
    call$0: [function() {
      var t1, t2;
      t1 = this.this_1._receivePort;
      if (!t1.get$_isClosed()) {
        if (this.shouldSerialize_2) {
          t2 = this.box_0;
          t2.msg_0 = H._deserializeMessage(t2.msg_0);
        }
        t1.__isolate_helper$_add$1(this.box_0.msg_0);
      }
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _WorkerSendPort: {
    "^": "_BaseSendPort;_workerId,_receivePortId,_isolateId",
    send$1: function(_, message) {
      var workerMessage, manager;
      workerMessage = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "message", "port", this, "msg", message], null, null));
      if (init.globalState.isWorker === true) {
        init.globalState.mainManager.toString;
        self.postMessage(workerMessage);
      } else {
        manager = init.globalState.managers.$index(0, this._workerId);
        if (manager != null)
          manager.postMessage(workerMessage);
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$is_WorkerSendPort && J.$eq(this._workerId, other._workerId) && J.$eq(this._isolateId, other._isolateId) && J.$eq(this._receivePortId, other._receivePortId);
    },
    get$hashCode: function(_) {
      var t1, t2, t3;
      t1 = J.$shl$n(this._workerId, 16);
      t2 = J.$shl$n(this._isolateId, 8);
      t3 = this._receivePortId;
      if (typeof t3 !== "number")
        return H.iae(t3);
      return (t1 ^ t2 ^ t3) >>> 0;
    },
    $is_WorkerSendPort: true,
    $isSendPort: true,
    $isCapability: true
  },
  RawReceivePortImpl: {
    "^": "Object;_id<,_handler,_isClosed<",
    _handler$1: function(arg0) {
      return this._handler.call$1(arg0);
    },
    __isolate_helper$_close$0: function() {
      this._isClosed = true;
      this._handler = null;
    },
    __isolate_helper$_add$1: function(dataEvent) {
      if (this._isClosed)
        return;
      this._handler$1(dataEvent);
    },
    $isRawReceivePortImpl: true,
    static: {"^": "RawReceivePortImpl__nextFreeId"}
  },
  _JsSerializer: {
    "^": "_Serializer;_nextFreeRefId,_visited",
    visitSendPort$1: function(x) {
      if (!!x.$is_NativeJsSendPort)
        return ["sendport", init.globalState.currentManagerId, x._isolateId, x._receivePort.get$_id()];
      if (!!x.$is_WorkerSendPort)
        return ["sendport", x._workerId, x._isolateId, x._receivePortId];
      throw H.wrapException("Illegal underlying port " + x.toString$0(0));
    },
    visitCapability$1: function(x) {
      if (!!x.$isCapabilityImpl)
        return ["capability", x._id];
      throw H.wrapException("Capability not serializable: " + x.toString$0(0));
    }
  },
  _JsCopier: {
    "^": "_Copier;_visited",
    visitSendPort$1: function(x) {
      if (!!x.$is_NativeJsSendPort)
        return new H._NativeJsSendPort(x._receivePort, x._isolateId);
      if (!!x.$is_WorkerSendPort)
        return new H._WorkerSendPort(x._workerId, x._receivePortId, x._isolateId);
      throw H.wrapException("Illegal underlying port " + x.toString$0(0));
    },
    visitCapability$1: function(x) {
      if (!!x.$isCapabilityImpl)
        return new H.CapabilityImpl(x._id);
      throw H.wrapException("Capability not serializable: " + x.toString$0(0));
    }
  },
  _JsDeserializer: {
    "^": "_Deserializer;_deserialized",
    deserializeSendPort$1: function(list) {
      var t1, managerId, isolateId, receivePortId, isolate, receivePort;
      t1 = J.getInterceptor$asx(list);
      managerId = t1.$index(list, 1);
      isolateId = t1.$index(list, 2);
      receivePortId = t1.$index(list, 3);
      if (J.$eq(managerId, init.globalState.currentManagerId)) {
        isolate = init.globalState.isolates.$index(0, isolateId);
        if (isolate == null)
          return;
        receivePort = isolate.lookup$1(receivePortId);
        if (receivePort == null)
          return;
        return new H._NativeJsSendPort(receivePort, isolateId);
      } else
        return new H._WorkerSendPort(managerId, receivePortId, isolateId);
    },
    deserializeCapability$1: function(list) {
      return new H.CapabilityImpl(J.$index$asx(list, 1));
    }
  },
  _JsVisitedMap: {
    "^": "Object;tagged",
    $index: function(_, object) {
      return object.__MessageTraverser__attached_info__;
    },
    $indexSet: function(_, object, info) {
      this.tagged.push(object);
      object.__MessageTraverser__attached_info__ = info;
    },
    reset$0: function(_) {
      this.tagged = [];
    },
    cleanup$0: function() {
      var $length, i, t1;
      for ($length = this.tagged.length, i = 0; i < $length; ++i) {
        t1 = this.tagged;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i].__MessageTraverser__attached_info__ = null;
      }
      this.tagged = null;
    }
  },
  _MessageTraverserVisitedMap: {
    "^": "Object;",
    $index: function(_, object) {
      return;
    },
    $indexSet: function(_, object, info) {
    },
    reset$0: function(_) {
    },
    cleanup$0: function() {
    }
  },
  _MessageTraverser: {
    "^": "Object;",
    traverse$1: function(x) {
      var result;
      if (H._MessageTraverser_isPrimitive(x))
        return this.visitPrimitive$1(x);
      this._visited.reset$0(0);
      result = null;
      try {
        result = this._dispatch$1(x);
      } finally {
        this._visited.cleanup$0();
      }
      return result;
    },
    _dispatch$1: function(x) {
      var t1;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return this.visitPrimitive$1(x);
      t1 = J.getInterceptor(x);
      if (!!t1.$isList)
        return this.visitList$1(x);
      if (!!t1.$isMap)
        return this.visitMap$1(x);
      if (!!t1.$isSendPort)
        return this.visitSendPort$1(x);
      if (!!t1.$isCapability)
        return this.visitCapability$1(x);
      return this.visitObject$1(x);
    },
    visitObject$1: function(x) {
      throw H.wrapException("Message serialization: Illegal value " + H.S(x) + " passed");
    }
  },
  _Copier: {
    "^": "_MessageTraverser;",
    visitPrimitive$1: function(x) {
      return x;
    },
    visitList$1: function(list) {
      var copy, t1, len, t2, i, t3;
      copy = this._visited.$index(0, list);
      if (copy != null)
        return copy;
      t1 = J.getInterceptor$asx(list);
      len = t1.get$length(list);
      if (typeof len !== "number")
        return H.iae(len);
      copy = Array(len);
      copy.fixed$length = init;
      this._visited.$indexSet(0, list, copy);
      for (t2 = copy.length, i = 0; i < len; ++i) {
        t3 = this._dispatch$1(t1.$index(list, i));
        if (i >= t2)
          return H.ioore(copy, i);
        copy[i] = t3;
      }
      return copy;
    },
    visitMap$1: function(map) {
      var t1, copy;
      t1 = {};
      copy = this._visited.$index(0, map);
      t1.copy_0 = copy;
      if (copy != null)
        return copy;
      copy = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1.copy_0 = copy;
      this._visited.$indexSet(0, map, copy);
      J.forEach$1$ax(map, new H._Copier_visitMap_closure(t1, this));
      return t1.copy_0;
    },
    visitSendPort$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitCapability$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  _Copier_visitMap_closure: {
    "^": "Closure:935;box_0,this_1",
    call$2: [function(key, val) {
      var t1 = this.this_1;
      J.$indexSet$ax(this.box_0.copy_0, t1._dispatch$1(key), t1._dispatch$1(val));
    }, "call$2", null, 4, 0, null, 231, [], 332, [], "call"],
    $isFunction: true
  },
  _Serializer: {
    "^": "_MessageTraverser;",
    visitPrimitive$1: function(x) {
      return x;
    },
    visitList$1: function(list) {
      var copyId, t1;
      copyId = this._visited.$index(0, list);
      if (copyId != null)
        return ["ref", copyId];
      t1 = this._nextFreeRefId++;
      this._visited.$indexSet(0, list, t1);
      return ["list", t1, this._serializeList$1(list)];
    },
    visitMap$1: function(map) {
      var copyId, t1, t2;
      copyId = this._visited.$index(0, map);
      if (copyId != null)
        return ["ref", copyId];
      t1 = this._nextFreeRefId++;
      this._visited.$indexSet(0, map, t1);
      t2 = J.getInterceptor$x(map);
      return ["map", t1, this._serializeList$1(J.toList$0$ax(t2.get$keys(map))), this._serializeList$1(J.toList$0$ax(t2.get$values(map)))];
    },
    _serializeList$1: function(list) {
      var t1, len, result, i, t2;
      t1 = J.getInterceptor$asx(list);
      len = t1.get$length(list);
      result = [];
      C.JSArray_methods.set$length(result, len);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i) {
        t2 = this._dispatch$1(t1.$index(list, i));
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t2;
      }
      return result;
    },
    visitSendPort$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitCapability$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  _Deserializer: {
    "^": "Object;",
    deserialize$1: function(x) {
      if (H._Deserializer_isPrimitive(x))
        return x;
      this._deserialized = P.HashMap_HashMap(null, null, null, null, null);
      return this._deserializeHelper$1(x);
    },
    _deserializeHelper$1: function(x) {
      var t1, id;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return x;
      t1 = J.getInterceptor$asx(x);
      switch (t1.$index(x, 0)) {
        case "ref":
          id = t1.$index(x, 1);
          return this._deserialized.$index(0, id);
        case "list":
          return this._deserializeList$1(x);
        case "map":
          return this._deserializeMap$1(x);
        case "sendport":
          return this.deserializeSendPort$1(x);
        case "capability":
          return this.deserializeCapability$1(x);
        default:
          return this.deserializeObject$1(x);
      }
    },
    _deserializeList$1: function(x) {
      var t1, id, dartList, len, i;
      t1 = J.getInterceptor$asx(x);
      id = t1.$index(x, 1);
      dartList = t1.$index(x, 2);
      this._deserialized.$indexSet(0, id, dartList);
      t1 = J.getInterceptor$asx(dartList);
      len = t1.get$length(dartList);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        t1.$indexSet(dartList, i, this._deserializeHelper$1(t1.$index(dartList, i)));
      return dartList;
    },
    _deserializeMap$1: function(x) {
      var result, t1, id, keys, values, len, t2, i;
      result = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1 = J.getInterceptor$asx(x);
      id = t1.$index(x, 1);
      this._deserialized.$indexSet(0, id, result);
      keys = t1.$index(x, 2);
      values = t1.$index(x, 3);
      t1 = J.getInterceptor$asx(keys);
      len = t1.get$length(keys);
      if (typeof len !== "number")
        return H.iae(len);
      t2 = J.getInterceptor$asx(values);
      i = 0;
      for (; i < len; ++i)
        result.$indexSet(0, this._deserializeHelper$1(t1.$index(keys, i)), this._deserializeHelper$1(t2.$index(values, i)));
      return result;
    },
    deserializeObject$1: function(x) {
      throw H.wrapException("Unexpected serialized object");
    }
  },
  TimerImpl: {
    "^": "Object;_once,_inEventLoop,_handle",
    cancel$0: function() {
      if (self.setTimeout != null) {
        if (this._inEventLoop)
          throw H.wrapException(P.UnsupportedError$("Timer in event loop cannot be canceled."));
        if (this._handle == null)
          return;
        H.leaveJsAsync();
        var t1 = this._handle;
        if (this._once)
          self.clearTimeout(t1);
        else
          self.clearInterval(t1);
        this._handle = null;
      } else
        throw H.wrapException(P.UnsupportedError$("Canceling a timer."));
    },
    TimerImpl$periodic$2: function(milliseconds, callback) {
      if (self.setTimeout != null) {
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        this._handle = self.setInterval(H.convertDartClosureToJS(new H.TimerImpl$periodic_closure(this, callback), 0), milliseconds);
      } else
        throw H.wrapException(P.UnsupportedError$("Periodic timer."));
    },
    TimerImpl$2: function(milliseconds, callback) {
      var t1, t2;
      if (milliseconds === 0)
        t1 = self.setTimeout == null || init.globalState.isWorker === true;
      else
        t1 = false;
      if (t1) {
        this._handle = 1;
        t1 = init.globalState.topEventLoop;
        t2 = init.globalState.currentContext;
        t1.events._add$1(new H._IsolateEvent(t2, new H.TimerImpl_internalCallback(this, callback), "timer"));
        this._inEventLoop = true;
      } else if (self.setTimeout != null) {
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        this._handle = self.setTimeout(H.convertDartClosureToJS(new H.TimerImpl_internalCallback0(this, callback), 0), milliseconds);
      } else
        throw H.wrapException(P.UnsupportedError$("Timer greater than 0."));
    },
    static: {TimerImpl$: function(milliseconds, callback) {
        var t1 = new H.TimerImpl(true, false, null);
        t1.TimerImpl$2(milliseconds, callback);
        return t1;
      }, TimerImpl$periodic: function(milliseconds, callback) {
        var t1 = new H.TimerImpl(false, false, null);
        t1.TimerImpl$periodic$2(milliseconds, callback);
        return t1;
      }}
  },
  TimerImpl_internalCallback: {
    "^": "Closure:550;this_0,callback_1",
    call$0: [function() {
      this.this_0._handle = null;
      this.callback_1.call$0();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  TimerImpl_internalCallback0: {
    "^": "Closure:550;this_2,callback_3",
    call$0: [function() {
      this.this_2._handle = null;
      H.leaveJsAsync();
      this.callback_3.call$0();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  TimerImpl$periodic_closure: {
    "^": "Closure:13;this_0,callback_1",
    call$0: [function() {
      this.callback_1.call$1(this.this_0);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  CapabilityImpl: {
    "^": "Object;_id<",
    get$hashCode: function(_) {
      var hash, t1, t2;
      hash = this._id;
      t1 = J.getInterceptor$n(hash);
      t2 = t1.$shr(hash, 0);
      t1 = t1.$tdiv(hash, 4294967296);
      if (typeof t1 !== "number")
        return H.iae(t1);
      hash = t2 ^ t1;
      hash = (~hash >>> 0) + (hash << 15 >>> 0) & 4294967295;
      hash = ((hash ^ hash >>> 12) >>> 0) * 5 & 4294967295;
      hash = ((hash ^ hash >>> 4) >>> 0) * 2057 & 4294967295;
      return (hash ^ hash >>> 16) >>> 0;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other === this)
        return true;
      if (!!J.getInterceptor(other).$isCapabilityImpl) {
        t1 = this._id;
        t2 = other._id;
        return t1 == null ? t2 == null : t1 === t2;
      }
      return false;
    },
    $isCapabilityImpl: true,
    $isCapability: true
  }
}],
["_js_helper", "dart:_js_helper", , H, {
  "^": "",
  isJsIndexable: function(object, record) {
    var result;
    if (record != null) {
      result = record.x;
      if (result != null)
        return result;
    }
    return !!J.getInterceptor(object).$isJavaScriptIndexingBehavior;
  },
  S: function(value) {
    var res;
    if (typeof value === "string")
      return value;
    if (typeof value === "number") {
      if (value !== 0)
        return "" + value;
    } else if (true === value)
      return "true";
    else if (false === value)
      return "false";
    else if (value == null)
      return "null";
    res = J.toString$0(value);
    if (typeof res !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return res;
  },
  throwInvalidReflectionError: function(memberName) {
    throw H.wrapException(P.UnsupportedError$("Can't use '" + H.S(memberName) + "' in reflection because it is not included in a @MirrorsUsed annotation."));
  },
  Primitives_objectHashCode: function(object) {
    var hash = object.$identityHash;
    if (hash == null) {
      hash = Math.random() * 0x3fffffff | 0;
      object.$identityHash = hash;
    }
    return hash;
  },
  Primitives__throwFormatException: [function(string) {
    throw H.wrapException(P.FormatException$(string, null, null));
  }, "call$1", "Primitives__throwFormatException$closure", 2, 0, 52],
  Primitives_parseInt: function(source, radix, handleError) {
    var match, t1, maxCharCode, digitsPart, i, t2;
    if (handleError == null)
      handleError = H.Primitives__throwFormatException$closure();
    if (typeof source !== "string")
      H.throwExpression(P.ArgumentError$(source));
    match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
    if (radix == null) {
      if (match != null) {
        t1 = match.length;
        if (2 >= t1)
          return H.ioore(match, 2);
        if (match[2] != null)
          return parseInt(source, 16);
        if (3 >= t1)
          return H.ioore(match, 3);
        if (match[3] != null)
          return parseInt(source, 10);
        return handleError.call$1(source);
      }
      radix = 10;
    } else {
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$("Radix " + H.S(radix) + " not in range 2..36"));
      if (match != null) {
        if (radix === 10) {
          if (3 >= match.length)
            return H.ioore(match, 3);
          t1 = match[3] != null;
        } else
          t1 = false;
        if (t1)
          return parseInt(source, 10);
        if (!(radix < 10)) {
          if (3 >= match.length)
            return H.ioore(match, 3);
          t1 = match[3] == null;
        } else
          t1 = true;
        if (t1) {
          maxCharCode = radix <= 10 ? 48 + radix - 1 : 97 + radix - 10 - 1;
          if (1 >= match.length)
            return H.ioore(match, 1);
          digitsPart = match[1];
          t1 = J.getInterceptor$asx(digitsPart);
          i = 0;
          while (true) {
            t2 = t1.get$length(digitsPart);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            t1.codeUnitAt$1(digitsPart, 0);
            if (t1.codeUnitAt$1(digitsPart, i) > maxCharCode)
              return handleError.call$1(source);
            ++i;
          }
        }
      }
    }
    if (match == null)
      return handleError.call$1(source);
    return parseInt(source, radix);
  },
  Primitives_parseDouble: function(source, handleError) {
    var result, trimmed, t1;
    if (typeof source !== "string")
      H.throwExpression(P.ArgumentError$(source));
    handleError = H.Primitives__throwFormatException$closure();
    if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source))
      return handleError.call$1(source);
    result = parseFloat(source);
    if (isNaN(result)) {
      trimmed = J.trim$0$s(source);
      t1 = J.getInterceptor(trimmed);
      if (t1.$eq(trimmed, "NaN") || t1.$eq(trimmed, "+NaN") || t1.$eq(trimmed, "-NaN"))
        return result;
      return handleError.call$1(source);
    }
    return result;
  },
  Primitives_objectTypeName: function(object) {
    var $name, decompiled;
    $name = C.JS_CONST_8ZY(J.getInterceptor(object));
    if ($name === "Object") {
      decompiled = String(object.constructor).match(/^\s*function\s*(\S*)\s*\(/)[1];
      if (typeof decompiled === "string")
        $name = /^\w+$/.test(decompiled) ? decompiled : $name;
    }
    if ($name.length > 1 && C.JSString_methods.codeUnitAt$1($name, 0) === 36)
      $name = C.JSString_methods.substring$1($name, 1);
    return ($name + H.joinArguments(H.getRuntimeTypeInfo(object), 0, null)).replace(/[^<,> ]+/g, function(m) {
      return init.mangledGlobalNames[m] || m;
    });
  },
  Primitives_objectToString: function(object) {
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Primitives__fromCharCodeApply: function(array) {
    var end, t1, result, i, subarray, t2;
    end = array.length;
    for (t1 = end <= 500, result = "", i = 0; i < end; i += 500) {
      if (t1)
        subarray = array;
      else {
        t2 = i + 500;
        t2 = t2 < end ? t2 : end;
        subarray = array.slice(i, t2);
      }
      result += String.fromCharCode.apply(null, subarray);
    }
    return result;
  },
  Primitives_stringFromCodePoints: function(codePoints) {
    var a, t1, i;
    a = [];
    a.$builtinTypeInfo = [P.$int];
    t1 = new H.ListIterator(codePoints, codePoints.length, 0, null);
    t1.$builtinTypeInfo = [H.getTypeArgumentByIndex(codePoints, 0)];
    for (; t1.moveNext$0();) {
      i = t1._current;
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i <= 65535)
        a.push(i);
      else if (i <= 1114111) {
        a.push(55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
        a.push(56320 + (i & 1023));
      } else
        throw H.wrapException(P.ArgumentError$(i));
    }
    return H.Primitives__fromCharCodeApply(a);
  },
  Primitives_stringFromCharCodes: function(charCodes) {
    var t1, i;
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(charCodes, charCodes.length, 0, null), [H.getTypeArgumentByIndex(charCodes, 0)]); t1.moveNext$0();) {
      i = t1._current;
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i < 0)
        throw H.wrapException(P.ArgumentError$(i));
      if (i > 65535)
        return H.Primitives_stringFromCodePoints(charCodes);
    }
    return H.Primitives__fromCharCodeApply(charCodes);
  },
  Primitives_stringFromCharCode: function(charCode) {
    var bits;
    if (typeof charCode !== "number")
      return H.iae(charCode);
    if (0 <= charCode) {
      if (charCode <= 65535)
        return String.fromCharCode(charCode);
      if (charCode <= 1114111) {
        bits = charCode - 65536;
        return String.fromCharCode((55296 | C.JSNumber_methods._shrOtherPositive$1(bits, 10)) >>> 0, (56320 | bits & 1023) >>> 0);
      }
    }
    throw H.wrapException(P.RangeError$range(charCode, 0, 1114111));
  },
  Primitives_lazyAsJsDate: function(receiver) {
    if (receiver.date === void 0)
      receiver.date = new Date(receiver.millisecondsSinceEpoch);
    return receiver.date;
  },
  Primitives_getProperty: function(object, key) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    return object[key];
  },
  Primitives_setProperty: function(object, key, value) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    object[key] = value;
  },
  Primitives_functionNoSuchMethod: function($function, positionalArguments, namedArguments) {
    var t1, $arguments, namedArgumentList, t2;
    t1 = {};
    t1.argumentCount_0 = 0;
    $arguments = [];
    namedArgumentList = [];
    if (positionalArguments != null) {
      t2 = J.get$length$asx(positionalArguments);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t1.argumentCount_0 = 0 + t2;
      C.JSArray_methods.addAll$1($arguments, positionalArguments);
    }
    t1.names_1 = "";
    if (namedArguments != null && !namedArguments.get$isEmpty(namedArguments))
      namedArguments.forEach$1(0, new H.Primitives_functionNoSuchMethod_closure(t1, $arguments, namedArgumentList));
    return J.noSuchMethod$1($function, new H.JSInvocationMirror(C.Symbol_call, "call$" + H.S(t1.argumentCount_0) + t1.names_1, 0, $arguments, namedArgumentList, null));
  },
  Primitives_applyFunction: function($function, positionalArguments, namedArguments) {
    var t1, jsFunction, info, t2, defaultArguments, t3, i, index, $arguments, argumentCount;
    t1 = {};
    if (namedArguments != null && !namedArguments.get$isEmpty(namedArguments)) {
      jsFunction = J.getInterceptor($function)["call*"];
      if (jsFunction == null)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      info = H.ReflectionInfo_ReflectionInfo(jsFunction);
      if (info == null || !info.areOptionalParametersNamed)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      positionalArguments = positionalArguments != null ? P.List_List$from(positionalArguments, true, null) : [];
      t2 = info.requiredParameterCount;
      if (t2 !== positionalArguments.length)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      defaultArguments = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      for (t3 = info.optionalParameterCount, i = 0; i < t3; ++i) {
        index = i + t2;
        defaultArguments.$indexSet(0, info.parameterNameInOrder$1(index), init.metadata[info.defaultValueInOrder$1(index)]);
      }
      t1.bad_0 = false;
      namedArguments.forEach$1(0, new H.Primitives_applyFunction_closure(t1, defaultArguments));
      if (t1.bad_0)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      C.JSArray_methods.addAll$1(positionalArguments, defaultArguments.get$values(defaultArguments));
      return jsFunction.apply($function, positionalArguments);
    }
    $arguments = [];
    if (positionalArguments != null) {
      t1 = J.get$length$asx(positionalArguments);
      if (typeof t1 !== "number")
        return H.iae(t1);
      argumentCount = 0 + t1;
      C.JSArray_methods.addAll$1($arguments, positionalArguments);
    } else
      argumentCount = 0;
    jsFunction = $function["call$" + H.S(argumentCount)];
    if (jsFunction == null)
      return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
    return jsFunction.apply($function, $arguments);
  },
  JsCache_allocate: function() {
    var result = Object.create(null);
    result.x = 0;
    delete result.x;
    return result;
  },
  iae: function(argument) {
    throw H.wrapException(P.ArgumentError$(argument));
  },
  ioore: function(receiver, index) {
    if (receiver == null)
      J.get$length$asx(receiver);
    if (typeof index !== "number" || Math.floor(index) !== index)
      H.iae(index);
    throw H.wrapException(P.RangeError$value(index));
  },
  wrapException: function(ex) {
    var wrapper;
    if (ex == null)
      ex = new P.NullThrownError();
    wrapper = new Error();
    wrapper.dartException = ex;
    if ("defineProperty" in Object) {
      Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
      wrapper.name = "";
    } else
      wrapper.toString = H.toStringWrapper;
    return wrapper;
  },
  toStringWrapper: [function() {
    return J.toString$0(this.dartException);
  }, "call$0", "toStringWrapper$closure", 0, 0, null],
  throwExpression: function(ex) {
    throw H.wrapException(ex);
  },
  unwrapException: function(ex) {
    var t1, message, number, ieErrorCode, t2, t3, t4, nullLiteralCall, t5, t6, t7, t8, t9, match;
    t1 = new H.unwrapException_saveStackTrace(ex);
    if (ex == null)
      return;
    if (typeof ex !== "object")
      return ex;
    if ("dartException" in ex)
      return t1.call$1(ex.dartException);
    else if (!("message" in ex))
      return ex;
    message = ex.message;
    if ("number" in ex && typeof ex.number == "number") {
      number = ex.number;
      ieErrorCode = number & 65535;
      if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
        switch (ieErrorCode) {
          case 438:
            return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
          case 445:
          case 5007:
            t2 = H.S(message) + " (Error " + ieErrorCode + ")";
            return t1.call$1(new H.NullError(t2, null));
        }
    }
    if (ex instanceof TypeError) {
      t2 = $.get$TypeErrorDecoder_noSuchMethodPattern();
      t3 = $.get$TypeErrorDecoder_notClosurePattern();
      t4 = $.get$TypeErrorDecoder_nullCallPattern();
      nullLiteralCall = $.get$TypeErrorDecoder_nullLiteralCallPattern();
      t5 = $.get$TypeErrorDecoder_undefinedCallPattern();
      t6 = $.get$TypeErrorDecoder_undefinedLiteralCallPattern();
      t7 = $.get$TypeErrorDecoder_nullPropertyPattern();
      $.get$TypeErrorDecoder_nullLiteralPropertyPattern();
      t8 = $.get$TypeErrorDecoder_undefinedPropertyPattern();
      t9 = $.get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
      match = t2.matchTypeError$1(message);
      if (match != null)
        return t1.call$1(H.JsNoSuchMethodError$(message, match));
      else {
        match = t3.matchTypeError$1(message);
        if (match != null) {
          match.method = "call";
          return t1.call$1(H.JsNoSuchMethodError$(message, match));
        } else {
          match = t4.matchTypeError$1(message);
          if (match == null) {
            match = nullLiteralCall.matchTypeError$1(message);
            if (match == null) {
              match = t5.matchTypeError$1(message);
              if (match == null) {
                match = t6.matchTypeError$1(message);
                if (match == null) {
                  match = t7.matchTypeError$1(message);
                  if (match == null) {
                    match = nullLiteralCall.matchTypeError$1(message);
                    if (match == null) {
                      match = t8.matchTypeError$1(message);
                      if (match == null) {
                        match = t9.matchTypeError$1(message);
                        t2 = match != null;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
          } else
            t2 = true;
          if (t2) {
            t2 = match == null ? null : match.method;
            return t1.call$1(new H.NullError(message, t2));
          }
        }
      }
      t2 = typeof message === "string" ? message : "";
      return t1.call$1(new H.UnknownJsTypeError(t2));
    }
    if (ex instanceof RangeError) {
      if (typeof message === "string" && message.indexOf("call stack") !== -1)
        return new P.StackOverflowError();
      return t1.call$1(new P.ArgumentError(null));
    }
    if (typeof InternalError == "function" && ex instanceof InternalError)
      if (typeof message === "string" && message === "too much recursion")
        return new P.StackOverflowError();
    return ex;
  },
  objectHashCode: function(object) {
    if (object == null || typeof object != 'object')
      return J.get$hashCode$(object);
    else
      return H.Primitives_objectHashCode(object);
  },
  fillLiteralMap: function(keyValuePairs, result) {
    var $length, index, index0, index1;
    $length = keyValuePairs.length;
    for (index = 0; index < $length; index = index1) {
      index0 = index + 1;
      index1 = index0 + 1;
      result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
    }
    return result;
  },
  invokeClosure: [function(closure, isolate, numberOfArguments, arg1, arg2, arg3, arg4) {
    var t1 = J.getInterceptor(numberOfArguments);
    if (t1.$eq(numberOfArguments, 0))
      return H._callInIsolate(isolate, new H.invokeClosure_closure(closure));
    else if (t1.$eq(numberOfArguments, 1))
      return H._callInIsolate(isolate, new H.invokeClosure_closure0(closure, arg1));
    else if (t1.$eq(numberOfArguments, 2))
      return H._callInIsolate(isolate, new H.invokeClosure_closure1(closure, arg1, arg2));
    else if (t1.$eq(numberOfArguments, 3))
      return H._callInIsolate(isolate, new H.invokeClosure_closure2(closure, arg1, arg2, arg3));
    else if (t1.$eq(numberOfArguments, 4))
      return H._callInIsolate(isolate, new H.invokeClosure_closure3(closure, arg1, arg2, arg3, arg4));
    else
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
  }, "call$7", "invokeClosure$closure", 14, 0, null, 543, [], 544, [], 545, [], 546, [], 547, [], 548, [], 549, []],
  convertDartClosureToJS: function(closure, arity) {
    var $function;
    if (closure == null)
      return;
    $function = closure.$identity;
    if (!!$function)
      return $function;
    $function = function(closure, arity, context, invoke) {
      return function(a1, a2, a3, a4) {
        return invoke(closure, context, arity, a1, a2, a3, a4);
      };
    }(closure, arity, init.globalState.currentContext, H.invokeClosure);
    closure.$identity = $function;
    return $function;
  },
  Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
    var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
    $function = functions[0];
    $function.$stubName;
    callName = $function.$callName;
    $function.$reflectionInfo = reflectionInfo;
    functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
    $prototype = isStatic ? Object.create(new H.TearOffClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
    $prototype.$initialize = $prototype.constructor;
    if (isStatic)
      $constructor = function() {
        this.$initialize();
      };
    else if (typeof dart_precompiled == "function") {
      t1 = function(a, b, c, d) {
        this.$initialize(a, b, c, d);
      };
      $constructor = t1;
    } else {
      t1 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t1, 1);
      t1 = new Function("a", "b", "c", "d", "this.$initialize(a,b,c,d);" + t1);
      $constructor = t1;
    }
    $prototype.constructor = $constructor;
    $constructor.prototype = $prototype;
    t1 = !isStatic;
    if (t1) {
      isIntercepted = jsArguments.length == 1 && true;
      trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
      trampoline.$reflectionInfo = reflectionInfo;
    } else {
      $prototype.$name = propertyName;
      trampoline = $function;
      isIntercepted = false;
    }
    if (typeof functionType == "number")
      signatureFunction = function(s) {
        return function() {
          return init.metadata[s];
        };
      }(functionType);
    else if (t1 && typeof functionType == "function") {
      getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
      signatureFunction = function(f, r) {
        return function() {
          return f.apply({$receiver: r(this)}, arguments);
        };
      }(functionType, getReceiver);
    } else
      throw H.wrapException("Error in reflectionInfo.");
    $prototype.$signature = signatureFunction;
    $prototype[callName] = trampoline;
    for (t1 = functions.length, i = 1; i < t1; ++i) {
      stub = functions[i];
      stubCallName = stub.$callName;
      if (stubCallName != null) {
        t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
        $prototype[stubCallName] = t2;
      }
    }
    $prototype["call*"] = trampoline;
    return $constructor;
  },
  Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
    var getSelf = H.BoundClosure_selfOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        return function(n, S) {
          return function() {
            return S(this)[n]();
          };
        }(stubName, getSelf);
      case 1:
        return function(n, S) {
          return function(a) {
            return S(this)[n](a);
          };
        }(stubName, getSelf);
      case 2:
        return function(n, S) {
          return function(a, b) {
            return S(this)[n](a, b);
          };
        }(stubName, getSelf);
      case 3:
        return function(n, S) {
          return function(a, b, c) {
            return S(this)[n](a, b, c);
          };
        }(stubName, getSelf);
      case 4:
        return function(n, S) {
          return function(a, b, c, d) {
            return S(this)[n](a, b, c, d);
          };
        }(stubName, getSelf);
      case 5:
        return function(n, S) {
          return function(a, b, c, d, e) {
            return S(this)[n](a, b, c, d, e);
          };
        }(stubName, getSelf);
      default:
        return function(f, s) {
          return function() {
            return f.apply(s(this), arguments);
          };
        }($function, getSelf);
    }
  },
  Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
    var stubName, arity, lookedUpFunction, t1, t2, $arguments;
    if (isIntercepted)
      return H.Closure_forwardInterceptedCallTo(receiver, $function);
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (typeof dart_precompiled == "function" || !t1 || arity >= 27)
      return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
    if (arity === 0) {
      t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t1;
      }
      t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "();";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
    t1 = "return function(" + $arguments + "){return this.";
    t2 = $.BoundClosure_selfFieldNameCache;
    if (t2 == null) {
      t2 = H.BoundClosure_computeFieldNamed("self");
      $.BoundClosure_selfFieldNameCache = t2;
    }
    t2 = t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");";
    t1 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t1, 1);
    return new Function(t2 + H.S(t1) + "}")();
  },
  Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
    var getSelf, getReceiver;
    getSelf = H.BoundClosure_selfOf;
    getReceiver = H.BoundClosure_receiverOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
      case 1:
        return function(n, s, r) {
          return function() {
            return s(this)[n](r(this));
          };
        }($name, getSelf, getReceiver);
      case 2:
        return function(n, s, r) {
          return function(a) {
            return s(this)[n](r(this), a);
          };
        }($name, getSelf, getReceiver);
      case 3:
        return function(n, s, r) {
          return function(a, b) {
            return s(this)[n](r(this), a, b);
          };
        }($name, getSelf, getReceiver);
      case 4:
        return function(n, s, r) {
          return function(a, b, c) {
            return s(this)[n](r(this), a, b, c);
          };
        }($name, getSelf, getReceiver);
      case 5:
        return function(n, s, r) {
          return function(a, b, c, d) {
            return s(this)[n](r(this), a, b, c, d);
          };
        }($name, getSelf, getReceiver);
      case 6:
        return function(n, s, r) {
          return function(a, b, c, d, e) {
            return s(this)[n](r(this), a, b, c, d, e);
          };
        }($name, getSelf, getReceiver);
      default:
        return function(f, s, r, a) {
          return function() {
            a = [r(this)];
            Array.prototype.push.apply(a, arguments);
            return f.apply(s(this), a);
          };
        }($function, getSelf, getReceiver);
    }
  },
  Closure_forwardInterceptedCallTo: function(receiver, $function) {
    var selfField, t1, stubName, arity, isCsp, lookedUpFunction, t2, $arguments;
    selfField = H.BoundClosure_selfFieldName();
    t1 = $.BoundClosure_receiverFieldNameCache;
    if (t1 == null) {
      t1 = H.BoundClosure_computeFieldNamed("receiver");
      $.BoundClosure_receiverFieldNameCache = t1;
    }
    stubName = $function.$stubName;
    arity = $function.length;
    isCsp = typeof dart_precompiled == "function";
    lookedUpFunction = receiver[stubName];
    t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (isCsp || !t2 || arity >= 28)
      return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
    if (arity === 1) {
      t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
    t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
    t2 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t2, 1);
    return new Function(t1 + H.S(t2) + "}")();
  },
  closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
    functions.fixed$length = init;
    reflectionInfo.fixed$length = init;
    return H.Closure_fromTearOff(receiver, functions, reflectionInfo, !!isStatic, jsArguments, $name);
  },
  propertyTypeCastError: function(value, property) {
    var t1 = J.getInterceptor$asx(property);
    throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), t1.substring$2(property, 3, t1.get$length(property))));
  },
  interceptedTypeCast: function(value, property) {
    var t1;
    if (value != null)
      t1 = typeof value === "object" && J.getInterceptor(value)[property];
    else
      t1 = true;
    if (t1)
      return value;
    H.propertyTypeCastError(value, property);
  },
  throwCyclicInit: function(staticName) {
    throw H.wrapException(P.CyclicInitializationError$("Cyclic initialization for static " + H.S(staticName)));
  },
  buildFunctionType: function(returnType, parameterTypes, optionalParameterTypes) {
    return new H.RuntimeFunctionType(returnType, parameterTypes, optionalParameterTypes, null);
  },
  getDynamicRuntimeType: function() {
    return C.C_DynamicRuntimeType;
  },
  random64: function() {
    return (Math.random() * 0x100000000 >>> 0) + (Math.random() * 0x100000000 >>> 0) * 4294967296;
  },
  createRuntimeType: function($name) {
    return new H.TypeImpl($name, null);
  },
  setRuntimeTypeInfo: function(target, typeInfo) {
    if (target != null)
      target.$builtinTypeInfo = typeInfo;
    return target;
  },
  getRuntimeTypeInfo: function(target) {
    if (target == null)
      return;
    return target.$builtinTypeInfo;
  },
  getRuntimeTypeArguments: function(target, substitutionName) {
    return H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
  },
  getRuntimeTypeArgument: function(target, substitutionName, index) {
    var $arguments = H.getRuntimeTypeArguments(target, substitutionName);
    return $arguments == null ? null : $arguments[index];
  },
  getTypeArgumentByIndex: function(target, index) {
    var rti = H.getRuntimeTypeInfo(target);
    return rti == null ? null : rti[index];
  },
  runtimeTypeToString: function(type, onTypeVariable) {
    if (type == null)
      return "dynamic";
    else if (typeof type === "object" && type !== null && type.constructor === Array)
      return type[0].builtin$cls + H.joinArguments(type, 1, onTypeVariable);
    else if (typeof type == "function")
      return type.builtin$cls;
    else if (typeof type === "number" && Math.floor(type) === type)
      if (onTypeVariable == null)
        return C.JSInt_methods.toString$0(type);
      else
        return onTypeVariable.call$1(type);
    else
      return;
  },
  joinArguments: function(types, startIndex, onTypeVariable) {
    var buffer, index, firstArgument, allDynamic, argument, str;
    if (types == null)
      return "";
    buffer = P.StringBuffer$("");
    for (index = startIndex, firstArgument = true, allDynamic = true; index < types.length; ++index) {
      if (firstArgument)
        firstArgument = false;
      else
        buffer._contents += ", ";
      argument = types[index];
      if (argument != null)
        allDynamic = false;
      str = H.runtimeTypeToString(argument, onTypeVariable);
      buffer._contents += typeof str === "string" ? str : H.S(str);
    }
    return allDynamic ? "" : "<" + H.S(buffer) + ">";
  },
  getRuntimeTypeString: function(object) {
    var className = J.getInterceptor(object).constructor.builtin$cls;
    if (object == null)
      return className;
    return className + H.joinArguments(object.$builtinTypeInfo, 0, null);
  },
  substitute: function(substitution, $arguments) {
    if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
      $arguments = substitution;
    else if (typeof substitution == "function") {
      substitution = H.invokeOn(substitution, null, $arguments);
      if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        $arguments = substitution;
      else if (typeof substitution == "function")
        $arguments = H.invokeOn(substitution, null, $arguments);
    }
    return $arguments;
  },
  checkSubtype: function(object, isField, checks, asField) {
    var $arguments, interceptor;
    if (object == null)
      return false;
    $arguments = H.getRuntimeTypeInfo(object);
    interceptor = J.getInterceptor(object);
    if (interceptor[isField] == null)
      return false;
    return H.areSubtypes(H.substitute(interceptor[asField], $arguments), checks);
  },
  areSubtypes: function(s, t) {
    var len, i;
    if (s == null || t == null)
      return true;
    len = s.length;
    for (i = 0; i < len; ++i)
      if (!H.isSubtype(s[i], t[i]))
        return false;
    return true;
  },
  computeSignature: function(signature, context, contextName) {
    return H.invokeOn(signature, context, H.getRuntimeTypeArguments(context, contextName));
  },
  checkSubtypeOfRuntimeType: function(o, t) {
    var rti, type;
    if (o == null)
      return t == null || t.builtin$cls === "Object" || t.builtin$cls === "Null";
    if (t == null)
      return true;
    rti = H.getRuntimeTypeInfo(o);
    o = J.getInterceptor(o);
    if (rti != null) {
      type = rti.slice();
      type.splice(0, 0, o);
    } else
      type = o;
    return H.isSubtype(type, t);
  },
  subtypeOfRuntimeTypeCast: function(object, type) {
    if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(object), H.runtimeTypeToString(type, null)));
    return object;
  },
  isSubtype: function(s, t) {
    var targetSignatureFunction, t1, typeOfS, t2, typeOfT, $name, substitution;
    if (s === t)
      return true;
    if (s == null || t == null)
      return true;
    if ("func" in t) {
      if (!("func" in s)) {
        if ("$is_" + H.S(t.func) in s)
          return true;
        targetSignatureFunction = s.$signature;
        if (targetSignatureFunction == null)
          return false;
        s = targetSignatureFunction.apply(s, null);
      }
      return H.isFunctionSubtype(s, t);
    }
    if (t.builtin$cls === "Function" && "func" in s)
      return true;
    t1 = typeof s === "object" && s !== null && s.constructor === Array;
    typeOfS = t1 ? s[0] : s;
    t2 = typeof t === "object" && t !== null && t.constructor === Array;
    typeOfT = t2 ? t[0] : t;
    $name = H.runtimeTypeToString(typeOfT, null);
    if (typeOfT !== typeOfS) {
      if (!("$is" + H.S($name) in typeOfS))
        return false;
      substitution = typeOfS["$as" + H.S(H.runtimeTypeToString(typeOfT, null))];
    } else
      substitution = null;
    if (!t1 && substitution == null || !t2)
      return true;
    t1 = t1 ? s.slice(1) : null;
    t2 = t2 ? t.slice(1) : null;
    return H.areSubtypes(H.substitute(substitution, t1), t2);
  },
  areAssignable: function(s, t, allowShorter) {
    var sLength, tLength, i, t1, t2;
    if (t == null && s == null)
      return true;
    if (t == null)
      return allowShorter;
    if (s == null)
      return false;
    sLength = s.length;
    tLength = t.length;
    if (allowShorter) {
      if (sLength < tLength)
        return false;
    } else if (sLength !== tLength)
      return false;
    for (i = 0; i < tLength; ++i) {
      t1 = s[i];
      t2 = t[i];
      if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
        return false;
    }
    return true;
  },
  areAssignableMaps: function(s, t) {
    var t1, names, i, $name, tType, sType;
    if (t == null)
      return true;
    if (s == null)
      return false;
    t1 = Object.getOwnPropertyNames(t);
    t1.fixed$length = init;
    names = t1;
    for (t1 = names.length, i = 0; i < t1; ++i) {
      $name = names[i];
      if (!Object.hasOwnProperty.call(s, $name))
        return false;
      tType = t[$name];
      sType = s[$name];
      if (!(H.isSubtype(tType, sType) || H.isSubtype(sType, tType)))
        return false;
    }
    return true;
  },
  isFunctionSubtype: function(s, t) {
    var sReturnType, tReturnType, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, pos, t1, t2, tPos, sPos;
    if (!("func" in s))
      return false;
    if ("void" in s) {
      if (!("void" in t) && "ret" in t)
        return false;
    } else if (!("void" in t)) {
      sReturnType = s.ret;
      tReturnType = t.ret;
      if (!(H.isSubtype(sReturnType, tReturnType) || H.isSubtype(tReturnType, sReturnType)))
        return false;
    }
    sParameterTypes = s.args;
    tParameterTypes = t.args;
    sOptionalParameterTypes = s.opt;
    tOptionalParameterTypes = t.opt;
    sParametersLen = sParameterTypes != null ? sParameterTypes.length : 0;
    tParametersLen = tParameterTypes != null ? tParameterTypes.length : 0;
    sOptionalParametersLen = sOptionalParameterTypes != null ? sOptionalParameterTypes.length : 0;
    tOptionalParametersLen = tOptionalParameterTypes != null ? tOptionalParameterTypes.length : 0;
    if (sParametersLen > tParametersLen)
      return false;
    if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
      return false;
    if (sParametersLen === tParametersLen) {
      if (!H.areAssignable(sParameterTypes, tParameterTypes, false))
        return false;
      if (!H.areAssignable(sOptionalParameterTypes, tOptionalParameterTypes, true))
        return false;
    } else {
      for (pos = 0; pos < sParametersLen; ++pos) {
        t1 = sParameterTypes[pos];
        t2 = tParameterTypes[pos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      for (tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos) {
        t1 = sOptionalParameterTypes[sPos];
        t2 = tParameterTypes[tPos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      for (tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos) {
        t1 = sOptionalParameterTypes[sPos];
        t2 = tOptionalParameterTypes[tPos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
    }
    return H.areAssignableMaps(s.named, t.named);
  },
  invokeOn: function($function, receiver, $arguments) {
    return $function.apply(receiver, $arguments);
  },
  toStringForNativeObject: function(obj) {
    var t1 = $.getTagFunction;
    return "Instance of " + (t1 == null ? "<Unknown>" : t1.call$1(obj));
  },
  hashCodeForNativeObject: function(object) {
    return H.Primitives_objectHashCode(object);
  },
  defineProperty: function(obj, property, value) {
    Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
  },
  lookupAndCacheInterceptor: function(obj) {
    var tag, record, interceptor, interceptorClass, mark, t1;
    tag = $.getTagFunction.call$1(obj);
    record = $.dispatchRecordsForInstanceTags[tag];
    if (record != null) {
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    interceptor = $.interceptorsForUncacheableTags[tag];
    if (interceptor != null)
      return interceptor;
    interceptorClass = init.interceptorsByTag[tag];
    if (interceptorClass == null) {
      tag = $.alternateTagFunction.call$2(obj, tag);
      if (tag != null) {
        record = $.dispatchRecordsForInstanceTags[tag];
        if (record != null) {
          Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
          return record.i;
        }
        interceptor = $.interceptorsForUncacheableTags[tag];
        if (interceptor != null)
          return interceptor;
        interceptorClass = init.interceptorsByTag[tag];
      }
    }
    if (interceptorClass == null)
      return;
    interceptor = interceptorClass.prototype;
    mark = tag[0];
    if (mark === "!") {
      record = H.makeLeafDispatchRecord(interceptor);
      $.dispatchRecordsForInstanceTags[tag] = record;
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    if (mark === "~") {
      $.interceptorsForUncacheableTags[tag] = interceptor;
      return interceptor;
    }
    if (mark === "-") {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    }
    if (mark === "+")
      return H.patchInteriorProto(obj, interceptor);
    if (mark === "*")
      throw H.wrapException(P.UnimplementedError$(tag));
    if (init.leafTags[tag] === true) {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    } else
      return H.patchInteriorProto(obj, interceptor);
  },
  patchInteriorProto: function(obj, interceptor) {
    var proto, record;
    proto = Object.getPrototypeOf(obj);
    record = J.makeDispatchRecord(interceptor, proto, null, null);
    Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
    return interceptor;
  },
  makeLeafDispatchRecord: function(interceptor) {
    return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
  },
  makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
    var interceptor = interceptorClass.prototype;
    if (init.leafTags[tag] === true)
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    else
      return J.makeDispatchRecord(interceptor, proto, null, null);
  },
  initNativeDispatch: function() {
    if (true === $.initNativeDispatchFlag)
      return;
    $.initNativeDispatchFlag = true;
    H.initNativeDispatchContinue();
  },
  initNativeDispatchContinue: function() {
    var map, tags, fun, i, tag, proto, record, interceptorClass;
    $.dispatchRecordsForInstanceTags = Object.create(null);
    $.interceptorsForUncacheableTags = Object.create(null);
    H.initHooks();
    map = init.interceptorsByTag;
    tags = Object.getOwnPropertyNames(map);
    if (typeof window != "undefined") {
      window;
      fun = function() {
      };
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        proto = $.prototypeForTagFunction.call$1(tag);
        if (proto != null) {
          record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
          if (record != null) {
            Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            fun.prototype = proto;
          }
        }
      }
    }
    for (i = 0; i < tags.length; ++i) {
      tag = tags[i];
      if (/^[A-Za-z_]/.test(tag)) {
        interceptorClass = map[tag];
        map["!" + tag] = interceptorClass;
        map["~" + tag] = interceptorClass;
        map["-" + tag] = interceptorClass;
        map["+" + tag] = interceptorClass;
        map["*" + tag] = interceptorClass;
      }
    }
  },
  initHooks: function() {
    var hooks, transformers, i, transformer, getTag, getUnknownTag, prototypeForTag;
    hooks = C.JS_CONST_oRe();
    hooks = H.applyHooksTransformer(C.JS_CONST_0, H.applyHooksTransformer(C.JS_CONST_rr7, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_gkc, H.applyHooksTransformer(C.JS_CONST_4hp, H.applyHooksTransformer(C.JS_CONST_QJm(C.JS_CONST_8ZY), hooks)))))));
    if (typeof dartNativeDispatchHooksTransformer != "undefined") {
      transformers = dartNativeDispatchHooksTransformer;
      if (typeof transformers == "function")
        transformers = [transformers];
      if (transformers.constructor == Array)
        for (i = 0; i < transformers.length; ++i) {
          transformer = transformers[i];
          if (typeof transformer == "function")
            hooks = transformer(hooks) || hooks;
        }
    }
    getTag = hooks.getTag;
    getUnknownTag = hooks.getUnknownTag;
    prototypeForTag = hooks.prototypeForTag;
    $.getTagFunction = new H.initHooks_closure(getTag);
    $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
    $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
  },
  applyHooksTransformer: function(transformer, hooks) {
    return transformer(hooks) || hooks;
  },
  allMatchesInStringUnchecked: function(needle, haystack, startIndex) {
    var result, $length, patternLength, position, endIndex;
    result = H.setRuntimeTypeInfo([], [P.Match]);
    $length = haystack.length;
    patternLength = needle.length;
    for (; true;) {
      position = C.JSString_methods.indexOf$2(haystack, needle, startIndex);
      if (position === -1)
        break;
      result.push(new H.StringMatch(position, haystack, needle));
      endIndex = position + patternLength;
      if (endIndex === $length)
        break;
      else
        startIndex = position === endIndex ? startIndex + 1 : endIndex;
    }
    return result;
  },
  stringContainsUnchecked: function(receiver, other, startIndex) {
    var t1, t2;
    if (typeof other === "string")
      return C.JSString_methods.indexOf$2(receiver, other, startIndex) !== -1;
    else {
      t1 = J.getInterceptor(other);
      if (!!t1.$isJSSyntaxRegExp) {
        t1 = C.JSString_methods.substring$1(receiver, startIndex);
        t2 = other._nativeRegExp;
        return t2.test(t1);
      } else
        return J.get$isNotEmpty$asx(t1.allMatches$1(other, C.JSString_methods.substring$1(receiver, startIndex)));
    }
  },
  stringReplaceAllUnchecked: function(receiver, from, to) {
    var result, $length, i, t1, nativeRegexp;
    if (typeof from === "string")
      if (from === "")
        if (receiver === "")
          return to;
        else {
          result = P.StringBuffer$("");
          $length = receiver.length;
          result.write$1(to);
          for (i = 0; i < $length; ++i) {
            t1 = receiver[i];
            t1 = result._contents += t1;
            result._contents = t1 + to;
          }
          return result._contents;
        }
      else
        return receiver.replace(new RegExp(from.replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), "\\$&"), 'g'), to.replace(/\$/g, "$$$$"));
    else if (!!J.getInterceptor(from).$isJSSyntaxRegExp) {
      nativeRegexp = from.get$_nativeGlobalVersion();
      nativeRegexp.lastIndex = 0;
      return receiver.replace(nativeRegexp, to.replace(/\$/g, "$$$$"));
    } else {
      if (from == null)
        H.throwExpression(P.ArgumentError$(null));
      throw H.wrapException("String.replaceAll(Pattern) UNIMPLEMENTED");
    }
  },
  stringReplaceFirstUnchecked: function(receiver, from, to) {
    if (typeof from === "string")
      return receiver.replace(from, to.replace(/\$/g, "$$$$"));
    else if (!!J.getInterceptor(from).$isJSSyntaxRegExp)
      return receiver.replace(from._nativeRegExp, to.replace(/\$/g, "$$$$"));
    else {
      if (from == null)
        H.throwExpression(P.ArgumentError$(null));
      throw H.wrapException("String.replace(Pattern) UNIMPLEMENTED");
    }
  },
  NoSideEffects: {
    "^": "Object;"
  },
  NoThrows: {
    "^": "Object;"
  },
  NoInline: {
    "^": "Object;"
  },
  Native: {
    "^": "Object;name>"
  },
  ConstantMap: {
    "^": "Object;",
    get$isEmpty: function(_) {
      return J.$eq(this.get$length(this), 0);
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    _throwUnmodifiable$0: function() {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable Map"));
    },
    $indexSet: function(_, key, val) {
      return this._throwUnmodifiable$0();
    },
    remove$1: function(_, key) {
      return this._throwUnmodifiable$0();
    },
    clear$0: function(_) {
      return this._throwUnmodifiable$0();
    },
    addAll$1: function(_, other) {
      return this._throwUnmodifiable$0();
    },
    $isMap: true,
    $asMap: null
  },
  ConstantStringMap: {
    "^": "ConstantMap;length>,_jsObject,_keys",
    containsKey$1: function(_, key) {
      if (typeof key !== "string")
        return false;
      if ("__proto__" === key)
        return false;
      return this._jsObject.hasOwnProperty(key);
    },
    $index: function(_, key) {
      if (!this.containsKey$1(0, key))
        return;
      return this._fetch$1(key);
    },
    _fetch$1: function(key) {
      return this._jsObject[key];
    },
    forEach$1: function(_, f) {
      var keys, i, key;
      keys = this._keys;
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        f.call$2(key, this._fetch$1(key));
      }
    },
    get$keys: function(_) {
      return H.setRuntimeTypeInfo(new H._ConstantMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return H.MappedIterable_MappedIterable(this._keys, new H.ConstantStringMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    $isEfficientLength: true
  },
  ConstantStringMap_values_closure: {
    "^": "Closure:63;this_0",
    call$1: [function(key) {
      return this.this_0._fetch$1(key);
    }, "call$1", null, 2, 0, null, 231, [], "call"],
    $isFunction: true
  },
  _ConstantMapKeyIterable: {
    "^": "IterableBase;__js_helper$_map",
    get$iterator: function(_) {
      return J.get$iterator$ax(this.__js_helper$_map._keys);
    }
  },
  _Patch: {
    "^": "Object;"
  },
  JSInvocationMirror: {
    "^": "Object;__js_helper$_memberName,_internalName,_kind,_arguments,_namedArgumentNames,_namedIndices",
    get$memberName: function() {
      var $name, t1, t2, unmangledName;
      $name = this.__js_helper$_memberName;
      t1 = J.getInterceptor($name);
      if (!!t1.$isSymbol0)
        return $name;
      t2 = $.get$mangledNames();
      unmangledName = t2.$index(0, $name);
      if (unmangledName != null) {
        t1 = unmangledName.split(":");
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        $name = t1[0];
      } else if (t2.$index(0, this._internalName) == null)
        P.print("Warning: '" + t1.toString$0($name) + "' is used reflectively but not in MirrorsUsed. This will break minified code.");
      t1 = new H.Symbol($name);
      this.__js_helper$_memberName = t1;
      return t1;
    },
    get$positionalArguments: function() {
      var t1, argumentCount, list, index;
      if (this._kind === 1)
        return C.List_empty;
      t1 = this._arguments;
      argumentCount = t1.length - this._namedArgumentNames.length;
      if (argumentCount === 0)
        return C.List_empty;
      list = [];
      for (index = 0; index < argumentCount; ++index) {
        if (index >= t1.length)
          return H.ioore(t1, index);
        list.push(t1[index]);
      }
      list.immutable$list = true;
      list.fixed$length = true;
      return list;
    },
    get$namedArguments: function() {
      var t1, namedArgumentCount, t2, namedArgumentsStartIndex, map, i, t3, t4;
      if (this._kind !== 0)
        return P.LinkedHashMap_LinkedHashMap$_empty(P.Symbol0, null);
      t1 = this._namedArgumentNames;
      namedArgumentCount = t1.length;
      t2 = this._arguments;
      namedArgumentsStartIndex = t2.length - namedArgumentCount;
      if (namedArgumentCount === 0)
        return P.LinkedHashMap_LinkedHashMap$_empty(P.Symbol0, null);
      map = P.LinkedHashMap_LinkedHashMap(null, null, null, P.Symbol0, null);
      for (i = 0; i < namedArgumentCount; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t3 = t1[i];
        t4 = namedArgumentsStartIndex + i;
        if (t4 < 0 || t4 >= t2.length)
          return H.ioore(t2, t4);
        map.$indexSet(0, new H.Symbol(t3), t2[t4]);
      }
      return map;
    },
    __js_helper$_getCachedInvocation$1: function(object) {
      var interceptor, $name, isIntercepted, interceptor0, receiver, method, baseName, isCatchAll;
      interceptor = J.getInterceptor(object);
      $name = this._internalName;
      isIntercepted = Object.prototype.hasOwnProperty.call(init.interceptedNames, $name) || $.interceptedNames.indexOf($name) !== -1;
      if (isIntercepted) {
        interceptor0 = object === interceptor ? null : interceptor;
        receiver = interceptor;
        interceptor = interceptor0;
      } else {
        receiver = object;
        interceptor = null;
      }
      method = receiver[$name];
      if (typeof method != "function") {
        baseName = this.get$memberName().get$_name();
        method = receiver[baseName + "*"];
        if (method == null) {
          interceptor = J.getInterceptor(object);
          method = interceptor[baseName + "*"];
          if (method != null)
            isIntercepted = true;
          else
            interceptor = null;
        }
        isCatchAll = true;
      } else
        isCatchAll = false;
      if (typeof method == "function")
        if (isCatchAll)
          return new H.CachedCatchAllInvocation(H.ReflectionInfo_ReflectionInfo(method), $name, method, isIntercepted, interceptor);
        else
          return new H.CachedInvocation($name, method, isIntercepted, interceptor);
      else
        return new H.CachedNoSuchMethodInvocation(interceptor);
    },
    static: {"^": "JSInvocationMirror_METHOD,JSInvocationMirror_GETTER,JSInvocationMirror_SETTER"}
  },
  CachedInvocation: {
    "^": "Object;mangledName<,jsFunction<,isIntercepted<,cachedInterceptor",
    get$isNoSuchMethod: function() {
      return false;
    },
    get$isGetterStub: function() {
      return !!this.jsFunction.$getterStub;
    },
    invokeOn$2: function(victim, $arguments) {
      var receiver, arguments0;
      if (!this.isIntercepted) {
        if ($arguments.constructor !== Array)
          $arguments = P.List_List$from($arguments, true, null);
        receiver = victim;
      } else {
        arguments0 = [victim];
        C.JSArray_methods.addAll$1(arguments0, $arguments);
        receiver = this.cachedInterceptor;
        receiver = receiver != null ? receiver : victim;
        $arguments = arguments0;
      }
      return this.jsFunction.apply(receiver, $arguments);
    }
  },
  CachedCatchAllInvocation: {
    "^": "CachedInvocation;info,mangledName,jsFunction,isIntercepted,cachedInterceptor",
    get$isGetterStub: function() {
      return false;
    },
    invokeOn$2: function(victim, $arguments) {
      var t1, t2, fullParameterCount, providedArgumentCount, receiver, arguments0, i;
      t1 = this.info;
      t2 = t1.requiredParameterCount;
      fullParameterCount = t2 + t1.optionalParameterCount;
      if (!this.isIntercepted) {
        if ($arguments.constructor === Array) {
          providedArgumentCount = $arguments.length;
          if (providedArgumentCount < fullParameterCount)
            $arguments = P.List_List$from($arguments, true, null);
        } else {
          $arguments = P.List_List$from($arguments, true, null);
          providedArgumentCount = $arguments.length;
        }
        receiver = victim;
      } else {
        arguments0 = [victim];
        C.JSArray_methods.addAll$1(arguments0, $arguments);
        receiver = this.cachedInterceptor;
        receiver = receiver != null ? receiver : victim;
        providedArgumentCount = arguments0.length - 1;
        $arguments = arguments0;
      }
      if (t1.areOptionalParametersNamed && providedArgumentCount > t2)
        throw H.wrapException(H.UnimplementedNoSuchMethodError$("Invocation of unstubbed method '" + t1.get$reflectionName() + "' with " + $arguments.length + " arguments."));
      else if (providedArgumentCount < t2)
        throw H.wrapException(H.UnimplementedNoSuchMethodError$("Invocation of unstubbed method '" + t1.get$reflectionName() + "' with " + providedArgumentCount + " arguments (too few)."));
      else if (providedArgumentCount > fullParameterCount)
        throw H.wrapException(H.UnimplementedNoSuchMethodError$("Invocation of unstubbed method '" + t1.get$reflectionName() + "' with " + providedArgumentCount + " arguments (too many)."));
      for (i = providedArgumentCount; i < fullParameterCount; ++i)
        C.JSArray_methods.add$1($arguments, init.metadata[t1.defaultValue$1(0, i)]);
      return this.jsFunction.apply(receiver, $arguments);
    }
  },
  CachedNoSuchMethodInvocation: {
    "^": "Object;interceptor",
    get$isNoSuchMethod: function() {
      return true;
    },
    get$isGetterStub: function() {
      return false;
    },
    invokeOn$2: function(victim, invocation) {
      var receiver = this.interceptor;
      return J.noSuchMethod$1(receiver == null ? victim : receiver, invocation);
    }
  },
  ReflectionInfo: {
    "^": "Object;jsFunction<,data>,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
    parameterName$1: function(parameter) {
      var metadataIndex = this.data[2 * parameter + this.optionalParameterCount + 3];
      return init.metadata[metadataIndex];
    },
    defaultValue$1: [function(_, parameter) {
      var t1 = this.requiredParameterCount;
      if (J.$lt$n(parameter, t1))
        return;
      return this.data[3 + parameter - t1];
    }, "call$1", "get$defaultValue", 2, 0, 210],
    defaultValueInOrder$1: function(parameter) {
      var t1 = this.requiredParameterCount;
      if (parameter < t1)
        return;
      if (!this.areOptionalParametersNamed || this.optionalParameterCount === 1)
        return this.defaultValue$1(0, parameter);
      return this.defaultValue$1(0, this.sortedIndex$1(parameter - t1));
    },
    parameterNameInOrder$1: function(parameter) {
      var t1 = this.requiredParameterCount;
      if (parameter < t1)
        return;
      if (!this.areOptionalParametersNamed || this.optionalParameterCount === 1)
        return this.parameterName$1(parameter);
      return this.parameterName$1(this.sortedIndex$1(parameter - t1));
    },
    sortedIndex$1: function(unsortedIndex) {
      var t1, t2, positions, t3, i, index, compare;
      t1 = {};
      if (this.cachedSortedIndices == null) {
        t2 = this.optionalParameterCount;
        this.cachedSortedIndices = Array(t2);
        positions = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.$int);
        for (t3 = this.requiredParameterCount, i = 0; i < t2; ++i) {
          index = t3 + i;
          positions.$indexSet(0, this.parameterName$1(index), index);
        }
        t1.index_0 = 0;
        t2 = positions.get$keys(positions).toList$0(0);
        compare = P.Comparable_compare$closure();
        H.Sort__doSort(t2, 0, t2.length - 1, compare);
        H.IterableMixinWorkaround_forEach(t2, new H.ReflectionInfo_sortedIndex_closure(t1, this, positions));
      }
      t1 = this.cachedSortedIndices;
      if (unsortedIndex < 0 || unsortedIndex >= t1.length)
        return H.ioore(t1, unsortedIndex);
      return t1[unsortedIndex];
    },
    computeFunctionRti$1: function(jsConstructor) {
      var t1, fakeInstance;
      t1 = this.functionType;
      if (typeof t1 == "number")
        return init.metadata[t1];
      else if (typeof t1 == "function") {
        fakeInstance = new jsConstructor();
        H.setRuntimeTypeInfo(fakeInstance, fakeInstance["<>"]);
        return t1.apply({$receiver: fakeInstance});
      } else
        throw H.wrapException(H.RuntimeError$("Unexpected function type"));
    },
    get$reflectionName: function() {
      return this.jsFunction.$reflectionName;
    },
    static: {"^": "ReflectionInfo_REQUIRED_PARAMETERS_INFO,ReflectionInfo_OPTIONAL_PARAMETERS_INFO,ReflectionInfo_FUNCTION_TYPE_INDEX,ReflectionInfo_FIRST_DEFAULT_ARGUMENT", ReflectionInfo_ReflectionInfo: function(jsFunction) {
        var data, requiredParametersInfo, optionalParametersInfo;
        data = jsFunction.$reflectionInfo;
        if (data == null)
          return;
        data.fixed$length = init;
        data = data;
        requiredParametersInfo = data[0];
        optionalParametersInfo = data[1];
        return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParametersInfo >> 1, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
      }}
  },
  ReflectionInfo_sortedIndex_closure: {
    "^": "Closure:52;box_0,this_1,positions_2",
    call$1: function($name) {
      var t1, t2, t3;
      t1 = this.this_1.cachedSortedIndices;
      t2 = this.box_0.index_0++;
      t3 = this.positions_2.$index(0, $name);
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      t1[t2] = t3;
    },
    $isFunction: true
  },
  Primitives_functionNoSuchMethod_closure: {
    "^": "Closure:80;box_0,arguments_1,namedArgumentList_2",
    call$2: function($name, argument) {
      var t1 = this.box_0;
      t1.names_1 = t1.names_1 + "$" + H.S($name);
      this.namedArgumentList_2.push($name);
      this.arguments_1.push(argument);
      ++t1.argumentCount_0;
    },
    $isFunction: true
  },
  Primitives_applyFunction_closure: {
    "^": "Closure:80;box_0,defaultArguments_1",
    call$2: function(parameter, value) {
      var t1 = this.defaultArguments_1;
      if (t1.containsKey$1(0, parameter))
        t1.$indexSet(0, parameter, value);
      else
        this.box_0.bad_0 = true;
    },
    $isFunction: true
  },
  TypeErrorDecoder: {
    "^": "Object;_pattern,_arguments,_argumentsExpr,_expr,_method,_receiver",
    matchTypeError$1: function(message) {
      var match, result, t1;
      match = new RegExp(this._pattern).exec(message);
      if (match == null)
        return;
      result = {};
      t1 = this._arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    },
    static: {"^": "TypeErrorDecoder_noSuchMethodPattern,TypeErrorDecoder_notClosurePattern,TypeErrorDecoder_nullCallPattern,TypeErrorDecoder_nullLiteralCallPattern,TypeErrorDecoder_undefinedCallPattern,TypeErrorDecoder_undefinedLiteralCallPattern,TypeErrorDecoder_nullPropertyPattern,TypeErrorDecoder_nullLiteralPropertyPattern,TypeErrorDecoder_undefinedPropertyPattern,TypeErrorDecoder_undefinedLiteralPropertyPattern", TypeErrorDecoder_extractPattern: function(message) {
        var match, $arguments, argumentsExpr, expr, method, receiver;
        message = message.replace(String({}), '$receiver$').replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), '\\$&');
        match = message.match(/\\\$[a-zA-Z]+\\\$/g);
        if (match == null)
          match = [];
        $arguments = match.indexOf("\\$arguments\\$");
        argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
        expr = match.indexOf("\\$expr\\$");
        method = match.indexOf("\\$method\\$");
        receiver = match.indexOf("\\$receiver\\$");
        return new H.TypeErrorDecoder(message.replace('\\$arguments\\$', '((?:x|[^x])*)').replace('\\$argumentsExpr\\$', '((?:x|[^x])*)').replace('\\$expr\\$', '((?:x|[^x])*)').replace('\\$method\\$', '((?:x|[^x])*)').replace('\\$receiver\\$', '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
      }, TypeErrorDecoder_provokeCallErrorOn: function(expression) {
        return function($expr$) {
          var $argumentsExpr$ = '$arguments$';
          try {
            $expr$.$method$($argumentsExpr$);
          } catch (e) {
            return e.message;
          }

        }(expression);
      }, TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
        return function($expr$) {
          try {
            $expr$.$method$;
          } catch (e) {
            return e.message;
          }

        }(expression);
      }}
  },
  NullError: {
    "^": "Error;_message,_method",
    toString$0: function(_) {
      var t1 = this._method;
      if (t1 == null)
        return "NullError: " + H.S(this._message);
      return "NullError: Cannot call \"" + H.S(t1) + "\" on null";
    },
    $isError: true
  },
  JsNoSuchMethodError: {
    "^": "Error;_message,_method,_receiver",
    toString$0: function(_) {
      var t1, t2;
      t1 = this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(this._message);
      t2 = this._receiver;
      if (t2 == null)
        return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" (" + H.S(this._message) + ")";
      return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" on \"" + H.S(t2) + "\" (" + H.S(this._message) + ")";
    },
    $isError: true,
    static: {JsNoSuchMethodError$: function(_message, match) {
        var t1, t2;
        t1 = match == null;
        t2 = t1 ? null : match.method;
        t1 = t1 ? null : match.receiver;
        return new H.JsNoSuchMethodError(_message, t2, t1);
      }}
  },
  UnknownJsTypeError: {
    "^": "Error;_message",
    toString$0: function(_) {
      var t1 = this._message;
      return C.JSString_methods.get$isEmpty(t1) ? "Error" : "Error: " + t1;
    }
  },
  unwrapException_saveStackTrace: {
    "^": "Closure:63;ex_0",
    call$1: function(error) {
      if (!!J.getInterceptor(error).$isError)
        if (error.$thrownJsError == null)
          error.$thrownJsError = this.ex_0;
      return error;
    },
    $isFunction: true
  },
  _StackTrace: {
    "^": "Object;_exception,_trace",
    toString$0: function(_) {
      var t1, trace;
      t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this._exception;
      trace = typeof t1 === "object" ? t1.stack : null;
      t1 = trace == null ? "" : trace;
      this._trace = t1;
      return t1;
    }
  },
  invokeClosure_closure: {
    "^": "Closure:13;closure_0",
    call$0: function() {
      return this.closure_0.call$0();
    },
    $isFunction: true
  },
  invokeClosure_closure0: {
    "^": "Closure:13;closure_1,arg1_2",
    call$0: function() {
      return this.closure_1.call$1(this.arg1_2);
    },
    $isFunction: true
  },
  invokeClosure_closure1: {
    "^": "Closure:13;closure_3,arg1_4,arg2_5",
    call$0: function() {
      return this.closure_3.call$2(this.arg1_4, this.arg2_5);
    },
    $isFunction: true
  },
  invokeClosure_closure2: {
    "^": "Closure:13;closure_6,arg1_7,arg2_8,arg3_9",
    call$0: function() {
      return this.closure_6.call$3(this.arg1_7, this.arg2_8, this.arg3_9);
    },
    $isFunction: true
  },
  invokeClosure_closure3: {
    "^": "Closure:13;closure_10,arg1_11,arg2_12,arg3_13,arg4_14",
    call$0: function() {
      return this.closure_10.call$4(this.arg1_11, this.arg2_12, this.arg3_13, this.arg4_14);
    },
    $isFunction: true
  },
  Closure: {
    "^": "Object;",
    toString$0: function(_) {
      return "Closure";
    },
    $isClosure: true,
    $isFunction: true,
    get$$call: function() {
      return this;
    }
  },
  "+Closure": [632, 0],
  TearOffClosure: {
    "^": "Closure;",
    $isTearOffClosure: true
  },
  BoundClosure: {
    "^": "TearOffClosure;_self,__js_helper$_target,_receiver,__js_helper$_name",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.getInterceptor(other).$isBoundClosure)
        return false;
      return this._self === other._self && this.__js_helper$_target === other.__js_helper$_target && this._receiver === other._receiver;
    },
    get$hashCode: function(_) {
      var t1, receiverHashCode;
      t1 = this._receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      return J.$xor$n(receiverHashCode, H.Primitives_objectHashCode(this.__js_helper$_target));
    },
    $isBoundClosure: true,
    static: {"^": "BoundClosure_selfFieldNameCache,BoundClosure_receiverFieldNameCache", BoundClosure_selfOf: function(closure) {
        return closure._self;
      }, BoundClosure_receiverOf: function(closure) {
        return closure._receiver;
      }, BoundClosure_selfFieldName: function() {
        var t1 = $.BoundClosure_selfFieldNameCache;
        if (t1 == null) {
          t1 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t1;
        }
        return t1;
      }, BoundClosure_computeFieldNamed: function(fieldName) {
        var template, t1, names, i, $name;
        template = new H.BoundClosure("self", "target", "receiver", "name");
        t1 = Object.getOwnPropertyNames(template);
        t1.fixed$length = init;
        names = t1;
        for (t1 = names.length, i = 0; i < t1; ++i) {
          $name = names[i];
          if (template[$name] === fieldName)
            return $name;
        }
      }}
  },
  "+BoundClosure": [1679],
  Creates: {
    "^": "Object;types"
  },
  Returns: {
    "^": "Object;types"
  },
  JSName: {
    "^": "Object;name>"
  },
  CastErrorImplementation: {
    "^": "Error;message",
    toString$0: function(_) {
      return this.message;
    },
    $isError: true,
    static: {CastErrorImplementation$: function(actualType, expectedType) {
        return new H.CastErrorImplementation("CastError: Casting value of type " + H.S(actualType) + " to incompatible type " + H.S(expectedType));
      }}
  },
  RuntimeError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "RuntimeError: " + H.S(this.message);
    },
    static: {RuntimeError$: function(message) {
        return new H.RuntimeError(message);
      }}
  },
  RuntimeType: {
    "^": "Object;"
  },
  RuntimeFunctionType: {
    "^": "RuntimeType;returnType,parameterTypes,optionalParameterTypes,namedParameters",
    _isTest$1: function(expression) {
      var functionTypeObject = this._extractFunctionTypeObjectFrom$1(expression);
      return functionTypeObject == null ? false : H.isFunctionSubtype(functionTypeObject, this.toRti$0());
    },
    _extractFunctionTypeObjectFrom$1: function(o) {
      var interceptor = J.getInterceptor(o);
      return "$signature" in interceptor ? interceptor.$signature() : null;
    },
    toRti$0: function() {
      var result, t1, t2, namedRti, keys, i, $name;
      result = {func: "dynafunc"};
      t1 = this.returnType;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isVoidRuntimeType)
        result.void = true;
      else if (!t2.$isDynamicRuntimeType)
        result.ret = t1.toRti$0();
      t1 = this.parameterTypes;
      if (t1 != null && t1.length !== 0)
        result.args = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0)
        result.opt = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.namedParameters;
      if (t1 != null) {
        namedRti = {};
        keys = H.extractKeys(t1);
        for (t2 = keys.length, i = 0; i < t2; ++i) {
          $name = keys[i];
          namedRti[$name] = t1[$name].toRti$0();
        }
        result.named = namedRti;
      }
      return result;
    },
    toString$0: function(_) {
      var t1, t2, result, needsComma, i, type, keys, $name;
      t1 = this.parameterTypes;
      if (t1 != null)
        for (t2 = t1.length, result = "(", needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = t1[i];
          if (needsComma)
            result += ", ";
          result += H.S(type);
        }
      else {
        result = "(";
        needsComma = false;
      }
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0) {
        result = (needsComma ? result + ", " : result) + "[";
        for (t2 = t1.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = t1[i];
          if (needsComma)
            result += ", ";
          result += H.S(type);
        }
        result += "]";
      } else {
        t1 = this.namedParameters;
        if (t1 != null) {
          result = (needsComma ? result + ", " : result) + "{";
          keys = H.extractKeys(t1);
          for (t2 = keys.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
            $name = keys[i];
            if (needsComma)
              result += ", ";
            result += H.S(t1[$name].toRti$0()) + " " + $name;
          }
          result += "}";
        }
      }
      return result + (") -> " + H.S(this.returnType));
    },
    static: {"^": "RuntimeFunctionType_inAssert", RuntimeFunctionType_listToRti: function(list) {
        var result, t1, i;
        list = list;
        result = [];
        for (t1 = list.length, i = 0; i < t1; ++i)
          result.push(list[i].toRti$0());
        return result;
      }}
  },
  DynamicRuntimeType: {
    "^": "RuntimeType;",
    toString$0: function(_) {
      return "dynamic";
    },
    toRti$0: function() {
      return;
    },
    $isDynamicRuntimeType: true
  },
  UnimplementedNoSuchMethodError: {
    "^": "Error;_message",
    toString$0: function(_) {
      return "Unsupported operation: " + this._message;
    },
    $isError: true,
    static: {UnimplementedNoSuchMethodError$: function(_message) {
        return new H.UnimplementedNoSuchMethodError(_message);
      }}
  },
  TypeImpl: {
    "^": "Object;_typeName<,_unmangledName",
    toString$0: function(_) {
      var t1, unmangledName;
      t1 = this._unmangledName;
      if (t1 != null)
        return t1;
      unmangledName = this._typeName.replace(/[^<,> ]+/g, function(m) {
        return init.mangledGlobalNames[m] || m;
      });
      this._unmangledName = unmangledName;
      return unmangledName;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this._typeName);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isTypeImpl && J.$eq(this._typeName, other._typeName);
    },
    $isTypeImpl: true,
    $isType: true
  },
  TypeVariable: {
    "^": "Object;owner<,name>,bound"
  },
  initHooks_closure: {
    "^": "Closure:63;getTag_0",
    call$1: function(o) {
      return this.getTag_0(o);
    },
    $isFunction: true
  },
  initHooks_closure0: {
    "^": "Closure:1680;getUnknownTag_1",
    call$2: function(o, tag) {
      return this.getUnknownTag_1(o, tag);
    },
    $isFunction: true
  },
  initHooks_closure1: {
    "^": "Closure:52;prototypeForTag_2",
    call$1: function(tag) {
      return this.prototypeForTag_2(tag);
    },
    $isFunction: true
  },
  JSSyntaxRegExp: {
    "^": "Object;pattern,_nativeRegExp,_nativeGlobalRegExp,_nativeAnchoredRegExp",
    get$_nativeGlobalVersion: function() {
      var t1 = this._nativeGlobalRegExp;
      if (t1 != null)
        return t1;
      t1 = this._nativeRegExp;
      t1 = H.JSSyntaxRegExp_makeNative(this.pattern, t1.multiline, !t1.ignoreCase, true);
      this._nativeGlobalRegExp = t1;
      return t1;
    },
    get$_nativeAnchoredVersion: function() {
      var t1 = this._nativeAnchoredRegExp;
      if (t1 != null)
        return t1;
      t1 = this._nativeRegExp;
      t1 = H.JSSyntaxRegExp_makeNative(this.pattern + "|()", t1.multiline, !t1.ignoreCase, true);
      this._nativeAnchoredRegExp = t1;
      return t1;
    },
    firstMatch$1: function(string) {
      var m = this._nativeRegExp.exec(string);
      if (m == null)
        return;
      return H._MatchImplementation$(this, m);
    },
    allMatches$2: function(_, string, start) {
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length));
      return new H._AllMatchesIterable(this, string, start);
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    _execGlobal$2: function(string, start) {
      var regexp, match;
      regexp = this.get$_nativeGlobalVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      return H._MatchImplementation$(this, match);
    },
    _execAnchored$2: function(string, start) {
      var regexp, match, t1, t2;
      regexp = this.get$_nativeAnchoredVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      t1 = match.length;
      t2 = t1 - 1;
      if (t2 < 0)
        return H.ioore(match, t2);
      if (match[t2] != null)
        return;
      C.JSArray_methods.set$length(match, t2);
      return H._MatchImplementation$(this, match);
    },
    matchAsPrefix$2: function(_, string, start) {
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length));
      return this._execAnchored$2(string, start);
    },
    $isJSSyntaxRegExp: true,
    $isRegExp: true,
    static: {JSSyntaxRegExp_makeNative: function(source, multiLine, caseSensitive, global) {
        var m, i, g, regexp, errorMessage;
        m = multiLine ? "m" : "";
        i = caseSensitive ? "" : "i";
        g = global ? "g" : "";
        regexp = function() {
          try {
            return new RegExp(source, m + i + g);
          } catch (e) {
            return e;
          }

        }();
        if (regexp instanceof RegExp)
          return regexp;
        errorMessage = String(regexp);
        throw H.wrapException(P.FormatException$("Illegal RegExp pattern: " + source + ", " + errorMessage, null, null));
      }}
  },
  _MatchImplementation: {
    "^": "Object;pattern,_match",
    get$input: function() {
      return this._match.input;
    },
    get$start: function(_) {
      return this._match.index;
    },
    start$1: function($receiver, arg0) {
      return this.get$start(this).call$1(arg0);
    },
    start$0: function($receiver) {
      return this.get$start(this).call$0();
    },
    start$3: function($receiver, arg0, arg1, arg2) {
      return this.get$start(this).call$3(arg0, arg1, arg2);
    },
    start$2: function($receiver, arg0, arg1) {
      return this.get$start(this).call$2(arg0, arg1);
    },
    start$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.get$start(this).call$4(arg0, arg1, arg2, arg3);
    },
    start$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.get$start(this).call$5(arg0, arg1, arg2, arg3, arg4);
    },
    get$end: function() {
      var t1, t2;
      t1 = this._match;
      t2 = t1.index;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1 = J.get$length$asx(t1[0]);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return t2 + t1;
    },
    end$0: function() {
      return this.get$end().call$0();
    },
    $index: function(_, index) {
      var t1 = this._match;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    _MatchImplementation$2: function(pattern, _match) {
    },
    $isMatch: true,
    static: {_MatchImplementation$: function(pattern, _match) {
        var t1 = new H._MatchImplementation(pattern, _match);
        t1._MatchImplementation$2(pattern, _match);
        return t1;
      }}
  },
  _AllMatchesIterable: {
    "^": "IterableBase;_re,_string,__js_helper$_start",
    get$iterator: function(_) {
      return new H._AllMatchesIterator(this._re, this._string, this.__js_helper$_start, null);
    },
    $asIterableBase: function() {
      return [P.Match];
    }
  },
  _AllMatchesIterator: {
    "^": "Object;_regExp,_string,_nextIndex,__js_helper$_current",
    get$current: function() {
      return this.__js_helper$_current;
    },
    moveNext$0: function() {
      var t1, t2, match, t3, nextIndex;
      t1 = this._string;
      if (t1 == null)
        return false;
      t2 = this._nextIndex;
      if (t2 <= t1.length) {
        match = this._regExp._execGlobal$2(t1, t2);
        if (match != null) {
          this.__js_helper$_current = match;
          t1 = match._match;
          t2 = t1.index;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t3 = J.get$length$asx(t1[0]);
          if (typeof t3 !== "number")
            return H.iae(t3);
          nextIndex = t2 + t3;
          this._nextIndex = t1.index === nextIndex ? nextIndex + 1 : nextIndex;
          return true;
        }
      }
      this.__js_helper$_current = null;
      this._string = null;
      return false;
    }
  },
  StringMatch: {
    "^": "Object;start>,input<,pattern",
    get$end: function() {
      return this.start + this.pattern.length;
    },
    end$0: function() {
      return this.get$end().call$0();
    },
    $index: function(_, g) {
      if (!J.$eq(g, 0))
        H.throwExpression(P.RangeError$value(g));
      return this.pattern;
    },
    start$1: function($receiver, arg0) {
      return this.start.call$1(arg0);
    },
    start$0: function($receiver) {
      return this.start.call$0();
    },
    start$3: function($receiver, arg0, arg1, arg2) {
      return this.start.call$3(arg0, arg1, arg2);
    },
    start$2: function($receiver, arg0, arg1) {
      return this.start.call$2(arg0, arg1);
    },
    start$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.start.call$4(arg0, arg1, arg2, arg3);
    },
    start$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.start.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    $isMatch: true
  }
}],
["alienzed", "main.dart", , Z, {
  "^": "",
  main: [function() {
    J.set$display$x(document.querySelector("#logo").style, "none");
    J.set$backgroundColor$x(document.querySelector("body").style, "black");
    P.print("create new game.0");
    var game = new Z.Alienzed(null, null, null, null, "", null, null, null, null, null, null, 0, false, false, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    game.Game$8(320, 480, 1, "", null, null, null, null);
    game.Alienzed$0();
    P.print("create new game.1");
  }, "call$0", "main$closure", 0, 0, 550],
  Alienzed: {
    "^": "Game;game@,width-601,height-601,renderer-809,parent-639,state-995,transparent-602,antialias-602,physicsConfig-754,id-599,config-754,renderType-599,isBooted-602,isRunning-602,raf-996,add-997,make-998,world-983,cache-999,input-1000,load-1001,net-1002,scale-1003,sound-1004,plugins-1005,stage-1006,time-1007,physics-1008,tweens-1009,rnd-1010,device-1011,camera-1012,canvas-808,context-850,debug-1013,particles-1014,stepping-602,pendingStep-602,stepCount-601,onPause-1015,onResume-1015,onBlur-1015,onFocus-1015,_paused-602,_codePaused-602,preserveDrawingBuffer-602,_onBoot-0",
    Alienzed$0: function() {
      var t1, t2, t3;
      P.print("Class Alienzed initialized");
      t1 = this.state;
      t2 = new Z.Start(false, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2.State$0();
      t3 = J.getInterceptor$ax(t1);
      t3.add$2(t1, "Start", t2);
      t2 = new Z.Assets(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2.State$0();
      t3.add$2(t1, "Assets", t2);
      t2 = new Z.Intro(1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2.State$0();
      t3.add$2(t1, "Intro", t2);
      t2 = new Z.Levels(C.C__JSRandom, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2.State$0();
      t3.add$2(t1, "Levels", t2);
      t2 = new Z.GameOver(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2.State$0();
      t3.add$2(t1, "GameOver", t2);
      t3.start$1(t1, "Start");
    },
    static: {"^": "Alienzed_GEMSIZE,Alienzed_MARGINTOP,Alienzed_GEMTYPES"}
  },
  Assets: {
    "^": "State;game-598,add-997,make-998,camera-1012,cache-999,input-1000,math-1060,load-1001,sound-1004,scale-1003,stage-1006,time-1007,tweens-1009,world-983,particles-1014,physics-1008,rnd-1010,state-995",
    preload$0: [function(_) {
      var t1;
      P.print("Class Assets initialized");
      t1 = this.load;
      t1.setPreloadSprite$1(this.add.sprite$3(0, 0, "splashScreen"));
      t1.image$2("background", "images/background.png");
      t1.image$2("board", "images/board.png");
      t1.image$2("startButton", "images/start_button.png");
      t1.image$2("arrow_right", "images/arrows/right.png");
      t1.image$2("arrow_left", "images/arrows/left.png");
      t1.image$2("arrow_down", "images/arrows/down.png");
      t1.image$2("arrow_lrot", "images/arrows/lrot.png");
      t1.image$2("arrow_rrot", "images/arrows/rrot.png");
      t1.image$2("gem_blue", "images/gems/blue.png");
      t1.image$2("gem_cyan", "images/gems/cyan.png");
      t1.image$2("gem_green", "images/gems/green.png");
      t1.image$2("gem_magenta", "images/gems/magenta.png");
      t1.image$2("gem_orange", "images/gems/orange.png");
      t1.image$2("gem_pink", "images/gems/pink.png");
      t1.image$2("gem_red", "images/gems/red.png");
      t1.image$2("gem_yellow", "images/gems/yellow.png");
    }, "call$0", "get$preload", 0, 0, 13, "preload"],
    create$0: [function() {
      J.start$3$x(this.state, "Intro", true, false);
    }, "call$0", "get$create", 0, 0, 13, "create"]
  },
  GameOver: {
    "^": "State;startButton,game-598,add-997,make-998,camera-1012,cache-999,input-1000,math-1060,load-1001,sound-1004,scale-1003,stage-1006,time-1007,tweens-1009,world-983,particles-1014,physics-1008,rnd-1010,state-995",
    create$0: [function() {
      var style, gameOver;
      style = R.TextStyle$("center", "#e22", "bold 30px Acme", "black", 0, 16777215);
      gameOver = J.text$4$x(this.add, 0, 0, "Game Over", style);
      gameOver.set$fixedToCamera(true);
      gameOver.get$cameraOffset().setTo$2(0, 0);
      this.startButton = J.button$5$x(this.add, J.$sub$n(this.world.get$centerX(), 95), 350, "startButton", this.get$startGame(), this);
    }, "call$0", "get$create", 0, 0, 13, "create"],
    startGame$3: [function(source, input, flag) {
      J.start$3$x(this.state, "Level1", true, false);
    }, "call$3", "get$startGame", 6, 0, 117, 170, [], 342, [], 1681, []]
  },
  Gem: {
    "^": "MatchObject;x*,y*,sprite@,level@,type",
    sprite$3: function(arg0, arg1, arg2) {
      return this.sprite.call$3(arg0, arg1, arg2);
    },
    sprite$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.sprite.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    sprite$4: function(arg0, arg1, arg2, arg3) {
      return this.sprite.call$4(arg0, arg1, arg2, arg3);
    },
    move$2: function(x, y) {
      this.x = x;
      this.y = y;
      J.set$x$x(this.sprite, J.$mul$ns(x, 48));
      J.set$y$x(this.sprite, J.$mul$ns(y, 48));
    },
    fall$3: function(x, y, next) {
      var t1, t2, point;
      t1 = J.$mul$ns(x, 48);
      t2 = J.$mul$ns(y, 48);
      if (typeof t2 !== "number")
        return H.iae(t2);
      point = P.LinkedHashMap_LinkedHashMap$_literal(["x", t1, "y", 96 + t2], null, null);
      t2 = this.level.add.tween$1(this.sprite);
      $.get$Easing_Bounce().toString;
      J.add$1$ax(t2.to$7(point, 500, $.get$Bounce_OUT().compute, true, 0, 0, false).onComplete, next);
    },
    Gem$4: function(level, type, x, y) {
      this.sprite = this.level.add.sprite$3(0, 0, "gem_" + type);
      this.move$2(this.x, this.y);
    },
    static: {Gem$: function(level, type, x, y) {
        var t1 = new Z.Gem(x, y, null, level, type);
        t1.Gem$4(level, type, x, y);
        return t1;
      }}
  },
  GemGroup: {
    "^": "Object;x*,currentPattern,patterns,gems,level@",
    updatePositions$0: function() {
      var t1, t2, pattern;
      t1 = this.patterns;
      t2 = this.currentPattern;
      if (t2 >>> 0 !== t2 || t2 >= 4)
        return H.ioore(t1, t2);
      pattern = t1[t2];
      t2 = pattern.first;
      this.gems.$index(0, "first").move$2(J.$add$ns(this.x, t2.x), t2.y);
      t2 = pattern.second;
      this.gems.$index(0, "second").move$2(J.$add$ns(this.x, t2.x), t2.y);
    },
    drop$0: function() {
      var t1, t2, t3, pattern;
      t1 = {};
      t2 = this.patterns;
      t3 = this.currentPattern;
      if (t3 >>> 0 !== t3 || t3 >= 4)
        return H.ioore(t2, t3);
      pattern = t2[t3];
      t1.dropped_0 = 0;
      H.IterableMixinWorkaround_forEach(pattern.order, new Z.GemGroup_drop_closure(t1, this, 2));
    },
    move$1: function(deltaX) {
      var newX, t1, maxX;
      newX = J.$add$ns(this.x, deltaX);
      t1 = this.currentPattern;
      maxX = t1 === 1 || t1 === 3 ? 4 : 5;
      t1 = J.getInterceptor$n(newX);
      if (t1.$ge(newX, 0) && t1.$le(newX, maxX))
        this.x = newX;
      this.updatePositions$0();
    },
    rotate$1: [function(_, direction) {
      var t1 = this.currentPattern;
      if (typeof direction !== "number")
        return H.iae(direction);
      t1 += direction;
      this.currentPattern = t1;
      if (t1 >= 4)
        this.currentPattern = 0;
      else if (t1 < 0)
        this.currentPattern = 3;
      if (J.$eq(this.x, 5)) {
        t1 = this.currentPattern;
        t1 = t1 === 1 || t1 === 3;
      } else
        t1 = false;
      if (t1)
        this.x = 4;
      this.updatePositions$0();
    }, "call$1", "get$rotate", 2, 0, 1682, 538, []],
    GemGroup$1: function(level) {
      var t1, t2, t3, t4, t5, t6;
      this.x = 0;
      t1 = ["first", "second"];
      t2 = new M.Pair(null, new M.Locus(0, 0), new M.Locus(0, 1), t1);
      t2.order = [t1[1], t1[0]];
      t1 = ["first", "second"];
      t3 = new M.Pair(null, new M.Locus(1, 1), new M.Locus(0, 1), t1);
      t3.order = [t1[1], t1[0]];
      t1 = ["first", "second"];
      t4 = new M.Pair(null, new M.Locus(0, 1), new M.Locus(0, 0), t1);
      t4.order = [t1[0], t1[1]];
      t1 = ["first", "second"];
      t5 = new M.Pair(null, new M.Locus(0, 1), new M.Locus(1, 1), t1);
      t5.order = [t1[0], t1[1]];
      this.patterns = [t2, t3, t4, t5];
      this.currentPattern = 0;
      t5 = this.level;
      t4 = t5.randomGemType$0();
      t3 = this.x;
      t2 = this.patterns;
      t1 = this.currentPattern;
      if (t1 >>> 0 !== t1 || t1 >= 4)
        return H.ioore(t2, t1);
      t1 = J.$add$ns(t3, t2[t1].first.x);
      t2 = this.patterns;
      t3 = this.currentPattern;
      if (t3 >>> 0 !== t3 || t3 >= 4)
        return H.ioore(t2, t3);
      t3 = Z.Gem$(t5, t4, t1, t2[t3].first.y);
      t2 = this.level;
      t1 = t2.randomGemType$0();
      t4 = this.x;
      t5 = this.patterns;
      t6 = this.currentPattern;
      if (t6 >>> 0 !== t6 || t6 >= 4)
        return H.ioore(t5, t6);
      t6 = J.$add$ns(t4, t5[t6].second.x);
      t5 = this.patterns;
      t4 = this.currentPattern;
      if (t4 >>> 0 !== t4 || t4 >= 4)
        return H.ioore(t5, t4);
      this.gems = P.LinkedHashMap_LinkedHashMap$_literal(["first", t3, "second", Z.Gem$(t2, t1, t6, t5[t4].second.y)], null, null);
    },
    static: {GemGroup$: function(level) {
        var t1 = new Z.GemGroup(0, 0, null, null, level);
        t1.GemGroup$1(level);
        return t1;
      }}
  },
  GemGroup_drop_closure: {
    "^": "Closure:63;box_0,this_1,gemsCount_2",
    call$1: [function(i) {
      var t1, t2, lastEmpty, t3;
      t1 = this.this_1;
      t2 = t1.gems.$index(0, i);
      lastEmpty = M.Grid_getLastEmptyPiece(t2.level.grid.getColumn$2(t2.x, 1));
      if (lastEmpty != null) {
        lastEmpty.set$object(t2);
        t3 = J.getInterceptor$x(lastEmpty);
        t2.fall$3(t3.get$x(lastEmpty), t3.get$y(lastEmpty), new Z.GemGroup_drop__closure(this.box_0, t1, this.gemsCount_2));
      } else
        J.start$3$x(t2.level.state, "GameOver", false, false);
    }, "call$1", null, 2, 0, null, 381, [], "call"],
    $isFunction: true
  },
  GemGroup_drop__closure: {
    "^": "Closure:1415;box_0,this_3,gemsCount_4",
    call$1: [function(s) {
      if (++this.box_0.dropped_0 === this.gemsCount_4)
        this.this_3.level.handleMatches$0();
    }, "call$1", null, 2, 0, null, 502, [], "call"],
    $isFunction: true
  },
  Intro: {
    "^": "State;level@,game-598,add-997,make-998,camera-1012,cache-999,input-1000,math-1060,load-1001,sound-1004,scale-1003,stage-1006,time-1007,tweens-1009,world-983,particles-1014,physics-1008,rnd-1010,state-995",
    create$0: [function() {
      var t1 = this.add;
      t1.sprite$3(0, 0, "splashScreen");
      J.button$5$x(t1, J.$sub$n(this.world.get$centerX(), 95), 350, "startButton", this.get$startGame(), this);
    }, "call$0", "get$create", 0, 0, 13, "create"],
    startGame$3: [function(source, input, flag) {
      J.start$3$x(this.state, "Levels", true, false);
    }, "call$3", "get$startGame", 6, 0, 117, 170, [], 342, [], 1681, []]
  },
  Levels: {
    "^": "State;rnd:alienzed$Levels$rnd@-1683,background,board,grid,startButton,text*,discoveredGems,gemGroup,score,game-598,add-997,make-998,camera-1012,cache-999,input-1000,math-1060,load-1001,sound-1004,scale-1003,stage-1006,time-1007,tweens-1009,world-983,particles-1014,physics-1008,rnd-1010,state-995",
    rnd$0: function() {
      return this.alienzed$Levels$rnd.call$0();
    },
    text$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.text.call$4(arg0, arg1, arg2, arg3);
    },
    text$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return this.text.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    text$3: function($receiver, arg0, arg1, arg2) {
      return this.text.call$3(arg0, arg1, arg2);
    },
    create$0: [function() {
      var t1, t2;
      this.time.set$advancedTiming(true);
      this.score = 0;
      this.background = this.add.sprite$3(0, 0, "background");
      t1 = this.add.sprite$3(0, 0, "board");
      this.board = t1;
      J.set$alpha$x(t1, 0.7);
      this.text = J.text$4$x(this.add, 100, 20, "Score: 0", R.TextStyle$("left", "#e0e0e0", "bold 30px Acme", "black", 0, 16777215));
      this.grid = M.Grid$("down", 7, 6);
      t1 = $.get$Alienzed_GEMTYPES();
      this.discoveredGems = [t1[0], t1[1], t1[2]];
      this.gemGroup = Z.GemGroup$(this);
      t1 = this.add;
      t2 = J.getInterceptor$x(t1);
      t2.button$5(t1, 0, 420, "arrow_left", this.get$leftButton(), this);
      t2.button$5(t1, 50, 420, "arrow_down", this.get$dropButton(), this);
      t2.button$5(t1, 100, 420, "arrow_right", this.get$rightButton(), this);
      t2.button$5(t1, 210, 420, "arrow_lrot", this.get$lrotButton(), this);
      t2.button$5(t1, 260, 420, "arrow_rrot", this.get$rrotButton(), this);
    }, "call$0", "get$create", 0, 0, 13, "create"],
    leftButton$3: [function(source, input, flag) {
      this.gemGroup.move$1(-1);
    }, "call$3", "get$leftButton", 6, 0, 117, 170, [], 342, [], 1681, []],
    rightButton$3: [function(source, input, flag) {
      this.gemGroup.move$1(1);
    }, "call$3", "get$rightButton", 6, 0, 117, 170, [], 342, [], 1681, []],
    lrotButton$3: [function(source, input, flag) {
      this.gemGroup.rotate$1(0, -1);
    }, "call$3", "get$lrotButton", 6, 0, 117, 170, [], 342, [], 1681, []],
    rrotButton$3: [function(source, input, flag) {
      this.gemGroup.rotate$1(0, 1);
    }, "call$3", "get$rrotButton", 6, 0, 117, 170, [], 342, [], 1681, []],
    dropButton$3: [function(source, input, flag) {
      this.gemGroup.drop$0();
      this.gemGroup = null;
    }, "call$3", "get$dropButton", 6, 0, 117, 170, [], 342, [], 1681, []],
    handleMatches$0: function() {
      var t1 = {};
      t1.piecesToUpgrade_0 = null;
      if (this.grid.getMatches$0() != null) {
        t1.piecesToUpgrade_0 = [];
        this.grid.forEachMatch$1(new Z.Levels_handleMatches_closure(t1, this));
        this.grid.clearMatches$0();
        this.handleUpgrade$1(t1.piecesToUpgrade_0);
      }
      this.handleFalling$0();
    },
    handleFalling$0: function() {
      var t1, fallingPieces;
      t1 = {};
      fallingPieces = this.grid.applyGravity$0();
      t1.hasFall_0 = null;
      if (fallingPieces.length > 0) {
        t1.hasFall_0 = 0;
        fallingPieces.toString;
        H.IterableMixinWorkaround_forEach(fallingPieces, new Z.Levels_handleFalling_closure(t1, this, fallingPieces));
      } else
        this.gemGroup = Z.GemGroup$(this);
    },
    handleUpgrade$1: function(piecesToUpgrade) {
      piecesToUpgrade.toString;
      H.IterableMixinWorkaround_forEach(piecesToUpgrade, new Z.Levels_handleUpgrade_closure(this));
    },
    randomGemType$0: function() {
      var i, t1;
      i = this.alienzed$Levels$rnd.integerInRange$2(0, this.discoveredGems.length - 1);
      t1 = this.discoveredGems;
      if (i >>> 0 !== i || i >= t1.length)
        return H.ioore(t1, i);
      return t1[i];
    }
  },
  Levels_handleMatches_closure: {
    "^": "Closure:935;box_0,this_1",
    call$2: function(matchingPieces, type) {
      var t1, t2, t3, t4;
      t1 = this.this_1;
      t2 = J.getInterceptor$asx(matchingPieces);
      t3 = J.$mul$ns(J.$add$ns(H.Lists_indexOf($.get$Alienzed_GEMTYPES(), type, 0, 8), 1), t2.get$length(matchingPieces));
      t4 = t1.score;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = t4 + t3;
      t1.score = t3;
      J.set$text$x(t1.text, "Score: " + H.S(t3));
      t1.text.updateText$0();
      this.box_0.piecesToUpgrade_0.push(P.LinkedHashMap_LinkedHashMap$_literal(["piece", t2.$index(matchingPieces, 0), "type", type], null, null));
      t2.forEach$1(matchingPieces, new Z.Levels_handleMatches__closure(t1));
    },
    $isFunction: true
  },
  Levels_handleMatches__closure: {
    "^": "Closure:63;this_2",
    call$1: [function(matchingPiece) {
      var t1, t2;
      t1 = J.repeat$1$x(this.this_2.add.tween$1(matchingPiece.get$object().get$sprite()), 6);
      t2 = P.LinkedHashMap_LinkedHashMap$_literal(["alpha", 0], null, null);
      $.get$Easing_Linear().toString;
      J.add$1$ax(t1.to$7(t2, 75, $.get$Linear_INOUT().compute, true, 0, 0, true).onComplete, new Z.Levels_handleMatches___closure());
    }, "call$1", null, 2, 0, null, 1684, [], "call"],
    $isFunction: true
  },
  Levels_handleMatches___closure: {
    "^": "Closure:1415;",
    call$1: [function(s) {
      return s.destroy$0();
    }, "call$1", null, 2, 0, null, 502, [], "call"],
    $isFunction: true
  },
  Levels_handleFalling_closure: {
    "^": "Closure:63;box_0,this_1,fallingPieces_2",
    call$1: function(piece) {
      var t1 = J.getInterceptor$x(piece);
      piece.get$object().fall$3(t1.get$x(piece), t1.get$y(piece), new Z.Levels_handleFalling__closure(this.box_0, this.this_1, this.fallingPieces_2));
    },
    $isFunction: true
  },
  Levels_handleFalling__closure: {
    "^": "Closure:1415;box_0,this_3,fallingPieces_4",
    call$1: [function(s) {
      var t1, t2, hasFall;
      t1 = this.box_0;
      t2 = t1.hasFall_0;
      if (typeof t2 !== "number")
        return t2.$add();
      hasFall = t2 + 1;
      t1.hasFall_0 = hasFall;
      if (hasFall === this.fallingPieces_4.length)
        this.this_3.handleMatches$0();
    }, "call$1", null, 2, 0, null, 502, [], "call"],
    $isFunction: true
  },
  Levels_handleUpgrade_closure: {
    "^": "Closure:63;this_0",
    call$1: function(pieceToUpgrade) {
      var t1, t2, upgradedType;
      t1 = $.get$Alienzed_GEMTYPES();
      t2 = J.$add$ns(H.Lists_indexOf(t1, J.$index$asx(pieceToUpgrade, "type"), 0, 8), 1);
      if (t2 >>> 0 !== t2 || t2 >= 8)
        return H.ioore(t1, t2);
      upgradedType = t1[t2];
      t1 = this.this_0;
      t2 = t1.discoveredGems;
      if (J.$eq(H.Lists_indexOf(t2, upgradedType, 0, t2.length), -1))
        t1.discoveredGems.push(upgradedType);
    },
    $isFunction: true
  },
  Start: {
    "^": "State;orientated,game-598,add-997,make-998,camera-1012,cache-999,input-1000,math-1060,load-1001,sound-1004,scale-1003,stage-1006,time-1007,tweens-1009,world-983,particles-1014,physics-1008,rnd-1010,state-995",
    preload$0: [function(_) {
      this.load.image$2("splashScreen", "images/splash.png");
    }, "call$0", "get$preload", 0, 0, 13, "preload"],
    create$0: [function() {
      var t1, t2;
      P.print("Class Start initialized");
      this.input.set$maxPointers(1);
      this.stage.set$disableVisibilityChange(true);
      t1 = this.game.get$device().get$desktop();
      t2 = this.scale;
      if (t1 === true) {
        t2.set$scaleMode(2);
        t1 = J.getInterceptor$x(t2);
        t1.set$minWidth(t2, 320);
        t1.set$minHeight(t2, 480);
        t1.set$maxWidth(t2, 640);
        t1.set$maxHeight(t2, 960);
        t2.set$pageAlignHorizontally(true);
        t2.set$pageAlignVertically(true);
        t2.setScreenSize$1(true);
      } else {
        t2.set$scaleMode(2);
        t1 = J.getInterceptor$x(t2);
        t1.set$minWidth(t2, 320);
        t1.set$minHeight(t2, 480);
        t1.set$maxWidth(t2, 640);
        t1.set$maxHeight(t2, 960);
        t2.set$pageAlignHorizontally(true);
        t2.set$pageAlignVertically(true);
        t2.forceOrientation$1(false);
        J.add$2$ax(t2.get$hasResized(), this.get$gameResized(), this);
        J.add$2$ax(t2.get$enterIncorrectOrientation(), this.get$enterIncorrectOrientation(), this);
        J.add$2$ax(t2.get$leaveIncorrectOrientation(), this.get$leaveIncorrectOrientation(), this);
        t2.setScreenSize$1(true);
      }
      J.start$3$x(this.state, "Assets", true, false);
    }, "call$0", "get$create", 0, 0, 13, "create"],
    gameResized$2: [function(width, height) {
    }, "call$2", "get$gameResized", 4, 0, 935, 10, [], 11, []],
    enterIncorrectOrientation$0: [function() {
      this.orientated = false;
      J.set$display$x(document.querySelector("#orientation").style, "block");
    }, "call$0", "get$enterIncorrectOrientation", 0, 0, 13],
    leaveIncorrectOrientation$0: [function() {
      this.orientated = true;
      J.set$display$x(document.querySelector("#orientation").style, "none");
    }, "call$0", "get$leaveIncorrectOrientation", 0, 0, 13]
  }
},
1],
["dart._internal", "dart:_internal", , H, {
  "^": "",
  IterableElementError_noElement: function() {
    return new P.StateError("No element");
  },
  IterableElementError_tooFew: function() {
    return new P.StateError("Too few elements");
  },
  Lists_copy: function(src, srcStart, dst, dstStart, count) {
    var t1, i, j, t2, t3;
    t1 = J.getInterceptor$n(srcStart);
    if (t1.$lt(srcStart, dstStart))
      for (i = J.$sub$n(t1.$add(srcStart, count), 1), j = J.$sub$n(J.$add$ns(dstStart, count), 1), t1 = J.getInterceptor$asx(src); t2 = J.getInterceptor$n(i), t2.$ge(i, srcStart); i = t2.$sub(i, 1), j = J.$sub$n(j, 1))
        C.JSArray_methods.$indexSet(dst, j, t1.$index(src, i));
    else
      for (t2 = J.getInterceptor$asx(src), j = dstStart, i = srcStart; t3 = J.getInterceptor$n(i), t3.$lt(i, t1.$add(srcStart, count)); i = t3.$add(i, 1), j = J.$add$ns(j, 1))
        C.JSArray_methods.$indexSet(dst, j, t2.$index(src, i));
  },
  Lists_indexOf: function(a, element, startIndex, endIndex) {
    var t1, i;
    t1 = J.getInterceptor$n(startIndex);
    if (t1.$ge(startIndex, a.length))
      return -1;
    if (t1.$lt(startIndex, 0))
      startIndex = 0;
    for (i = startIndex; J.$lt$n(i, endIndex); ++i) {
      if (i >>> 0 !== i || i >= a.length)
        return H.ioore(a, i);
      if (J.$eq(a[i], element))
        return i;
    }
    return -1;
  },
  Sort__doSort: function(a, left, right, compare) {
    if (J.$le$n(J.$sub$n(right, left), 32))
      H.Sort__insertionSort(a, left, right, compare);
    else
      H.Sort__dualPivotQuicksort(a, left, right, compare);
  },
  Sort__insertionSort: function(a, left, right, compare) {
    var i, t1, t2, el, j, t3;
    for (i = J.$add$ns(left, 1), t1 = J.getInterceptor$asx(a); t2 = J.getInterceptor$n(i), t2.$le(i, right); i = t2.$add(i, 1)) {
      el = t1.$index(a, i);
      j = i;
      while (true) {
        t3 = J.getInterceptor$n(j);
        if (!(t3.$gt(j, left) && J.$gt$n(compare.call$2(t1.$index(a, t3.$sub(j, 1)), el), 0)))
          break;
        t1.$indexSet(a, j, t1.$index(a, t3.$sub(j, 1)));
        j = t3.$sub(j, 1);
      }
      t1.$indexSet(a, j, el);
    }
  },
  Sort__dualPivotQuicksort: function(a, left, right, compare) {
    var t1, sixth, t2, index1, index5, index3, t3, index2, index4, el1, el2, el3, el4, el5, t0, less, great, k, ak, comp, t4, less0, great0, pivots_are_equal;
    t1 = J.getInterceptor$n(right);
    sixth = J.$tdiv$n(J.$add$ns(t1.$sub(right, left), 1), 6);
    t2 = J.getInterceptor$ns(left);
    index1 = t2.$add(left, sixth);
    index5 = t1.$sub(right, sixth);
    index3 = J.$tdiv$n(t2.$add(left, right), 2);
    t3 = J.getInterceptor$n(index3);
    index2 = t3.$sub(index3, sixth);
    index4 = t3.$add(index3, sixth);
    t3 = J.getInterceptor$asx(a);
    el1 = t3.$index(a, index1);
    el2 = t3.$index(a, index2);
    el3 = t3.$index(a, index3);
    el4 = t3.$index(a, index4);
    el5 = t3.$index(a, index5);
    if (J.$gt$n(compare.call$2(el1, el2), 0)) {
      t0 = el2;
      el2 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    if (J.$gt$n(compare.call$2(el1, el3), 0)) {
      t0 = el3;
      el3 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el1, el4), 0)) {
      t0 = el4;
      el4 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el3, el4), 0)) {
      t0 = el4;
      el4 = el3;
      el3 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el5), 0)) {
      t0 = el5;
      el5 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    t3.$indexSet(a, index1, el1);
    t3.$indexSet(a, index3, el3);
    t3.$indexSet(a, index5, el5);
    t3.$indexSet(a, index2, t3.$index(a, left));
    t3.$indexSet(a, index4, t3.$index(a, right));
    less = t2.$add(left, 1);
    great = t1.$sub(right, 1);
    if (J.$eq(compare.call$2(el2, el4), 0)) {
      for (k = less; t1 = J.getInterceptor$n(k), t1.$le(k, great); k = t1.$add(k, 1)) {
        ak = t3.$index(a, k);
        comp = compare.call$2(ak, el2);
        t2 = J.getInterceptor(comp);
        if (t2.$eq(comp, 0))
          continue;
        if (t2.$lt(comp, 0)) {
          if (!t1.$eq(k, less)) {
            t3.$indexSet(a, k, t3.$index(a, less));
            t3.$indexSet(a, less, ak);
          }
          less = J.$add$ns(less, 1);
        } else
          for (; true;) {
            comp = compare.call$2(t3.$index(a, great), el2);
            t2 = J.getInterceptor$n(comp);
            if (t2.$gt(comp, 0)) {
              great = J.$sub$n(great, 1);
              continue;
            } else {
              t4 = J.getInterceptor$n(great);
              if (t2.$lt(comp, 0)) {
                t3.$indexSet(a, k, t3.$index(a, less));
                less0 = J.$add$ns(less, 1);
                t3.$indexSet(a, less, t3.$index(a, great));
                great0 = t4.$sub(great, 1);
                t3.$indexSet(a, great, ak);
                great = great0;
                less = less0;
                break;
              } else {
                t3.$indexSet(a, k, t3.$index(a, great));
                great0 = t4.$sub(great, 1);
                t3.$indexSet(a, great, ak);
                great = great0;
                break;
              }
            }
          }
      }
      pivots_are_equal = true;
    } else {
      for (k = less; t1 = J.getInterceptor$n(k), t1.$le(k, great); k = t1.$add(k, 1)) {
        ak = t3.$index(a, k);
        if (J.$lt$n(compare.call$2(ak, el2), 0)) {
          if (!t1.$eq(k, less)) {
            t3.$indexSet(a, k, t3.$index(a, less));
            t3.$indexSet(a, less, ak);
          }
          less = J.$add$ns(less, 1);
        } else if (J.$gt$n(compare.call$2(ak, el4), 0))
          for (; true;)
            if (J.$gt$n(compare.call$2(t3.$index(a, great), el4), 0)) {
              great = J.$sub$n(great, 1);
              if (J.$lt$n(great, k))
                break;
              continue;
            } else {
              t2 = J.getInterceptor$n(great);
              if (J.$lt$n(compare.call$2(t3.$index(a, great), el2), 0)) {
                t3.$indexSet(a, k, t3.$index(a, less));
                less0 = J.$add$ns(less, 1);
                t3.$indexSet(a, less, t3.$index(a, great));
                great0 = t2.$sub(great, 1);
                t3.$indexSet(a, great, ak);
                great = great0;
                less = less0;
              } else {
                t3.$indexSet(a, k, t3.$index(a, great));
                great0 = t2.$sub(great, 1);
                t3.$indexSet(a, great, ak);
                great = great0;
              }
              break;
            }
      }
      pivots_are_equal = false;
    }
    t1 = J.getInterceptor$n(less);
    t3.$indexSet(a, left, t3.$index(a, t1.$sub(less, 1)));
    t3.$indexSet(a, t1.$sub(less, 1), el2);
    t2 = J.getInterceptor$ns(great);
    t3.$indexSet(a, right, t3.$index(a, t2.$add(great, 1)));
    t3.$indexSet(a, t2.$add(great, 1), el4);
    H.Sort__doSort(a, left, t1.$sub(less, 2), compare);
    H.Sort__doSort(a, t2.$add(great, 2), right, compare);
    if (pivots_are_equal)
      return;
    if (t1.$lt(less, index1) && t2.$gt(great, index5)) {
      for (; J.$eq(compare.call$2(t3.$index(a, less), el2), 0);)
        less = J.$add$ns(less, 1);
      for (; J.$eq(compare.call$2(t3.$index(a, great), el4), 0);)
        great = J.$sub$n(great, 1);
      for (k = less; t1 = J.getInterceptor$n(k), t1.$le(k, great); k = t1.$add(k, 1)) {
        ak = t3.$index(a, k);
        if (J.$eq(compare.call$2(ak, el2), 0)) {
          if (!t1.$eq(k, less)) {
            t3.$indexSet(a, k, t3.$index(a, less));
            t3.$indexSet(a, less, ak);
          }
          less = J.$add$ns(less, 1);
        } else if (J.$eq(compare.call$2(ak, el4), 0))
          for (; true;)
            if (J.$eq(compare.call$2(t3.$index(a, great), el4), 0)) {
              great = J.$sub$n(great, 1);
              if (J.$lt$n(great, k))
                break;
              continue;
            } else {
              t2 = J.getInterceptor$n(great);
              if (J.$lt$n(compare.call$2(t3.$index(a, great), el2), 0)) {
                t3.$indexSet(a, k, t3.$index(a, less));
                less0 = J.$add$ns(less, 1);
                t3.$indexSet(a, less, t3.$index(a, great));
                great0 = t2.$sub(great, 1);
                t3.$indexSet(a, great, ak);
                great = great0;
                less = less0;
              } else {
                t3.$indexSet(a, k, t3.$index(a, great));
                great0 = t2.$sub(great, 1);
                t3.$indexSet(a, great, ak);
                great = great0;
              }
              break;
            }
      }
      H.Sort__doSort(a, less, great, compare);
    } else
      H.Sort__doSort(a, less, great, compare);
  },
  ListIterable: {
    "^": "IterableBase;",
    get$iterator: function(_) {
      return H.setRuntimeTypeInfo(new H.ListIterator(this, this.get$length(this), 0, null), [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
    },
    forEach$1: function(_, action) {
      var $length, i;
      $length = this.get$length(this);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        action.call$1(this.elementAt$1(0, i));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return J.$eq(this.get$length(this), 0);
    },
    get$last: function(_) {
      if (J.$eq(this.get$length(this), 0))
        throw H.wrapException(H.IterableElementError_noElement());
      return this.elementAt$1(0, J.$sub$n(this.get$length(this), 1));
    },
    contains$1: [function(_, element) {
      var $length, i;
      $length = this.get$length(this);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        if (J.$eq(this.elementAt$1(0, i), element))
          return true;
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return false;
    }, "call$1", "get$contains", 2, 0, 1677],
    any$1: [function(_, test) {
      var $length, i;
      $length = this.get$length(this);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        if (test.call$1(this.elementAt$1(0, i)) === true)
          return true;
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return false;
    }, "call$1", "get$any", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__bool__E0", ret: P.bool, args: [{func: "bool__E0", ret: P.bool, args: [E]}]};
      }, this.$receiver, "ListIterable");
    }],
    firstWhere$2$orElse: function(_, test, orElse) {
      var $length, i, element;
      $length = this.get$length(this);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        element = this.elementAt$1(0, i);
        if (test.call$1(element) === true)
          return element;
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return orElse.call$0();
    },
    join$1: function(_, separator) {
      var $length, t1, first, buffer, i, str;
      $length = this.get$length(this);
      if (separator.length !== 0) {
        t1 = J.getInterceptor($length);
        if (t1.$eq($length, 0))
          return "";
        first = H.S(this.elementAt$1(0, 0));
        if (!t1.$eq($length, this.get$length(this)))
          throw H.wrapException(P.ConcurrentModificationError$(this));
        buffer = P.StringBuffer$(first);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 1;
        for (; i < $length; ++i) {
          buffer._contents += separator;
          str = this.elementAt$1(0, i);
          buffer._contents += typeof str === "string" ? str : H.S(str);
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return buffer._contents;
      } else {
        buffer = P.StringBuffer$("");
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          str = this.elementAt$1(0, i);
          buffer._contents += typeof str === "string" ? str : H.S(str);
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return buffer._contents;
      }
    },
    where$1: function(_, test) {
      return P.IterableBase.prototype.where$1.call(this, this, test);
    },
    map$1: [function(_, f) {
      return H.setRuntimeTypeInfo(new H.MappedListIterable(this, f), [null, null]);
    }, "call$1", "get$map", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "Iterable__dynamic__E0", ret: P.Iterable, args: [{func: "dynamic__E0", args: [E]}]};
      }, this.$receiver, "ListIterable");
    }],
    fold$2: function(_, initialValue, combine) {
      var $length, value, i;
      $length = this.get$length(this);
      if (typeof $length !== "number")
        return H.iae($length);
      value = initialValue;
      i = 0;
      for (; i < $length; ++i) {
        value = combine.call$2(value, this.elementAt$1(0, i));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return value;
    },
    toList$1$growable: function(_, growable) {
      var result, t1, i;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(this));
      } else {
        t1 = this.get$length(this);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = Array(t1);
        t1.fixed$length = init;
        result = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
      }
      i = 0;
      while (true) {
        t1 = this.get$length(this);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        t1 = this.elementAt$1(0, i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
        ++i;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    $isEfficientLength: true
  },
  SubListIterable: {
    "^": "ListIterable;_iterable,_start,_endOrLength",
    get$_endIndex: function() {
      var $length, t1;
      $length = J.get$length$asx(this._iterable);
      t1 = this._endOrLength;
      if (t1 == null || J.$gt$n(t1, $length))
        return $length;
      return t1;
    },
    get$_startIndex: function() {
      var $length, t1;
      $length = J.get$length$asx(this._iterable);
      t1 = this._start;
      if (J.$gt$n(t1, $length))
        return $length;
      return t1;
    },
    get$length: function(_) {
      var $length, t1, t2;
      $length = J.get$length$asx(this._iterable);
      t1 = this._start;
      if (J.$ge$n(t1, $length))
        return 0;
      t2 = this._endOrLength;
      if (t2 == null || J.$ge$n(t2, $length))
        return J.$sub$n($length, t1);
      return J.$sub$n(t2, t1);
    },
    elementAt$1: function(_, index) {
      var realIndex = J.$add$ns(this.get$_startIndex(), index);
      if (J.$lt$n(index, 0) || J.$ge$n(realIndex, this.get$_endIndex()))
        throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this)));
      return J.elementAt$1$ax(this._iterable, realIndex);
    },
    take$1: function(_, count) {
      var t1, t2, newEnd;
      if (J.$lt$n(count, 0))
        throw H.wrapException(P.RangeError$value(count));
      t1 = this._endOrLength;
      t2 = this._start;
      if (t1 == null)
        return H.SubListIterable$(this._iterable, t2, J.$add$ns(t2, count), H.getTypeArgumentByIndex(this, 0));
      else {
        newEnd = J.$add$ns(t2, count);
        if (J.$lt$n(t1, newEnd))
          return this;
        return H.SubListIterable$(this._iterable, t2, newEnd, H.getTypeArgumentByIndex(this, 0));
      }
    },
    SubListIterable$3: function(_iterable, _start, _endOrLength, $E) {
      var t1, t2, t3;
      t1 = this._start;
      t2 = J.getInterceptor$n(t1);
      if (t2.$lt(t1, 0))
        throw H.wrapException(P.RangeError$value(t1));
      t3 = this._endOrLength;
      if (t3 != null) {
        if (J.$lt$n(t3, 0))
          throw H.wrapException(P.RangeError$value(t3));
        if (t2.$gt(t1, t3))
          throw H.wrapException(P.RangeError$range(t1, 0, t3));
      }
    },
    static: {SubListIterable$: function(_iterable, _start, _endOrLength, $E) {
        var t1 = H.setRuntimeTypeInfo(new H.SubListIterable(_iterable, _start, _endOrLength), [$E]);
        t1.SubListIterable$3(_iterable, _start, _endOrLength, $E);
        return t1;
      }}
  },
  ListIterator: {
    "^": "Object;_iterable,_length,_index,_current",
    get$current: function() {
      return this._current;
    },
    moveNext$0: function() {
      var t1, t2, $length, t3;
      t1 = this._iterable;
      t2 = J.getInterceptor$asx(t1);
      $length = t2.get$length(t1);
      if (!J.$eq(this._length, $length))
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t3 = this._index;
      if (typeof $length !== "number")
        return H.iae($length);
      if (t3 >= $length) {
        this._current = null;
        return false;
      }
      this._current = t2.elementAt$1(t1, t3);
      ++this._index;
      return true;
    }
  },
  MappedIterable: {
    "^": "IterableBase;_iterable,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    get$iterator: function(_) {
      var t1 = new H.MappedIterator(null, J.get$iterator$ax(this._iterable), this._f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$length: function(_) {
      return J.get$length$asx(this._iterable);
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this._iterable);
    },
    get$last: function(_) {
      return this._f$1(J.get$last$ax(this._iterable));
    },
    elementAt$1: function(_, index) {
      return this._f$1(J.elementAt$1$ax(this._iterable, index));
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    static: {MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
        if (!!J.getInterceptor(iterable).$isEfficientLength)
          return H.setRuntimeTypeInfo(new H.EfficientLengthMappedIterable(iterable, $function), [$S, $T]);
        return H.setRuntimeTypeInfo(new H.MappedIterable(iterable, $function), [$S, $T]);
      }}
  },
  EfficientLengthMappedIterable: {
    "^": "MappedIterable;_iterable,_f",
    $isEfficientLength: true
  },
  MappedIterator: {
    "^": "Iterator;_current,_iterator,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    moveNext$0: function() {
      var t1 = this._iterator;
      if (t1.moveNext$0()) {
        this._current = this._f$1(t1.get$current());
        return true;
      }
      this._current = null;
      return false;
    },
    get$current: function() {
      return this._current;
    },
    $asIterator: function($S, $T) {
      return [$T];
    }
  },
  MappedListIterable: {
    "^": "ListIterable;__internal$_source,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    get$length: function(_) {
      return J.get$length$asx(this.__internal$_source);
    },
    elementAt$1: function(_, index) {
      return this._f$1(J.elementAt$1$ax(this.__internal$_source, index));
    },
    $asListIterable: function($S, $T) {
      return [$T];
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    $isEfficientLength: true
  },
  WhereIterable: {
    "^": "IterableBase;_iterable,_f",
    get$iterator: function(_) {
      var t1 = new H.WhereIterator(J.get$iterator$ax(this._iterable), this._f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    }
  },
  WhereIterator: {
    "^": "Iterator;_iterator,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    moveNext$0: function() {
      for (var t1 = this._iterator; t1.moveNext$0();)
        if (this._f$1(t1.get$current()) === true)
          return true;
      return false;
    },
    get$current: function() {
      return this._iterator.get$current();
    }
  },
  IterableMixinWorkaround: {
    "^": "Object;",
    static: {IterableMixinWorkaround_forEach: function(iterable, f) {
        var t1;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();)
          f.call$1(t1._current);
      }, IterableMixinWorkaround_any: function(iterable, f) {
        var t1;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();)
          if (f.call$1(t1._current) === true)
            return true;
        return false;
      }, IterableMixinWorkaround_fold: function(iterable, initialValue, combine) {
        var t1;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();)
          initialValue = combine.call$2(initialValue, t1._current);
        return initialValue;
      }, IterableMixinWorkaround_firstWhere: function(iterable, test, orElse) {
        var t1, element;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();) {
          element = t1._current;
          if (test.call$1(element) === true)
            return element;
        }
        return orElse.call$0();
      }, IterableMixinWorkaround_shuffleList: function(list, random) {
        var $length, pos, t1, tmp;
        $length = list.length;
        for (; $length > 1;) {
          pos = C.C__JSRandom.nextInt$1($length);
          --$length;
          t1 = list.length;
          if ($length >= t1)
            return H.ioore(list, $length);
          tmp = list[$length];
          if (pos < 0 || pos >= t1)
            return H.ioore(list, pos);
          C.JSArray_methods.$indexSet(list, $length, list[pos]);
          C.JSArray_methods.$indexSet(list, pos, tmp);
        }
      }, IterableMixinWorkaround__rangeCheck: function(list, start, end) {
        var t1 = J.getInterceptor$n(start);
        if (t1.$lt(start, 0) || t1.$gt(start, list.length))
          throw H.wrapException(P.RangeError$range(start, 0, list.length));
        t1 = J.getInterceptor$n(end);
        if (t1.$lt(end, start) || t1.$gt(end, list.length))
          throw H.wrapException(P.RangeError$range(end, start, list.length));
      }, IterableMixinWorkaround_setRangeList: function(list, start, end, from, skipCount) {
        var $length, t1;
        H.IterableMixinWorkaround__rangeCheck(list, start, end);
        $length = J.$sub$n(end, start);
        if (J.$eq($length, 0))
          return;
        if (skipCount < 0)
          throw H.wrapException(P.ArgumentError$(skipCount));
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = J.get$length$asx(from);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (skipCount + $length > t1)
          throw H.wrapException(H.IterableElementError_tooFew());
        H.Lists_copy(from, skipCount, list, start, $length);
      }, IterableMixinWorkaround_insertAllList: function(list, index, iterable) {
        var t1, index0;
        if (index > list.length)
          throw H.wrapException(P.RangeError$range(index, 0, list.length));
        C.JSArray_methods.set$length(list, list.length + 2);
        t1 = list.length;
        if (!!list.immutable$list)
          H.throwExpression(P.UnsupportedError$("set range"));
        H.IterableMixinWorkaround_setRangeList(list, index + 2, t1, list, index);
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, 2, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0(); index = index0) {
          index0 = index + 1;
          C.JSArray_methods.$indexSet(list, index, t1._current);
        }
      }}
  },
  FixedLengthListMixin: {
    "^": "Object;",
    set$length: function(receiver, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of a fixed-length list"));
    },
    add$1: [function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E0", void: true, args: [E]};
      }, this.$receiver, "FixedLengthListMixin");
    }, 100, []],
    insert$2: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    },
    addAll$1: function(receiver, iterable) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    },
    remove$1: function(receiver, element) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    },
    clear$0: function(receiver) {
      throw H.wrapException(P.UnsupportedError$("Cannot clear a fixed-length list"));
    },
    removeAt$1: function(receiver, index) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    },
    removeLast$0: function(receiver) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    },
    removeRange$2: function(receiver, start, end) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    }
  },
  UnmodifiableListMixin: {
    "^": "Object;",
    $indexSet: function(_, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of an unmodifiable list"));
    },
    add$1: [function(_, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E1", void: true, args: [E]};
      }, this.$receiver, "UnmodifiableListMixin");
    }, 100, []],
    insert$2: function(_, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
    },
    addAll$1: function(_, iterable) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
    },
    remove$1: function(_, element) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
    },
    sort$1: function(_, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    clear$0: function(_) {
      throw H.wrapException(P.UnsupportedError$("Cannot clear an unmodifiable list"));
    },
    removeAt$1: function(_, index) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
    },
    removeLast$0: function(_) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    removeRange$2: function(_, start, end) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  UnmodifiableListBase: {
    "^": "ListBase+UnmodifiableListMixin;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  ReversedListIterable: {
    "^": "ListIterable;__internal$_source",
    get$length: function(_) {
      return J.get$length$asx(this.__internal$_source);
    },
    elementAt$1: function(_, index) {
      var t1, t2;
      t1 = this.__internal$_source;
      t2 = J.getInterceptor$asx(t1);
      return t2.elementAt$1(t1, J.$sub$n(J.$sub$n(t2.get$length(t1), 1), index));
    }
  },
  Symbol: {
    "^": "Object;_name<",
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isSymbol && J.$eq(this._name, other._name);
    },
    get$hashCode: function(_) {
      var t1 = J.get$hashCode$(this._name);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 536870911 & 664597 * t1;
    },
    toString$0: function(_) {
      return "Symbol(\"" + H.S(this._name) + "\")";
    },
    $isSymbol: true,
    $isSymbol0: true,
    static: {"^": "Symbol_reservedWordRE,Symbol_publicIdentifierRE,Symbol_identifierRE,Symbol_operatorRE,Symbol_publicSymbolPattern,Symbol_symbolPattern", Symbol_validatePublicSymbol: function($name) {
        var t1, t2;
        t1 = J.getInterceptor$asx($name);
        if (t1.get$isEmpty($name) !== true) {
          t2 = $.get$Symbol_publicSymbolPattern()._nativeRegExp;
          if (typeof $name !== "string")
            H.throwExpression(P.ArgumentError$($name));
          t2 = t2.test($name);
        } else
          t2 = true;
        if (t2)
          return $name;
        if (t1.startsWith$1($name, "_"))
          throw H.wrapException(P.ArgumentError$("\"" + H.S($name) + "\" is a private identifier"));
        throw H.wrapException(P.ArgumentError$("\"" + H.S($name) + "\" is not a valid (qualified) symbol name"));
      }}
  }
}],
["dart._js_mirrors", "dart:_js_mirrors", , H, {
  "^": "",
  n: function(symbol) {
    return symbol.get$_name();
  },
  s: function($name) {
    if ($name == null)
      return;
    return new H.Symbol($name);
  },
  reflect: [function(reflectee) {
    if (!!J.getInterceptor(reflectee).$isClosure)
      return new H.JsClosureMirror(reflectee, 4);
    else
      return new H.JsInstanceMirror(reflectee, 4);
  }, "call$1", "reflect$closure", 2, 0, 551, 552, []],
  reflectClassByMangledName: function(mangledName) {
    var unmangledName, t1;
    unmangledName = $.get$mangledGlobalNames().$index(0, mangledName);
    t1 = J.getInterceptor(mangledName);
    if (t1.$eq(mangledName, "dynamic"))
      return $.get$JsMirrorSystem__dynamicType();
    if (t1.$eq(mangledName, "void"))
      return $.get$JsMirrorSystem__voidType();
    return H.reflectClassByName(H.s(unmangledName == null ? mangledName : unmangledName), mangledName);
  },
  reflectClassByName: function(symbol, mangledName) {
    var t1, mirror, typeArgIndex, t2, t3, $constructor, descriptor, fields, fieldsMetadata, mixins, classMirror, typeVariables, typeArguments, i;
    t1 = $.classMirrors;
    if (t1 == null) {
      t1 = H.JsCache_allocate();
      $.classMirrors = t1;
    }
    mirror = t1[mangledName];
    if (mirror != null)
      return mirror;
    t1 = J.getInterceptor$asx(mangledName);
    typeArgIndex = t1.indexOf$1(mangledName, "<");
    t2 = J.getInterceptor(typeArgIndex);
    if (!t2.$eq(typeArgIndex, -1)) {
      t3 = H.reflectClassByMangledName(t1.substring$2(mangledName, 0, typeArgIndex)).get$originalDeclaration();
      mirror = new H.JsTypeBoundClassMirror(t3, t1.substring$2(mangledName, t2.$add(typeArgIndex, 1), J.$sub$n(t1.get$length(mangledName), 1)), null, null, null, null, null, null, null, null, null, null, null, null, null, t3.get$simpleName());
      $.classMirrors[mangledName] = mirror;
      return mirror;
    }
    $constructor = init.allClasses[mangledName];
    if ($constructor == null)
      throw H.wrapException(P.UnsupportedError$("Cannot find class for: " + H.S(H.n(symbol))));
    descriptor = $constructor["@"];
    if (descriptor == null) {
      fields = null;
      fieldsMetadata = null;
    } else {
      fields = descriptor["^"];
      t1 = J.getInterceptor(fields);
      if (!!t1.$isList) {
        fieldsMetadata = t1.getRange$2(fields, 1, t1.get$length(fields)).toList$0(0);
        fields = t1.$index(fields, 0);
      } else
        fieldsMetadata = null;
      if (typeof fields !== "string")
        fields = "";
    }
    t1 = J.getInterceptor$s(fields);
    if (t1.startsWith$1(fields, ":")) {
      mirror = new H.JsTypedefMirror(mangledName, null, symbol);
      mirror.referent = new H.JsFunctionTypeMirror(init.metadata[H.Primitives_parseInt(t1.substring$2(fields, 1, t1.get$length(fields) - 1), null, null)], null, null, null, mirror);
    } else {
      t1 = t1.split$1(fields, ";");
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      mixins = J.split$1$s(t1[0], "+");
      if (mixins.length > 1 && $.get$mangledGlobalNames().$index(0, mangledName) == null)
        mirror = H.reflectMixinApplication(mixins, mangledName);
      else {
        classMirror = new H.JsClassMirror(mangledName, $constructor, fields, fieldsMetadata, H.JsCache_allocate(), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, symbol);
        typeVariables = $constructor.prototype["<>"];
        if (typeVariables == null || typeVariables.length === 0)
          mirror = classMirror;
        else {
          for (t1 = typeVariables.length, typeArguments = "dynamic", i = 1; i < t1; ++i)
            typeArguments += ",dynamic";
          mirror = new H.JsTypeBoundClassMirror(classMirror, typeArguments, null, null, null, null, null, null, null, null, null, null, null, null, null, classMirror.simpleName);
        }
      }
    }
    $.classMirrors[mangledName] = mirror;
    return mirror;
  },
  filterConstructors: function(methods) {
    var result, t1, method;
    result = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(methods, methods.length, 0, null), [H.getTypeArgumentByIndex(methods, 0)]); t1.moveNext$0();) {
      method = t1._current;
      if (method.get$isConstructor())
        result.$indexSet(0, method.get$simpleName(), method);
    }
    return result;
  },
  reflectMixinApplication: function(mixinNames, mangledName) {
    var mixins, t1, it, superclass;
    mixins = [];
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(mixinNames, mixinNames.length, 0, null), [H.getTypeArgumentByIndex(mixinNames, 0)]); t1.moveNext$0();)
      mixins.push(H.reflectClassByMangledName(t1._current));
    it = H.setRuntimeTypeInfo(new H.ListIterator(mixins, mixins.length, 0, null), [H.getTypeArgumentByIndex(mixins, 0)]);
    it.moveNext$0();
    superclass = it._current;
    for (; it.moveNext$0();)
      superclass = new H.JsMixinApplication(superclass, it._current, null, null, H.s(mangledName));
    return superclass;
  },
  findTypeVariableIndex: function(typeVariables, $name) {
    var t1, i, t2;
    t1 = J.getInterceptor$asx(typeVariables);
    i = 0;
    while (true) {
      t2 = t1.get$length(typeVariables);
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (!(i < t2))
        break;
      if (J.$eq(t1.$index(typeVariables, i).get$simpleName(), H.s($name)))
        return i;
      ++i;
    }
    throw H.wrapException(P.ArgumentError$("Type variable not present in list."));
  },
  typeMirrorFromRuntimeTypeRepresentation: function(owner, type) {
    var t1, context, t2, representation, typeVariable, typeVariables, typeArgument;
    t1 = {};
    t1.ownerClass_0 = null;
    for (context = owner; context != null;) {
      t2 = J.getInterceptor(context);
      if (!!t2.$isClassMirror) {
        t1.ownerClass_0 = context;
        break;
      }
      if (!!t2.$isTypedefMirror)
        break;
      context = context.get$owner();
    }
    if (type == null)
      return $.get$JsMirrorSystem__dynamicType();
    else {
      t2 = t1.ownerClass_0;
      if (t2 == null)
        representation = H.runtimeTypeToString(type, null);
      else if (t2.get$isOriginalDeclaration())
        if (typeof type === "number") {
          typeVariable = init.metadata[type];
          typeVariables = t1.ownerClass_0.get$typeVariables();
          return J.$index$asx(typeVariables, H.findTypeVariableIndex(typeVariables, J.get$name$x(typeVariable)));
        } else
          representation = H.runtimeTypeToString(type, null);
      else {
        t1 = new H.typeMirrorFromRuntimeTypeRepresentation_getTypeArgument(t1);
        if (typeof type === "number") {
          typeArgument = t1.call$1(type);
          if (!!J.getInterceptor(typeArgument).$isJsTypeVariableMirror)
            return typeArgument;
        }
        representation = H.runtimeTypeToString(type, new H.typeMirrorFromRuntimeTypeRepresentation_substituteTypeVariable(t1));
      }
    }
    if (representation != null)
      return H.reflectClassByMangledName(representation);
    return P.reflectClass(C.Type_EjN);
  },
  computeQualifiedName: function(owner, simpleName) {
    if (owner == null)
      return simpleName;
    return H.s(H.S(owner.get$qualifiedName()._name) + "." + H.S(simpleName._name));
  },
  extractMetadata: function(victim) {
    var metadataFunction, t1;
    metadataFunction = Object.prototype.hasOwnProperty.call(victim, "@") ? victim["@"] : null;
    if (metadataFunction != null)
      return metadataFunction();
    if (typeof victim != "function")
      return C.List_empty;
    if ("$metadataIndex" in victim) {
      t1 = victim.$reflectionInfo.splice(victim.$metadataIndex);
      t1.fixed$length = init;
      return H.setRuntimeTypeInfo(new H.MappedListIterable(t1, new H.extractMetadata_closure()), [null, null]).toList$0(0);
    }
    return C.List_empty;
  },
  isOperatorName: function($name) {
    switch ($name) {
      case "==":
      case "[]":
      case "*":
      case "/":
      case "%":
      case "~/":
      case "+":
      case "<<":
      case ">>":
      case ">=":
      case ">":
      case "<=":
      case "<":
      case "&":
      case "^":
      case "|":
      case "-":
      case "unary-":
      case "[]=":
      case "~":
        return true;
      default:
        return false;
    }
  },
  isReflectiveDataInPrototype: function(key) {
    var t1, firstChar;
    t1 = J.getInterceptor(key);
    if (t1.$eq(key, "^") || t1.$eq(key, "$methodsWithOptionalArguments"))
      return true;
    firstChar = t1.$index(key, 0);
    t1 = J.getInterceptor(firstChar);
    return t1.$eq(firstChar, "*") || t1.$eq(firstChar, "+");
  },
  JsMirrorSystem: {
    "^": "Object;_cachedLibraries,isolate",
    static: {"^": "JsMirrorSystem__dynamicType,JsMirrorSystem__voidType,JsMirrorSystem_librariesByName", JsMirrorSystem_computeLibrariesByName: function() {
        var result, jsLibraries, t1, data, t2, $name, uri, classes, functions, metadataFunction, fields, isRoot, globalObject, metadata;
        result = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.List, P.LibraryMirror]);
        jsLibraries = init.libraries;
        if (jsLibraries == null)
          return result;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(jsLibraries, jsLibraries.length, 0, null), [H.getTypeArgumentByIndex(jsLibraries, 0)]); t1.moveNext$0();) {
          data = t1._current;
          t2 = J.getInterceptor$asx(data);
          $name = t2.$index(data, 0);
          uri = P.Uri_parse(t2.$index(data, 1));
          classes = t2.$index(data, 2);
          functions = t2.$index(data, 3);
          metadataFunction = t2.$index(data, 4);
          fields = t2.$index(data, 5);
          isRoot = t2.$index(data, 6);
          globalObject = t2.$index(data, 7);
          metadata = metadataFunction == null ? C.List_empty : metadataFunction();
          J.add$1$ax(result.putIfAbsent$2(0, $name, new H.JsMirrorSystem_computeLibrariesByName_closure()), new H.JsLibraryMirror(uri, classes, functions, metadata, fields, isRoot, globalObject, null, null, null, null, null, null, null, null, null, null, H.s($name)));
        }
        return result;
      }}
  },
  JsMirrorSystem_computeLibrariesByName_closure: {
    "^": "Closure:13;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [P.LibraryMirror]);
    },
    $isFunction: true
  },
  JsMirror: {
    "^": "Object;",
    toString$0: function(_) {
      return this.get$_prettyName();
    }
  },
  JsIsolateMirror: {
    "^": "JsMirror;_isolateContext",
    get$_prettyName: function() {
      return "Isolate";
    }
  },
  JsDeclarationMirror: {
    "^": "JsMirror;simpleName<",
    get$qualifiedName: function() {
      return H.computeQualifiedName(this.get$owner(), this.get$simpleName());
    },
    toString$0: function(_) {
      return this.get$_prettyName() + " on '" + H.S(this.get$simpleName()._name) + "'";
    },
    _invoke$2: function(positionalArguments, namedArguments) {
      throw H.wrapException(H.RuntimeError$("Should not call _invoke"));
    }
  },
  JsTypeVariableMirror: {
    "^": "JsTypeMirror;owner<,_typeVariable,_metadataIndex,_cachedUpperBound,simpleName",
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isJsTypeVariableMirror && J.$eq(this.simpleName, other.simpleName) && this.owner.$eq(0, other.owner);
    },
    get$hashCode: function(_) {
      var t1, t2;
      t1 = J.get$hashCode$(C.Type_AGr._typeName);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = this.owner;
      return (1073741823 & t1 ^ 17 * J.get$hashCode$(this.simpleName) ^ 19 * t2.get$hashCode(t2)) >>> 0;
    },
    get$_prettyName: function() {
      return "TypeVariableMirror";
    },
    _asRuntimeType$0: function() {
      return this._metadataIndex;
    },
    $isJsTypeVariableMirror: true,
    $isTypeVariableMirror: true,
    $isTypeMirror: true
  },
  JsTypeMirror: {
    "^": "JsDeclarationMirror;simpleName",
    get$_prettyName: function() {
      return "TypeMirror";
    },
    get$owner: function() {
      return;
    },
    get$typeVariables: function() {
      return C.List_empty0;
    },
    get$typeArguments: function() {
      return C.List_empty1;
    },
    get$isOriginalDeclaration: function() {
      return true;
    },
    get$originalDeclaration: function() {
      return this;
    },
    _asRuntimeType$0: [function() {
      if (this.$eq(0, $.get$JsMirrorSystem__dynamicType()))
        return;
      if (this.$eq(0, $.get$JsMirrorSystem__voidType()))
        return;
      throw H.wrapException(H.RuntimeError$("Should not call _asRuntimeType"));
    }, "call$0", "get$_asRuntimeType", 0, 0, 13],
    $isTypeMirror: true
  },
  JsLibraryMirror: {
    "^": "JsDeclarationMirror_JsObjectMirror;_uri,_classes,_functions,_metadata,_compactFieldSpecification,_isRoot,_globalObject,_cachedFunctionMirrors,_cachedFields,_cachedClasses,_cachedFunctions,_cachedGetters,_cachedSetters,_cachedVariables,_cachedMembers,_cachedDeclarations,_cachedMetadata,simpleName",
    get$_prettyName: function() {
      return "LibraryMirror";
    },
    get$qualifiedName: function() {
      return this.simpleName;
    },
    get$__classes: function() {
      var t1, result, cls, t2;
      t1 = this._cachedClasses;
      if (t1 != null)
        return t1;
      result = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      for (t1 = J.get$iterator$ax(this._classes); t1.moveNext$0();) {
        cls = H.reflectClassByMangledName(t1.get$current());
        if (!!J.getInterceptor(cls).$isClassMirror)
          cls = cls.get$originalDeclaration();
        t2 = J.getInterceptor(cls);
        if (!!t2.$isJsClassMirror) {
          result.$indexSet(0, cls.simpleName, cls);
          cls._owner = this;
        } else if (!!t2.$isJsTypedefMirror)
          result.$indexSet(0, cls.simpleName, cls);
      }
      t1 = H.setRuntimeTypeInfo(new P.UnmodifiableMapView(result), [P.Symbol0, P.ClassMirror]);
      this._cachedClasses = t1;
      return t1;
    },
    get$owner: function() {
      return;
    },
    $isLibraryMirror: true
  },
  JsDeclarationMirror_JsObjectMirror: {
    "^": "JsDeclarationMirror+JsObjectMirror;"
  },
  JsMixinApplication: {
    "^": "JsTypeMirror_JsObjectMirror;superclass,mixin,_cachedSimpleName,_cachedInstanceMembers,simpleName",
    get$_prettyName: function() {
      return "ClassMirror";
    },
    get$simpleName: function() {
      var t1, superName;
      t1 = this._cachedSimpleName;
      if (t1 != null)
        return t1;
      superName = this.superclass.get$qualifiedName()._name;
      t1 = this.mixin;
      t1 = J.contains$1$asx(superName, " with ") === true ? H.s(H.S(superName) + ", " + H.S(t1.get$qualifiedName()._name)) : H.s(H.S(superName) + " with " + H.S(t1.get$qualifiedName()._name));
      this._cachedSimpleName = t1;
      return t1;
    },
    get$qualifiedName: function() {
      return this.get$simpleName();
    },
    _asRuntimeType$0: function() {
      return;
    },
    newInstance$3: function(constructorName, positionalArguments, namedArguments) {
      throw H.wrapException(P.UnsupportedError$("Can't instantiate mixin application '" + H.S(H.n(this.get$qualifiedName())) + "'"));
    },
    newInstance$2: function(constructorName, positionalArguments) {
      return this.newInstance$3(constructorName, positionalArguments, null);
    },
    get$isOriginalDeclaration: function() {
      return true;
    },
    get$originalDeclaration: function() {
      return this;
    },
    get$typeVariables: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    get$typeArguments: function() {
      return C.List_empty1;
    },
    $isClassMirror: true,
    $isTypeMirror: true
  },
  JsTypeMirror_JsObjectMirror: {
    "^": "JsTypeMirror+JsObjectMirror;"
  },
  JsObjectMirror: {
    "^": "Object;"
  },
  JsInstanceMirror: {
    "^": "JsObjectMirror;reflectee<,_getterCache",
    get$type: function(_) {
      var t1 = this.reflectee;
      if (t1 == null)
        return P.reflectClass(C.Type_eZO);
      return H.reflectClassByMangledName(H.getRuntimeTypeString(t1));
    },
    invoke$3: function(memberName, positionalArguments, namedArguments) {
      return this._invoke$4(memberName, 0, positionalArguments, namedArguments);
    },
    _invokeMethodWithNamedArguments$3: function(reflectiveName, positionalArguments, namedArguments) {
      var t1, jsFunction, info, t2, defaultArguments, t3, i, t4;
      t1 = this.reflectee;
      jsFunction = J.getInterceptor(t1)[reflectiveName];
      if (jsFunction == null)
        throw H.wrapException(H.UnimplementedNoSuchMethodError$("Invoking noSuchMethod with named arguments not implemented"));
      info = H.ReflectionInfo_ReflectionInfo(jsFunction);
      positionalArguments = P.List_List$from(positionalArguments, true, null);
      t2 = info.requiredParameterCount;
      if (t2 !== positionalArguments.length)
        throw H.wrapException(H.UnimplementedNoSuchMethodError$("Invoking noSuchMethod with named arguments not implemented"));
      defaultArguments = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      for (t3 = info.optionalParameterCount, i = 0; i < t3; ++i) {
        t4 = i + t2;
        defaultArguments.$indexSet(0, info.parameterName$1(t4), init.metadata[info.defaultValue$1(0, t4)]);
      }
      namedArguments.forEach$1(0, new H.JsInstanceMirror__invokeMethodWithNamedArguments_closure(defaultArguments));
      C.JSArray_methods.addAll$1(positionalArguments, defaultArguments.get$values(defaultArguments));
      return H.reflect(jsFunction.apply(t1, positionalArguments));
    },
    get$_classInvocationCache: function() {
      var cacheName, cacheHolder, cache;
      cacheName = $.Primitives_mirrorInvokeCacheName;
      cacheHolder = this.reflectee;
      if (cacheHolder == null)
        cacheHolder = J.getInterceptor(null);
      cache = cacheHolder.constructor[cacheName];
      if (cache == null) {
        cache = H.JsCache_allocate();
        cacheHolder.constructor[cacheName] = cache;
      }
      return cache;
    },
    _computeReflectiveName$4: function(symbolName, type, positionalArguments, namedArguments) {
      var $name, nbArgs;
      $name = symbolName.get$_name();
      switch (type) {
        case 1:
          return $name;
        case 2:
          return H.S($name) + "=";
        case 0:
          if (!J.$eq(namedArguments.get$length(namedArguments), 0))
            return H.S($name) + "*";
          nbArgs = positionalArguments.length;
          return H.S($name) + ":" + nbArgs + ":0";
      }
      throw H.wrapException(H.RuntimeError$("Could not compute reflective name for " + H.S($name)));
    },
    _getCachedInvocation$5: function($name, type, reflectiveName, positionalArguments, namedArguments) {
      var cache, cacheEntry;
      cache = this.get$_classInvocationCache();
      cacheEntry = cache[reflectiveName];
      if (cacheEntry == null) {
        cacheEntry = new H.JSInvocationMirror($name, $.get$reflectiveNames().$index(0, reflectiveName), type, positionalArguments, C.List_empty, null).__js_helper$_getCachedInvocation$1(this.reflectee);
        cache[reflectiveName] = cacheEntry;
      }
      return cacheEntry;
    },
    _invoke$4: function($name, type, positionalArguments, namedArguments) {
      var reflectiveName, cacheEntry, t1, getterCacheEntry;
      reflectiveName = this._computeReflectiveName$4($name, type, positionalArguments, namedArguments);
      if (!J.$eq(namedArguments.get$length(namedArguments), 0))
        return this._invokeMethodWithNamedArguments$3(reflectiveName, positionalArguments, namedArguments);
      cacheEntry = this._getCachedInvocation$5($name, type, reflectiveName, positionalArguments, namedArguments);
      if (!cacheEntry.get$isNoSuchMethod())
        t1 = !("$reflectable" in cacheEntry.get$jsFunction() || !!J.getInterceptor(this.reflectee).$isTearOffClosure);
      else
        t1 = true;
      if (t1) {
        if (type === 0) {
          getterCacheEntry = this._getCachedInvocation$5($name, 1, this._computeReflectiveName$4($name, 1, C.List_empty, C.Map_empty), C.List_empty, C.Map_empty);
          t1 = !getterCacheEntry.get$isNoSuchMethod() && !getterCacheEntry.get$isGetterStub();
        } else
          t1 = false;
        if (t1)
          return this.getField$1($name).invoke$3(C.Symbol_call, positionalArguments, namedArguments);
        if (type === 2)
          $name = H.s(H.S($name.get$_name()) + "=");
        if (!cacheEntry.get$isNoSuchMethod())
          H.throwInvalidReflectionError(reflectiveName);
        return H.reflect(cacheEntry.invokeOn$2(this.reflectee, new H.JSInvocationMirror($name, $.get$reflectiveNames().$index(0, reflectiveName), type, positionalArguments, [], null)));
      } else
        return H.reflect(cacheEntry.invokeOn$2(this.reflectee, positionalArguments));
    },
    getField$1: function(fieldName) {
      var cache, getter, value, result;
      $FASTPATH$0: {
        cache = this._getterCache;
        if (typeof cache == "number" || typeof fieldName.$p == "undefined")
          break $FASTPATH$0;
        getter = fieldName.$p(cache);
        if (typeof getter == "undefined")
          break $FASTPATH$0;
        value = getter(this.reflectee);
        if (value === getter.v)
          return getter.m;
        else {
          result = H.reflect(value);
          getter.v = value;
          getter.m = result;
          return result;
        }
      }
      return this._getFieldSlow$1(fieldName);
    },
    _getFieldSlow$1: function(fieldName) {
      var result, $name, cacheEntry, cache, useEval, mangledName, getter;
      result = this._invoke$4(fieldName, 1, C.List_empty, C.Map_empty);
      $name = fieldName.get$_name();
      cacheEntry = this.get$_classInvocationCache()[$name];
      if (cacheEntry.get$isNoSuchMethod())
        return result;
      cache = this._getterCache;
      if (typeof cache == "number") {
        cache = J.$sub$n(cache, 1);
        this._getterCache = cache;
        if (!J.$eq(cache, 0))
          return result;
        cache = Object.create(null);
        this._getterCache = cache;
      }
      useEval = typeof dart_precompiled != "function";
      if (typeof fieldName.$p == "undefined")
        fieldName.$p = this._newProbeFn$2($name, useEval);
      mangledName = cacheEntry.get$mangledName();
      getter = cacheEntry.get$isIntercepted() ? this._newInterceptedGetterFn$2(mangledName, useEval) : this._newGetterFn$2(mangledName, useEval);
      cache[$name] = getter;
      getter.v = getter.m = cache;
      return result;
    },
    _newProbeFn$2: function(id, useEval) {
      if (useEval)
        return function(b) {
          return eval(b);
        }("(function probe$" + H.S(id) + "(c){return c." + H.S(id) + "})");
      else
        return function(n) {
          return function(c) {
            return c[n];
          };
        }(id);
    },
    _newGetterFn$2: function($name, useEval) {
      if (!useEval)
        return function(n) {
          return function(o) {
            return o[n]();
          };
        }($name);
      return function(b) {
        return eval(b);
      }("(function " + this.reflectee.constructor.name + "$" + H.S($name) + "(o){return o." + H.S($name) + "()})");
    },
    _newInterceptedGetterFn$2: function($name, useEval) {
      var interceptor, functionName;
      interceptor = J.getInterceptor(this.reflectee);
      if (!useEval)
        return function(n, i) {
          return function(o) {
            return i[n](o);
          };
        }($name, interceptor);
      functionName = interceptor.constructor.name + "$" + H.S($name);
      return function(b) {
        return eval(b);
      }("(function(i) {  function " + functionName + "(o){return i." + H.S($name) + "(o)}  return " + functionName + ";})")(interceptor);
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!!J.getInterceptor(other).$isJsInstanceMirror) {
        t1 = this.reflectee;
        t2 = other.reflectee;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return J.$xor$n(H.objectHashCode(this.reflectee), 909522486);
    },
    toString$0: function(_) {
      return "InstanceMirror on " + H.S(P.Error_safeToString(this.reflectee));
    },
    $isJsInstanceMirror: true
  },
  JsInstanceMirror__invokeMethodWithNamedArguments_closure: {
    "^": "Closure:1685;defaultArguments_0",
    call$2: function(symbol, value) {
      var parameter, t1;
      parameter = symbol.get$_name();
      t1 = this.defaultArguments_0;
      if (t1.containsKey$1(0, parameter))
        t1.$indexSet(0, parameter, value);
      else
        throw H.wrapException(H.UnimplementedNoSuchMethodError$("Invoking noSuchMethod with named arguments not implemented"));
    },
    $isFunction: true
  },
  JsTypeBoundClassMirror: {
    "^": "JsDeclarationMirror;_class,_typeArguments,_cachedTypeArguments,_cachedDeclarations,_cachedMembers,_cachedConstructors,_cachedVariables,_cachedGetters,_cachedSetters,_cachedMethodsMap,_cachedMethods,_superclass,_cachedSuperinterfaces,_cachedInstanceMembers,_cachedStaticMembers,simpleName",
    get$_prettyName: function() {
      return "ClassMirror";
    },
    toString$0: function(_) {
      var result, t1, t2;
      result = "ClassMirror on " + H.S(this._class.get$simpleName()._name);
      if (this.get$typeArguments() != null) {
        t1 = result + "<";
        t2 = this.get$typeArguments();
        result = t1 + t2.join$1(t2, ", ") + ">";
      }
      return result;
    },
    get$_mangledName: function() {
      for (var t1 = this.get$typeArguments(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
        if (!J.$eq(t1._current, $.get$JsMirrorSystem__dynamicType()))
          return H.S(this._class.get$_mangledName()) + "<" + this._typeArguments + ">";
      return this._class.get$_mangledName();
    },
    get$typeVariables: function() {
      return this._class.get$typeVariables();
    },
    get$typeArguments: function() {
      var t1, result, t2, t3, level, currentTypeArgument, i, character;
      t1 = this._cachedTypeArguments;
      if (t1 != null)
        return t1;
      result = [];
      t1 = new H.JsTypeBoundClassMirror_typeArguments_addTypeArgument(result);
      t2 = this._typeArguments;
      if (C.JSString_methods.indexOf$1(t2, "<") === -1)
        H.IterableMixinWorkaround_forEach(t2.split(","), new H.JsTypeBoundClassMirror_typeArguments_closure(t1));
      else {
        for (t3 = t2.length, level = 0, currentTypeArgument = "", i = 0; i < t3; ++i) {
          character = t2[i];
          if (character === " ")
            continue;
          else if (character === "<") {
            currentTypeArgument += character;
            ++level;
          } else if (character === ">") {
            currentTypeArgument += character;
            --level;
          } else if (character === ",")
            if (level > 0)
              currentTypeArgument += character;
            else {
              t1.call$1(currentTypeArgument);
              currentTypeArgument = "";
            }
          else
            currentTypeArgument += character;
        }
        t1.call$1(currentTypeArgument);
      }
      t1 = H.setRuntimeTypeInfo(new P.UnmodifiableListView(result), [null]);
      this._cachedTypeArguments = t1;
      return t1;
    },
    newInstance$3: function(constructorName, positionalArguments, namedArguments) {
      var instance, t1;
      instance = this._class._getInvokedInstance$3(constructorName, positionalArguments, namedArguments);
      t1 = this.get$typeArguments();
      return H.reflect(H.setRuntimeTypeInfo(instance, t1.map$1(t1, new H.JsTypeBoundClassMirror_newInstance_closure()).toList$0(0)));
    },
    newInstance$2: function(constructorName, positionalArguments) {
      return this.newInstance$3(constructorName, positionalArguments, null);
    },
    _asRuntimeType$0: function() {
      var t1, t2;
      t1 = this._class.get$_jsConstructor();
      t2 = this.get$typeArguments();
      return C.JSArray_methods.addAll$1([t1], t2.map$1(t2, new H.JsTypeBoundClassMirror__asRuntimeType_closure()));
    },
    get$owner: function() {
      return this._class.get$owner();
    },
    get$isOriginalDeclaration: function() {
      return false;
    },
    get$originalDeclaration: function() {
      return this._class;
    },
    get$qualifiedName: function() {
      return this._class.get$qualifiedName();
    },
    get$simpleName: function() {
      return this._class.get$simpleName();
    },
    $isJsTypeBoundClassMirror: true,
    $isClassMirror: true,
    $isTypeMirror: true
  },
  JsTypeBoundClassMirror_typeArguments_addTypeArgument: {
    "^": "Closure:52;result_0",
    call$1: function(typeArgument) {
      var parsedIndex, t1, typeVariable;
      parsedIndex = H.Primitives_parseInt(typeArgument, null, new H.JsTypeBoundClassMirror_typeArguments_addTypeArgument_closure());
      t1 = this.result_0;
      if (J.$eq(parsedIndex, -1))
        t1.push(H.reflectClassByMangledName(J.trim$0$s(typeArgument)));
      else {
        typeVariable = init.metadata[parsedIndex];
        t1.push(new H.JsTypeVariableMirror(P.reflectClass(typeVariable.get$owner()), typeVariable, parsedIndex, null, H.s(J.get$name$x(typeVariable))));
      }
    },
    $isFunction: true
  },
  JsTypeBoundClassMirror_typeArguments_addTypeArgument_closure: {
    "^": "Closure:63;",
    call$1: function(_) {
      return -1;
    },
    $isFunction: true
  },
  JsTypeBoundClassMirror_typeArguments_closure: {
    "^": "Closure:63;addTypeArgument_1",
    call$1: function(t) {
      return this.addTypeArgument_1.call$1(t);
    },
    $isFunction: true
  },
  JsTypeBoundClassMirror_newInstance_closure: {
    "^": "Closure:63;",
    call$1: [function(t) {
      return t._asRuntimeType$0();
    }, "call$1", null, 2, 0, null, 380, [], "call"],
    $isFunction: true
  },
  JsTypeBoundClassMirror__asRuntimeType_closure: {
    "^": "Closure:63;",
    call$1: [function(t) {
      return t._asRuntimeType$0();
    }, "call$1", null, 2, 0, null, 380, [], "call"],
    $isFunction: true
  },
  JsClassMirror: {
    "^": "JsTypeMirror_JsObjectMirror0;_mangledName<,_jsConstructor<,_fieldsDescriptor,_fieldsMetadata,_jsConstructorCache,_metadata,_superclass,_cachedMethods,_cachedFields,_cachedConstructors,_cachedMethodsMap,_cachedGetters,_cachedSetters,_cachedVariables,_cachedMembers,_cachedDeclarations,_cachedMetadata,_cachedSuperinterfaces,_cachedTypeVariables,_cachedInstanceMembers,_cachedStaticMembers,_owner,simpleName",
    get$_prettyName: function() {
      return "ClassMirror";
    },
    get$__constructors: function() {
      var t1 = this._cachedConstructors;
      if (t1 != null)
        return t1;
      t1 = H.setRuntimeTypeInfo(new P.UnmodifiableMapView(H.filterConstructors(this.get$_methods())), [P.Symbol0, P.MethodMirror]);
      this._cachedConstructors = t1;
      return t1;
    },
    _asRuntimeType$0: function() {
      var type, i, t1;
      if (J.get$isEmpty$asx(this.get$typeVariables()))
        return this._jsConstructor;
      type = [this._jsConstructor];
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.get$typeVariables());
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        type.push($.get$JsMirrorSystem__dynamicType().get$_asRuntimeType());
        ++i;
      }
      return type;
    },
    _getMethodsWithOwner$1: function(methodOwner) {
      var $prototype, keys, result, t1, key, simpleName, $function, mirror, mangledName, jsFunction, reflectionName, isConstructor, t2;
      $prototype = this._jsConstructor.prototype;
      keys = H.extractKeys($prototype);
      result = H.setRuntimeTypeInfo([], [H.JsMethodMirror]);
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(keys, keys.length, 0, null), [H.getTypeArgumentByIndex(keys, 0)]); t1.moveNext$0();) {
        key = t1._current;
        if (H.isReflectiveDataInPrototype(key))
          continue;
        simpleName = $.get$mangledNames().$index(0, key);
        if (simpleName == null)
          continue;
        $function = $prototype[key];
        if ($function.$reflectable == 2)
          continue;
        mirror = H.JsMethodMirror_JsMethodMirror$fromUnmangledName(simpleName, $function, false, false);
        result.push(mirror);
        mirror._owner = methodOwner;
      }
      keys = H.extractKeys(init.statics[this._mangledName]);
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(keys, keys.length, 0, null), [H.getTypeArgumentByIndex(keys, 0)]); t1.moveNext$0();) {
        mangledName = t1._current;
        if (H.isReflectiveDataInPrototype(mangledName))
          continue;
        jsFunction = this.get$owner()._globalObject[mangledName];
        if ("$reflectable" in jsFunction) {
          reflectionName = jsFunction.$reflectionName;
          if (reflectionName == null)
            continue;
          isConstructor = C.JSString_methods.startsWith$1(reflectionName, "new ");
          if (isConstructor) {
            t2 = C.JSString_methods.substring$1(reflectionName, 4);
            reflectionName = H.stringReplaceAllUnchecked(t2, "$", ".");
          }
        } else
          continue;
        mirror = H.JsMethodMirror_JsMethodMirror$fromUnmangledName(reflectionName, jsFunction, !isConstructor, isConstructor);
        result.push(mirror);
        mirror._owner = methodOwner;
      }
      return result;
    },
    get$_methods: function() {
      var t1 = this._cachedMethods;
      if (t1 != null)
        return t1;
      t1 = this._getMethodsWithOwner$1(this);
      this._cachedMethods = t1;
      return t1;
    },
    _getInvokedInstance$3: function(constructorName, positionalArguments, namedArguments) {
      var t1, t2, mirror, t3;
      t1 = this._jsConstructorCache;
      t2 = constructorName._name;
      mirror = t1[t2];
      if (mirror == null) {
        t3 = this.get$__constructors()._map;
        mirror = t3.get$values(t3).firstWhere$2$orElse(0, new H.JsClassMirror__getInvokedInstance_closure(constructorName), new H.JsClassMirror__getInvokedInstance_closure0(constructorName, positionalArguments, namedArguments));
        t1[t2] = mirror;
      }
      return mirror._invoke$2(positionalArguments, namedArguments);
    },
    newInstance$3: function(constructorName, positionalArguments, namedArguments) {
      return H.reflect(this._getInvokedInstance$3(constructorName, positionalArguments, namedArguments));
    },
    newInstance$2: function(constructorName, positionalArguments) {
      return this.newInstance$3(constructorName, positionalArguments, null);
    },
    get$owner: function() {
      var t1, t2;
      t1 = this._owner;
      if (t1 == null) {
        t1 = $.get$JsMirrorSystem_librariesByName();
        t1 = t1.get$values(t1);
        t2 = new H.MappedIterator(null, J.get$iterator$ax(t1._iterable), t1._f);
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)];
        for (; t2.moveNext$0();)
          for (t1 = J.get$iterator$ax(t2._current); t1.moveNext$0();)
            t1.get$current().get$__classes();
        t1 = this._owner;
        if (t1 == null)
          throw H.wrapException(P.StateError$("Class \"" + H.S(H.n(this.simpleName)) + "\" has no owner"));
      }
      return t1;
    },
    get$isOriginalDeclaration: function() {
      return true;
    },
    get$originalDeclaration: function() {
      return this;
    },
    get$typeVariables: function() {
      var t1, result, typeVariables, i, typeVariable;
      t1 = this._cachedTypeVariables;
      if (t1 != null)
        return t1;
      result = [];
      typeVariables = this._jsConstructor.prototype["<>"];
      if (typeVariables == null)
        return result;
      for (i = 0; i < typeVariables.length; ++i) {
        t1 = typeVariables[i];
        typeVariable = init.metadata[t1];
        result.push(new H.JsTypeVariableMirror(this, typeVariable, t1, null, H.s(J.get$name$x(typeVariable))));
      }
      t1 = new P.UnmodifiableListView(result);
      t1.$builtinTypeInfo = [null];
      this._cachedTypeVariables = t1;
      return t1;
    },
    get$typeArguments: function() {
      return C.List_empty1;
    },
    $isJsClassMirror: true,
    $isClassMirror: true,
    $isTypeMirror: true
  },
  JsTypeMirror_JsObjectMirror0: {
    "^": "JsTypeMirror+JsObjectMirror;"
  },
  JsClassMirror__getInvokedInstance_closure: {
    "^": "Closure:63;constructorName_0",
    call$1: function(m) {
      return J.$eq(m.get$constructorName(), this.constructorName_0);
    },
    $isFunction: true
  },
  JsClassMirror__getInvokedInstance_closure0: {
    "^": "Closure:13;constructorName_1,positionalArguments_2,namedArguments_3",
    call$0: function() {
      throw H.wrapException(H.NoSuchStaticMethodError$method(null, this.constructorName_1, this.positionalArguments_2, this.namedArguments_3));
    },
    $isFunction: true
  },
  JsClosureMirror: {
    "^": "JsInstanceMirror;reflectee,_getterCache",
    apply$2: function(positionalArguments, namedArguments) {
      return H.reflect(H.Primitives_applyFunction(this.reflectee, positionalArguments, P.Function__toMangledNames(namedArguments)));
    },
    apply$1: function(positionalArguments) {
      return this.apply$2(positionalArguments, null);
    },
    toString$0: function(_) {
      return "ClosureMirror on '" + H.S(P.Error_safeToString(this.reflectee)) + "'";
    },
    get$source: function(_) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  JsMethodMirror: {
    "^": "JsDeclarationMirror;_jsFunction,_requiredParameterCount,_optionalParameterCount,isGetter,isSetter,isStatic,isConstructor<,isOperator,_owner,_metadata,_returnType,_parameters,simpleName",
    get$_prettyName: function() {
      return "MethodMirror";
    },
    get$parameters: function() {
      var t1 = this._parameters;
      if (t1 != null)
        return t1;
      this.get$metadata();
      return this._parameters;
    },
    get$owner: function() {
      return this._owner;
    },
    get$metadata: function() {
      var t1, raw, t2, formals, info, functionType, type, isNamed, t3, t4, t5, i, parameter, $name, result, p, defaultValue, i0;
      t1 = this._metadata;
      if (t1 == null) {
        t1 = this._jsFunction;
        raw = H.extractMetadata(t1);
        t2 = J.$add$ns(this._requiredParameterCount, this._optionalParameterCount);
        if (typeof t2 !== "number")
          return H.iae(t2);
        formals = Array(t2);
        info = H.ReflectionInfo_ReflectionInfo(t1);
        if (info != null) {
          functionType = info.functionType;
          if (typeof functionType === "number" && Math.floor(functionType) === functionType)
            type = new H.JsFunctionTypeMirror(info.computeFunctionRti$1(null), null, null, null, this);
          else
            type = this.get$owner() != null && !!J.getInterceptor(this.get$owner()).$isLibraryMirror ? new H.JsFunctionTypeMirror(info.computeFunctionRti$1(null), null, null, null, this._owner) : new H.JsFunctionTypeMirror(info.computeFunctionRti$1(this._owner.get$originalDeclaration().get$_jsConstructor()), null, null, null, this._owner);
          if (this.isConstructor)
            this._returnType = this._owner;
          else
            this._returnType = type.get$returnType();
          isNamed = info.areOptionalParametersNamed;
          for (t1 = type.get$parameters(), t1 = t1.get$iterator(t1), t2 = formals.length, t3 = info.requiredParameterCount, t4 = info.data, t5 = info.optionalParameterCount, i = 0; t1.moveNext$0(); i = i0) {
            parameter = t1._current;
            $name = info.parameterName$1(i);
            result = t4[2 * i + t5 + 3 + 1];
            if (i < t3)
              p = new H.JsParameterMirror(this, parameter.get$_type(), false, false, null, result, H.s($name));
            else {
              defaultValue = info.defaultValue$1(0, i);
              p = new H.JsParameterMirror(this, parameter.get$_type(), true, isNamed, defaultValue, result, H.s($name));
            }
            i0 = i + 1;
            if (i >= t2)
              return H.ioore(formals, i);
            formals[i] = p;
          }
        }
        this._parameters = H.setRuntimeTypeInfo(new P.UnmodifiableListView(formals), [P.ParameterMirror]);
        t1 = H.setRuntimeTypeInfo(new P.UnmodifiableListView(J.map$1$ax(raw, H.reflect$closure())), [null]);
        this._metadata = t1;
      }
      return t1;
    },
    get$constructorName: function() {
      var $name, t1, index, t2;
      if (!this.isConstructor)
        return C.Symbol_0c4;
      $name = this.simpleName._name;
      t1 = J.getInterceptor$asx($name);
      index = t1.indexOf$1($name, ".");
      t2 = J.getInterceptor(index);
      if (t2.$eq(index, -1))
        return C.Symbol_0c4;
      return H.s(t1.substring$1($name, t2.$add(index, 1)));
    },
    _invoke$2: function(positionalArguments, namedArguments) {
      var t1, positionalLength, t2, t3, i;
      if (namedArguments != null && !J.$eq(namedArguments.get$length(namedArguments), 0))
        throw H.wrapException(P.UnsupportedError$("Named arguments are not implemented."));
      if (!this.isStatic && !this.isConstructor)
        throw H.wrapException(H.RuntimeError$("Cannot invoke instance method without receiver."));
      t1 = J.getInterceptor$asx(positionalArguments);
      positionalLength = t1.get$length(positionalArguments);
      t2 = this._requiredParameterCount;
      t3 = J.getInterceptor$n(positionalLength);
      if (t3.$lt(positionalLength, t2) || t3.$gt(positionalLength, J.$add$ns(t2, this._optionalParameterCount)) || this._jsFunction == null)
        throw H.wrapException(P.NoSuchMethodError$(this.get$owner(), this.simpleName, positionalArguments, namedArguments, null));
      if (t3.$lt(positionalLength, J.$add$ns(t2, this._optionalParameterCount))) {
        positionalArguments = t1.toList$0(positionalArguments);
        for (t1 = J.getInterceptor$ax(positionalArguments), i = positionalLength; t2 = J.getInterceptor$n(i), t2.$lt(i, J.get$length$asx(this.get$parameters()._collection$_source)); i = t2.$add(i, 1))
          t1.add$1(positionalArguments, J.get$defaultValue$x(J.elementAt$1$ax(this.get$parameters()._collection$_source, i)).get$reflectee());
      }
      return this._jsFunction.apply($, P.List_List$from(positionalArguments, true, null));
    },
    get$source: function(_) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    $isJsMethodMirror: true,
    $isMethodMirror: true,
    static: {JsMethodMirror_JsMethodMirror$fromUnmangledName: function($name, jsFunction, isStatic, isConstructor) {
        var info, isOperator, isSetter, t1, requiredParameterCount, isGetter, optionalParameterCount;
        info = $name.split(":");
        if (0 >= info.length)
          return H.ioore(info, 0);
        $name = info[0];
        isOperator = H.isOperatorName($name);
        isSetter = !isOperator && J.endsWith$1$s($name, "=");
        t1 = info.length;
        if (t1 === 1) {
          if (isSetter) {
            requiredParameterCount = 1;
            isGetter = false;
          } else {
            requiredParameterCount = 0;
            isGetter = true;
          }
          optionalParameterCount = 0;
        } else {
          if (1 >= t1)
            return H.ioore(info, 1);
          requiredParameterCount = H.Primitives_parseInt(info[1], null, null);
          if (2 >= info.length)
            return H.ioore(info, 2);
          optionalParameterCount = H.Primitives_parseInt(info[2], null, null);
          isGetter = false;
        }
        return new H.JsMethodMirror(jsFunction, requiredParameterCount, optionalParameterCount, isGetter, isSetter, isStatic, isConstructor, isOperator, null, null, null, null, H.s($name));
      }}
  },
  JsParameterMirror: {
    "^": "JsDeclarationMirror;owner<,_type<,isOptional,isNamed,_defaultValue,metadataList,simpleName",
    get$_prettyName: function() {
      return "ParameterMirror";
    },
    get$type: function(_) {
      return H.typeMirrorFromRuntimeTypeRepresentation(this.owner, this._type);
    },
    get$defaultValue: function(_) {
      var t1 = this._defaultValue;
      return t1 != null ? H.reflect(init.metadata[t1]) : null;
    },
    $isParameterMirror: true
  },
  JsTypedefMirror: {
    "^": "JsDeclarationMirror;_mangledName<,referent,simpleName",
    get$value: function(_) {
      return this.referent;
    },
    get$_prettyName: function() {
      return "TypedefMirror";
    },
    get$originalDeclaration: function() {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    get$owner: function() {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    $isJsTypedefMirror: true,
    $isTypedefMirror: true,
    $isTypeMirror: true
  },
  BrokenClassMirror: {
    "^": "Object;",
    newInstance$3: function(constructorName, positionalArguments, namedArguments) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    newInstance$2: function(constructorName, positionalArguments) {
      return this.newInstance$3(constructorName, positionalArguments, null);
    },
    get$typeVariables: function() {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    get$typeArguments: function() {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    get$originalDeclaration: function() {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    get$simpleName: function() {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    get$qualifiedName: function() {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  JsFunctionTypeMirror: {
    "^": "BrokenClassMirror;_typeData,_cachedToString,_cachedReturnType,_cachedParameters,owner<",
    get$isOriginalDeclaration: function() {
      return true;
    },
    get$returnType: function() {
      var t1 = this._cachedReturnType;
      if (t1 != null)
        return t1;
      t1 = this._typeData;
      if (!!t1.void) {
        t1 = $.get$JsMirrorSystem__voidType();
        this._cachedReturnType = t1;
        return t1;
      }
      if (!("ret" in t1)) {
        t1 = $.get$JsMirrorSystem__dynamicType();
        this._cachedReturnType = t1;
        return t1;
      }
      t1 = H.typeMirrorFromRuntimeTypeRepresentation(this.owner, t1.ret);
      this._cachedReturnType = t1;
      return t1;
    },
    get$parameters: function() {
      var t1, result, t2, parameterCount, parameterCount0, $name;
      t1 = this._cachedParameters;
      if (t1 != null)
        return t1;
      result = [];
      t1 = this._typeData;
      if ("args" in t1)
        for (t2 = t1.args, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), parameterCount = 0; t2.moveNext$0(); parameterCount = parameterCount0) {
          parameterCount0 = parameterCount + 1;
          result.push(new H.JsParameterMirror(this, t2._current, false, false, null, C.List_empty2, H.s("argument" + parameterCount)));
        }
      else
        parameterCount = 0;
      if ("opt" in t1)
        for (t2 = t1.opt, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0(); parameterCount = parameterCount0) {
          parameterCount0 = parameterCount + 1;
          result.push(new H.JsParameterMirror(this, t2._current, false, false, null, C.List_empty2, H.s("argument" + parameterCount)));
        }
      if ("named" in t1)
        for (t2 = H.extractKeys(t1.named), t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();) {
          $name = t2._current;
          result.push(new H.JsParameterMirror(this, t1.named[$name], false, false, null, C.List_empty2, H.s($name)));
        }
      t1 = H.setRuntimeTypeInfo(new P.UnmodifiableListView(result), [P.ParameterMirror]);
      this._cachedParameters = t1;
      return t1;
    },
    _unmangleIfPreserved$1: function(mangled) {
      var result = init.mangledGlobalNames[mangled];
      if (result != null)
        return result;
      return mangled;
    },
    toString$0: function(_) {
      var t1, t2, s, sep, argument, $name;
      t1 = this._cachedToString;
      if (t1 != null)
        return t1;
      t1 = this._typeData;
      if ("args" in t1)
        for (t2 = t1.args, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), s = "FunctionTypeMirror on '(", sep = ""; t2.moveNext$0(); sep = ", ") {
          argument = t2._current;
          s = C.JSString_methods.$add(s + sep, this._unmangleIfPreserved$1(H.runtimeTypeToString(argument, null)));
        }
      else {
        s = "FunctionTypeMirror on '(";
        sep = "";
      }
      if ("opt" in t1) {
        s += sep + "[";
        for (t2 = t1.opt, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), sep = ""; t2.moveNext$0(); sep = ", ") {
          argument = t2._current;
          s = C.JSString_methods.$add(s + sep, this._unmangleIfPreserved$1(H.runtimeTypeToString(argument, null)));
        }
        s += "]";
      }
      if ("named" in t1) {
        s += sep + "{";
        for (t2 = H.extractKeys(t1.named), t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), sep = ""; t2.moveNext$0(); sep = ", ") {
          $name = t2._current;
          s = C.JSString_methods.$add(s + sep + (H.S($name) + ": "), this._unmangleIfPreserved$1(H.runtimeTypeToString(t1.named[$name], null)));
        }
        s += "}";
      }
      s += ") -> ";
      if (!!t1.void)
        s += "void";
      else
        s = "ret" in t1 ? C.JSString_methods.$add(s, this._unmangleIfPreserved$1(H.runtimeTypeToString(t1.ret, null))) : s + "dynamic";
      t1 = s + "'";
      this._cachedToString = t1;
      return t1;
    },
    $isClassMirror: true,
    $isTypeMirror: true
  },
  typeMirrorFromRuntimeTypeRepresentation_getTypeArgument: {
    "^": "Closure:1686;box_0",
    call$1: function(index) {
      var typeVariable, t1, variableIndex;
      typeVariable = init.metadata[index];
      t1 = this.box_0;
      variableIndex = H.findTypeVariableIndex(t1.ownerClass_0.get$typeVariables(), J.get$name$x(typeVariable));
      return J.$index$asx(t1.ownerClass_0.get$typeArguments(), variableIndex);
    },
    $isFunction: true
  },
  typeMirrorFromRuntimeTypeRepresentation_substituteTypeVariable: {
    "^": "Closure:516;getTypeArgument_1",
    call$1: function(index) {
      var typeArgument, t1;
      typeArgument = this.getTypeArgument_1.call$1(index);
      t1 = J.getInterceptor(typeArgument);
      if (!!t1.$isJsTypeVariableMirror)
        return H.S(typeArgument._metadataIndex);
      if (!t1.$isJsClassMirror && !t1.$isJsTypeBoundClassMirror)
        if (t1.$eq(typeArgument, $.get$JsMirrorSystem__dynamicType()))
          return "dynamic";
        else if (t1.$eq(typeArgument, $.get$JsMirrorSystem__voidType()))
          return "void";
        else
          return "dynamic";
      return typeArgument.get$_mangledName();
    },
    $isFunction: true
  },
  extractMetadata_closure: {
    "^": "Closure:60;",
    call$1: [function(i) {
      return init.metadata[i];
    }, "call$1", null, 2, 0, null, 381, [], "call"],
    $isFunction: true
  },
  NoSuchStaticMethodError: {
    "^": "Error;_cls,__js_mirrors$_name,_positionalArguments,__js_mirrors$_namedArguments,__js_mirrors$_kind",
    toString$0: function(_) {
      switch (this.__js_mirrors$_kind) {
        case 0:
          return "NoSuchMethodError: No constructor named '" + H.S(this.__js_mirrors$_name._name) + "' in class '" + H.S(this._cls.get$qualifiedName().get$_name()) + "'.";
        case 1:
          return "NoSuchMethodError: No top-level method named '" + H.S(this.__js_mirrors$_name._name) + "'.";
        default:
          return "NoSuchMethodError";
      }
    },
    $isError: true,
    static: {"^": "NoSuchStaticMethodError_MISSING_CONSTRUCTOR,NoSuchStaticMethodError_MISSING_METHOD", NoSuchStaticMethodError$method: function(_cls, _name, _positionalArguments, _namedArguments) {
        return new H.NoSuchStaticMethodError(_cls, _name, _positionalArguments, _namedArguments, 1);
      }}
  }
}],
["dart._js_names", "dart:_js_names", , H, {
  "^": "",
  computeMangledNames: function(jsMangledNames, isGlobal) {
    var keys, result, t1, t2, key, value, t3;
    keys = H.extractKeys(jsMangledNames);
    result = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String);
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(keys, keys.length, 0, null), [H.getTypeArgumentByIndex(keys, 0)]), t2 = !isGlobal; t1.moveNext$0();) {
      key = t1._current;
      value = jsMangledNames[key];
      result.$indexSet(0, key, value);
      if (t2) {
        t3 = J.getInterceptor$s(key);
        if (t3.startsWith$1(key, "get$"))
          result.$indexSet(0, "set$" + t3.substring$1(key, 4), value + "=");
      }
    }
    return result;
  },
  computeReflectiveNames: function(map) {
    var result = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String);
    map.forEach$1(0, new H.computeReflectiveNames_closure(result));
    return result;
  },
  extractKeys: function(victim) {
    var t1 = H.setRuntimeTypeInfo(function(victim, hasOwnProperty) {
      var result = [];
      for (var key in victim) {
        if (hasOwnProperty.call(victim, key))
          result.push(key);
      }
      return result;
    }(victim, Object.prototype.hasOwnProperty), [null]);
    t1.fixed$length = init;
    return t1;
  },
  computeReflectiveNames_closure: {
    "^": "Closure:743;result_0",
    call$2: function(mangledName, reflectiveName) {
      this.result_0.$indexSet(0, reflectiveName, mangledName);
    },
    $isFunction: true
  }
}],
["dart.async", "dart:async", , P, {
  "^": "",
  _AsyncRun__initializeScheduleImmediate: function() {
    var t1, div, span;
    t1 = {};
    if (self.scheduleImmediate != null)
      return P._AsyncRun__scheduleImmediateJsOverride$closure();
    if (self.MutationObserver != null && self.document != null) {
      div = self.document.createElement("div");
      span = self.document.createElement("span");
      t1.storedCallback_0 = null;
      new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
      return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
    }
    return P._AsyncRun__scheduleImmediateWithTimer$closure();
  },
  _AsyncRun__scheduleImmediateJsOverride: [function(callback) {
    ++init.globalState.topEventLoop._activeJsAsyncCount;
    self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(callback), 0));
  }, "call$1", "_AsyncRun__scheduleImmediateJsOverride$closure", 2, 0, 553],
  _AsyncRun__scheduleImmediateWithTimer: [function(callback) {
    P.Timer__createTimer(C.Duration_0, callback);
  }, "call$1", "_AsyncRun__scheduleImmediateWithTimer$closure", 2, 0, 553],
  _registerErrorHandler: function(errorHandler, zone) {
    var t1 = H.getDynamicRuntimeType();
    t1 = H.buildFunctionType(t1, [t1, t1])._isTest$1(errorHandler);
    if (t1) {
      zone.toString;
      return errorHandler;
    } else {
      zone.toString;
      return errorHandler;
    }
  },
  _asyncRunCallbackLoop: function() {
    var t1, t2;
    for (; t1 = $._nextCallback, t1 != null;) {
      $._lastPriorityCallback = null;
      t2 = t1.get$next();
      $._nextCallback = t2;
      if (t2 == null)
        $._lastCallback = null;
      t1.callback$0();
    }
  },
  _asyncRunCallback: [function() {
    $._isInCallbackLoop = true;
    try {
      P._asyncRunCallbackLoop();
    } finally {
      $._lastPriorityCallback = null;
      $._isInCallbackLoop = false;
      if ($._nextCallback != null)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    }
  }, "call$0", "_asyncRunCallback$closure", 0, 0, 550],
  scheduleMicrotask: function(callback) {
    var t1 = $.Zone__current;
    if (C.C__RootZone === t1) {
      P._rootScheduleMicrotask(null, null, C.C__RootZone, callback);
      return;
    }
    P._rootScheduleMicrotask(null, null, t1, t1.bindCallback$2$runGuarded(callback, true));
  },
  _runGuarded: function(notificationHandler) {
    var result, e, s, exception, t1;
    if (notificationHandler == null)
      return;
    try {
      result = notificationHandler.call$0();
      if (!!J.getInterceptor(result).$isFuture)
        return result;
      return;
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = new H._StackTrace(exception, null);
      t1 = $.Zone__current;
      t1.toString;
      P._rootHandleUncaughtError(null, null, t1, e, s);
    }

  },
  _nullDataHandler: [function(value) {
  }, "call$1", "_nullDataHandler$closure", 2, 0, 554, 100, []],
  _nullErrorHandler: [function(error, stackTrace) {
    var t1 = $.Zone__current;
    t1.toString;
    P._rootHandleUncaughtError(null, null, t1, error, stackTrace);
  }, function(error) {
    return P._nullErrorHandler(error, null);
  }, null, "call$2", "call$1", "_nullErrorHandler$closure", 2, 2, 555, 32, 556, [], 557, []],
  _nullDoneHandler: [function() {
  }, "call$0", "_nullDoneHandler$closure", 0, 0, 550],
  _runUserCode: function(userCode, onSuccess, onError) {
    var e, s, exception, t1;
    try {
      onSuccess.call$1(userCode.call$0());
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = new H._StackTrace(exception, null);
      onError.call$2(e, s);
    }

  },
  _cancelAndError: function(subscription, future, error, stackTrace) {
    var cancelFuture = subscription.cancel$0();
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndError_closure(future, error, stackTrace));
    else
      future._completeError$2(error, stackTrace);
  },
  _cancelAndErrorClosure: function(subscription, future) {
    return new P._cancelAndErrorClosure_closure(subscription, future);
  },
  _cancelAndValue: function(subscription, future, value) {
    var cancelFuture = subscription.cancel$0();
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndValue_closure(future, value));
    else
      future._complete$1(value);
  },
  Timer_Timer: function(duration, callback) {
    var t1 = $.Zone__current;
    if (t1 === C.C__RootZone) {
      t1.toString;
      return P.Timer__createTimer(duration, callback);
    }
    return P.Timer__createTimer(duration, t1.bindCallback$2$runGuarded(callback, true));
  },
  Timer_Timer$periodic: function(duration, callback) {
    var t1 = $.Zone__current;
    if (t1 === C.C__RootZone) {
      t1.toString;
      return P.Timer__createPeriodicTimer(duration, callback);
    }
    return P.Timer__createPeriodicTimer(duration, t1.bindUnaryCallback$2$runGuarded(callback, true));
  },
  Timer__createTimer: function(duration, callback) {
    var milliseconds = C.JSNumber_methods._tdivFast$1(duration._duration, 1000);
    return H.TimerImpl$(milliseconds < 0 ? 0 : milliseconds, callback);
  },
  Timer__createPeriodicTimer: function(duration, callback) {
    var milliseconds = C.JSNumber_methods._tdivFast$1(duration._duration, 1000);
    return H.TimerImpl$periodic(milliseconds < 0 ? 0 : milliseconds, callback);
  },
  Zone__enter: function(zone) {
    var previous = $.Zone__current;
    $.Zone__current = zone;
    return previous;
  },
  _rootHandleUncaughtError: function($self, $parent, zone, error, stackTrace) {
    var entry, t1, t2;
    entry = new P._AsyncCallbackEntry(new P._rootHandleUncaughtError_closure(error, stackTrace), null);
    t1 = $._nextCallback;
    if (t1 == null) {
      $._lastPriorityCallback = entry;
      $._lastCallback = entry;
      $._nextCallback = entry;
      if (!$._isInCallbackLoop)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    } else {
      t2 = $._lastPriorityCallback;
      if (t2 == null) {
        entry.next = t1;
        $._lastPriorityCallback = entry;
        $._nextCallback = entry;
      } else {
        entry.next = t2.next;
        t2.next = entry;
        $._lastPriorityCallback = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    }
  },
  _rootRun: function($self, $parent, zone, f) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$0();
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$0();
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootRunUnary: function($self, $parent, zone, f, arg) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$1(arg);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$1(arg);
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootRunBinary: function($self, $parent, zone, f, arg1, arg2) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$2(arg1, arg2);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$2(arg1, arg2);
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootScheduleMicrotask: function($self, $parent, zone, f) {
    var t1, newEntry;
    if (C.C__RootZone !== zone)
      f = zone.bindCallback$1(f);
    if ($._nextCallback == null) {
      t1 = new P._AsyncCallbackEntry(f, null);
      $._lastCallback = t1;
      $._nextCallback = t1;
      if (!$._isInCallbackLoop)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    } else {
      newEntry = new P._AsyncCallbackEntry(f, null);
      $._lastCallback.next = newEntry;
      $._lastCallback = newEntry;
    }
  },
  _AsyncRun__initializeScheduleImmediate_internalCallback: {
    "^": "Closure:63;box_0",
    call$1: [function(_) {
      var t1, f;
      H.leaveJsAsync();
      t1 = this.box_0;
      f = t1.storedCallback_0;
      t1.storedCallback_0 = null;
      f.call$0();
    }, "call$1", null, 2, 0, null, 1687, [], "call"],
    $isFunction: true
  },
  _AsyncRun__initializeScheduleImmediate_closure: {
    "^": "Closure:1688;box_0,div_1,span_2",
    call$1: function(callback) {
      var t1, t2;
      ++init.globalState.topEventLoop._activeJsAsyncCount;
      this.box_0.storedCallback_0 = callback;
      t1 = this.div_1;
      t2 = this.span_2;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    },
    $isFunction: true
  },
  _AsyncRun__scheduleImmediateJsOverride_internalCallback: {
    "^": "Closure:13;callback_0",
    call$0: [function() {
      H.leaveJsAsync();
      this.callback_0.call$0();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _AsyncError: {
    "^": "Object;error>,stackTrace<",
    $isError: true
  },
  _UncaughtAsyncError: {
    "^": "_AsyncError;error,stackTrace",
    toString$0: function(_) {
      var result, t1;
      result = "Uncaught Error: " + H.S(this.error);
      t1 = this.stackTrace;
      return t1 != null ? result + ("\nStack Trace:\n" + H.S(t1)) : result;
    },
    static: {_UncaughtAsyncError$: function(error, stackTrace) {
        return new P._UncaughtAsyncError(error, P._UncaughtAsyncError__getBestStackTrace(error, stackTrace));
      }, _UncaughtAsyncError__getBestStackTrace: function(error, stackTrace) {
        if (stackTrace != null)
          return stackTrace;
        if (!!J.getInterceptor(error).$isError)
          return error.get$stackTrace();
        return;
      }}
  },
  _BroadcastStream: {
    "^": "_ControllerStream;_async$_controller"
  },
  _BroadcastSubscription: {
    "^": "_ControllerSubscription;_eventState@,_async$_next@,_async$_previous@,_async$_controller,_async$_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    get$_async$_controller: function() {
      return this._async$_controller;
    },
    _expectsEvent$1: function(eventId) {
      var t1 = this._eventState;
      if (typeof t1 !== "number")
        return t1.$and();
      return (t1 & 1) === eventId;
    },
    _toggleEventId$0: function() {
      var t1 = this._eventState;
      if (typeof t1 !== "number")
        return t1.$xor();
      this._eventState = t1 ^ 1;
    },
    get$_isFiring: function() {
      var t1 = this._eventState;
      if (typeof t1 !== "number")
        return t1.$and();
      return (t1 & 2) !== 0;
    },
    _setRemoveAfterFiring$0: function() {
      var t1 = this._eventState;
      if (typeof t1 !== "number")
        return t1.$or();
      this._eventState = t1 | 4;
    },
    get$_removeAfterFiring: function() {
      var t1 = this._eventState;
      if (typeof t1 !== "number")
        return t1.$and();
      return (t1 & 4) !== 0;
    },
    _async$_onPause$0: [function() {
    }, "call$0", "get$_async$_onPause", 0, 0, 550],
    _async$_onResume$0: [function() {
    }, "call$0", "get$_async$_onResume", 0, 0, 550],
    static: {"^": "_BroadcastSubscription__STATE_EVENT_ID,_BroadcastSubscription__STATE_FIRING,_BroadcastSubscription__STATE_REMOVE_AFTER_FIRING"}
  },
  _BroadcastStreamController: {
    "^": "Object;_async$_next@,_async$_previous@",
    get$isPaused: function() {
      return false;
    },
    get$_isFiring: function() {
      return (this._state & 2) !== 0;
    },
    _ensureDoneFuture$0: function() {
      var t1 = this._doneFuture;
      if (t1 != null)
        return t1;
      t1 = P._Future$(null);
      this._doneFuture = t1;
      return t1;
    },
    _removeListener$1: function(subscription) {
      var previous, next;
      previous = subscription.get$_async$_previous();
      next = subscription.get$_async$_next();
      previous.set$_async$_next(next);
      next.set$_async$_previous(previous);
      subscription.set$_async$_previous(subscription);
      subscription.set$_async$_next(subscription);
    },
    _subscribe$4: function(onData, onError, onDone, cancelOnError) {
      var t1, t2, subscription;
      if ((this._state & 4) !== 0) {
        if (onDone == null)
          onDone = P._nullDoneHandler$closure();
        t1 = new P._DoneStreamSubscription($.Zone__current, 0, onDone);
        t1.$builtinTypeInfo = this.$builtinTypeInfo;
        t1._schedule$0();
        return t1;
      }
      t1 = $.Zone__current;
      t2 = cancelOnError ? 1 : 0;
      subscription = new P._BroadcastSubscription(null, null, null, this, null, null, null, t1, t2, null, null);
      subscription.$builtinTypeInfo = this.$builtinTypeInfo;
      subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(this, 0));
      subscription._async$_previous = subscription;
      subscription._async$_next = subscription;
      t2 = this._async$_previous;
      subscription._async$_previous = t2;
      subscription._async$_next = this;
      t2.set$_async$_next(subscription);
      this._async$_previous = subscription;
      subscription._eventState = this._state & 1;
      if (this._async$_next === subscription)
        P._runGuarded(this._onListen);
      return subscription;
    },
    _recordCancel$1: function(subscription) {
      if (subscription.get$_async$_next() === subscription)
        return;
      if (subscription.get$_isFiring())
        subscription._setRemoveAfterFiring$0();
      else {
        this._removeListener$1(subscription);
        if ((this._state & 2) === 0 && this._async$_next === this)
          this._callOnCancel$0();
      }
      return;
    },
    _recordPause$1: function(subscription) {
    },
    _recordResume$1: function(subscription) {
    },
    _addEventError$0: function() {
      if ((this._state & 4) !== 0)
        return new P.StateError("Cannot add new events after calling close");
      return new P.StateError("Cannot add new events while doing an addStream");
    },
    add$1: [function(_, data) {
      if (this._state >= 4)
        throw H.wrapException(this._addEventError$0());
      this._sendData$1(data);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "void__T", void: true, args: [T]};
      }, this.$receiver, "_BroadcastStreamController");
    }, 48, []],
    addError$2: [function(error, stackTrace) {
      if (this._state >= 4)
        throw H.wrapException(this._addEventError$0());
      this._sendError$2(error, stackTrace);
    }, function(error) {
      return this.addError$2(error, null);
    }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 1689, 32, 556, [], 557, []],
    close$0: function(_) {
      var t1, doneFuture;
      t1 = this._state;
      if ((t1 & 4) !== 0)
        return this._doneFuture;
      if (t1 >= 4)
        throw H.wrapException(this._addEventError$0());
      this._state = t1 | 4;
      doneFuture = this._ensureDoneFuture$0();
      this._sendDone$0();
      return doneFuture;
    },
    _async$_add$1: function(data) {
      this._sendData$1(data);
    },
    _addError$2: function(error, stackTrace) {
      this._sendError$2(error, stackTrace);
    },
    _close$0: function() {
      var addState = this._addStreamState;
      this._addStreamState = null;
      this._state &= 4294967287;
      C.JSNull_methods.complete$0(addState);
    },
    _forEachListener$1: function(action) {
      var t1, link, id, link0;
      t1 = this._state;
      if ((t1 & 2) !== 0)
        throw H.wrapException(P.StateError$("Cannot fire new event. Controller is already firing an event"));
      link = this._async$_next;
      if (link === this)
        return;
      id = t1 & 1;
      this._state = t1 ^ 3;
      for (; link !== this;)
        if (link._expectsEvent$1(id)) {
          t1 = link.get$_eventState();
          if (typeof t1 !== "number")
            return t1.$or();
          link.set$_eventState(t1 | 2);
          action.call$1(link);
          link._toggleEventId$0();
          link0 = link.get$_async$_next();
          if (link.get$_removeAfterFiring())
            this._removeListener$1(link);
          t1 = link.get$_eventState();
          if (typeof t1 !== "number")
            return t1.$and();
          link.set$_eventState(t1 & 4294967293);
          link = link0;
        } else
          link = link.get$_async$_next();
      this._state &= 4294967293;
      if (this._async$_next === this)
        this._callOnCancel$0();
    },
    _callOnCancel$0: function() {
      if ((this._state & 4) !== 0 && this._doneFuture._state === 0)
        this._doneFuture._asyncComplete$1(null);
      P._runGuarded(this._onCancel);
    }
  },
  _SyncBroadcastStreamController: {
    "^": "_BroadcastStreamController;_onListen,_onCancel,_state,_async$_next,_async$_previous,_addStreamState,_doneFuture",
    _sendData$1: function(data) {
      var t1 = this._async$_next;
      if (t1 === this)
        return;
      if (t1.get$_async$_next() === this) {
        this._state |= 2;
        this._async$_next._async$_add$1(data);
        this._state &= 4294967293;
        if (this._async$_next === this)
          this._callOnCancel$0();
        return;
      }
      this._forEachListener$1(new P._SyncBroadcastStreamController__sendData_closure(this, data));
    },
    _sendError$2: function(error, stackTrace) {
      if (this._async$_next === this)
        return;
      this._forEachListener$1(new P._SyncBroadcastStreamController__sendError_closure(this, error, stackTrace));
    },
    _sendDone$0: function() {
      if (this._async$_next !== this)
        this._forEachListener$1(new P._SyncBroadcastStreamController__sendDone_closure(this));
      else
        this._doneFuture._asyncComplete$1(null);
    }
  },
  _SyncBroadcastStreamController__sendData_closure: {
    "^": "Closure;this_0,data_1",
    call$1: function(subscription) {
      subscription._async$_add$1(this.data_1);
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic___BufferingStreamSubscription", args: [[P._BufferingStreamSubscription, T]]};
      }, this.this_0, "_SyncBroadcastStreamController");
    }
  },
  _SyncBroadcastStreamController__sendError_closure: {
    "^": "Closure;this_0,error_1,stackTrace_2",
    call$1: function(subscription) {
      subscription._addError$2(this.error_1, this.stackTrace_2);
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic___BufferingStreamSubscription", args: [[P._BufferingStreamSubscription, T]]};
      }, this.this_0, "_SyncBroadcastStreamController");
    }
  },
  _SyncBroadcastStreamController__sendDone_closure: {
    "^": "Closure;this_0",
    call$1: function(subscription) {
      subscription._close$0();
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic___BroadcastSubscription", args: [[P._BroadcastSubscription, T]]};
      }, this.this_0, "_SyncBroadcastStreamController");
    }
  },
  Future: {
    "^": "Object;",
    $isFuture: true
  },
  _Completer: {
    "^": "Object;"
  },
  _AsyncCompleter: {
    "^": "_Completer;future",
    complete$1: [function(_, value) {
      var t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._asyncComplete$1(value);
    }, function($receiver) {
      return this.complete$1($receiver, null);
    }, "complete$0", "call$1", "call$0", "get$complete", 0, 2, 1690, 32],
    completeError$2: function(error, stackTrace) {
      var t1;
      if (error == null)
        throw H.wrapException(P.ArgumentError$("Error must not be null"));
      t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._asyncCompleteError$2(error, stackTrace);
    },
    completeError$1: function(error) {
      return this.completeError$2(error, null);
    }
  },
  _Future: {
    "^": "Object;_state,_zone<,_resultOrListeners,_nextListener@,_onValueCallback?,_errorTestCallback?,_onErrorCallback?,_whenCompleteActionCallback?",
    get$_isComplete: function() {
      return this._state >= 4;
    },
    get$_hasValue: function() {
      return this._state === 4;
    },
    get$_hasError: function() {
      return this._state === 8;
    },
    set$_isChained: function(value) {
      if (value)
        this._state = 2;
      else
        this._state = 0;
    },
    get$_onValue: function() {
      return this._state === 2 ? null : this._onValueCallback;
    },
    get$_errorTest: function() {
      return this._state === 2 ? null : this._errorTestCallback;
    },
    get$_onError: function() {
      return this._state === 2 ? null : this._onErrorCallback;
    },
    get$_whenCompleteAction: function() {
      return this._state === 2 ? null : this._whenCompleteActionCallback;
    },
    then$2$onError: function(f, onError) {
      var t1, result;
      t1 = $.Zone__current;
      t1.toString;
      result = H.setRuntimeTypeInfo(new P._Future(0, t1, null, null, f, null, P._registerErrorHandler(onError, t1), null), [null]);
      this._addListener$1(result);
      return result;
    },
    then$1: function(f) {
      return this.then$2$onError(f, null);
    },
    whenComplete$1: function(action) {
      var t1, result;
      t1 = $.Zone__current;
      t1.toString;
      result = new P._Future(0, t1, null, null, null, null, null, action);
      result.$builtinTypeInfo = this.$builtinTypeInfo;
      this._addListener$1(result);
      return result;
    },
    get$_async$_value: function() {
      return this._resultOrListeners;
    },
    get$_error: function() {
      return this._resultOrListeners;
    },
    _setValue$1: function(value) {
      this._state = 4;
      this._resultOrListeners = value;
    },
    _setError$2: function(error, stackTrace) {
      this._state = 8;
      this._resultOrListeners = new P._AsyncError(error, stackTrace);
    },
    _addListener$1: function(listener) {
      var t1;
      if (this._state >= 4) {
        t1 = this._zone;
        t1.toString;
        P._rootScheduleMicrotask(null, null, t1, new P._Future__addListener_closure(this, listener));
      } else {
        listener.set$_nextListener(this._resultOrListeners);
        this._resultOrListeners = listener;
      }
    },
    _removeListeners$0: function() {
      var current, prev, next;
      current = this._resultOrListeners;
      this._resultOrListeners = null;
      for (prev = null; current != null; prev = current, current = next) {
        next = current.get$_nextListener();
        current.set$_nextListener(prev);
      }
      return prev;
    },
    _complete$1: function(value) {
      var t1, listeners;
      t1 = J.getInterceptor(value);
      if (!!t1.$isFuture)
        if (!!t1.$is_Future)
          P._Future__chainCoreFuture(value, this);
        else
          P._Future__chainForeignFuture(value, this);
      else {
        listeners = this._removeListeners$0();
        this._setValue$1(value);
        P._Future__propagateToListeners(this, listeners);
      }
    },
    _completeWithValue$1: function(value) {
      var listeners = this._removeListeners$0();
      this._setValue$1(value);
      P._Future__propagateToListeners(this, listeners);
    },
    _completeError$2: [function(error, stackTrace) {
      var listeners = this._removeListeners$0();
      this._setError$2(error, stackTrace);
      P._Future__propagateToListeners(this, listeners);
    }, function(error) {
      return this._completeError$2(error, null);
    }, "_completeError$1", "call$2", "call$1", "get$_completeError", 2, 2, 555, 32, 556, [], 557, []],
    _asyncComplete$1: function(value) {
      var t1;
      if (value == null)
        ;
      else {
        t1 = J.getInterceptor(value);
        if (!!t1.$isFuture) {
          if (!!t1.$is_Future) {
            t1 = value._state;
            if (t1 >= 4 && t1 === 8) {
              if (this._state !== 0)
                H.throwExpression(P.StateError$("Future already completed"));
              this._state = 1;
              t1 = this._zone;
              t1.toString;
              P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncComplete_closure(this, value));
            } else
              P._Future__chainCoreFuture(value, this);
          } else
            P._Future__chainForeignFuture(value, this);
          return;
        }
      }
      if (this._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      this._state = 1;
      t1 = this._zone;
      t1.toString;
      P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncComplete_closure0(this, value));
    },
    _asyncCompleteError$2: function(error, stackTrace) {
      var t1;
      if (this._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      this._state = 1;
      t1 = this._zone;
      t1.toString;
      P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncCompleteError_closure(this, error, stackTrace));
    },
    $is_Future: true,
    $isFuture: true,
    static: {"^": "_Future__INCOMPLETE,_Future__PENDING_COMPLETE,_Future__CHAINED,_Future__VALUE,_Future__ERROR", _Future$: function($T) {
        return H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null, null, null, null, null, null), [$T]);
      }, _Future__chainForeignFuture: function(source, target) {
        target.set$_isChained(true);
        source.then$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target));
      }, _Future__chainCoreFuture: function(source, target) {
        target.set$_isChained(true);
        if (source._state >= 4)
          P._Future__propagateToListeners(source, target);
        else
          source._addListener$1(target);
      }, _Future__propagateMultipleListeners: function(source, listeners) {
        var listeners0;
        do {
          listeners0 = listeners.get$_nextListener();
          listeners.set$_nextListener(null);
          P._Future__propagateToListeners(source, listeners);
          if (listeners0 != null) {
            listeners = listeners0;
            continue;
          } else
            break;
        } while (true);
      }, _Future__propagateToListeners: function(source, listeners) {
        var t1, t2, t3, hasError, asyncError, t4, sourceValue, zone, oldZone, chainSource, listeners0;
        t1 = {};
        t1.source_4 = source;
        for (t2 = source; true;) {
          t3 = {};
          if (!t2.get$_isComplete())
            return;
          hasError = t1.source_4.get$_hasError();
          if (hasError && listeners == null) {
            asyncError = t1.source_4.get$_error();
            t2 = t1.source_4.get$_zone();
            t3 = J.get$error$x(asyncError);
            t4 = asyncError.get$stackTrace();
            t2.toString;
            P._rootHandleUncaughtError(null, null, t2, t3, t4);
            return;
          }
          if (listeners == null)
            return;
          if (listeners.get$_nextListener() != null) {
            P._Future__propagateMultipleListeners(t1.source_4, listeners);
            return;
          }
          t3.listenerHasValue_1 = true;
          sourceValue = t1.source_4.get$_hasValue() ? t1.source_4.get$_async$_value() : null;
          t3.listenerValueOrError_2 = sourceValue;
          t3.isPropagationAborted_3 = false;
          t2 = !hasError;
          if (!t2 || listeners.get$_onValue() != null || listeners.get$_whenCompleteAction() != null) {
            zone = listeners.get$_zone();
            if (hasError) {
              t4 = t1.source_4.get$_zone().get$errorZone();
              zone.toString;
              t4 = t4 !== zone;
            } else
              t4 = false;
            if (t4) {
              asyncError = t1.source_4.get$_error();
              t2 = t1.source_4.get$_zone();
              t3 = J.get$error$x(asyncError);
              t4 = asyncError.get$stackTrace();
              t2.toString;
              P._rootHandleUncaughtError(null, null, t2, t3, t4);
              return;
            }
            oldZone = $.Zone__current;
            if (oldZone == null ? zone != null : oldZone !== zone)
              $.Zone__current = zone;
            else
              oldZone = null;
            if (t2) {
              if (listeners.get$_onValue() != null)
                t3.listenerHasValue_1 = new P._Future__propagateToListeners_handleValueCallback(t3, listeners, sourceValue, zone).call$0();
            } else
              new P._Future__propagateToListeners_handleError(t1, t3, listeners, zone).call$0();
            if (listeners.get$_whenCompleteAction() != null)
              new P._Future__propagateToListeners_handleWhenCompleteCallback(t1, t3, hasError, listeners, zone).call$0();
            if (oldZone != null)
              $.Zone__current = oldZone;
            listeners.set$_onValueCallback(null);
            listeners.set$_errorTestCallback(null);
            listeners.set$_onErrorCallback(null);
            listeners.set$_whenCompleteActionCallback(null);
            if (t3.isPropagationAborted_3)
              return;
            if (t3.listenerHasValue_1 === true) {
              t2 = t3.listenerValueOrError_2;
              t2 = (sourceValue == null ? t2 != null : sourceValue !== t2) && !!J.getInterceptor(t2).$isFuture;
            } else
              t2 = false;
            if (t2) {
              chainSource = t3.listenerValueOrError_2;
              if (!!J.getInterceptor(chainSource).$is_Future)
                if (chainSource._state >= 4) {
                  listeners.set$_isChained(true);
                  t1.source_4 = chainSource;
                  t2 = chainSource;
                  continue;
                } else
                  P._Future__chainCoreFuture(chainSource, listeners);
              else
                P._Future__chainForeignFuture(chainSource, listeners);
              return;
            }
          }
          if (t3.listenerHasValue_1 === true) {
            listeners0 = listeners._removeListeners$0();
            listeners._setValue$1(t3.listenerValueOrError_2);
          } else {
            listeners0 = listeners._removeListeners$0();
            asyncError = t3.listenerValueOrError_2;
            listeners._setError$2(J.get$error$x(asyncError), asyncError.get$stackTrace());
          }
          t1.source_4 = listeners;
          t2 = listeners;
          listeners = listeners0;
        }
      }}
  },
  _Future__addListener_closure: {
    "^": "Closure:13;this_0,listener_1",
    call$0: [function() {
      P._Future__propagateToListeners(this.this_0, this.listener_1);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _Future__chainForeignFuture_closure: {
    "^": "Closure:63;target_0",
    call$1: [function(value) {
      this.target_0._completeWithValue$1(value);
    }, "call$1", null, 2, 0, null, 100, [], "call"],
    $isFunction: true
  },
  _Future__chainForeignFuture_closure0: {
    "^": "Closure:862;target_1",
    call$2: [function(error, stackTrace) {
      this.target_1._completeError$2(error, stackTrace);
    }, function(error) {
      return this.call$2(error, null);
    }, "call$1", "call$2", null, null, 2, 2, null, 32, 556, [], 557, [], "call"],
    $isFunction: true
  },
  _Future__asyncComplete_closure: {
    "^": "Closure:13;this_0,coreFuture_1",
    call$0: [function() {
      P._Future__chainCoreFuture(this.coreFuture_1, this.this_0);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _Future__asyncComplete_closure0: {
    "^": "Closure:13;this_2,value_3",
    call$0: [function() {
      this.this_2._completeWithValue$1(this.value_3);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _Future__asyncCompleteError_closure: {
    "^": "Closure:13;this_0,error_1,stackTrace_2",
    call$0: [function() {
      this.this_0._completeError$2(this.error_1, this.stackTrace_2);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _Future__propagateToListeners_handleValueCallback: {
    "^": "Closure:209;box_1,listener_3,sourceValue_4,zone_5",
    call$0: function() {
      var e, s, exception, t1;
      try {
        this.box_1.listenerValueOrError_2 = this.zone_5.runUnary$2(this.listener_3.get$_onValue(), this.sourceValue_4);
        return true;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.box_1.listenerValueOrError_2 = new P._AsyncError(e, s);
        return false;
      }

    },
    $isFunction: true
  },
  _Future__propagateToListeners_handleError: {
    "^": "Closure:550;box_2,box_1,listener_6,zone_7",
    call$0: function() {
      var asyncError, test, matchesTest, e, s, errorCallback, e0, s0, t1, exception, t2, listenerValueOrError, t3, t4;
      asyncError = this.box_2.source_4.get$_error();
      t1 = this.listener_6;
      test = t1.get$_errorTest();
      matchesTest = true;
      if (test != null)
        try {
          matchesTest = this.zone_7.runUnary$2(test, J.get$error$x(asyncError));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = new H._StackTrace(exception, null);
          t1 = J.get$error$x(asyncError);
          t2 = e;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P._AsyncError(e, s);
          t1 = this.box_1;
          t1.listenerValueOrError_2 = listenerValueOrError;
          t1.listenerHasValue_1 = false;
          return;
        }

      errorCallback = t1.get$_onError();
      if (matchesTest === true && errorCallback != null) {
        try {
          t1 = errorCallback;
          t2 = H.getDynamicRuntimeType();
          t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
          t3 = this.zone_7;
          t4 = this.box_1;
          if (t2)
            t4.listenerValueOrError_2 = t3.runBinary$3(errorCallback, J.get$error$x(asyncError), asyncError.get$stackTrace());
          else
            t4.listenerValueOrError_2 = t3.runUnary$2(errorCallback, J.get$error$x(asyncError));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e0 = t1;
          s0 = new H._StackTrace(exception, null);
          t1 = J.get$error$x(asyncError);
          t2 = e0;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P._AsyncError(e0, s0);
          t1 = this.box_1;
          t1.listenerValueOrError_2 = listenerValueOrError;
          t1.listenerHasValue_1 = false;
          return;
        }

        this.box_1.listenerHasValue_1 = true;
      } else {
        t1 = this.box_1;
        t1.listenerValueOrError_2 = asyncError;
        t1.listenerHasValue_1 = false;
      }
    },
    $isFunction: true
  },
  _Future__propagateToListeners_handleWhenCompleteCallback: {
    "^": "Closure:550;box_2,box_1,hasError_8,listener_9,zone_10",
    call$0: function() {
      var t1, e, s, exception, t2, t3;
      t1 = {};
      t1.completeResult_0 = null;
      try {
        t1.completeResult_0 = this.zone_10.run$1(this.listener_9.get$_whenCompleteAction());
      } catch (exception) {
        t2 = H.unwrapException(exception);
        e = t2;
        s = new H._StackTrace(exception, null);
        if (this.hasError_8) {
          t2 = J.get$error$x(this.box_2.source_4.get$_error());
          t3 = e;
          t3 = t2 == null ? t3 == null : t2 === t3;
          t2 = t3;
        } else
          t2 = false;
        t3 = this.box_1;
        if (t2)
          t3.listenerValueOrError_2 = this.box_2.source_4.get$_error();
        else
          t3.listenerValueOrError_2 = new P._AsyncError(e, s);
        t3.listenerHasValue_1 = false;
      }

      if (!!J.getInterceptor(t1.completeResult_0).$isFuture) {
        t2 = this.listener_9;
        t2.set$_isChained(true);
        this.box_1.isPropagationAborted_3 = true;
        t1.completeResult_0.then$2$onError(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(this.box_2, t2), new P._Future__propagateToListeners_handleWhenCompleteCallback_closure0(t1, t2));
      }
    },
    $isFunction: true
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure: {
    "^": "Closure:63;box_2,listener_11",
    call$1: [function(ignored) {
      P._Future__propagateToListeners(this.box_2.source_4, this.listener_11);
    }, "call$1", null, 2, 0, null, 1691, [], "call"],
    $isFunction: true
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure0: {
    "^": "Closure:862;box_0,listener_12",
    call$2: [function(error, stackTrace) {
      var t1, completeResult;
      t1 = this.box_0;
      if (!J.getInterceptor(t1.completeResult_0).$is_Future) {
        completeResult = P._Future$(null);
        t1.completeResult_0 = completeResult;
        completeResult._setError$2(error, stackTrace);
      }
      P._Future__propagateToListeners(t1.completeResult_0, this.listener_12);
    }, function(error) {
      return this.call$2(error, null);
    }, "call$1", "call$2", null, null, 2, 2, null, 32, 556, [], 557, [], "call"],
    $isFunction: true
  },
  _AsyncCallbackEntry: {
    "^": "Object;callback<,next@",
    callback$0: function() {
      return this.callback.call$0();
    },
    callback$3: function(arg0, arg1, arg2) {
      return this.callback.call$3(arg0, arg1, arg2);
    },
    callback$1: function(arg0) {
      return this.callback.call$1(arg0);
    },
    next$0: function() {
      return this.next.call$0();
    },
    next$1: function(arg0) {
      return this.next.call$1(arg0);
    }
  },
  Stream: {
    "^": "Object;",
    where$1: function(_, test) {
      return H.setRuntimeTypeInfo(new P._WhereStream(test, this), [H.getRuntimeTypeArgument(this, "Stream", 0)]);
    },
    map$1: [function(_, convert) {
      return H.setRuntimeTypeInfo(new P._MapStream(convert, this), [H.getRuntimeTypeArgument(this, "Stream", 0), null]);
    }, "call$1", "get$map", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "Stream__dynamic__T", ret: P.Stream, args: [{func: "dynamic__T0", args: [T]}]};
      }, this.$receiver, "Stream");
    }],
    fold$2: function(_, initialValue, combine) {
      var t1, result;
      t1 = {};
      result = P._Future$(null);
      t1.value_0 = initialValue;
      t1.subscription_1 = null;
      t1.subscription_1 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_fold_closure(t1, this, combine, result), true, new P.Stream_fold_closure0(t1, result), new P.Stream_fold_closure1(result));
      return result;
    },
    join$1: function(_, separator) {
      var t1, result, buffer;
      t1 = {};
      result = P._Future$(P.String);
      buffer = P.StringBuffer$("");
      t1.subscription_0 = null;
      t1.first_1 = true;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_join_closure(t1, this, separator, result, buffer), true, new P.Stream_join_closure0(result, buffer), new P.Stream_join_closure1(result));
      return result;
    },
    contains$1: [function(_, needle) {
      var t1, future;
      t1 = {};
      future = P._Future$(P.bool);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_contains_closure(t1, this, needle, future), true, new P.Stream_contains_closure0(future), future.get$_completeError());
      return future;
    }, "call$1", "get$contains", 2, 0, 1692],
    forEach$1: function(_, action) {
      var t1, future;
      t1 = {};
      future = P._Future$(null);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_forEach_closure(t1, this, action, future), true, new P.Stream_forEach_closure0(future), future.get$_completeError());
      return future;
    },
    any$1: [function(_, test) {
      var t1, future;
      t1 = {};
      future = P._Future$(P.bool);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_any_closure(t1, this, test, future), true, new P.Stream_any_closure0(future), future.get$_completeError());
      return future;
    }, "call$1", "get$any", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "Future__bool__T", ret: [P.Future, P.bool], args: [{func: "bool__T0", ret: P.bool, args: [T]}]};
      }, this.$receiver, "Stream");
    }],
    get$length: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(P.$int);
      t1.count_0 = 0;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
      return future;
    },
    get$isEmpty: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(P.bool);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_isEmpty_closure(t1, future), true, new P.Stream_isEmpty_closure0(future), future.get$_completeError());
      return future;
    },
    toList$0: function(_) {
      var result, future;
      result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      future = P._Future$([P.List, H.getRuntimeTypeArgument(this, "Stream", 0)]);
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_toList_closure(this, result), true, new P.Stream_toList_closure0(result, future), future.get$_completeError());
      return future;
    },
    get$last: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(H.getRuntimeTypeArgument(this, "Stream", 0));
      t1.result_0 = null;
      t1.foundResult_1 = false;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_last_closure(t1, this), true, new P.Stream_last_closure0(t1, future), future.get$_completeError());
      return future;
    },
    elementAt$1: function(_, index) {
      var t1, future;
      t1 = {};
      t1.index_0 = index;
      if (typeof index !== "number" || Math.floor(index) !== index || J.$lt$n(index, 0))
        throw H.wrapException(P.ArgumentError$(t1.index_0));
      future = P._Future$(H.getRuntimeTypeArgument(this, "Stream", 0));
      t1.subscription_1 = null;
      t1.subscription_1 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_elementAt_closure(t1, this, future), true, new P.Stream_elementAt_closure0(t1, future), future.get$_completeError());
      return future;
    },
    $isStream: true
  },
  Stream_fold_closure: {
    "^": "Closure;box_0,this_1,combine_2,result_3",
    call$1: [function(element) {
      var t1 = this.box_0;
      P._runUserCode(new P.Stream_fold__closure(t1, this.combine_2, element), new P.Stream_fold__closure0(t1), P._cancelAndErrorClosure(t1.subscription_1, this.result_3));
    }, "call$1", null, 2, 0, null, 432, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_fold__closure: {
    "^": "Closure:13;box_0,combine_4,element_5",
    call$0: function() {
      return this.combine_4.call$2(this.box_0.value_0, this.element_5);
    },
    $isFunction: true
  },
  Stream_fold__closure0: {
    "^": "Closure:63;box_0",
    call$1: function(newValue) {
      this.box_0.value_0 = newValue;
    },
    $isFunction: true
  },
  Stream_fold_closure1: {
    "^": "Closure:935;result_6",
    call$2: [function(e, st) {
      this.result_6._completeError$2(e, st);
    }, "call$2", null, 4, 0, null, 312, [], 1693, [], "call"],
    $isFunction: true
  },
  Stream_fold_closure0: {
    "^": "Closure:13;box_0,result_7",
    call$0: [function() {
      this.result_7._complete$1(this.box_0.value_0);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_join_closure: {
    "^": "Closure;box_0,this_1,separator_2,result_3,buffer_4",
    call$1: [function(element) {
      var e, s, t1, exception, t2;
      t1 = this.box_0;
      if (!t1.first_1)
        this.buffer_4.write$1(this.separator_2);
      t1.first_1 = false;
      try {
        this.buffer_4.write$1(element);
      } catch (exception) {
        t2 = H.unwrapException(exception);
        e = t2;
        s = new H._StackTrace(exception, null);
        P._cancelAndError(t1.subscription_0, this.result_3, e, s);
      }

    }, "call$1", null, 2, 0, null, 432, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_join_closure1: {
    "^": "Closure:63;result_5",
    call$1: [function(e) {
      this.result_5._completeError$1(e);
    }, "call$1", null, 2, 0, null, 312, [], "call"],
    $isFunction: true
  },
  Stream_join_closure0: {
    "^": "Closure:13;result_6,buffer_7",
    call$0: [function() {
      this.result_6._complete$1(this.buffer_7._contents);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_contains_closure: {
    "^": "Closure;box_0,this_1,needle_2,future_3",
    call$1: [function(element) {
      var t1, t2;
      t1 = this.box_0;
      t2 = this.future_3;
      P._runUserCode(new P.Stream_contains__closure(this.needle_2, element), new P.Stream_contains__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription_0, t2));
    }, "call$1", null, 2, 0, null, 432, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_contains__closure: {
    "^": "Closure:13;needle_4,element_5",
    call$0: function() {
      return J.$eq(this.element_5, this.needle_4);
    },
    $isFunction: true
  },
  Stream_contains__closure0: {
    "^": "Closure:650;box_0,future_6",
    call$1: function(isMatch) {
      if (isMatch === true)
        P._cancelAndValue(this.box_0.subscription_0, this.future_6, true);
    },
    $isFunction: true
  },
  Stream_contains_closure0: {
    "^": "Closure:13;future_7",
    call$0: [function() {
      this.future_7._complete$1(false);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_forEach_closure: {
    "^": "Closure;box_0,this_1,action_2,future_3",
    call$1: [function(element) {
      P._runUserCode(new P.Stream_forEach__closure(this.action_2, element), new P.Stream_forEach__closure0(), P._cancelAndErrorClosure(this.box_0.subscription_0, this.future_3));
    }, "call$1", null, 2, 0, null, 432, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_forEach__closure: {
    "^": "Closure:13;action_4,element_5",
    call$0: function() {
      return this.action_4.call$1(this.element_5);
    },
    $isFunction: true
  },
  Stream_forEach__closure0: {
    "^": "Closure:63;",
    call$1: function(_) {
    },
    $isFunction: true
  },
  Stream_forEach_closure0: {
    "^": "Closure:13;future_6",
    call$0: [function() {
      this.future_6._complete$1(null);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_any_closure: {
    "^": "Closure;box_0,this_1,test_2,future_3",
    call$1: [function(element) {
      var t1, t2;
      t1 = this.box_0;
      t2 = this.future_3;
      P._runUserCode(new P.Stream_any__closure(this.test_2, element), new P.Stream_any__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription_0, t2));
    }, "call$1", null, 2, 0, null, 432, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_any__closure: {
    "^": "Closure:13;test_4,element_5",
    call$0: function() {
      return this.test_4.call$1(this.element_5);
    },
    $isFunction: true
  },
  Stream_any__closure0: {
    "^": "Closure:650;box_0,future_6",
    call$1: function(isMatch) {
      if (isMatch === true)
        P._cancelAndValue(this.box_0.subscription_0, this.future_6, true);
    },
    $isFunction: true
  },
  Stream_any_closure0: {
    "^": "Closure:13;future_7",
    call$0: [function() {
      this.future_7._complete$1(false);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_length_closure: {
    "^": "Closure:63;box_0",
    call$1: [function(_) {
      ++this.box_0.count_0;
    }, "call$1", null, 2, 0, null, 1687, [], "call"],
    $isFunction: true
  },
  Stream_length_closure0: {
    "^": "Closure:13;box_0,future_1",
    call$0: [function() {
      this.future_1._complete$1(this.box_0.count_0);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_isEmpty_closure: {
    "^": "Closure:63;box_0,future_1",
    call$1: [function(_) {
      P._cancelAndValue(this.box_0.subscription_0, this.future_1, false);
    }, "call$1", null, 2, 0, null, 1687, [], "call"],
    $isFunction: true
  },
  Stream_isEmpty_closure0: {
    "^": "Closure:13;future_2",
    call$0: [function() {
      this.future_2._complete$1(true);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_toList_closure: {
    "^": "Closure;this_0,result_1",
    call$1: [function(data) {
      this.result_1.push(data);
    }, "call$1", null, 2, 0, null, 48, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_0, "Stream");
    }
  },
  Stream_toList_closure0: {
    "^": "Closure:13;result_2,future_3",
    call$0: [function() {
      this.future_3._complete$1(this.result_2);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_last_closure: {
    "^": "Closure;box_0,this_1",
    call$1: [function(value) {
      var t1 = this.box_0;
      t1.foundResult_1 = true;
      t1.result_0 = value;
    }, "call$1", null, 2, 0, null, 100, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_last_closure0: {
    "^": "Closure:13;box_0,future_2",
    call$0: [function() {
      var e, s, t1, exception;
      t1 = this.box_0;
      if (t1.foundResult_1) {
        this.future_2._complete$1(t1.result_0);
        return;
      }
      try {
        t1 = H.IterableElementError_noElement();
        throw H.wrapException(t1);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.future_2._completeError$2(e, s);
      }

    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_elementAt_closure: {
    "^": "Closure;box_0,this_1,future_2",
    call$1: [function(value) {
      var t1 = this.box_0;
      if (J.$eq(t1.index_0, 0)) {
        P._cancelAndValue(t1.subscription_1, this.future_2, value);
        return;
      }
      t1.index_0 = J.$sub$n(t1.index_0, 1);
    }, "call$1", null, 2, 0, null, 100, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T0", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_elementAt_closure0: {
    "^": "Closure:13;box_0,future_3",
    call$0: [function() {
      this.future_3._completeError$1(new P.RangeError("value " + H.S(this.box_0.index_0)));
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  StreamSubscription: {
    "^": "Object;",
    $isStreamSubscription: true
  },
  _ControllerStream: {
    "^": "_StreamImpl;",
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      return this._async$_controller._subscribe$4(onData, onError, onDone, cancelOnError);
    },
    get$hashCode: function(_) {
      return (H.Primitives_objectHashCode(this._async$_controller) ^ 892482866) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.getInterceptor(other).$is_ControllerStream)
        return false;
      return other._async$_controller === this._async$_controller;
    },
    $is_ControllerStream: true
  },
  _ControllerSubscription: {
    "^": "_BufferingStreamSubscription;_async$_controller<",
    _onCancel$0: function() {
      return this.get$_async$_controller()._recordCancel$1(this);
    },
    _async$_onPause$0: [function() {
      this.get$_async$_controller()._recordPause$1(this);
    }, "call$0", "get$_async$_onPause", 0, 0, 550],
    _async$_onResume$0: [function() {
      this.get$_async$_controller()._recordResume$1(this);
    }, "call$0", "get$_async$_onResume", 0, 0, 550]
  },
  _EventSink: {
    "^": "Object;"
  },
  _BufferingStreamSubscription: {
    "^": "Object;_async$_onData,_onError<,_onDone,_zone<,_state,_cancelFuture,_pending",
    onError$1: [function(_, handleError) {
      if (handleError == null)
        handleError = P._nullErrorHandler$closure();
      this._onError = P._registerErrorHandler(handleError, this._zone);
    }, "call$1", "get$onError", 2, 0, 1694],
    pause$1: function(_, resumeSignal) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      this._state = (t1 + 128 | 4) >>> 0;
      if (t1 < 128 && this._pending != null)
        this._pending.cancelSchedule$0();
      if ((t1 & 4) === 0 && (this._state & 32) === 0)
        this._guardCallback$1(this.get$_async$_onPause());
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function() {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 >= 128) {
        t1 -= 128;
        this._state = t1;
        if (t1 < 128) {
          if ((t1 & 64) !== 0) {
            t1 = this._pending;
            t1 = !t1.get$isEmpty(t1);
          } else
            t1 = false;
          if (t1)
            this._pending.schedule$1(this);
          else {
            t1 = (this._state & 4294967291) >>> 0;
            this._state = t1;
            if ((t1 & 32) === 0)
              this._guardCallback$1(this.get$_async$_onResume());
          }
        }
      }
    },
    cancel$0: function() {
      var t1 = (this._state & 4294967279) >>> 0;
      this._state = t1;
      if ((t1 & 8) !== 0)
        return this._cancelFuture;
      this._cancel$0();
      return this._cancelFuture;
    },
    get$isPaused: function() {
      return this._state >= 128;
    },
    _cancel$0: function() {
      var t1 = (this._state | 8) >>> 0;
      this._state = t1;
      if ((t1 & 64) !== 0)
        this._pending.cancelSchedule$0();
      if ((this._state & 32) === 0)
        this._pending = null;
      this._cancelFuture = this._onCancel$0();
    },
    _async$_add$1: function(data) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendData$1(data);
      else
        this._addPending$1(H.setRuntimeTypeInfo(new P._DelayedData(data, null), [null]));
    },
    _addError$2: function(error, stackTrace) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendError$2(error, stackTrace);
      else
        this._addPending$1(new P._DelayedError(error, stackTrace, null));
    },
    _close$0: function() {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      t1 = (t1 | 2) >>> 0;
      this._state = t1;
      if (t1 < 32)
        this._sendDone$0();
      else
        this._addPending$1(C.C__DelayedDone);
    },
    _async$_onPause$0: [function() {
    }, "call$0", "get$_async$_onPause", 0, 0, 550],
    _async$_onResume$0: [function() {
    }, "call$0", "get$_async$_onResume", 0, 0, 550],
    _onCancel$0: function() {
      return;
    },
    _addPending$1: function($event) {
      var pending, t1;
      pending = this._pending;
      if (pending == null) {
        pending = new P._StreamImplEvents(null, null, 0);
        this._pending = pending;
      }
      pending.add$1(0, $event);
      t1 = this._state;
      if ((t1 & 64) === 0) {
        t1 = (t1 | 64) >>> 0;
        this._state = t1;
        if (t1 < 128)
          this._pending.schedule$1(this);
      }
    },
    _sendData$1: function(data) {
      var t1 = this._state;
      this._state = (t1 | 32) >>> 0;
      this._zone.runUnaryGuarded$2(this._async$_onData, data);
      this._state = (this._state & 4294967263) >>> 0;
      this._checkState$1((t1 & 4) !== 0);
    },
    _sendError$2: function(error, stackTrace) {
      var t1, t2;
      t1 = this._state;
      t2 = new P._BufferingStreamSubscription__sendError_sendError(this, error, stackTrace);
      if ((t1 & 1) !== 0) {
        this._state = (t1 | 16) >>> 0;
        this._cancel$0();
        t1 = this._cancelFuture;
        if (!!J.getInterceptor(t1).$isFuture)
          t1.whenComplete$1(t2);
        else
          t2.call$0();
      } else {
        t2.call$0();
        this._checkState$1((t1 & 4) !== 0);
      }
    },
    _sendDone$0: function() {
      var t1, t2;
      t1 = new P._BufferingStreamSubscription__sendDone_sendDone(this);
      this._cancel$0();
      this._state = (this._state | 16) >>> 0;
      t2 = this._cancelFuture;
      if (!!J.getInterceptor(t2).$isFuture)
        t2.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1: function(callback) {
      var t1 = this._state;
      this._state = (t1 | 32) >>> 0;
      callback.call$0();
      this._state = (this._state & 4294967263) >>> 0;
      this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1: function(wasInputPaused) {
      var t1, isInputPaused;
      if ((this._state & 64) !== 0) {
        t1 = this._pending;
        t1 = t1.get$isEmpty(t1);
      } else
        t1 = false;
      if (t1) {
        t1 = (this._state & 4294967231) >>> 0;
        this._state = t1;
        if ((t1 & 4) !== 0)
          if (t1 < 128) {
            t1 = this._pending;
            t1 = t1 == null || t1.get$isEmpty(t1);
          } else
            t1 = false;
        else
          t1 = false;
        if (t1)
          this._state = (this._state & 4294967291) >>> 0;
      }
      for (; true; wasInputPaused = isInputPaused) {
        t1 = this._state;
        if ((t1 & 8) !== 0) {
          this._pending = null;
          return;
        }
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        this._state = (t1 ^ 32) >>> 0;
        if (isInputPaused)
          this._async$_onPause$0();
        else
          this._async$_onResume$0();
        this._state = (this._state & 4294967263) >>> 0;
      }
      t1 = this._state;
      if ((t1 & 64) !== 0 && t1 < 128)
        this._pending.schedule$1(this);
    },
    _BufferingStreamSubscription$4: function(onData, onError, onDone, cancelOnError, $T) {
      this._zone.toString;
      this._async$_onData = onData;
      this.onError$1(0, onError);
      this._onDone = onDone == null ? P._nullDoneHandler$closure() : onDone;
    },
    $isStreamSubscription: true,
    static: {"^": "_BufferingStreamSubscription__STATE_CANCEL_ON_ERROR,_BufferingStreamSubscription__STATE_CLOSED,_BufferingStreamSubscription__STATE_INPUT_PAUSED,_BufferingStreamSubscription__STATE_CANCELED,_BufferingStreamSubscription__STATE_WAIT_FOR_CANCEL,_BufferingStreamSubscription__STATE_IN_CALLBACK,_BufferingStreamSubscription__STATE_HAS_PENDING,_BufferingStreamSubscription__STATE_PAUSE_COUNT,_BufferingStreamSubscription__STATE_PAUSE_COUNT_SHIFT", _BufferingStreamSubscription$: function(onData, onError, onDone, cancelOnError, $T) {
        var t1, t2;
        t1 = $.Zone__current;
        t2 = cancelOnError ? 1 : 0;
        t2 = H.setRuntimeTypeInfo(new P._BufferingStreamSubscription(null, null, null, t1, t2, null, null), [$T]);
        t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
        return t2;
      }}
  },
  _BufferingStreamSubscription__sendError_sendError: {
    "^": "Closure:550;this_0,error_1,stackTrace_2",
    call$0: [function() {
      var t1, t2, t3, t4, t5, t6;
      t1 = this.this_0;
      t2 = t1._state;
      if ((t2 & 8) !== 0 && (t2 & 16) === 0)
        return;
      t1._state = (t2 | 32) >>> 0;
      t2 = t1._onError;
      t3 = H.getDynamicRuntimeType();
      t3 = H.buildFunctionType(t3, [t3, t3])._isTest$1(t2);
      t4 = t1._zone;
      t5 = this.error_1;
      t6 = t1._onError;
      if (t3)
        t4.runBinaryGuarded$3(t6, t5, this.stackTrace_2);
      else
        t4.runUnaryGuarded$2(t6, t5);
      t1._state = (t1._state & 4294967263) >>> 0;
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _BufferingStreamSubscription__sendDone_sendDone: {
    "^": "Closure:550;this_0",
    call$0: function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = t1._state;
      if ((t2 & 16) === 0)
        return;
      t1._state = (t2 | 42) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._state = (t1._state & 4294967263) >>> 0;
    },
    $isFunction: true
  },
  _StreamImpl: {
    "^": "Stream;",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      return this._createSubscription$4(onData, onError, onDone, true === cancelOnError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      return P._BufferingStreamSubscription$(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(this, 0));
    }
  },
  _DelayedEvent: {
    "^": "Object;next@",
    next$0: function() {
      return this.next.call$0();
    },
    next$1: function(arg0) {
      return this.next.call$1(arg0);
    }
  },
  _DelayedData: {
    "^": "_DelayedEvent;value>,next",
    perform$1: function(dispatch) {
      dispatch._sendData$1(this.value);
    }
  },
  _DelayedError: {
    "^": "_DelayedEvent;error>,stackTrace<,next",
    perform$1: function(dispatch) {
      dispatch._sendError$2(this.error, this.stackTrace);
    }
  },
  _DelayedDone: {
    "^": "Object;",
    perform$1: function(dispatch) {
      dispatch._sendDone$0();
    },
    get$next: function() {
      return;
    },
    next$0: function() {
      return this.get$next().call$0();
    },
    next$1: function(arg0) {
      return this.get$next().call$1(arg0);
    },
    set$next: function(_) {
      throw H.wrapException(P.StateError$("No events after a done."));
    }
  },
  _PendingEvents: {
    "^": "Object;",
    schedule$1: function(dispatch) {
      var t1 = this._state;
      if (t1 === 1)
        return;
      if (t1 >= 1) {
        this._state = 1;
        return;
      }
      P.scheduleMicrotask(new P._PendingEvents_schedule_closure(this, dispatch));
      this._state = 1;
    },
    cancelSchedule$0: function() {
      if (this._state === 1)
        this._state = 3;
    }
  },
  _PendingEvents_schedule_closure: {
    "^": "Closure:13;this_0,dispatch_1",
    call$0: [function() {
      var t1, oldState;
      t1 = this.this_0;
      oldState = t1._state;
      t1._state = 0;
      if (oldState === 3)
        return;
      t1.handleNext$1(this.dispatch_1);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _StreamImplEvents: {
    "^": "_PendingEvents;firstPendingEvent,lastPendingEvent,_state",
    get$isEmpty: function(_) {
      return this.lastPendingEvent == null;
    },
    add$1: [function(_, $event) {
      var t1 = this.lastPendingEvent;
      if (t1 == null) {
        this.lastPendingEvent = $event;
        this.firstPendingEvent = $event;
      } else {
        t1.set$next($event);
        this.lastPendingEvent = $event;
      }
    }, "call$1", "get$add", 2, 0, 1695, 815, []],
    handleNext$1: function(dispatch) {
      var $event, t1;
      $event = this.firstPendingEvent;
      t1 = $event.get$next();
      this.firstPendingEvent = t1;
      if (t1 == null)
        this.lastPendingEvent = null;
      $event.perform$1(dispatch);
    },
    clear$0: function(_) {
      if (this._state === 1)
        this._state = 3;
      this.lastPendingEvent = null;
      this.firstPendingEvent = null;
    }
  },
  _DoneStreamSubscription: {
    "^": "Object;_zone<,_state,_onDone",
    get$isPaused: function() {
      return this._state >= 4;
    },
    _schedule$0: function() {
      var t1, t2;
      if ((this._state & 2) !== 0)
        return;
      t1 = this._zone;
      t2 = this.get$_sendDone();
      t1.toString;
      P._rootScheduleMicrotask(null, null, t1, t2);
      this._state = (this._state | 2) >>> 0;
    },
    onError$1: [function(_, handleError) {
    }, "call$1", "get$onError", 2, 0, 1694],
    pause$1: function(_, resumeSignal) {
      this._state += 4;
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function() {
      var t1 = this._state;
      if (t1 >= 4) {
        t1 -= 4;
        this._state = t1;
        if (t1 < 4 && (t1 & 1) === 0)
          this._schedule$0();
      }
    },
    cancel$0: function() {
      return;
    },
    _sendDone$0: [function() {
      var t1 = (this._state & 4294967293) >>> 0;
      this._state = t1;
      if (t1 >= 4)
        return;
      this._state = (t1 | 1) >>> 0;
      t1 = this._onDone;
      if (t1 != null)
        this._zone.runGuarded$1(t1);
    }, "call$0", "get$_sendDone", 0, 0, 550],
    $isStreamSubscription: true,
    static: {"^": "_DoneStreamSubscription__DONE_SENT,_DoneStreamSubscription__SCHEDULED,_DoneStreamSubscription__PAUSED"}
  },
  _cancelAndError_closure: {
    "^": "Closure:13;future_0,error_1,stackTrace_2",
    call$0: [function() {
      return this.future_0._completeError$2(this.error_1, this.stackTrace_2);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _cancelAndErrorClosure_closure: {
    "^": "Closure:1696;subscription_0,future_1",
    call$2: function(error, stackTrace) {
      return P._cancelAndError(this.subscription_0, this.future_1, error, stackTrace);
    },
    $isFunction: true
  },
  _cancelAndValue_closure: {
    "^": "Closure:13;future_0,value_1",
    call$0: [function() {
      return this.future_0._complete$1(this.value_1);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _ForwardingStream: {
    "^": "Stream;",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1, t2, t3, t4;
      cancelOnError = true === cancelOnError;
      t1 = H.getRuntimeTypeArgument(this, "_ForwardingStream", 0);
      t2 = H.getRuntimeTypeArgument(this, "_ForwardingStream", 1);
      t3 = $.Zone__current;
      t4 = cancelOnError ? 1 : 0;
      t4 = H.setRuntimeTypeInfo(new P._ForwardingStreamSubscription(this, null, null, null, null, t3, t4, null, null), [t1, t2]);
      t4._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, t2);
      t4._ForwardingStreamSubscription$5(this, onData, onError, onDone, cancelOnError, t1, t2);
      return t4;
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    _handleData$2: function(data, sink) {
      sink._async$_add$1(data);
    },
    $asStream: function($S, $T) {
      return [$T];
    }
  },
  _ForwardingStreamSubscription: {
    "^": "_BufferingStreamSubscription;_stream,_subscription,_async$_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    _async$_add$1: function(data) {
      if ((this._state & 2) !== 0)
        return;
      P._BufferingStreamSubscription.prototype._async$_add$1.call(this, data);
    },
    _addError$2: function(error, stackTrace) {
      if ((this._state & 2) !== 0)
        return;
      P._BufferingStreamSubscription.prototype._addError$2.call(this, error, stackTrace);
    },
    _async$_onPause$0: [function() {
      var t1 = this._subscription;
      if (t1 == null)
        return;
      t1.pause$0(0);
    }, "call$0", "get$_async$_onPause", 0, 0, 550],
    _async$_onResume$0: [function() {
      var t1 = this._subscription;
      if (t1 == null)
        return;
      t1.resume$0();
    }, "call$0", "get$_async$_onResume", 0, 0, 550],
    _onCancel$0: function() {
      var t1 = this._subscription;
      if (t1 != null) {
        this._subscription = null;
        t1.cancel$0();
      }
      return;
    },
    _handleData$1: [function(data) {
      this._stream._handleData$2(data, this);
    }, "call$1", "get$_handleData", 2, 0, function() {
      return H.computeSignature(function(S, T) {
        return {func: "void__S", void: true, args: [S]};
      }, this.$receiver, "_ForwardingStreamSubscription");
    }, 48, []],
    _handleError$2: [function(error, stackTrace) {
      this._addError$2(error, stackTrace);
    }, "call$2", "get$_handleError", 4, 0, 1697, 556, [], 557, []],
    _handleDone$0: [function() {
      this._close$0();
    }, "call$0", "get$_handleDone", 0, 0, 550],
    _ForwardingStreamSubscription$5: function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
      var t1, t2;
      t1 = this.get$_handleData();
      t2 = this.get$_handleError();
      this._subscription = this._stream._source.listen$3$onDone$onError(t1, this.get$_handleDone(), t2);
    },
    $as_BufferingStreamSubscription: function($S, $T) {
      return [$T];
    },
    $asStreamSubscription: function($S, $T) {
      return [$T];
    }
  },
  _WhereStream: {
    "^": "_ForwardingStream;_test,_source",
    _test$1: function(arg0) {
      return this._test.call$1(arg0);
    },
    _handleData$2: function(inputEvent, sink) {
      var satisfies, e, s, exception, t1;
      satisfies = null;
      try {
        satisfies = this._test$1(inputEvent);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        sink._addError$2(e, s);
        return;
      }

      if (satisfies === true)
        sink._async$_add$1(inputEvent);
    },
    $as_ForwardingStream: function($T) {
      return [$T, $T];
    },
    $asStream: null
  },
  _MapStream: {
    "^": "_ForwardingStream;_transform,_source",
    _transform$1: function(arg0) {
      return this._transform.call$1(arg0);
    },
    _handleData$2: function(inputEvent, sink) {
      var outputEvent, e, s, exception, t1;
      outputEvent = null;
      try {
        outputEvent = this._transform$1(inputEvent);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        sink._addError$2(e, s);
        return;
      }

      sink._async$_add$1(outputEvent);
    }
  },
  _Zone: {
    "^": "Object;"
  },
  _rootHandleUncaughtError_closure: {
    "^": "Closure:13;error_0,stackTrace_1",
    call$0: function() {
      throw H.wrapException(P._UncaughtAsyncError$(this.error_0, this.stackTrace_1));
    },
    $isFunction: true
  },
  _RootZone: {
    "^": "_Zone;",
    get$parent: function(_) {
      return;
    },
    get$errorZone: function() {
      return this;
    },
    runGuarded$1: function(f) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$0();
          return t1;
        }
        t1 = P._rootRun(null, null, this, f);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    runUnaryGuarded$2: function(f, arg) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$1(arg);
          return t1;
        }
        t1 = P._rootRunUnary(null, null, this, f, arg);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    runBinaryGuarded$3: function(f, arg1, arg2) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$2(arg1, arg2);
          return t1;
        }
        t1 = P._rootRunBinary(null, null, this, f, arg1, arg2);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    bindCallback$2$runGuarded: function(f, runGuarded) {
      if (runGuarded)
        return new P._RootZone_bindCallback_closure(this, f);
      else
        return new P._RootZone_bindCallback_closure0(this, f);
    },
    bindCallback$1: function(f) {
      return this.bindCallback$2$runGuarded(f, true);
    },
    bindUnaryCallback$2$runGuarded: function(f, runGuarded) {
      if (runGuarded)
        return new P._RootZone_bindUnaryCallback_closure(this, f);
      else
        return new P._RootZone_bindUnaryCallback_closure0(this, f);
    },
    $index: function(_, key) {
      return;
    },
    run$1: function(f) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$0();
      return P._rootRun(null, null, this, f);
    },
    runUnary$2: function(f, arg) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$1(arg);
      return P._rootRunUnary(null, null, this, f, arg);
    },
    runBinary$3: function(f, arg1, arg2) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$2(arg1, arg2);
      return P._rootRunBinary(null, null, this, f, arg1, arg2);
    },
    static: {"^": "_RootZone__rootMap,_RootZone__rootDelegate"}
  },
  _RootZone_bindCallback_closure: {
    "^": "Closure:13;this_0,f_1",
    call$0: [function() {
      return this.this_0.runGuarded$1(this.f_1);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _RootZone_bindCallback_closure0: {
    "^": "Closure:13;this_2,f_3",
    call$0: [function() {
      return this.this_2.run$1(this.f_3);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _RootZone_bindUnaryCallback_closure: {
    "^": "Closure:63;this_0,f_1",
    call$1: [function(arg) {
      return this.this_0.runUnaryGuarded$2(this.f_1, arg);
    }, "call$1", null, 2, 0, null, 1698, [], "call"],
    $isFunction: true
  },
  _RootZone_bindUnaryCallback_closure0: {
    "^": "Closure:63;this_2,f_3",
    call$1: [function(arg) {
      return this.this_2.runUnary$2(this.f_3, arg);
    }, "call$1", null, 2, 0, null, 1698, [], "call"],
    $isFunction: true
  }
}],
["dart.collection", "dart:collection", , P, {
  "^": "",
  LinkedHashMap_LinkedHashMap$_literal: function(keyValuePairs, $K, $V) {
    return H.fillLiteralMap(keyValuePairs, H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]));
  },
  LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  _defaultEquals: [function(a, b) {
    return J.$eq(a, b);
  }, "call$2", "_defaultEquals$closure", 4, 0, 558],
  _defaultHashCode: [function(a) {
    return J.get$hashCode$(a);
  }, "call$1", "_defaultHashCode$closure", 2, 0, 118, 304, []],
  HashMap_HashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._HashMap(0, null, null, null, null), [$K, $V]);
  },
  IterableBase_iterableToShortString: function(iterable, leftDelimiter, rightDelimiter) {
    var parts, t1;
    if (P.IterableBase__isToStringVisiting(iterable)) {
      if (leftDelimiter === "(" && rightDelimiter === ")")
        return "(...)";
      return leftDelimiter + "..." + rightDelimiter;
    }
    parts = [];
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      P.IterableBase__iterablePartsToStrings(iterable, parts);
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = P.StringBuffer$(leftDelimiter);
    t1.writeAll$2(parts, ", ");
    t1.write$1(rightDelimiter);
    return t1._contents;
  },
  IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
    var buffer, t1;
    if (P.IterableBase__isToStringVisiting(iterable))
      return leftDelimiter + "..." + rightDelimiter;
    buffer = P.StringBuffer$(leftDelimiter);
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      buffer.writeAll$2(iterable, ", ");
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    buffer.write$1(rightDelimiter);
    return buffer.get$_contents();
  },
  IterableBase__isToStringVisiting: function(o) {
    var i, t1;
    for (i = 0; t1 = $.get$IterableBase__toStringVisiting(), i < t1.length; ++i) {
      t1 = t1[i];
      if (o == null ? t1 == null : o === t1)
        return true;
    }
    return false;
  },
  IterableBase__iterablePartsToStrings: function(iterable, parts) {
    var it, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision;
    it = iterable.get$iterator(iterable);
    $length = 0;
    count = 0;
    while (true) {
      if (!($length < 80 || count < 3))
        break;
      if (!it.moveNext$0())
        return;
      next = H.S(it.get$current());
      parts.push(next);
      $length += next.length + 2;
      ++count;
    }
    if (!it.moveNext$0()) {
      if (count <= 5)
        return;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      ultimateString = parts.pop();
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      penultimateString = parts.pop();
    } else {
      penultimate = it.get$current();
      ++count;
      if (!it.moveNext$0()) {
        if (count <= 4) {
          parts.push(H.S(penultimate));
          return;
        }
        ultimateString = H.S(penultimate);
        if (0 >= parts.length)
          return H.ioore(parts, 0);
        penultimateString = parts.pop();
        $length += ultimateString.length + 2;
      } else {
        ultimate = it.get$current();
        ++count;
        for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
          ultimate0 = it.get$current();
          ++count;
          if (count > 100) {
            while (true) {
              if (!($length > 75 && count > 3))
                break;
              if (0 >= parts.length)
                return H.ioore(parts, 0);
              $length -= parts.pop().length + 2;
              --count;
            }
            parts.push("...");
            return;
          }
        }
        penultimateString = H.S(penultimate);
        ultimateString = H.S(ultimate);
        $length += ultimateString.length + penultimateString.length + 4;
      }
    }
    if (count > parts.length + 2) {
      $length += 5;
      elision = "...";
    } else
      elision = null;
    while (true) {
      if (!($length > 80 && parts.length > 3))
        break;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      $length -= parts.pop().length + 2;
      if (elision == null) {
        $length += 5;
        elision = "...";
      }
    }
    if (elision != null)
      parts.push(elision);
    parts.push(penultimateString);
    parts.push(ultimateString);
  },
  LinkedHashMap_LinkedHashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  LinkedHashSet_LinkedHashSet: function(equals, hashCode, isValidKey, $E) {
    return H.setRuntimeTypeInfo(new P._LinkedHashSet(0, null, null, null, null, null, 0), [$E]);
  },
  Maps_mapToString: function(m) {
    var t1, result;
    t1 = {};
    if (P.IterableBase__isToStringVisiting(m))
      return "{...}";
    result = P.StringBuffer$("");
    try {
      $.get$IterableBase__toStringVisiting().push(m);
      result.write$1("{");
      t1.first_0 = true;
      J.forEach$1$ax(m, new P.Maps_mapToString_closure(t1, result));
      result.write$1("}");
    } finally {
      t1 = $.get$IterableBase__toStringVisiting();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    return result.get$_contents();
  },
  _HashMap: {
    "^": "Object;_collection$_length,_strings,_nums,_rest,_collection$_keys",
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$keys: function(_) {
      return H.setRuntimeTypeInfo(new P.HashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return H.MappedIterable_MappedIterable(H.setRuntimeTypeInfo(new P.HashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), new P._HashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    containsKey$1: function(_, key) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        return strings == null ? false : strings[key] != null;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        return nums == null ? false : nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1: function(key) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(key)], key) >= 0;
    },
    addAll$1: function(_, other) {
      J.forEach$1$ax(other, new P._HashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, t1, entry, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          t1 = null;
        else {
          entry = strings[key];
          t1 = entry === strings ? null : entry;
        }
        return t1;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          t1 = null;
        else {
          entry = nums[key];
          t1 = entry === nums ? null : entry;
        }
        return t1;
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      return index < 0 ? null : bucket[index + 1];
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = P._HashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._HashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._HashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        P._HashMap__setTableEntry(rest, hash, [key, value]);
        ++this._collection$_length;
        this._collection$_keys = null;
      } else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index + 1] = value;
        else {
          bucket.push(key, value);
          ++this._collection$_length;
          this._collection$_keys = null;
        }
      }
    },
    remove$1: function(_, key) {
      if (typeof key === "string" && key !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return this._removeHashTableEntry$2(this._nums, key);
      else
        return this._remove$1(key);
    },
    _remove$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      --this._collection$_length;
      this._collection$_keys = null;
      return bucket.splice(index, 2)[1];
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._collection$_keys = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
      }
    },
    forEach$1: function(_, action) {
      var keys, $length, i, key;
      keys = this._collection$_computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        key = keys[i];
        action.call$2(key, this.$index(0, key));
        if (keys !== this._collection$_keys)
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    _collection$_computeKeys$0: function() {
      var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
      t1 = this._collection$_keys;
      if (t1 != null)
        return t1;
      result = Array(this._collection$_length);
      result.fixed$length = init;
      strings = this._strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = this._nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = this._rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; i0 += 2) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      this._collection$_keys = result;
      return result;
    },
    _addHashTableEntry$3: function(table, key, value) {
      if (table[key] == null) {
        ++this._collection$_length;
        this._collection$_keys = null;
      }
      P._HashMap__setTableEntry(table, key, value);
    },
    _removeHashTableEntry$2: function(table, key) {
      var value;
      if (table != null && table[key] != null) {
        value = P._HashMap__getTableEntry(table, key);
        delete table[key];
        --this._collection$_length;
        this._collection$_keys = null;
        return value;
      } else
        return;
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2)
        if (J.$eq(bucket[i], key))
          return i;
      return -1;
    },
    $isMap: true,
    $asMap: null,
    static: {_HashMap__getTableEntry: function(table, key) {
        var entry = table[key];
        return entry === table ? null : entry;
      }, _HashMap__setTableEntry: function(table, key, value) {
        if (value == null)
          table[key] = table;
        else
          table[key] = value;
      }, _HashMap__newHashTable: function() {
        var table = Object.create(null);
        P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _HashMap_values_closure: {
    "^": "Closure:63;this_0",
    call$1: [function(each) {
      return this.this_0.$index(0, each);
    }, "call$1", null, 2, 0, null, 1699, [], "call"],
    $isFunction: true
  },
  _HashMap_addAll_closure: {
    "^": "Closure;this_0",
    call$2: [function(key, value) {
      this.this_0.$indexSet(0, key, value);
    }, "call$2", null, 4, 0, null, 231, [], 100, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(K, V) {
        return {func: "dynamic__K_V", args: [K, V]};
      }, this.this_0, "_HashMap");
    }
  },
  HashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._map._collection$_length === 0;
    },
    get$iterator: function(_) {
      var t1 = this._map;
      t1 = new P.HashMapKeyIterator(t1, t1._collection$_computeKeys$0(), 0, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    contains$1: [function(_, element) {
      return this._map.containsKey$1(0, element);
    }, "call$1", "get$contains", 2, 0, 1677],
    forEach$1: function(_, f) {
      var t1, keys, $length, i;
      t1 = this._map;
      keys = t1._collection$_computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        f.call$1(keys[i]);
        if (keys !== t1._collection$_keys)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
      }
    },
    $isEfficientLength: true
  },
  HashMapKeyIterator: {
    "^": "Object;_map,_collection$_keys,_offset,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var keys, offset, t1;
      keys = this._collection$_keys;
      offset = this._offset;
      t1 = this._map;
      if (keys !== t1._collection$_keys)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= keys.length) {
        this._collection$_current = null;
        return false;
      } else {
        this._collection$_current = keys[offset];
        this._offset = offset + 1;
        return true;
      }
    }
  },
  _LinkedHashMap: {
    "^": "Object;_collection$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$keys: function(_) {
      return H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return H.MappedIterable_MappedIterable(H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), new P._LinkedHashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    containsKey$1: function(_, key) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return false;
        return strings[key] != null;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1: function(key) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(key)], key) >= 0;
    },
    addAll$1: function(_, other) {
      J.forEach$1$ax(other, new P._LinkedHashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, cell, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return;
        cell = strings[key];
        return cell == null ? null : cell.get$_value();
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return;
        cell = nums[key];
        return cell == null ? null : cell.get$_value();
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      return bucket[index].get$_value();
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = P._LinkedHashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._LinkedHashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._LinkedHashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [this._newLinkedCell$2(key, value)];
      else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index].set$_value(value);
        else
          bucket.push(this._newLinkedCell$2(key, value));
      }
    },
    putIfAbsent$2: function(_, key, ifAbsent) {
      var value;
      if (this.containsKey$1(0, key))
        return this.$index(0, key);
      value = ifAbsent.call$0();
      this.$indexSet(0, key, value);
      return value;
    },
    remove$1: function(_, key) {
      if (typeof key === "string" && key !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return this._removeHashTableEntry$2(this._nums, key);
      else
        return this._remove$1(key);
    },
    _remove$1: function(key) {
      var rest, bucket, index, cell;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      cell = bucket.splice(index, 1)[0];
      this._unlinkCell$1(cell);
      return cell.get$_value();
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._last = null;
        this._first = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
        this._modifications = this._modifications + 1 & 67108863;
      }
    },
    forEach$1: function(_, action) {
      var cell, modifications;
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        action.call$2(cell.get$_key(cell), cell.get$_value());
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell.get$_next();
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      var cell = table[key];
      if (cell == null)
        table[key] = this._newLinkedCell$2(key, value);
      else
        cell.set$_value(value);
    },
    _removeHashTableEntry$2: function(table, key) {
      var cell;
      if (table == null)
        return;
      cell = table[key];
      if (cell == null)
        return;
      this._unlinkCell$1(cell);
      delete table[key];
      return cell.get$_value();
    },
    _newLinkedCell$2: function(key, value) {
      var cell, last;
      cell = new P.LinkedHashMapCell(key, value, null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last.set$_next(cell);
        this._last = cell;
      }
      ++this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next;
      previous = cell.get$_previous();
      next = cell.get$_next();
      if (previous == null)
        this._first = next;
      else
        previous.set$_next(next);
      if (next == null)
        this._last = previous;
      else
        next.set$_previous(previous);
      --this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(J.get$_key$x(bucket[i]), key))
          return i;
      return -1;
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    $isMap: true,
    $asMap: null,
    static: {_LinkedHashMap__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _LinkedHashMap_values_closure: {
    "^": "Closure:63;this_0",
    call$1: [function(each) {
      return this.this_0.$index(0, each);
    }, "call$1", null, 2, 0, null, 1699, [], "call"],
    $isFunction: true
  },
  _LinkedHashMap_addAll_closure: {
    "^": "Closure;this_0",
    call$2: [function(key, value) {
      this.this_0.$indexSet(0, key, value);
    }, "call$2", null, 4, 0, null, 231, [], 100, [], "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(K, V) {
        return {func: "dynamic__K_V0", args: [K, V]};
      }, this.this_0, "_LinkedHashMap");
    }
  },
  LinkedHashMapCell: {
    "^": "Object;_key>,_value@,_next@,_previous@"
  },
  LinkedHashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._map._collection$_length === 0;
    },
    get$iterator: function(_) {
      var t1, t2;
      t1 = this._map;
      t2 = new P.LinkedHashMapKeyIterator(t1, t1._modifications, null, null);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      t2._cell = t1._first;
      return t2;
    },
    contains$1: [function(_, element) {
      return this._map.containsKey$1(0, element);
    }, "call$1", "get$contains", 2, 0, 1677],
    forEach$1: function(_, f) {
      var t1, cell, modifications;
      t1 = this._map;
      cell = t1._first;
      modifications = t1._modifications;
      for (; cell != null;) {
        f.call$1(cell.get$_key(cell));
        if (modifications !== t1._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        cell = cell.get$_next();
      }
    },
    $isEfficientLength: true
  },
  LinkedHashMapKeyIterator: {
    "^": "Object;_map,_modifications,_cell,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1 = this._map;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = t1.get$_key(t1);
          this._cell = this._cell.get$_next();
          return true;
        }
      }
    }
  },
  _LinkedHashSet: {
    "^": "_HashSetBase;_collection$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$iterator: function(_) {
      var t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(this, this._modifications, null, null), [null]);
      t1._cell = t1._set._first;
      return t1;
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    contains$1: [function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return false;
        return strings[object] != null;
      } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[object] != null;
      } else
        return this._contains$1(object);
    }, "call$1", "get$contains", 2, 0, 1677],
    _contains$1: function(object) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
    },
    lookup$1: function(object) {
      var t1;
      if (!(typeof object === "string" && object !== "__proto__"))
        t1 = typeof object === "number" && (object & 0x3ffffff) === object;
      else
        t1 = true;
      if (t1)
        return this.contains$1(0, object) ? object : null;
      else
        return this._lookup$1(object);
    },
    _lookup$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return;
      return J.$index$asx(bucket, index).get$_collection$_element();
    },
    forEach$1: function(_, action) {
      var cell, modifications;
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        action.call$1(cell.get$_collection$_element());
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell.get$_next();
      }
    },
    get$last: function(_) {
      var t1 = this._last;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No elements"));
      return t1.get$_collection$_element();
    },
    add$1: [function(_, element) {
      var strings, table, nums;
      if (typeof element === "string" && element !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._strings = table;
          strings = table;
        }
        return this._addHashTableEntry$2(strings, element);
      } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
        nums = this._nums;
        if (nums == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._nums = table;
          nums = table;
        }
        return this._addHashTableEntry$2(nums, element);
      } else
        return this._add$1(element);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__E1", ret: P.bool, args: [E]};
      }, this.$receiver, "_LinkedHashSet");
    }, 432, []],
    _add$1: function(element) {
      var rest, hash, bucket;
      rest = this._rest;
      if (rest == null) {
        rest = P._LinkedHashSet__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [this._newLinkedCell$1(element)];
      else {
        if (this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(this._newLinkedCell$1(element));
      }
      return true;
    },
    remove$1: function(_, object) {
      if (typeof object === "string" && object !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, object);
      else if (typeof object === "number" && (object & 0x3ffffff) === object)
        return this._removeHashTableEntry$2(this._nums, object);
      else
        return this._remove$1(object);
    },
    _remove$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return false;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      this._unlinkCell$1(bucket.splice(index, 1)[0]);
      return true;
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._last = null;
        this._first = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
        this._modifications = this._modifications + 1 & 67108863;
      }
    },
    _addHashTableEntry$2: function(table, element) {
      if (table[element] != null)
        return false;
      table[element] = this._newLinkedCell$1(element);
      return true;
    },
    _removeHashTableEntry$2: function(table, element) {
      var cell;
      if (table == null)
        return false;
      cell = table[element];
      if (cell == null)
        return false;
      this._unlinkCell$1(cell);
      delete table[element];
      return true;
    },
    _newLinkedCell$1: function(element) {
      var cell, last;
      cell = new P.LinkedHashSetCell(element, null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last.set$_next(cell);
        this._last = cell;
      }
      ++this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next;
      previous = cell.get$_previous();
      next = cell.get$_next();
      if (previous == null)
        this._first = next;
      else
        previous.set$_next(next);
      if (next == null)
        this._last = previous;
      else
        next.set$_previous(previous);
      --this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i].get$_collection$_element(), element))
          return i;
      return -1;
    },
    $isEfficientLength: true,
    static: {_LinkedHashSet__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  LinkedHashSetCell: {
    "^": "Object;_collection$_element<,_next@,_previous@"
  },
  LinkedHashSetIterator: {
    "^": "Object;_set,_modifications,_cell,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1 = this._set;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = t1.get$_collection$_element();
          this._cell = this._cell.get$_next();
          return true;
        }
      }
    }
  },
  UnmodifiableListView: {
    "^": "UnmodifiableListBase;_collection$_source",
    get$length: function(_) {
      return J.get$length$asx(this._collection$_source);
    },
    $index: function(_, index) {
      return J.elementAt$1$ax(this._collection$_source, index);
    }
  },
  _HashSetBase: {
    "^": "SetBase;"
  },
  IterableBase: {
    "^": "Object;",
    map$1: [function(_, f) {
      return H.MappedIterable_MappedIterable(this, f, H.getRuntimeTypeArgument(this, "IterableBase", 0), null);
    }, "call$1", "get$map", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "Iterable__dynamic__E1", ret: P.Iterable, args: [{func: "dynamic__E1", args: [E]}]};
      }, this.$receiver, "IterableBase");
    }],
    where$1: function(_, f) {
      return H.setRuntimeTypeInfo(new H.WhereIterable(this, f), [H.getRuntimeTypeArgument(this, "IterableBase", 0)]);
    },
    contains$1: [function(_, element) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (J.$eq(t1.get$current(), element))
          return true;
      return false;
    }, "call$1", "get$contains", 2, 0, 1677],
    forEach$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current());
    },
    fold$2: function(_, initialValue, combine) {
      var t1, value;
      for (t1 = this.get$iterator(this), value = initialValue; t1.moveNext$0();)
        value = combine.call$2(value, t1.get$current());
      return value;
    },
    join$1: function(_, separator) {
      var iterator, buffer, t1;
      iterator = this.get$iterator(this);
      if (!iterator.moveNext$0())
        return "";
      buffer = P.StringBuffer$("");
      if (separator === "") {
        do {
          t1 = H.S(iterator.get$current());
          buffer._contents += t1;
        } while (iterator.moveNext$0());
      } else {
        buffer.write$1(H.S(iterator.get$current()));
        for (; iterator.moveNext$0();) {
          buffer._contents += separator;
          t1 = H.S(iterator.get$current());
          buffer._contents += t1;
        }
      }
      return buffer._contents;
    },
    any$1: [function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (f.call$1(t1.get$current()) === true)
          return true;
      return false;
    }, "call$1", "get$any", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__bool__E1", ret: P.bool, args: [{func: "bool__E2", ret: P.bool, args: [E]}]};
      }, this.$receiver, "IterableBase");
    }],
    toList$1$growable: function(_, growable) {
      return P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "IterableBase", 0));
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$length: function(_) {
      var it, count;
      it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    get$isEmpty: function(_) {
      return !this.get$iterator(this).moveNext$0();
    },
    get$isNotEmpty: function(_) {
      return this.get$isEmpty(this) !== true;
    },
    get$last: function(_) {
      var it, result;
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = it.get$current();
      while (it.moveNext$0());
      return result;
    },
    firstWhere$2$orElse: function(_, test, orElse) {
      var t1, element;
      for (t1 = this.get$iterator(this); t1.moveNext$0();) {
        element = t1.get$current();
        if (test.call$1(element) === true)
          return element;
      }
      return orElse.call$0();
    },
    elementAt$1: function(_, index) {
      var t1, remaining, element, t2;
      if (typeof index !== "number" || Math.floor(index) !== index || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      for (t1 = this.get$iterator(this), remaining = index; t1.moveNext$0();) {
        element = t1.get$current();
        t2 = J.getInterceptor(remaining);
        if (t2.$eq(remaining, 0))
          return element;
        remaining = t2.$sub(remaining, 1);
      }
      throw H.wrapException(P.RangeError$value(index));
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToShortString(this, "(", ")");
    }
  },
  ListBase: {
    "^": "Object_ListMixin;"
  },
  Object_ListMixin: {
    "^": "Object+ListMixin;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  ListMixin: {
    "^": "Object;",
    get$iterator: function(receiver) {
      return H.setRuntimeTypeInfo(new H.ListIterator(receiver, this.get$length(receiver), 0, null), [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    forEach$1: function(receiver, action) {
      var $length, i;
      $length = this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        action.call$1(this.$index(receiver, i));
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    get$isEmpty: function(receiver) {
      return J.$eq(this.get$length(receiver), 0);
    },
    get$last: function(receiver) {
      if (J.$eq(this.get$length(receiver), 0))
        throw H.wrapException(P.StateError$("No elements"));
      return this.$index(receiver, J.$sub$n(this.get$length(receiver), 1));
    },
    contains$1: [function(receiver, element) {
      var $length, t1, i, t2;
      $length = this.get$length(receiver);
      t1 = J.getInterceptor($length);
      i = 0;
      while (true) {
        t2 = this.get$length(receiver);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        if (J.$eq(this.$index(receiver, i), element))
          return true;
        if (!t1.$eq($length, this.get$length(receiver)))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
        ++i;
      }
      return false;
    }, "call$1", "get$contains", 2, 0, 1677],
    any$1: [function(receiver, test) {
      var $length, i;
      $length = this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        if (test.call$1(this.$index(receiver, i)) === true)
          return true;
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    }, "call$1", "get$any", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__bool__E2", ret: P.bool, args: [{func: "bool__E3", ret: P.bool, args: [E]}]};
      }, this.$receiver, "ListMixin");
    }],
    firstWhere$2$orElse: function(receiver, test, orElse) {
      var $length, i, element;
      $length = this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        element = this.$index(receiver, i);
        if (test.call$1(element) === true)
          return element;
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return orElse.call$0();
    },
    join$1: function(receiver, separator) {
      var buffer;
      if (J.$eq(this.get$length(receiver), 0))
        return "";
      buffer = P.StringBuffer$("");
      buffer.writeAll$2(receiver, separator);
      return buffer._contents;
    },
    where$1: function(receiver, test) {
      return H.setRuntimeTypeInfo(new H.WhereIterable(receiver, test), [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
    },
    map$1: [function(receiver, f) {
      return H.setRuntimeTypeInfo(new H.MappedListIterable(receiver, f), [null, null]);
    }, "call$1", "get$map", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "Iterable__dynamic__E2", ret: P.Iterable, args: [{func: "dynamic__E2", args: [E]}]};
      }, this.$receiver, "ListMixin");
    }],
    fold$2: function(receiver, initialValue, combine) {
      var $length, value, i;
      $length = this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      value = initialValue;
      i = 0;
      for (; i < $length; ++i) {
        value = combine.call$2(value, this.$index(receiver, i));
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return value;
    },
    toList$1$growable: function(receiver, growable) {
      var result, t1, i;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(receiver));
      } else {
        t1 = this.get$length(receiver);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = Array(t1);
        t1.fixed$length = init;
        result = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      }
      i = 0;
      while (true) {
        t1 = this.get$length(receiver);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        t1 = this.$index(receiver, i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
        ++i;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    add$1: [function(receiver, element) {
      var t1 = this.get$length(receiver);
      this.set$length(receiver, J.$add$ns(t1, 1));
      this.$indexSet(receiver, t1, element);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E2", void: true, args: [E]};
      }, this.$receiver, "ListMixin");
    }, 432, []],
    addAll$1: function(receiver, iterable) {
      var t1, element, t2;
      for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0();) {
        element = t1.get$current();
        t2 = this.get$length(receiver);
        this.set$length(receiver, J.$add$ns(t2, 1));
        this.$indexSet(receiver, t2, element);
      }
    },
    remove$1: function(receiver, element) {
      var i, t1;
      i = 0;
      while (true) {
        t1 = this.get$length(receiver);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$eq(this.$index(receiver, i), element)) {
          this.setRange$4(receiver, i, J.$sub$n(this.get$length(receiver), 1), receiver, i + 1);
          this.set$length(receiver, J.$sub$n(this.get$length(receiver), 1));
          return true;
        }
        ++i;
      }
      return false;
    },
    clear$0: function(receiver) {
      this.set$length(receiver, 0);
    },
    removeLast$0: function(receiver) {
      var result;
      if (J.$eq(this.get$length(receiver), 0))
        throw H.wrapException(P.StateError$("No elements"));
      result = this.$index(receiver, J.$sub$n(this.get$length(receiver), 1));
      this.set$length(receiver, J.$sub$n(this.get$length(receiver), 1));
      return result;
    },
    sort$1: function(receiver, compare) {
      if (compare == null)
        compare = P.Comparable_compare$closure();
      H.Sort__doSort(receiver, 0, J.$sub$n(this.get$length(receiver), 1), compare);
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    _rangeCheck$2: function(receiver, start, end) {
      var t1 = J.getInterceptor$n(start);
      if (t1.$lt(start, 0) || t1.$gt(start, this.get$length(receiver)))
        throw H.wrapException(P.RangeError$range(start, 0, this.get$length(receiver)));
      t1 = J.getInterceptor$n(end);
      if (t1.$lt(end, start) || t1.$gt(end, this.get$length(receiver)))
        throw H.wrapException(P.RangeError$range(end, start, this.get$length(receiver)));
    },
    sublist$2: function(receiver, start, end) {
      var $length, result, i, t1;
      if (end == null)
        end = this.get$length(receiver);
      this._rangeCheck$2(receiver, start, end);
      $length = J.$sub$n(end, start);
      result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      C.JSArray_methods.set$length(result, $length);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        t1 = this.$index(receiver, start + i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return result;
    },
    getRange$2: function(receiver, start, end) {
      this._rangeCheck$2(receiver, start, end);
      return H.SubListIterable$(receiver, start, end, null);
    },
    removeRange$2: function(receiver, start, end) {
      var $length;
      this._rangeCheck$2(receiver, start, end);
      $length = J.$sub$n(end, start);
      this.setRange$4(receiver, start, J.$sub$n(this.get$length(receiver), $length), receiver, end);
      this.set$length(receiver, J.$sub$n(this.get$length(receiver), $length));
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var t1, t2, $length, t3, t4, i;
      t1 = J.getInterceptor$n(start);
      if (t1.$lt(start, 0) || t1.$gt(start, this.get$length(receiver)))
        H.throwExpression(P.RangeError$range(start, 0, this.get$length(receiver)));
      t2 = J.getInterceptor$n(end);
      if (t2.$lt(end, start) || t2.$gt(end, this.get$length(receiver)))
        H.throwExpression(P.RangeError$range(end, start, this.get$length(receiver)));
      $length = t2.$sub(end, start);
      t2 = J.getInterceptor($length);
      if (t2.$eq($length, 0))
        return;
      t3 = J.getInterceptor$n(skipCount);
      if (t3.$lt(skipCount, 0))
        throw H.wrapException(P.ArgumentError$(skipCount));
      t4 = J.getInterceptor$asx(iterable);
      if (J.$gt$n(t3.$add(skipCount, $length), t4.get$length(iterable)))
        throw H.wrapException(P.StateError$("Not enough elements"));
      if (t3.$lt(skipCount, start))
        for (i = t2.$sub($length, 1); t2 = J.getInterceptor$n(i), t2.$ge(i, 0); i = t2.$sub(i, 1))
          this.$indexSet(receiver, t1.$add(start, i), t4.$index(iterable, t3.$add(skipCount, i)));
      else {
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i)
          this.$indexSet(receiver, t1.$add(start, i), t4.$index(iterable, t3.$add(skipCount, i)));
      }
    },
    indexOf$2: function(receiver, element, startIndex) {
      var t1, i;
      t1 = J.getInterceptor$n(startIndex);
      if (t1.$ge(startIndex, this.get$length(receiver)))
        return -1;
      if (t1.$lt(startIndex, 0))
        startIndex = 0;
      for (i = startIndex; t1 = J.getInterceptor$n(i), t1.$lt(i, this.get$length(receiver)); i = t1.$add(i, 1))
        if (J.$eq(this.$index(receiver, i), element))
          return i;
      return -1;
    },
    indexOf$1: function($receiver, element) {
      return this.indexOf$2($receiver, element, 0);
    },
    insert$2: function(receiver, index, element) {
      var t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$gt(index, this.get$length(receiver)))
        throw H.wrapException(P.RangeError$range(index, 0, this.get$length(receiver)));
      if (t1.$eq(index, this.get$length(receiver))) {
        this.add$1(receiver, element);
        return;
      }
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      this.set$length(receiver, J.$add$ns(this.get$length(receiver), 1));
      this.setRange$4(receiver, index + 1, this.get$length(receiver), receiver, index);
      this.$indexSet(receiver, index, element);
    },
    removeAt$1: function(receiver, index) {
      var result = this.$index(receiver, index);
      this.setRange$4(receiver, index, J.$sub$n(this.get$length(receiver), 1), receiver, J.$add$ns(index, 1));
      this.set$length(receiver, J.$sub$n(this.get$length(receiver), 1));
      return result;
    },
    get$reversed: function(receiver) {
      return H.setRuntimeTypeInfo(new H.ReversedListIterable(receiver), [null]);
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  _UnmodifiableMapMixin: {
    "^": "Object;",
    $indexSet: function(_, key, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    },
    addAll$1: function(_, other) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    },
    clear$0: function(_) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    },
    remove$1: function(_, key) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    },
    $isMap: true,
    $asMap: null
  },
  MapView: {
    "^": "Object;",
    $index: function(_, key) {
      return this._map.$index(0, key);
    },
    $indexSet: function(_, key, value) {
      this._map.$indexSet(0, key, value);
    },
    addAll$1: function(_, other) {
      this._map.addAll$1(0, other);
    },
    clear$0: function(_) {
      this._map.clear$0(0);
    },
    containsKey$1: function(_, key) {
      return this._map.containsKey$1(0, key);
    },
    forEach$1: function(_, action) {
      this._map.forEach$1(0, action);
    },
    get$isEmpty: function(_) {
      return this._map._collection$_length === 0;
    },
    get$length: function(_) {
      return this._map._collection$_length;
    },
    get$keys: function(_) {
      var t1 = this._map;
      return H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]);
    },
    remove$1: function(_, key) {
      return this._map.remove$1(0, key);
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this._map);
    },
    get$values: function(_) {
      var t1 = this._map;
      return t1.get$values(t1);
    },
    $isMap: true,
    $asMap: null
  },
  UnmodifiableMapView: {
    "^": "MapView+_UnmodifiableMapMixin;_map",
    $isMap: true,
    $asMap: null
  },
  Maps_mapToString_closure: {
    "^": "Closure:935;box_0,result_1",
    call$2: function(k, v) {
      var t1 = this.box_0;
      if (!t1.first_0)
        this.result_1.write$1(", ");
      t1.first_0 = false;
      t1 = this.result_1;
      t1.write$1(k);
      t1.write$1(": ");
      t1.write$1(v);
    },
    $isFunction: true
  },
  DoubleLinkedQueueEntry: {
    "^": "Object;_previous@,_next@,_collection$_element<",
    _link$2: function(previous, next) {
      this._next = next;
      this._previous = previous;
      previous.set$_next(this);
      next.set$_previous(this);
    },
    append$1: function(_, e) {
      var t1 = new P.DoubleLinkedQueueEntry(null, null, e);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      t1._link$2(this, this._next);
    },
    remove$0: function(_) {
      this._previous.set$_next(this._next);
      this._next.set$_previous(this._previous);
      this._next = null;
      this._previous = null;
      return this._collection$_element;
    },
    get$element: function() {
      return this._collection$_element;
    }
  },
  _DoubleLinkedQueueEntrySentinel: {
    "^": "DoubleLinkedQueueEntry;_previous,_next,_collection$_element",
    remove$0: function(_) {
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$element: function() {
      throw H.wrapException(H.IterableElementError_noElement());
    }
  },
  DoubleLinkedQueue: {
    "^": "IterableBase;_sentinel,_elementCount",
    get$length: function(_) {
      return this._elementCount;
    },
    add$1: [function(_, value) {
      var t1 = this._sentinel;
      H.setRuntimeTypeInfo(new P.DoubleLinkedQueueEntry(null, null, value), [H.getTypeArgumentByIndex(t1, 0)])._link$2(t1._previous, t1);
      ++this._elementCount;
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E3", void: true, args: [E]};
      }, this.$receiver, "DoubleLinkedQueue");
    }, 100, []],
    addAll$1: function(_, iterable) {
      var t1, value, t2, t3, t4;
      for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0();) {
        value = t1.get$current();
        t2 = this._sentinel;
        t3 = new P.DoubleLinkedQueueEntry(null, null, value);
        t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
        t4 = t2._previous;
        t3._next = t2;
        t3._previous = t4;
        t4.set$_next(t3);
        t2._previous = t3;
        ++this._elementCount;
      }
    },
    removeLast$0: function(_) {
      var result = this._sentinel._previous.remove$0(0);
      --this._elementCount;
      return result;
    },
    removeFirst$0: function() {
      var result = this._sentinel._next.remove$0(0);
      --this._elementCount;
      return result;
    },
    remove$1: function(_, o) {
      var entry = this._sentinel._next;
      for (; entry !== this._sentinel;) {
        if (J.$eq(entry.get$element(), o)) {
          entry.remove$0(0);
          --this._elementCount;
          return true;
        }
        entry = entry.get$_next();
      }
      return false;
    },
    get$last: function(_) {
      return this._sentinel._previous.get$element();
    },
    get$isEmpty: function(_) {
      var t1 = this._sentinel;
      return t1._next === t1;
    },
    clear$0: function(_) {
      var t1 = this._sentinel;
      t1._next = t1;
      t1._previous = t1;
      this._elementCount = 0;
    },
    get$iterator: function(_) {
      var t1 = this._sentinel;
      t1 = new P._DoubleLinkedQueueIterator(t1, t1._next, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    $isEfficientLength: true
  },
  _DoubleLinkedQueueIterator: {
    "^": "Object;_sentinel,_nextEntry,_collection$_current",
    moveNext$0: function() {
      var t1, t2;
      t1 = this._nextEntry;
      t2 = this._sentinel;
      if (t1 == null ? t2 != null : t1 !== t2) {
        this._collection$_current = t1.get$_collection$_element();
        this._nextEntry = this._nextEntry.get$_next();
        return true;
      }
      this._collection$_current = null;
      this._sentinel = null;
      this._nextEntry = null;
      return false;
    },
    get$current: function() {
      return this._collection$_current;
    }
  },
  ListQueue: {
    "^": "IterableBase;_table,_head,_tail,_modificationCount",
    get$iterator: function(_) {
      var t1 = new P._ListQueueIterator(this, this._tail, this._modificationCount, this._head, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    forEach$1: function(_, action) {
      var modificationCount, i, t1;
      modificationCount = this._modificationCount;
      for (i = this._head; i !== this._tail; i = (i + 1 & this._table.length - 1) >>> 0) {
        t1 = this._table;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        action.call$1(t1[i]);
        if (modificationCount !== this._modificationCount)
          H.throwExpression(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this._head === this._tail;
    },
    get$length: function(_) {
      return J.$and$n(J.$sub$n(this._tail, this._head), this._table.length - 1);
    },
    get$last: function(_) {
      var t1, t2;
      t1 = this._head;
      t2 = this._tail;
      if (t1 === t2)
        throw H.wrapException(H.IterableElementError_noElement());
      t1 = this._table;
      t2 = J.$and$n(J.$sub$n(t2, 1), this._table.length - 1);
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    elementAt$1: function(_, index) {
      var t1, t2, t3;
      t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$gt(index, this.get$length(this)))
        throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this)));
      t1 = this._table;
      t2 = this._head;
      if (typeof index !== "number")
        return H.iae(index);
      t3 = t1.length;
      t2 = (t2 + index & t3 - 1) >>> 0;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    toList$1$growable: function(_, growable) {
      var list, t1;
      if (growable) {
        list = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(this, 0)]);
        C.JSArray_methods.set$length(list, this.get$length(this));
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = init;
        list = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      }
      this._writeToList$1(list);
      return list;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    add$1: [function(_, element) {
      this._add$1(element);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E4", void: true, args: [E]};
      }, this.$receiver, "ListQueue");
    }, 432, []],
    addAll$1: function(_, elements) {
      var t1, addCount, $length, t2, t3, newCapacity, newTable, endSpace, preSpace;
      t1 = J.getInterceptor(elements);
      if (!!t1.$isList) {
        addCount = t1.get$length(elements);
        $length = this.get$length(this);
        if (typeof addCount !== "number")
          return H.iae(addCount);
        t1 = $length + addCount;
        t2 = this._table;
        t3 = t2.length;
        if (t1 >= t3) {
          newCapacity = P.ListQueue__nextPowerOf2(t1);
          if (typeof newCapacity !== "number")
            return H.iae(newCapacity);
          t2 = Array(newCapacity);
          t2.fixed$length = init;
          newTable = H.setRuntimeTypeInfo(t2, [H.getTypeArgumentByIndex(this, 0)]);
          this._tail = this._writeToList$1(newTable);
          this._table = newTable;
          this._head = 0;
          H.IterableMixinWorkaround_setRangeList(newTable, $length, t1, elements, 0);
          this._tail = J.$add$ns(this._tail, addCount);
        } else {
          t1 = this._tail;
          if (typeof t1 !== "number")
            return H.iae(t1);
          endSpace = t3 - t1;
          if (addCount < endSpace) {
            H.IterableMixinWorkaround_setRangeList(t2, t1, t1 + addCount, elements, 0);
            this._tail = J.$add$ns(this._tail, addCount);
          } else {
            preSpace = addCount - endSpace;
            H.IterableMixinWorkaround_setRangeList(t2, t1, t1 + endSpace, elements, 0);
            t1 = this._table;
            H.IterableMixinWorkaround_setRangeList(t1, 0, preSpace, elements, endSpace);
            this._tail = preSpace;
          }
        }
        ++this._modificationCount;
      } else
        for (t1 = t1.get$iterator(elements); t1.moveNext$0();)
          this._add$1(t1.get$current());
    },
    remove$1: function(_, object) {
      var i, t1;
      for (i = this._head; i !== this._tail; i = (i + 1 & this._table.length - 1) >>> 0) {
        t1 = this._table;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        if (J.$eq(t1[i], object)) {
          this._remove$1(i);
          ++this._modificationCount;
          return true;
        }
      }
      return false;
    },
    clear$0: function(_) {
      var i, t1, t2, t3, t4;
      i = this._head;
      t1 = this._tail;
      if (i !== t1) {
        for (t2 = this._table, t3 = t2.length, t4 = t3 - 1; i !== t1; i = (i + 1 & t4) >>> 0) {
          if (i < 0 || i >= t3)
            return H.ioore(t2, i);
          t2[i] = null;
        }
        this._tail = 0;
        this._head = 0;
        ++this._modificationCount;
      }
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    removeFirst$0: function() {
      var t1, t2, t3, result;
      t1 = this._head;
      if (t1 === this._tail)
        throw H.wrapException(H.IterableElementError_noElement());
      ++this._modificationCount;
      t2 = this._table;
      t3 = t2.length;
      if (t1 >= t3)
        return H.ioore(t2, t1);
      result = t2[t1];
      t2[t1] = null;
      this._head = (t1 + 1 & t3 - 1) >>> 0;
      return result;
    },
    removeLast$0: function(_) {
      var t1, t2, result;
      t1 = this._head;
      t2 = this._tail;
      if (t1 === t2)
        throw H.wrapException(H.IterableElementError_noElement());
      ++this._modificationCount;
      t1 = J.$and$n(J.$sub$n(t2, 1), this._table.length - 1);
      this._tail = t1;
      t2 = this._table;
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      result = t2[t1];
      t2[t1] = null;
      return result;
    },
    _add$1: function(element) {
      var t1, t2;
      t1 = this._table;
      t2 = this._tail;
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      t1[t2] = element;
      t2 = (t2 + 1 & this._table.length - 1) >>> 0;
      this._tail = t2;
      if (this._head === t2)
        this._grow$0();
      ++this._modificationCount;
    },
    _remove$1: function(offset) {
      var mask, t1, t2, t3, i, prevOffset, t4, nextOffset;
      mask = this._table.length - 1;
      if ((offset - this._head & mask) >>> 0 < J.$and$n(J.$sub$n(this._tail, offset), mask)) {
        for (t1 = this._head, t2 = this._table, t3 = t2.length, i = offset; i !== t1; i = prevOffset) {
          prevOffset = (i - 1 & mask) >>> 0;
          if (prevOffset < 0 || prevOffset >= t3)
            return H.ioore(t2, prevOffset);
          t4 = t2[prevOffset];
          if (i < 0 || i >= t3)
            return H.ioore(t2, i);
          t2[i] = t4;
        }
        if (t1 >= t3)
          return H.ioore(t2, t1);
        t2[t1] = null;
        this._head = (t1 + 1 & mask) >>> 0;
        return (offset + 1 & mask) >>> 0;
      } else {
        t1 = J.$and$n(J.$sub$n(this._tail, 1), mask);
        this._tail = t1;
        for (t2 = this._table, t3 = t2.length, i = offset; i !== t1; i = nextOffset) {
          nextOffset = (i + 1 & mask) >>> 0;
          if (nextOffset < 0 || nextOffset >= t3)
            return H.ioore(t2, nextOffset);
          t4 = t2[nextOffset];
          if (i < 0 || i >= t3)
            return H.ioore(t2, i);
          t2[i] = t4;
        }
        if (t1 >= t3)
          return H.ioore(t2, t1);
        t2[t1] = null;
        return offset;
      }
    },
    _grow$0: function() {
      var t1, newTable, t2, split;
      t1 = Array(this._table.length * 2);
      t1.fixed$length = init;
      newTable = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      t1 = this._table;
      t2 = this._head;
      split = t1.length - t2;
      H.IterableMixinWorkaround_setRangeList(newTable, 0, split, t1, t2);
      t1 = this._head;
      t2 = this._table;
      H.IterableMixinWorkaround_setRangeList(newTable, split, split + t1, t2, 0);
      this._head = 0;
      this._tail = this._table.length;
      this._table = newTable;
    },
    _writeToList$1: function(target) {
      var t1, t2, $length, firstPartSize;
      t1 = this._head;
      t2 = this._tail;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 <= t2) {
        $length = t2 - t1;
        t1 = this._table;
        t2 = this._head;
        H.IterableMixinWorkaround_setRangeList(target, 0, $length, t1, t2);
        return $length;
      } else {
        t2 = this._table;
        firstPartSize = t2.length - t1;
        H.IterableMixinWorkaround_setRangeList(target, 0, firstPartSize, t2, t1);
        t1 = this._tail;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = this._table;
        H.IterableMixinWorkaround_setRangeList(target, firstPartSize, firstPartSize + t1, t2, 0);
        return J.$add$ns(this._tail, firstPartSize);
      }
    },
    ListQueue$1: function(initialCapacity, $E) {
      var t1 = Array(8);
      t1.fixed$length = init;
      this._table = H.setRuntimeTypeInfo(t1, [$E]);
    },
    $isEfficientLength: true,
    static: {"^": "ListQueue__INITIAL_CAPACITY", ListQueue__nextPowerOf2: function(number) {
        var nextNumber;
        if (typeof number !== "number")
          return number.$shl();
        number = (number << 2 >>> 0) - 1;
        for (; true; number = nextNumber) {
          nextNumber = (number & number - 1) >>> 0;
          if (nextNumber === 0)
            return number;
        }
      }}
  },
  _ListQueueIterator: {
    "^": "Object;_queue,_end,_modificationCount,_collection$_position,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1, t2, t3;
      t1 = this._queue;
      if (this._modificationCount !== t1._modificationCount)
        H.throwExpression(P.ConcurrentModificationError$(t1));
      t2 = this._collection$_position;
      if (t2 === this._end) {
        this._collection$_current = null;
        return false;
      }
      t1 = t1._table;
      t3 = t1.length;
      if (t2 >= t3)
        return H.ioore(t1, t2);
      this._collection$_current = t1[t2];
      this._collection$_position = (t2 + 1 & t3 - 1) >>> 0;
      return true;
    }
  },
  SetMixin: {
    "^": "Object;",
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    clear$0: function(_) {
      this.removeAll$1(this.toList$0(0));
    },
    addAll$1: function(_, elements) {
      var t1;
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        this.add$1(0, t1.get$current());
    },
    removeAll$1: function(elements) {
      var t1;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(elements, elements.length, 0, null), [H.getTypeArgumentByIndex(elements, 0)]); t1.moveNext$0();)
        this.remove$1(0, t1._current);
    },
    toList$1$growable: function(_, growable) {
      var result, t1, i, element, i0;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(this, 0)]);
        C.JSArray_methods.set$length(result, this.get$length(this));
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = init;
        result = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      }
      for (t1 = this.get$iterator(this), i = 0; t1.moveNext$0(); i = i0) {
        element = t1._collection$_current;
        i0 = i + 1;
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = element;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    map$1: [function(_, f) {
      return H.setRuntimeTypeInfo(new H.EfficientLengthMappedIterable(this, f), [H.getTypeArgumentByIndex(this, 0), null]);
    }, "call$1", "get$map", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "Iterable__dynamic__E3", ret: P.Iterable, args: [{func: "dynamic__E3", args: [E]}]};
      }, this.$receiver, "SetMixin");
    }],
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    where$1: function(_, f) {
      var t1 = new H.WhereIterable(this, f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    forEach$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1._collection$_current);
    },
    fold$2: function(_, initialValue, combine) {
      var t1, value;
      for (t1 = this.get$iterator(this), value = initialValue; t1.moveNext$0();)
        value = combine.call$2(value, t1._collection$_current);
      return value;
    },
    join$1: function(_, separator) {
      var iterator, buffer, t1;
      iterator = this.get$iterator(this);
      if (!iterator.moveNext$0())
        return "";
      buffer = P.StringBuffer$("");
      if (separator === "") {
        do {
          t1 = H.S(iterator._collection$_current);
          buffer._contents += t1;
        } while (iterator.moveNext$0());
      } else {
        buffer.write$1(H.S(iterator._collection$_current));
        for (; iterator.moveNext$0();) {
          buffer._contents += separator;
          t1 = H.S(iterator._collection$_current);
          buffer._contents += t1;
        }
      }
      return buffer._contents;
    },
    any$1: [function(_, test) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (test.call$1(t1._collection$_current) === true)
          return true;
      return false;
    }, "call$1", "get$any", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__bool__E3", ret: P.bool, args: [{func: "bool__E4", ret: P.bool, args: [E]}]};
      }, this.$receiver, "SetMixin");
    }],
    get$last: function(_) {
      var it, result;
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = it._collection$_current;
      while (it.moveNext$0());
      return result;
    },
    firstWhere$2$orElse: function(_, test, orElse) {
      var t1, element;
      for (t1 = this.get$iterator(this); t1.moveNext$0();) {
        element = t1._collection$_current;
        if (test.call$1(element) === true)
          return element;
      }
      return orElse.call$0();
    },
    elementAt$1: function(_, index) {
      var t1, remaining, element, t2;
      if (typeof index !== "number" || Math.floor(index) !== index || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      for (t1 = this.get$iterator(this), remaining = index; t1.moveNext$0();) {
        element = t1._collection$_current;
        t2 = J.getInterceptor(remaining);
        if (t2.$eq(remaining, 0))
          return element;
        remaining = t2.$sub(remaining, 1);
      }
      throw H.wrapException(P.RangeError$value(index));
    },
    $isEfficientLength: true
  },
  SetBase: {
    "^": "SetMixin;"
  }
}],
["dart.convert", "dart:convert", , P, {
  "^": "",
  _convertJsonToDartLazy: function(object) {
    var i;
    if (object == null)
      return;
    if (typeof object != "object")
      return object;
    if (Object.getPrototypeOf(object) !== Array.prototype)
      return new P._JsonMap(object, Object.create(null), null);
    for (i = 0; i < object.length; ++i)
      object[i] = P._convertJsonToDartLazy(object[i]);
    return object;
  },
  _parseJson: function(source, reviver) {
    var parsed, e, t1, exception;
    t1 = source;
    if (typeof t1 !== "string")
      throw H.wrapException(P.ArgumentError$(source));
    parsed = null;
    try {
      parsed = JSON.parse(source);
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      throw H.wrapException(P.FormatException$(String(e), null, null));
    }

    return P._convertJsonToDartLazy(parsed);
  },
  _isLeadSurrogate: function(codeUnit) {
    codeUnit.$and(0, 64512);
    return false;
  },
  _combineSurrogatePair: function(lead, tail) {
    return (65536 + (lead.$and(0, 1023) << 10 >>> 0) | tail & 1023) >>> 0;
  },
  _JsonMap: {
    "^": "Object;_original,_processed,_data",
    $index: function(_, key) {
      var t1, result;
      t1 = this._processed;
      if (t1 == null)
        return this._data.$index(0, key);
      else if (typeof key !== "string")
        return;
      else {
        result = t1[key];
        return typeof result == "undefined" ? this._process$1(key) : result;
      }
    },
    get$length: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        t1 = t1.get$length(t1);
      } else
        t1 = this._computeKeys$0().length;
      return t1;
    },
    get$isEmpty: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        t1 = t1.get$length(t1);
      } else
        t1 = this._computeKeys$0().length;
      return t1 === 0;
    },
    get$keys: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        return t1.get$keys(t1);
      }
      t1 = this._computeKeys$0();
      return H.SubListIterable$(t1, 0, null, H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t1, 0)]), 0));
    },
    get$values: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        return t1.get$values(t1);
      }
      return H.MappedIterable_MappedIterable(this._computeKeys$0(), new P._JsonMap_values_closure(this), null, null);
    },
    $indexSet: function(_, key, value) {
      var processed, original;
      if (this._processed == null)
        this._data.$indexSet(0, key, value);
      else if (this.containsKey$1(0, key)) {
        processed = this._processed;
        processed[key] = value;
        original = this._original;
        if (original == null ? processed != null : original !== processed)
          original[key] = null;
      } else
        this._upgrade$0().$indexSet(0, key, value);
    },
    addAll$1: function(_, other) {
      J.forEach$1$ax(other, new P._JsonMap_addAll_closure(this));
    },
    containsKey$1: function(_, key) {
      if (this._processed == null)
        return this._data.containsKey$1(0, key);
      if (typeof key !== "string")
        return false;
      return Object.prototype.hasOwnProperty.call(this._original, key);
    },
    remove$1: function(_, key) {
      if (this._processed != null && !this.containsKey$1(0, key))
        return;
      return this._upgrade$0().remove$1(0, key);
    },
    clear$0: function(_) {
      var t1;
      if (this._processed == null)
        this._data.clear$0(0);
      else {
        t1 = this._data;
        if (t1 != null)
          J.clear$0$ax(t1);
        this._processed = null;
        this._original = null;
        this._data = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      }
    },
    forEach$1: function(_, f) {
      var keys, i, key, value;
      if (this._processed == null)
        return this._data.forEach$1(0, f);
      keys = this._computeKeys$0();
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        value = this._processed[key];
        if (typeof value == "undefined") {
          value = P._convertJsonToDartLazy(this._original[key]);
          this._processed[key] = value;
        }
        f.call$2(key, value);
        if (keys !== this._data)
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    _computeKeys$0: function() {
      var keys = this._data;
      if (keys == null) {
        keys = Object.keys(this._original);
        this._data = keys;
      }
      return keys;
    },
    _upgrade$0: function() {
      var result, keys, i, t1, key;
      if (this._processed == null)
        return this._data;
      result = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      keys = this._computeKeys$0();
      for (i = 0; t1 = keys.length, i < t1; ++i) {
        key = keys[i];
        result.$indexSet(0, key, this.$index(0, key));
      }
      if (t1 === 0)
        keys.push(null);
      else
        C.JSArray_methods.set$length(keys, 0);
      this._processed = null;
      this._original = null;
      this._data = result;
      return result;
    },
    _process$1: function(key) {
      var result;
      if (!Object.prototype.hasOwnProperty.call(this._original, key))
        return;
      result = P._convertJsonToDartLazy(this._original[key]);
      return this._processed[key] = result;
    },
    $isMap: true,
    $asMap: function() {
      return [null, null];
    }
  },
  _JsonMap_values_closure: {
    "^": "Closure:63;this_0",
    call$1: [function(each) {
      return this.this_0.$index(0, each);
    }, "call$1", null, 2, 0, null, 1699, [], "call"],
    $isFunction: true
  },
  _JsonMap_addAll_closure: {
    "^": "Closure:935;this_0",
    call$2: [function(key, value) {
      this.this_0.$indexSet(0, key, value);
    }, "call$2", null, 4, 0, null, 231, [], 100, [], "call"],
    $isFunction: true
  },
  Codec: {
    "^": "Object;"
  },
  Converter: {
    "^": "Object;"
  },
  Encoding: {
    "^": "Codec;",
    $asCodec: function() {
      return [P.String, [P.List, P.$int]];
    }
  },
  JsonCodec: {
    "^": "Codec;_reviver,_toEncodable",
    decode$2$reviver: function(source, reviver) {
      return P._parseJson(source, this.get$decoder()._reviver);
    },
    decode$1: function(source) {
      return this.decode$2$reviver(source, null);
    },
    get$decoder: function() {
      return C.JsonDecoder_null;
    },
    $asCodec: function() {
      return [P.Object, P.String];
    }
  },
  JsonDecoder: {
    "^": "Converter;_reviver",
    $asConverter: function() {
      return [P.String, P.Object];
    }
  },
  Utf8Codec: {
    "^": "Encoding;_allowMalformed",
    get$name: function(_) {
      return "utf-8";
    },
    get$encoder: function() {
      return new P.Utf8Encoder();
    }
  },
  Utf8Encoder: {
    "^": "Converter;",
    convert$1: function(string) {
      var t1, encoder;
      t1 = Array(string.get$length(string).$mul(0, 3));
      t1.fixed$length = init;
      t1 = H.setRuntimeTypeInfo(t1, [P.$int]);
      encoder = new P._Utf8Encoder(0, 0, t1);
      encoder._fillBuffer$3(string, 0, string.get$length(string));
      string.get$length(string);
      encoder._writeSurrogate$2(string.codeUnitAt$1(0, string.get$length(string).$sub(0, 1)), 0);
      return C.JSArray_methods.sublist$2(t1, 0, encoder._bufferIndex);
    },
    $asConverter: function() {
      return [P.String, [P.List, P.$int]];
    }
  },
  _Utf8Encoder: {
    "^": "Object;_carry,_bufferIndex,_buffer",
    _writeSurrogate$2: function(leadingSurrogate, nextCodeUnit) {
      var t1, t2, t3, t4;
      if ((nextCodeUnit & 64512) === 56320)
        P._combineSurrogatePair(leadingSurrogate, nextCodeUnit);
      else {
        t1 = this._buffer;
        t2 = this._bufferIndex++;
        t3 = C.JSInt_methods.$or(224, leadingSurrogate.$shr(0, 12));
        t4 = t1.length;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = t3;
        t3 = this._bufferIndex++;
        t2 = leadingSurrogate.$shr(0, 6).$and(0, 63);
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | t2;
        t2 = this._bufferIndex++;
        t3 = leadingSurrogate.$and(0, 63);
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 128 | t3;
        return false;
      }
    },
    _fillBuffer$3: function(str, start, end) {
      var t1, t2, stringIndex, codeUnit, t3, t4;
      P._isLeadSurrogate(str.codeUnitAt$1(0, end.$sub(0, 1)));
      for (t1 = this._buffer, t2 = t1.length, stringIndex = start; C.JSInt_methods.$lt(stringIndex, end); ++stringIndex) {
        codeUnit = str.codeUnitAt$1(0, stringIndex);
        codeUnit.$le(0, 127);
        P._isLeadSurrogate(codeUnit);
        codeUnit.$le(0, 2047);
        t3 = this._bufferIndex;
        if (t3 + 2 >= t2)
          break;
        this._bufferIndex = t3 + 1;
        t4 = C.JSInt_methods.$or(224, codeUnit.$shr(0, 12));
        if (t3 >= t2)
          return H.ioore(t1, t3);
        t1[t3] = t4;
        t4 = this._bufferIndex++;
        t3 = codeUnit.$shr(0, 6).$and(0, 63);
        if (t4 >= t2)
          return H.ioore(t1, t4);
        t1[t4] = 128 | t3;
        t3 = this._bufferIndex++;
        t4 = codeUnit.$and(0, 63);
        if (t3 >= t2)
          return H.ioore(t1, t3);
        t1[t3] = 128 | t4;
      }
      return stringIndex;
    },
    static: {"^": "_Utf8Encoder__DEFAULT_BYTE_BUFFER_SIZE"}
  },
  Utf8Decoder: {
    "^": "Converter;_allowMalformed",
    convert$1: function(codeUnits) {
      var buffer, decoder;
      buffer = P.StringBuffer$("");
      decoder = new P._Utf8Decoder(this._allowMalformed, buffer, true, 0, 0, 0);
      decoder.convert$3(codeUnits, 0, J.get$length$asx(codeUnits));
      decoder.flush$0(0);
      return buffer._contents;
    },
    $asConverter: function() {
      return [[P.List, P.$int], P.String];
    }
  },
  _Utf8Decoder: {
    "^": "Object;_allowMalformed,_stringSink,_isFirstCharacter,_convert$_value,_expectedUnits,_extraUnits",
    flush$0: function(_) {
      if (this._expectedUnits > 0) {
        if (this._allowMalformed !== true)
          throw H.wrapException(P.FormatException$("Unfinished UTF-8 octet sequence", null, null));
        this._stringSink.write$1(H.Primitives_stringFromCharCode(65533));
        this._convert$_value = 0;
        this._expectedUnits = 0;
        this._extraUnits = 0;
      }
    },
    convert$3: function(codeUnits, startIndex, endIndex) {
      var value, expectedUnits, extraUnits, t1, t2, t3, t4, t5, i, unit, t6, oneBytes, i0;
      value = this._convert$_value;
      expectedUnits = this._expectedUnits;
      extraUnits = this._extraUnits;
      this._convert$_value = 0;
      this._expectedUnits = 0;
      this._extraUnits = 0;
      t1 = new P._Utf8Decoder_convert_scanOneByteCharacters(endIndex);
      t2 = new P._Utf8Decoder_convert_addSingleBytes(this, codeUnits, startIndex, endIndex);
      $loop$0:
        for (t3 = this._stringSink, t4 = this._allowMalformed !== true, t5 = J.getInterceptor$asx(codeUnits), i = startIndex; true; i = i0) {
          $multibyte$2: {
            if (expectedUnits > 0) {
              do {
                if (i === endIndex)
                  break $loop$0;
                unit = t5.$index(codeUnits, i);
                t6 = J.getInterceptor$n(unit);
                if (t6.$and(unit, 192) !== 128) {
                  if (t4)
                    throw H.wrapException(P.FormatException$("Bad UTF-8 encoding 0x" + t6.toRadixString$1(unit, 16), null, null));
                  this._isFirstCharacter = false;
                  t6 = H.Primitives_stringFromCharCode(65533);
                  t3._contents += t6;
                  expectedUnits = 0;
                  break $multibyte$2;
                } else {
                  value = (value << 6 | t6.$and(unit, 63)) >>> 0;
                  --expectedUnits;
                  ++i;
                }
              } while (expectedUnits > 0);
              t6 = extraUnits - 1;
              if (t6 < 0 || t6 >= 4)
                return H.ioore(C.List_127_2047_65535_1114111, t6);
              if (value <= C.List_127_2047_65535_1114111[t6]) {
                if (t4)
                  throw H.wrapException(P.FormatException$("Overlong encoding of 0x" + C.JSInt_methods.toRadixString$1(value, 16), null, null));
                value = 65533;
                expectedUnits = 0;
                extraUnits = 0;
              }
              if (value > 1114111) {
                if (t4)
                  throw H.wrapException(P.FormatException$("Character outside valid Unicode range: 0x" + C.JSInt_methods.toRadixString$1(value, 16), null, null));
                value = 65533;
              }
              if (!this._isFirstCharacter || value !== 65279) {
                t6 = H.Primitives_stringFromCharCode(value);
                t3._contents += t6;
              }
              this._isFirstCharacter = false;
            }
          }
          for (; i < endIndex; i = i0) {
            oneBytes = t1.call$2(codeUnits, i);
            if (J.$gt$n(oneBytes, 0)) {
              this._isFirstCharacter = false;
              if (typeof oneBytes !== "number")
                return H.iae(oneBytes);
              i0 = i + oneBytes;
              t2.call$2(i, i0);
              if (i0 === endIndex)
                break;
              i = i0;
            }
            i0 = i + 1;
            unit = t5.$index(codeUnits, i);
            t6 = J.getInterceptor$n(unit);
            if (t6.$lt(unit, 0)) {
              if (t4)
                throw H.wrapException(P.FormatException$("Negative UTF-8 code unit: -0x" + J.toRadixString$1$n(t6.$negate(unit), 16), null, null));
              t6 = H.Primitives_stringFromCharCode(65533);
              t3._contents += t6;
            } else {
              if (t6.$and(unit, 224) === 192) {
                value = t6.$and(unit, 31);
                expectedUnits = 1;
                extraUnits = 1;
                continue $loop$0;
              }
              if (t6.$and(unit, 240) === 224) {
                value = t6.$and(unit, 15);
                expectedUnits = 2;
                extraUnits = 2;
                continue $loop$0;
              }
              if (t6.$and(unit, 248) === 240 && t6.$lt(unit, 245)) {
                value = t6.$and(unit, 7);
                expectedUnits = 3;
                extraUnits = 3;
                continue $loop$0;
              }
              if (t4)
                throw H.wrapException(P.FormatException$("Bad UTF-8 encoding 0x" + t6.toRadixString$1(unit, 16), null, null));
              this._isFirstCharacter = false;
              t6 = H.Primitives_stringFromCharCode(65533);
              t3._contents += t6;
              value = 65533;
              expectedUnits = 0;
              extraUnits = 0;
            }
          }
          break $loop$0;
        }
      if (expectedUnits > 0) {
        this._convert$_value = value;
        this._expectedUnits = expectedUnits;
        this._extraUnits = extraUnits;
      }
    },
    static: {"^": "_Utf8Decoder__LIMITS"}
  },
  _Utf8Decoder_convert_scanOneByteCharacters: {
    "^": "Closure:1700;endIndex_0",
    call$2: function(units, from) {
      var to, t1, i, unit;
      to = this.endIndex_0;
      for (t1 = J.getInterceptor$asx(units), i = from; i < to; ++i) {
        unit = t1.$index(units, i);
        if (J.$and$n(unit, 127) !== unit)
          return i - from;
      }
      return to - from;
    },
    $isFunction: true
  },
  _Utf8Decoder_convert_addSingleBytes: {
    "^": "Closure:1701;this_1,codeUnits_2,startIndex_3,endIndex_4",
    call$2: function(from, to) {
      var t1, t2, t3;
      t1 = from === 0 && to === J.get$length$asx(this.codeUnits_2);
      t2 = this.this_1;
      t3 = this.codeUnits_2;
      if (t1)
        t2._stringSink.write$1(P.String_String$fromCharCodes(t3));
      else
        t2._stringSink.write$1(P.String_String$fromCharCodes(J.sublist$2$ax(t3, from, to)));
    },
    $isFunction: true
  }
}],
["dart.core", "dart:core", , P, {
  "^": "",
  Function__toMangledNames: function(namedArguments) {
    return;
  },
  Comparable_compare: [function(a, b) {
    return J.compareTo$1$ns(a, b);
  }, "call$2", "Comparable_compare$closure", 4, 0, 559],
  Error_safeToString: function(object) {
    var buffer, t1, i, t2, codeUnit;
    if (typeof object === "number" || typeof object === "boolean" || null == object)
      return J.toString$0(object);
    if (typeof object === "string") {
      buffer = new P.StringBuffer("");
      buffer._contents = "\"";
      for (t1 = object.length, i = 0, t2 = "\""; i < t1; ++i) {
        codeUnit = C.JSString_methods.codeUnitAt$1(object, i);
        if (codeUnit <= 31)
          if (codeUnit === 10)
            t2 = buffer._contents += "\\n";
          else if (codeUnit === 13)
            t2 = buffer._contents += "\\r";
          else if (codeUnit === 9)
            t2 = buffer._contents += "\\t";
          else {
            t2 = buffer._contents += "\\x";
            if (codeUnit < 16)
              buffer._contents = t2 + "0";
            else {
              buffer._contents = t2 + "1";
              codeUnit -= 16;
            }
            t2 = H.Primitives_stringFromCharCode(codeUnit < 10 ? 48 + codeUnit : 87 + codeUnit);
            t2 = buffer._contents += t2;
          }
        else if (codeUnit === 92)
          t2 = buffer._contents += "\\\\";
        else if (codeUnit === 34)
          t2 = buffer._contents += "\\\"";
        else {
          t2 = H.Primitives_stringFromCharCode(codeUnit);
          t2 = buffer._contents += t2;
        }
      }
      t1 = t2 + "\"";
      buffer._contents = t1;
      return t1;
    }
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Exception_Exception: function(message) {
    return new P._ExceptionImplementation(message);
  },
  identical: [function(a, b) {
    return a == null ? b == null : a === b;
  }, "call$2", "identical$closure", 4, 0, 560],
  identityHashCode: [function(object) {
    return H.objectHashCode(object);
  }, "call$1", "identityHashCode$closure", 2, 0, 561],
  List_List$from: function(other, growable, $E) {
    var list, t1;
    list = H.setRuntimeTypeInfo([], [$E]);
    for (t1 = J.get$iterator$ax(other); t1.moveNext$0();)
      list.push(t1.get$current());
    if (growable)
      return list;
    list.fixed$length = init;
    return list;
  },
  print: function(object) {
    var line = H.S(object);
    H.printString(line);
  },
  String_String$fromCharCodes: function(charCodes) {
    return H.Primitives_stringFromCharCodes(charCodes.constructor !== Array ? P.List_List$from(charCodes, true, null) : charCodes);
  },
  Function__toMangledNames_closure: {
    "^": "Closure:935;result_0",
    call$2: function(symbol, value) {
      this.result_0.$indexSet(0, symbol.get$_name(), value);
    },
    $isFunction: true
  },
  NoSuchMethodError_toString_closure: {
    "^": "Closure:1685;box_0",
    call$2: function(key, value) {
      var t1 = this.box_0;
      if (t1.i_1 > 0)
        t1.sb_0.write$1(", ");
      t1.sb_0.write$1(key.get$_name());
      t1.sb_0.write$1(": ");
      t1.sb_0.write$1(P.Error_safeToString(value));
      ++t1.i_1;
    },
    $isFunction: true
  },
  Deprecated: {
    "^": "Object;expires",
    toString$0: function(_) {
      return "Deprecated feature. Will be removed " + this.expires;
    }
  },
  bool: {
    "^": "Object;",
    toString$0: function(_) {
      return this ? "true" : "false";
    },
    $isbool: true
  },
  "+bool": 0,
  Comparable: {
    "^": "Object;"
  },
  DateTime: {
    "^": "Object;millisecondsSinceEpoch<,isUtc",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isDateTime)
        return false;
      return this.millisecondsSinceEpoch === other.millisecondsSinceEpoch && this.isUtc === other.isUtc;
    },
    compareTo$1: function(_, other) {
      return C.JSNumber_methods.compareTo$1(this.millisecondsSinceEpoch, other.get$millisecondsSinceEpoch());
    },
    get$hashCode: function(_) {
      return this.millisecondsSinceEpoch;
    },
    toString$0: function(_) {
      var t1, y, m, d, h, min, sec, ms;
      t1 = this.isUtc;
      y = P.DateTime__fourDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCFullYear() + 0 : H.Primitives_lazyAsJsDate(this).getFullYear() + 0);
      m = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMonth() + 1 : H.Primitives_lazyAsJsDate(this).getMonth() + 1);
      d = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCDate() + 0 : H.Primitives_lazyAsJsDate(this).getDate() + 0);
      h = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCHours() + 0 : H.Primitives_lazyAsJsDate(this).getHours() + 0);
      min = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMinutes() + 0 : H.Primitives_lazyAsJsDate(this).getMinutes() + 0);
      sec = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCSeconds() + 0 : H.Primitives_lazyAsJsDate(this).getSeconds() + 0);
      ms = P.DateTime__threeDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMilliseconds() + 0 : H.Primitives_lazyAsJsDate(this).getMilliseconds() + 0);
      if (t1)
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + "Z";
      else
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms;
    },
    add$1: [function(_, duration) {
      return P.DateTime$fromMillisecondsSinceEpoch(this.millisecondsSinceEpoch + duration.get$inMilliseconds(), this.isUtc);
    }, "call$1", "get$add", 2, 0, 1702, 55, []],
    difference$1: function(other) {
      return P.Duration$(0, 0, 0, this.millisecondsSinceEpoch - other.get$millisecondsSinceEpoch(), 0, 0);
    },
    get$second: function() {
      return this.isUtc ? H.Primitives_lazyAsJsDate(this).getUTCSeconds() + 0 : H.Primitives_lazyAsJsDate(this).getSeconds() + 0;
    },
    DateTime$fromMillisecondsSinceEpoch$2$isUtc: function(millisecondsSinceEpoch, isUtc) {
      if (Math.abs(millisecondsSinceEpoch) > 8640000000000000)
        throw H.wrapException(P.ArgumentError$(millisecondsSinceEpoch));
    },
    DateTime$_now$0: function() {
      H.Primitives_lazyAsJsDate(this);
    },
    $isDateTime: true,
    static: {"^": "DateTime_MONDAY,DateTime_TUESDAY,DateTime_WEDNESDAY,DateTime_THURSDAY,DateTime_FRIDAY,DateTime_SATURDAY,DateTime_SUNDAY,DateTime_DAYS_PER_WEEK,DateTime_JANUARY,DateTime_FEBRUARY,DateTime_MARCH,DateTime_APRIL,DateTime_MAY,DateTime_JUNE,DateTime_JULY,DateTime_AUGUST,DateTime_SEPTEMBER,DateTime_OCTOBER,DateTime_NOVEMBER,DateTime_DECEMBER,DateTime_MONTHS_PER_YEAR,DateTime__MAX_MILLISECONDS_SINCE_EPOCH", DateTime$fromMillisecondsSinceEpoch: function(millisecondsSinceEpoch, isUtc) {
        var t1 = new P.DateTime(millisecondsSinceEpoch, isUtc);
        t1.DateTime$fromMillisecondsSinceEpoch$2$isUtc(millisecondsSinceEpoch, isUtc);
        return t1;
      }, DateTime__fourDigits: function(n) {
        var absN, sign;
        absN = Math.abs(n);
        sign = n < 0 ? "-" : "";
        if (absN >= 1000)
          return "" + n;
        if (absN >= 100)
          return sign + "0" + H.S(absN);
        if (absN >= 10)
          return sign + "00" + H.S(absN);
        return sign + "000" + H.S(absN);
      }, DateTime__threeDigits: function(n) {
        if (n >= 100)
          return "" + n;
        if (n >= 10)
          return "0" + n;
        return "00" + n;
      }, DateTime__twoDigits: function(n) {
        if (n >= 10)
          return "" + n;
        return "0" + n;
      }}
  },
  $double: {
    "^": "num;",
    $is$double: true
  },
  "+double": 0,
  Duration: {
    "^": "Object;_duration<",
    $add: function(_, other) {
      return P.Duration$(0, 0, this._duration + other.get$_duration(), 0, 0, 0);
    },
    $sub: function(_, other) {
      return P.Duration$(0, 0, this._duration - other.get$_duration(), 0, 0, 0);
    },
    $mul: function(_, factor) {
      if (typeof factor !== "number")
        return H.iae(factor);
      return P.Duration$(0, 0, C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(this._duration * factor)), 0, 0, 0);
    },
    $tdiv: function(_, quotient) {
      if (J.$eq(quotient, 0))
        throw H.wrapException(P.IntegerDivisionByZeroException$());
      if (typeof quotient !== "number")
        return H.iae(quotient);
      return P.Duration$(0, 0, C.JSNumber_methods.$tdiv(this._duration, quotient), 0, 0, 0);
    },
    $lt: function(_, other) {
      return this._duration < other.get$_duration();
    },
    $gt: function(_, other) {
      return this._duration > other.get$_duration();
    },
    $le: function(_, other) {
      return this._duration <= other.get$_duration();
    },
    $ge: function(_, other) {
      return this._duration >= other.get$_duration();
    },
    get$inMilliseconds: function() {
      return C.JSNumber_methods._tdivFast$1(this._duration, 1000);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isDuration)
        return false;
      return this._duration === other._duration;
    },
    get$hashCode: function(_) {
      return this._duration & 0x1FFFFFFF;
    },
    compareTo$1: function(_, other) {
      return C.JSNumber_methods.compareTo$1(this._duration, other.get$_duration());
    },
    toString$0: function(_) {
      var t1, t2, twoDigitMinutes, twoDigitSeconds, sixDigitUs;
      t1 = new P.Duration_toString_twoDigits();
      t2 = this._duration;
      if (t2 < 0)
        return "-" + P.Duration$(0, 0, -t2, 0, 0, 0).toString$0(0);
      twoDigitMinutes = t1.call$1(C.JSNumber_methods.remainder$1(C.JSNumber_methods._tdivFast$1(t2, 60000000), 60));
      twoDigitSeconds = t1.call$1(C.JSNumber_methods.remainder$1(C.JSNumber_methods._tdivFast$1(t2, 1000000), 60));
      sixDigitUs = new P.Duration_toString_sixDigits().call$1(C.JSNumber_methods.remainder$1(t2, 1000000));
      return H.S(C.JSNumber_methods._tdivFast$1(t2, 3600000000)) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
    },
    abs$0: function(_) {
      return P.Duration$(0, 0, Math.abs(this._duration), 0, 0, 0);
    },
    $negate: function(_) {
      return P.Duration$(0, 0, -this._duration, 0, 0, 0);
    },
    $isDuration: true,
    static: {"^": "Duration_MICROSECONDS_PER_MILLISECOND,Duration_MILLISECONDS_PER_SECOND,Duration_SECONDS_PER_MINUTE,Duration_MINUTES_PER_HOUR,Duration_HOURS_PER_DAY,Duration_MICROSECONDS_PER_SECOND,Duration_MICROSECONDS_PER_MINUTE,Duration_MICROSECONDS_PER_HOUR,Duration_MICROSECONDS_PER_DAY,Duration_MILLISECONDS_PER_MINUTE,Duration_MILLISECONDS_PER_HOUR,Duration_MILLISECONDS_PER_DAY,Duration_SECONDS_PER_HOUR,Duration_SECONDS_PER_DAY,Duration_MINUTES_PER_DAY,Duration_ZERO", Duration$: function(days, hours, microseconds, milliseconds, minutes, seconds) {
        return new P.Duration(days * 86400000000 + hours * 3600000000 + minutes * 60000000 + seconds * 1000000 + milliseconds * 1000 + microseconds);
      }}
  },
  Duration_toString_sixDigits: {
    "^": "Closure:516;",
    call$1: function(n) {
      if (n >= 100000)
        return H.S(n);
      if (n >= 10000)
        return "0" + H.S(n);
      if (n >= 1000)
        return "00" + H.S(n);
      if (n >= 100)
        return "000" + H.S(n);
      if (n >= 10)
        return "0000" + H.S(n);
      return "00000" + H.S(n);
    },
    $isFunction: true
  },
  Duration_toString_twoDigits: {
    "^": "Closure:516;",
    call$1: function(n) {
      if (n >= 10)
        return H.S(n);
      return "0" + H.S(n);
    },
    $isFunction: true
  },
  Error: {
    "^": "Object;",
    get$stackTrace: function() {
      return new H._StackTrace(this.$thrownJsError, null);
    },
    $isError: true
  },
  NullThrownError: {
    "^": "Error;",
    toString$0: function(_) {
      return "Throw of null.";
    }
  },
  ArgumentError: {
    "^": "Error;message",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 != null)
        return "Illegal argument(s): " + H.S(t1);
      return "Illegal argument(s)";
    },
    static: {ArgumentError$: function(message) {
        return new P.ArgumentError(message);
      }}
  },
  RangeError: {
    "^": "ArgumentError;message",
    toString$0: function(_) {
      return "RangeError: " + H.S(this.message);
    },
    static: {RangeError$: function(message) {
        return new P.RangeError(message);
      }, RangeError$value: function(value) {
        return new P.RangeError("value " + H.S(value));
      }, RangeError$range: function(value, start, end) {
        return new P.RangeError("value " + H.S(value) + " not in range " + H.S(start) + ".." + H.S(end));
      }}
  },
  NoSuchMethodError: {
    "^": "Error;_core$_receiver,_memberName,_core$_arguments,_namedArguments,_existingArgumentNames",
    toString$0: function(_) {
      var t1, t2, t3, t4, t5, str;
      t1 = {};
      t1.sb_0 = P.StringBuffer$("");
      t1.i_1 = 0;
      t2 = this._core$_arguments;
      if (t2 != null) {
        t3 = J.getInterceptor$asx(t2);
        t4 = 0;
        while (true) {
          t5 = t3.get$length(t2);
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (!(t4 < t5))
            break;
          t4 = t1.i_1;
          if (t4 > 0) {
            t5 = t1.sb_0;
            t5._contents += ", ";
          }
          t5 = t1.sb_0;
          str = P.Error_safeToString(t3.$index(t2, t4));
          t5._contents += typeof str === "string" ? str : H.S(str);
          t4 = ++t1.i_1;
        }
      }
      t2 = this._namedArguments;
      if (t2 != null)
        t2.forEach$1(0, new P.NoSuchMethodError_toString_closure(t1));
      return "NoSuchMethodError : method not found: '" + J.toString$0(this._memberName) + "'\nReceiver: " + H.S(P.Error_safeToString(this._core$_receiver)) + "\nArguments: [" + t1.sb_0._contents + "]";
    },
    static: {NoSuchMethodError$: function(receiver, memberName, positionalArguments, namedArguments, existingArgumentNames) {
        return new P.NoSuchMethodError(receiver, memberName, positionalArguments, namedArguments, existingArgumentNames);
      }}
  },
  UnsupportedError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    static: {UnsupportedError$: function(message) {
        return new P.UnsupportedError(message);
      }}
  },
  UnimplementedError: {
    "^": "Error;message",
    toString$0: function(_) {
      var t1 = this.message;
      return t1 != null ? "UnimplementedError: " + H.S(t1) : "UnimplementedError";
    },
    $isError: true,
    static: {UnimplementedError$: function(message) {
        return new P.UnimplementedError(message);
      }}
  },
  StateError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Bad state: " + this.message;
    },
    static: {StateError$: function(message) {
        return new P.StateError(message);
      }}
  },
  ConcurrentModificationError: {
    "^": "Error;modifiedObject",
    toString$0: function(_) {
      var t1 = this.modifiedObject;
      if (t1 == null)
        return "Concurrent modification during iteration.";
      return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(t1)) + ".";
    },
    static: {ConcurrentModificationError$: function(modifiedObject) {
        return new P.ConcurrentModificationError(modifiedObject);
      }}
  },
  OutOfMemoryError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Out of Memory";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: true
  },
  StackOverflowError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Stack Overflow";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: true
  },
  CyclicInitializationError: {
    "^": "Error;variableName",
    toString$0: function(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    },
    static: {CyclicInitializationError$: function(variableName) {
        return new P.CyclicInitializationError(variableName);
      }}
  },
  _ExceptionImplementation: {
    "^": "Object;message",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 == null)
        return "Exception";
      return "Exception: " + H.S(t1);
    }
  },
  FormatException: {
    "^": "Object;message,source>,offset>",
    offset$2: function($receiver, arg0, arg1) {
      return this.offset.call$2(arg0, arg1);
    },
    toString$0: function(_) {
      var t1, report, offset, source, lineNum, lineStart, lastWasCR, i, $char, lineEnd, t2, end, start, prefix, postfix, slice;
      t1 = this.message;
      report = t1 != null && "" !== t1 ? "FormatException: " + H.S(t1) : "FormatException";
      offset = this.offset;
      source = this.source;
      if (typeof source !== "string")
        return offset != null ? report + (" (at offset " + H.S(offset) + ")") : report;
      if (offset != null) {
        t1 = J.getInterceptor$n(offset);
        t1 = t1.$lt(offset, 0) || t1.$gt(offset, J.get$length$asx(source));
      } else
        t1 = false;
      if (t1)
        offset = null;
      if (offset == null) {
        t1 = J.getInterceptor$asx(source);
        if (J.$gt$n(t1.get$length(source), 78))
          source = t1.substring$2(source, 0, 75) + "...";
        return report + "\n" + H.S(source);
      }
      if (typeof offset !== "number")
        return H.iae(offset);
      t1 = J.getInterceptor$asx(source);
      lineNum = 1;
      lineStart = 0;
      lastWasCR = null;
      i = 0;
      for (; i < offset; ++i) {
        $char = t1.codeUnitAt$1(source, i);
        if ($char === 10) {
          if (lineStart !== i || lastWasCR !== true)
            ++lineNum;
          lineStart = i + 1;
          lastWasCR = false;
        } else if ($char === 13) {
          ++lineNum;
          lineStart = i + 1;
          lastWasCR = true;
        }
      }
      report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + H.S(offset - lineStart + 1) + ")\n") : report + (" (at character " + H.S(offset + 1) + ")\n");
      lineEnd = t1.get$length(source);
      i = offset;
      while (true) {
        t2 = t1.get$length(source);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        $char = t1.codeUnitAt$1(source, i);
        if ($char === 10 || $char === 13) {
          lineEnd = i;
          break;
        }
        ++i;
      }
      t2 = J.getInterceptor$n(lineEnd);
      if (J.$gt$n(t2.$sub(lineEnd, lineStart), 78))
        if (offset - lineStart < 75) {
          end = lineStart + 75;
          start = lineStart;
          prefix = "";
          postfix = "...";
        } else {
          if (J.$lt$n(t2.$sub(lineEnd, offset), 75)) {
            start = t2.$sub(lineEnd, 75);
            end = lineEnd;
            postfix = "";
          } else {
            start = offset - 36;
            end = offset + 36;
            postfix = "...";
          }
          prefix = "...";
        }
      else {
        end = lineEnd;
        start = lineStart;
        prefix = "";
        postfix = "";
      }
      slice = t1.substring$2(source, start, end);
      if (typeof start !== "number")
        return H.iae(start);
      return report + prefix + slice + postfix + "\n" + C.JSString_methods.$mul(" ", offset - start + prefix.length) + "^\n";
    },
    static: {FormatException$: function(message, source, offset) {
        return new P.FormatException(message, source, offset);
      }}
  },
  IntegerDivisionByZeroException: {
    "^": "Object;",
    toString$0: function(_) {
      return "IntegerDivisionByZeroException";
    },
    static: {IntegerDivisionByZeroException$: function() {
        return new P.IntegerDivisionByZeroException();
      }}
  },
  Expando: {
    "^": "Object;name>",
    toString$0: function(_) {
      return "Expando:" + H.S(this.name);
    },
    $index: function(_, object) {
      var values = H.Primitives_getProperty(object, "expando$values");
      return values == null ? null : H.Primitives_getProperty(values, this._getKey$0());
    },
    $indexSet: function(_, object, value) {
      var values = H.Primitives_getProperty(object, "expando$values");
      if (values == null) {
        values = new P.Object();
        H.Primitives_setProperty(object, "expando$values", values);
      }
      H.Primitives_setProperty(values, this._getKey$0(), value);
    },
    _getKey$0: function() {
      var key, t1;
      key = H.Primitives_getProperty(this, "expando$key");
      if (key == null) {
        t1 = $.Expando__keyCount;
        $.Expando__keyCount = t1 + 1;
        key = "expando$key$" + t1;
        H.Primitives_setProperty(this, "expando$key", key);
      }
      return key;
    },
    static: {"^": "Expando__KEY_PROPERTY_NAME,Expando__EXPANDO_PROPERTY_NAME,Expando__keyCount", Expando$: function($name, $T) {
        return H.setRuntimeTypeInfo(new P.Expando($name), [$T]);
      }}
  },
  Function: {
    "^": "Object;",
    $isFunction: true
  },
  $int: {
    "^": "num;",
    $is$int: true
  },
  "+int": 0,
  Invocation: {
    "^": "Object;"
  },
  Iterable: {
    "^": "Object;"
  },
  Iterator: {
    "^": "Object;"
  },
  List: {
    "^": "Object;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  "+List": 0,
  Map: {
    "^": "Object;",
    $isMap: true,
    $asMap: null
  },
  Null: {
    "^": "Object;",
    toString$0: function(_) {
      return "null";
    }
  },
  "+Null": 0,
  num: {
    "^": "Object;",
    $isnum: true
  },
  "+num": 0,
  Object: {
    "^": ";",
    $eq: [function(_, other) {
      return this === other;
    }, "call$1", "get$==", 2, 0, 979, 1703, [], "=="],
    get$hashCode: [function(_) {
      return H.Primitives_objectHashCode(this);
    }, null, null, 1, 0, 367, "hashCode"],
    toString$0: [function(_) {
      return H.Primitives_objectToString(this);
    }, "call$0", "get$toString", 0, 0, 782, "toString"],
    noSuchMethod$1: [function(_, invocation) {
      throw H.wrapException(P.NoSuchMethodError$(this, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments(), null));
    }, "call$1", "get$noSuchMethod", 2, 0, 1704, 1676, [], "noSuchMethod"],
    get$runtimeType: [function(_) {
      return new H.TypeImpl(H.getRuntimeTypeString(this), null);
    }, null, null, 1, 0, 12, "runtimeType"],
    $isObject: true
  },
  Pattern: {
    "^": "Object;"
  },
  Match: {
    "^": "Object;",
    $isMatch: true
  },
  StackTrace: {
    "^": "Object;"
  },
  String: {
    "^": "Object;",
    $isString: true
  },
  "+String": 0,
  StringBuffer: {
    "^": "Object;_contents<",
    get$length: function(_) {
      return this._contents.length;
    },
    get$isEmpty: function(_) {
      return this._contents.length === 0;
    },
    write$1: function(obj) {
      this._contents += typeof obj === "string" ? obj : H.S(obj);
    },
    writeAll$2: function(objects, separator) {
      var iterator, str;
      iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return;
      if (separator.length === 0) {
        do {
          str = iterator.get$current();
          this._contents += typeof str === "string" ? str : H.S(str);
        } while (iterator.moveNext$0());
      } else {
        this.write$1(iterator.get$current());
        for (; iterator.moveNext$0();) {
          this._contents += separator;
          str = iterator.get$current();
          this._contents += typeof str === "string" ? str : H.S(str);
        }
      }
    },
    clear$0: function(_) {
      this._contents = "";
    },
    toString$0: function(_) {
      return this._contents;
    },
    StringBuffer$1: function($content) {
      this._contents = $content;
    },
    static: {StringBuffer$: function($content) {
        var t1 = new P.StringBuffer("");
        t1.StringBuffer$1($content);
        return t1;
      }}
  },
  Symbol0: {
    "^": "Object;",
    $isSymbol0: true
  },
  Type: {
    "^": "Object;",
    $isType: true
  },
  Uri: {
    "^": "Object;_host,_port,_path,scheme,_userInfo,_query,_fragment,_pathSegments,_queryParameters",
    get$host: function(_) {
      var t1 = this._host;
      if (t1 == null)
        return "";
      if (J.getInterceptor$s(t1).startsWith$1(t1, "["))
        return C.JSString_methods.substring$2(t1, 1, t1.length - 1);
      return t1;
    },
    get$port: function(_) {
      var t1 = this._port;
      if (t1 == null)
        return P.Uri__defaultPort(this.scheme);
      return t1;
    },
    toString$0: function(_) {
      var sb, t1, t2, t3;
      sb = P.StringBuffer$("");
      t1 = this.scheme;
      if ("" !== t1) {
        sb.write$1(t1);
        sb.write$1(":");
      }
      t2 = this._host;
      t3 = t2 == null;
      if (!t3 || C.JSString_methods.startsWith$1(this._path, "//") || t1 === "file") {
        sb.write$1("//");
        t1 = this._userInfo;
        if (t1.length !== 0) {
          sb.write$1(t1);
          sb.write$1("@");
        }
        if (!t3)
          sb.write$1(t2);
        t1 = this._port;
        if (t1 != null) {
          sb.write$1(":");
          sb.write$1(t1);
        }
      }
      sb.write$1(this._path);
      t1 = this._query;
      if (t1 != null) {
        sb.write$1("?");
        sb.write$1(t1);
      }
      t1 = this._fragment;
      if (t1 != null) {
        sb.write$1("#");
        sb.write$1(t1);
      }
      return sb._contents;
    },
    $eq: function(_, other) {
      var t1, t2, t3, t4;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isUri)
        return false;
      if (this.scheme === other.scheme)
        if (this._host != null === (other._host != null))
          if (this._userInfo === other._userInfo) {
            t2 = this.get$host(this);
            t3 = t1.get$host(other);
            if (t2 == null ? t3 == null : t2 === t3) {
              t2 = this.get$port(this);
              t1 = t1.get$port(other);
              if (t2 == null ? t1 == null : t2 === t1)
                if (this._path === other._path) {
                  t1 = this._query;
                  t2 = t1 == null;
                  t3 = other._query;
                  t4 = t3 == null;
                  if (!t2 === !t4) {
                    if (t2)
                      t1 = "";
                    if (t1 == null ? (t4 ? "" : t3) == null : t1 === (t4 ? "" : t3)) {
                      t1 = this._fragment;
                      t2 = t1 == null;
                      t3 = other._fragment;
                      t4 = t3 == null;
                      if (!t2 === !t4) {
                        if (t2)
                          t1 = "";
                        t1 = t1 == null ? (t4 ? "" : t3) == null : t1 === (t4 ? "" : t3);
                      } else
                        t1 = false;
                    } else
                      t1 = false;
                  } else
                    t1 = false;
                } else
                  t1 = false;
              else
                t1 = false;
            } else
              t1 = false;
          } else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1, t2, t3, t4, t5;
      t1 = new P.Uri_hashCode_combine();
      t2 = this.get$host(this);
      t3 = this.get$port(this);
      t4 = this._query;
      if (t4 == null)
        t4 = "";
      t5 = this._fragment;
      return t1.call$2(this.scheme, t1.call$2(this._userInfo, t1.call$2(t2, t1.call$2(t3, t1.call$2(this._path, t1.call$2(t4, t1.call$2(t5 == null ? "" : t5, 1)))))));
    },
    $isUri: true,
    static: {"^": "Uri__SPACE,Uri__DOUBLE_QUOTE,Uri__NUMBER_SIGN,Uri__PERCENT,Uri__ASTERISK,Uri__PLUS,Uri__SLASH,Uri__ZERO,Uri__NINE,Uri__COLON,Uri__LESS,Uri__GREATER,Uri__QUESTION,Uri__AT_SIGN,Uri__UPPER_CASE_A,Uri__UPPER_CASE_F,Uri__UPPER_CASE_Z,Uri__LEFT_BRACKET,Uri__BACKSLASH,Uri__RIGHT_BRACKET,Uri__LOWER_CASE_A,Uri__LOWER_CASE_F,Uri__LOWER_CASE_Z,Uri__BAR,Uri__unreservedTable,Uri__unreserved2396Table,Uri__encodeFullTable,Uri__schemeTable,Uri__schemeLowerTable,Uri__subDelimitersTable,Uri__genDelimitersTable,Uri__userinfoTable,Uri__regNameTable,Uri__pathCharTable,Uri__pathCharOrSlashTable,Uri__queryCharTable", Uri__defaultPort: function(scheme) {
        if (scheme === "http")
          return 80;
        if (scheme === "https")
          return 443;
        return 0;
      }, Uri_parse: function(uri) {
        var t1, pathStart, state, t2, i, t3, $char, index, t4, path, numberSignIndex, t5, query, fragment;
        t1 = {};
        t1.scheme_0 = "";
        t1.userinfo_1 = "";
        t1.host_2 = null;
        t1.port_3 = null;
        t1.index_4 = 0;
        t1.char_5 = -1;
        t2 = J.getInterceptor$asx(uri);
        i = 0;
        while (true) {
          t3 = t2.get$length(uri);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3)) {
            pathStart = 0;
            state = 0;
            break;
          }
          $char = t2.codeUnitAt$1(uri, i);
          t1.char_5 = $char;
          if ($char === 63 || $char === 35) {
            pathStart = 0;
            state = 0;
            break;
          }
          if ($char === 47) {
            state = i === 0 ? 2 : 1;
            pathStart = 0;
            break;
          }
          if ($char === 58) {
            if (i === 0)
              P.Uri__fail(uri, 0, "Invalid empty scheme");
            t1.scheme_0 = P.Uri__makeScheme(uri, i);
            ++i;
            if (i === t2.get$length(uri)) {
              t1.char_5 = -1;
              state = 0;
            } else {
              $char = t2.codeUnitAt$1(uri, i);
              t1.char_5 = $char;
              if ($char === 63 || $char === 35)
                state = 0;
              else
                state = $char === 47 ? 2 : 1;
            }
            pathStart = i;
            break;
          }
          ++i;
          t1.char_5 = -1;
        }
        t1.index_4 = i;
        if (state === 2) {
          index = i + 1;
          t1.index_4 = index;
          if (index === t2.get$length(uri)) {
            t1.char_5 = -1;
            state = 0;
          } else {
            $char = t2.codeUnitAt$1(uri, t1.index_4);
            t1.char_5 = $char;
            if ($char === 47) {
              t1.index_4 = J.$add$ns(t1.index_4, 1);
              new P.Uri_parse_parseAuth(t1, uri, -1).call$0();
              pathStart = t1.index_4;
            }
            t3 = t1.char_5;
            state = t3 === 63 || t3 === 35 || t3 === -1 ? 0 : 1;
          }
        }
        if (state === 1)
          for (; index = J.$add$ns(t1.index_4, 1), t1.index_4 = index, J.$lt$n(index, t2.get$length(uri));) {
            $char = t2.codeUnitAt$1(uri, t1.index_4);
            t1.char_5 = $char;
            if ($char === 63 || $char === 35)
              break;
            t1.char_5 = -1;
          }
        t3 = t1.scheme_0;
        t4 = t1.host_2;
        path = P.Uri__makePath(uri, pathStart, t1.index_4, null, t4 != null, t3 === "file");
        t3 = t1.char_5;
        if (t3 === 63) {
          numberSignIndex = t2.indexOf$2(uri, "#", J.$add$ns(t1.index_4, 1));
          t3 = J.getInterceptor$n(numberSignIndex);
          t4 = t3.$lt(numberSignIndex, 0);
          t5 = t1.index_4;
          if (t4) {
            query = P.Uri__makeQuery(uri, J.$add$ns(t5, 1), t2.get$length(uri), null);
            fragment = null;
          } else {
            query = P.Uri__makeQuery(uri, J.$add$ns(t5, 1), numberSignIndex, null);
            fragment = P.Uri__makeFragment(uri, t3.$add(numberSignIndex, 1), t2.get$length(uri));
          }
        } else {
          fragment = t3 === 35 ? P.Uri__makeFragment(uri, J.$add$ns(t1.index_4, 1), t2.get$length(uri)) : null;
          query = null;
        }
        t2 = t1.scheme_0;
        t3 = t1.userinfo_1;
        return new P.Uri(t1.host_2, t1.port_3, path, t2, t3, query, fragment, null, null);
      }, Uri__fail: function(uri, index, message) {
        throw H.wrapException(P.FormatException$(message, uri, index));
      }, Uri__makePort: function(port, scheme) {
        if (port != null && port === P.Uri__defaultPort(scheme))
          return;
        return port;
      }, Uri__makeHost: function(host, start, end, strictIPv6) {
        var t1, t2, t3, i;
        if (host == null)
          return;
        t1 = J.getInterceptor(start);
        if (t1.$eq(start, end))
          return "";
        t2 = J.getInterceptor$s(host);
        if (t2.codeUnitAt$1(host, start) === 91) {
          t3 = J.getInterceptor$n(end);
          if (t2.codeUnitAt$1(host, t3.$sub(end, 1)) !== 93)
            P.Uri__fail(host, start, "Missing end `]` to match `[` in host");
          P.Uri_parseIPv6Address(host, t1.$add(start, 1), t3.$sub(end, 1));
          return t2.substring$2(host, start, end).toLowerCase();
        }
        if (!strictIPv6)
          for (i = start; t1 = J.getInterceptor$n(i), t1.$lt(i, end); i = t1.$add(i, 1))
            if (t2.codeUnitAt$1(host, i) === 58) {
              P.Uri_parseIPv6Address(host, start, end);
              return "[" + H.S(host) + "]";
            }
        return P.Uri__normalizeRegName(host, start, end);
      }, Uri__normalizeRegName: function(host, start, end) {
        var t1, index, sectionStart, buffer, isNormalized, t2, $char, replacement, t3, slice, sourceLength, tail;
        for (t1 = J.getInterceptor$s(host), index = start, sectionStart = index, buffer = null, isNormalized = true; t2 = J.getInterceptor$n(index), t2.$lt(index, end);) {
          $char = t1.codeUnitAt$1(host, index);
          if ($char === 37) {
            replacement = P.Uri__normalizeEscape(host, index, true);
            t3 = replacement == null;
            if (t3 && isNormalized) {
              index = t2.$add(index, 3);
              continue;
            }
            if (buffer == null) {
              buffer = new P.StringBuffer("");
              buffer._contents = "";
            }
            slice = t1.substring$2(host, sectionStart, index);
            if (!isNormalized)
              slice = slice.toLowerCase();
            buffer.toString;
            buffer._contents = buffer._contents + slice;
            if (t3) {
              replacement = t1.substring$2(host, index, t2.$add(index, 3));
              sourceLength = 3;
            } else if (replacement === "%") {
              replacement = "%25";
              sourceLength = 1;
            } else
              sourceLength = 3;
            buffer._contents += replacement;
            index = t2.$add(index, sourceLength);
            sectionStart = index;
            isNormalized = true;
          } else {
            if ($char < 127) {
              t3 = $char >>> 4;
              if (t3 >= 8)
                return H.ioore(C.List_qNA, t3);
              t3 = (C.List_qNA[t3] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
            } else
              t3 = false;
            if (t3) {
              if (isNormalized && 65 <= $char && 90 >= $char) {
                if (buffer == null) {
                  buffer = new P.StringBuffer("");
                  buffer._contents = "";
                }
                if (J.$lt$n(sectionStart, index)) {
                  t3 = t1.substring$2(host, sectionStart, index);
                  buffer.toString;
                  buffer._contents = buffer._contents + t3;
                  sectionStart = index;
                }
                isNormalized = false;
              }
              index = t2.$add(index, 1);
            } else {
              if ($char <= 93) {
                t3 = $char >>> 4;
                if (t3 >= 8)
                  return H.ioore(C.List_2Vk, t3);
                t3 = (C.List_2Vk[t3] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
              } else
                t3 = false;
              if (t3)
                P.Uri__fail(host, index, "Invalid character");
              else {
                if (($char & 64512) === 55296 && J.$lt$n(t2.$add(index, 1), end)) {
                  tail = t1.codeUnitAt$1(host, t2.$add(index, 1));
                  if ((tail & 64512) === 56320) {
                    $char = (65536 | ($char & 1023) << 10 | tail & 1023) >>> 0;
                    sourceLength = 2;
                  } else
                    sourceLength = 1;
                } else
                  sourceLength = 1;
                if (buffer == null) {
                  buffer = new P.StringBuffer("");
                  buffer._contents = "";
                }
                slice = t1.substring$2(host, sectionStart, index);
                if (!isNormalized)
                  slice = slice.toLowerCase();
                buffer.toString;
                buffer._contents = buffer._contents + slice;
                t3 = P.Uri__escapeChar($char);
                buffer._contents += t3;
                index = t2.$add(index, sourceLength);
                sectionStart = index;
              }
            }
          }
        }
        if (buffer == null)
          return t1.substring$2(host, start, end);
        if (J.$lt$n(sectionStart, end)) {
          slice = t1.substring$2(host, sectionStart, end);
          buffer.write$1(!isNormalized ? slice.toLowerCase() : slice);
        }
        return buffer.toString$0(0);
      }, Uri__makeScheme: function(scheme, end) {
        var t1, $char, allLowercase, t2, t3, i, codeUnit, t4;
        if (J.$eq(end, 0))
          return "";
        t1 = J.getInterceptor$s(scheme);
        $char = t1.codeUnitAt$1(scheme, 0);
        allLowercase = $char >= 97;
        if (!(allLowercase && $char <= 122))
          t2 = $char >= 65 && $char <= 90;
        else
          t2 = true;
        if (!t2)
          P.Uri__fail(scheme, 0, "Scheme not starting with alphabetic character");
        if (typeof end !== "number")
          return H.iae(end);
        t2 = 97 <= $char;
        t3 = 122 >= $char;
        i = 0;
        for (; i < end; ++i) {
          codeUnit = t1.codeUnitAt$1(scheme, i);
          if (codeUnit < 128) {
            t4 = codeUnit >>> 4;
            if (t4 >= 8)
              return H.ioore(C.List_JYB, t4);
            t4 = (C.List_JYB[t4] & C.JSInt_methods._shlPositive$1(1, codeUnit & 15)) !== 0;
          } else
            t4 = false;
          if (!t4)
            P.Uri__fail(scheme, i, "Illegal scheme character");
          if (t2 && t3)
            allLowercase = false;
        }
        scheme = t1.substring$2(scheme, 0, end);
        return !allLowercase ? scheme.toLowerCase() : scheme;
      }, Uri__makeUserInfo: function(userInfo, start, end) {
        if (userInfo == null)
          return "";
        return P.Uri__normalize(userInfo, start, end, C.List_gRj);
      }, Uri__makePath: function(path, start, end, pathSegments, ensureLeadingSlash, isFile) {
        var t1, result;
        t1 = path == null;
        if (t1 && true)
          return isFile ? "/" : "";
        t1 = !t1;
        if (t1)
          ;
        result = t1 ? P.Uri__normalize(path, start, end, C.List_qg4) : C.JSNull_methods.map$1(pathSegments, new P.Uri__makePath_closure()).join$1(0, "/");
        if (result.length === 0) {
          if (isFile)
            return "/";
        } else if ((isFile || ensureLeadingSlash) && C.JSString_methods.codeUnitAt$1(result, 0) !== 47)
          return "/" + result;
        return result;
      }, Uri__makeQuery: function(query, start, end, queryParameters) {
        var t1, t2, result;
        t1 = {};
        t2 = query == null;
        if (t2 && true)
          return;
        t2 = !t2;
        if (t2)
          ;
        if (t2)
          return P.Uri__normalize(query, start, end, C.List_CVk);
        result = P.StringBuffer$("");
        t1.first_0 = true;
        C.JSNull_methods.forEach$1(queryParameters, new P.Uri__makeQuery_closure(t1, result));
        return result._contents;
      }, Uri__makeFragment: function(fragment, start, end) {
        if (fragment == null)
          return;
        return P.Uri__normalize(fragment, start, end, C.List_CVk);
      }, Uri__isHexDigit: function($char) {
        if (57 >= $char)
          return 48 <= $char;
        $char |= 32;
        return 97 <= $char && 102 >= $char;
      }, Uri__hexValue: function($char) {
        if (57 >= $char)
          return $char - 48;
        return ($char | 32) - 87;
      }, Uri__normalizeEscape: function(source, index, lowerCase) {
        var t1, t2, firstDigit, secondDigit, value, t3;
        t1 = J.getInterceptor$ns(index);
        t2 = J.getInterceptor$asx(source);
        if (J.$ge$n(t1.$add(index, 2), t2.get$length(source)))
          return "%";
        firstDigit = t2.codeUnitAt$1(source, t1.$add(index, 1));
        secondDigit = t2.codeUnitAt$1(source, t1.$add(index, 2));
        if (!P.Uri__isHexDigit(firstDigit) || !P.Uri__isHexDigit(secondDigit))
          return "%";
        value = P.Uri__hexValue(firstDigit) * 16 + P.Uri__hexValue(secondDigit);
        if (value < 127) {
          t3 = C.JSInt_methods._shrOtherPositive$1(value, 4);
          if (t3 >= 8)
            return H.ioore(C.List_nxB, t3);
          t3 = (C.List_nxB[t3] & C.JSInt_methods._shlPositive$1(1, value & 15)) !== 0;
        } else
          t3 = false;
        if (t3)
          return H.Primitives_stringFromCharCode(lowerCase && 65 <= value && 90 >= value ? (value | 32) >>> 0 : value);
        if (firstDigit >= 97 || secondDigit >= 97)
          return t2.substring$2(source, index, t1.$add(index, 3)).toUpperCase();
        return;
      }, Uri__escapeChar: function($char) {
        var codeUnits, t1, flag, encodedBytes, index, $byte, t2, t3;
        if ($char < 128) {
          codeUnits = Array(3);
          codeUnits.fixed$length = init;
          codeUnits[0] = 37;
          t1 = $char >>> 4;
          if (t1 >= 16)
            H.throwExpression(P.RangeError$value(t1));
          codeUnits[1] = "0123456789ABCDEF".charCodeAt(t1);
          codeUnits[2] = "0123456789ABCDEF".charCodeAt($char & 15);
        } else {
          if ($char > 2047)
            if ($char > 65535) {
              flag = 240;
              encodedBytes = 4;
            } else {
              flag = 224;
              encodedBytes = 3;
            }
          else {
            flag = 192;
            encodedBytes = 2;
          }
          t1 = 3 * encodedBytes;
          codeUnits = Array(t1);
          codeUnits.fixed$length = init;
          for (index = 0; --encodedBytes, encodedBytes >= 0; flag = 128) {
            $byte = C.JSInt_methods._shrReceiverPositive$1($char, 6 * encodedBytes) & 63 | flag;
            if (index >= t1)
              return H.ioore(codeUnits, index);
            codeUnits[index] = 37;
            t2 = index + 1;
            t3 = $byte >>> 4;
            if (t3 >= 16)
              H.throwExpression(P.RangeError$value(t3));
            t3 = "0123456789ABCDEF".charCodeAt(t3);
            if (t2 >= t1)
              return H.ioore(codeUnits, t2);
            codeUnits[t2] = t3;
            t3 = index + 2;
            t2 = "0123456789ABCDEF".charCodeAt($byte & 15);
            if (t3 >= t1)
              return H.ioore(codeUnits, t3);
            codeUnits[t3] = t2;
            index += 3;
          }
        }
        return H.Primitives_stringFromCharCodes(codeUnits);
      }, Uri__normalize: function(component, start, end, charTable) {
        var t1, index, sectionStart, buffer, t2, $char, t3, replacement, sourceLength, tail;
        for (t1 = J.getInterceptor$s(component), index = start, sectionStart = index, buffer = null; t2 = J.getInterceptor$n(index), t2.$lt(index, end);) {
          $char = t1.codeUnitAt$1(component, index);
          if ($char < 127) {
            t3 = $char >>> 4;
            if (t3 >= 8)
              return H.ioore(charTable, t3);
            t3 = (charTable[t3] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
          } else
            t3 = false;
          if (t3)
            index = t2.$add(index, 1);
          else {
            if ($char === 37) {
              replacement = P.Uri__normalizeEscape(component, index, false);
              if (replacement == null) {
                index = t2.$add(index, 3);
                continue;
              }
              if ("%" === replacement) {
                replacement = "%25";
                sourceLength = 1;
              } else
                sourceLength = 3;
            } else {
              if ($char <= 93) {
                t3 = $char >>> 4;
                if (t3 >= 8)
                  return H.ioore(C.List_2Vk, t3);
                t3 = (C.List_2Vk[t3] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
              } else
                t3 = false;
              if (t3) {
                P.Uri__fail(component, index, "Invalid character");
                replacement = null;
                sourceLength = null;
              } else {
                if (($char & 64512) === 55296)
                  if (J.$lt$n(t2.$add(index, 1), end)) {
                    tail = t1.codeUnitAt$1(component, t2.$add(index, 1));
                    if ((tail & 64512) === 56320) {
                      $char = (65536 | ($char & 1023) << 10 | tail & 1023) >>> 0;
                      sourceLength = 2;
                    } else
                      sourceLength = 1;
                  } else
                    sourceLength = 1;
                else
                  sourceLength = 1;
                replacement = P.Uri__escapeChar($char);
              }
            }
            if (buffer == null) {
              buffer = new P.StringBuffer("");
              buffer._contents = "";
            }
            t3 = t1.substring$2(component, sectionStart, index);
            buffer.toString;
            buffer._contents = buffer._contents + t3;
            buffer._contents += typeof replacement === "string" ? replacement : H.S(replacement);
            index = t2.$add(index, sourceLength);
            sectionStart = index;
          }
        }
        if (buffer == null)
          return t1.substring$2(component, start, end);
        if (J.$lt$n(sectionStart, end))
          buffer.write$1(t1.substring$2(component, sectionStart, end));
        return buffer.toString$0(0);
      }, Uri_parseIPv4Address: function(host) {
        var t1, bytes;
        t1 = new P.Uri_parseIPv4Address_error();
        bytes = host.split(".");
        if (bytes.length !== 4)
          t1.call$1("IPv4 address should contain exactly 4 parts");
        return H.setRuntimeTypeInfo(new H.MappedListIterable(bytes, new P.Uri_parseIPv4Address_closure(t1)), [null, null]).toList$0(0);
      }, Uri_parseIPv6Address: function(host, start, end) {
        var error, parseHex, parts, partStart, last, i, wildcardSeen, t1, atEnd, isLastWildcard, exception, t2, bytes, index, value, wildCardLength, j;
        if (end == null)
          end = J.get$length$asx(host);
        error = new P.Uri_parseIPv6Address_error(host);
        parseHex = new P.Uri_parseIPv6Address_parseHex(host, error);
        if (J.$lt$n(J.get$length$asx(host), 2))
          error.call$1("address is too short");
        parts = [];
        partStart = start;
        for (i = start, wildcardSeen = false; t1 = J.getInterceptor$n(i), t1.$lt(i, end); i = J.$add$ns(i, 1))
          if (J.codeUnitAt$1$s(host, i) === 58) {
            if (t1.$eq(i, start)) {
              i = t1.$add(i, 1);
              if (J.codeUnitAt$1$s(host, i) !== 58)
                error.call$2("invalid start colon.", i);
              partStart = i;
            }
            t1 = J.getInterceptor(i);
            if (t1.$eq(i, partStart)) {
              if (wildcardSeen)
                error.call$2("only one wildcard `::` is allowed", i);
              J.add$1$ax(parts, -1);
              wildcardSeen = true;
            } else
              J.add$1$ax(parts, parseHex.call$2(partStart, i));
            partStart = t1.$add(i, 1);
          }
        if (J.get$length$asx(parts) === 0)
          error.call$1("too few parts");
        atEnd = J.$eq(partStart, end);
        isLastWildcard = J.$eq(J.get$last$ax(parts), -1);
        if (atEnd && !isLastWildcard)
          error.call$2("expected a part after last `:`", end);
        if (!atEnd)
          try {
            J.add$1$ax(parts, parseHex.call$2(partStart, end));
          } catch (exception) {
            H.unwrapException(exception);
            try {
              last = P.Uri_parseIPv4Address(J.substring$2$s(host, partStart, end));
              t1 = J.$shl$n(J.$index$asx(last, 0), 8);
              t2 = J.$index$asx(last, 1);
              if (typeof t2 !== "number")
                return H.iae(t2);
              J.add$1$ax(parts, (t1 | t2) >>> 0);
              t2 = J.$shl$n(J.$index$asx(last, 2), 8);
              t1 = J.$index$asx(last, 3);
              if (typeof t1 !== "number")
                return H.iae(t1);
              J.add$1$ax(parts, (t2 | t1) >>> 0);
            } catch (exception) {
              H.unwrapException(exception);
              error.call$2("invalid end of IPv6 address.", partStart);
            }

          }

        if (wildcardSeen) {
          if (J.get$length$asx(parts) > 7)
            error.call$1("an address with a wildcard must have less than 7 parts");
        } else if (J.get$length$asx(parts) !== 8)
          error.call$1("an address without a wildcard must contain exactly 8 parts");
        bytes = Array(16);
        bytes.$builtinTypeInfo = [P.$int];
        i = 0;
        index = 0;
        while (true) {
          t1 = J.get$length$asx(parts);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          value = J.$index$asx(parts, i);
          t1 = J.getInterceptor(value);
          if (t1.$eq(value, -1)) {
            wildCardLength = 9 - J.get$length$asx(parts);
            for (j = 0; j < wildCardLength; ++j) {
              if (index < 0 || index >= 16)
                return H.ioore(bytes, index);
              bytes[index] = 0;
              t1 = index + 1;
              if (t1 >= 16)
                return H.ioore(bytes, t1);
              bytes[t1] = 0;
              index += 2;
            }
          } else {
            t2 = t1.$shr(value, 8);
            if (index < 0 || index >= 16)
              return H.ioore(bytes, index);
            bytes[index] = t2;
            t2 = index + 1;
            t1 = t1.$and(value, 255);
            if (t2 >= 16)
              return H.ioore(bytes, t2);
            bytes[t2] = t1;
            index += 2;
          }
          ++i;
        }
        return bytes;
      }, Uri__uriEncode: function(canonicalTable, text, encoding, spaceToPlus) {
        var t1, result, bytes, i, $byte, t2, t3;
        t1 = new P.Uri__uriEncode_byteToHex();
        result = P.StringBuffer$("");
        bytes = encoding.get$encoder().convert$1(text);
        for (i = 0; i < bytes.length; ++i) {
          $byte = bytes[i];
          t2 = J.getInterceptor$n($byte);
          if (t2.$lt($byte, 128)) {
            t3 = t2.$shr($byte, 4);
            if (t3 >= 8)
              return H.ioore(canonicalTable, t3);
            t3 = (canonicalTable[t3] & C.JSInt_methods._shlPositive$1(1, t2.$and($byte, 15))) !== 0;
          } else
            t3 = false;
          if (t3) {
            t2 = H.Primitives_stringFromCharCode($byte);
            result._contents += t2;
          } else if (spaceToPlus && t2.$eq($byte, 32)) {
            t2 = H.Primitives_stringFromCharCode(43);
            result._contents += t2;
          } else {
            t2 = H.Primitives_stringFromCharCode(37);
            result._contents += t2;
            t1.call$2($byte, result);
          }
        }
        return result._contents;
      }, Uri__hexCharPairToByte: function(s, pos) {
        var t1, $byte, i, t2, charCode;
        for (t1 = s.length, $byte = 0, i = 0; i < 2; ++i) {
          t2 = pos + i;
          if (t2 >= t1)
            H.throwExpression(P.RangeError$value(t2));
          charCode = s.charCodeAt(t2);
          if (48 <= charCode && charCode <= 57)
            $byte = $byte * 16 + charCode - 48;
          else {
            charCode |= 32;
            if (97 <= charCode && charCode <= 102)
              $byte = $byte * 16 + charCode - 87;
            else
              throw H.wrapException(P.ArgumentError$("Invalid URL encoding"));
          }
        }
        return $byte;
      }, Uri__uriDecode: function(text, encoding, plusToSpace) {
        var t1, simple, i, codeUnit, bytes, allowMalformed;
        t1 = text.length;
        simple = true;
        i = 0;
        while (true) {
          if (!(i < t1 && simple))
            break;
          if (i >= t1)
            H.throwExpression(P.RangeError$value(i));
          codeUnit = text.charCodeAt(i);
          simple = codeUnit !== 37 && codeUnit !== 43;
          ++i;
        }
        if (simple)
          if (encoding === C.Utf8Codec_false || false)
            return text;
          else
            bytes = new J._CodeUnits(text);
        else {
          bytes = [];
          for (i = 0; i < t1; ++i) {
            if (i >= t1)
              H.throwExpression(P.RangeError$value(i));
            codeUnit = text.charCodeAt(i);
            if (codeUnit > 127)
              throw H.wrapException(P.ArgumentError$("Illegal percent encoding in URI"));
            if (codeUnit === 37) {
              if (i + 3 > t1)
                throw H.wrapException(P.ArgumentError$("Truncated URI"));
              bytes.push(P.Uri__hexCharPairToByte(text, i + 1));
              i += 2;
            } else if (plusToSpace && codeUnit === 43)
              bytes.push(32);
            else
              bytes.push(codeUnit);
          }
        }
        allowMalformed = encoding._allowMalformed;
        return new P.Utf8Decoder(allowMalformed).convert$1(bytes);
      }}
  },
  Uri_parse_isRegName: {
    "^": "Closure:368;",
    call$1: function(ch) {
      ch.$lt(0, 128);
      return false;
    },
    $isFunction: true
  },
  Uri_parse_parseAuth: {
    "^": "Closure:550;box_0,uri_1,EOI_2",
    call$0: function() {
      var t1, t2, t3, authStart, $char, lastColon, lastAt, char0, endBracket, hostEnd, t4, hostStart, i, portNumber, digit;
      t1 = this.box_0;
      t2 = this.uri_1;
      t3 = J.getInterceptor$asx(t2);
      if (J.$eq(t1.index_4, t3.get$length(t2))) {
        t1.char_5 = this.EOI_2;
        return;
      }
      authStart = t1.index_4;
      t1.char_5 = t3.codeUnitAt$1(t2, authStart);
      for ($char = this.EOI_2, lastColon = -1, lastAt = -1; J.$lt$n(t1.index_4, t3.get$length(t2));) {
        char0 = t3.codeUnitAt$1(t2, t1.index_4);
        t1.char_5 = char0;
        if (char0 === 47 || char0 === 63 || char0 === 35)
          break;
        if (char0 === 64) {
          lastAt = t1.index_4;
          lastColon = -1;
        } else if (char0 === 58)
          lastColon = t1.index_4;
        else if (char0 === 91) {
          endBracket = t3.indexOf$2(t2, "]", J.$add$ns(t1.index_4, 1));
          if (J.$eq(endBracket, -1)) {
            t1.index_4 = t3.get$length(t2);
            t1.char_5 = $char;
            lastColon = -1;
            break;
          } else
            t1.index_4 = endBracket;
          lastColon = -1;
        }
        t1.index_4 = J.$add$ns(t1.index_4, 1);
        t1.char_5 = $char;
      }
      hostEnd = t1.index_4;
      t4 = J.getInterceptor$n(lastAt);
      if (t4.$ge(lastAt, 0)) {
        t1.userinfo_1 = P.Uri__makeUserInfo(t2, authStart, lastAt);
        hostStart = t4.$add(lastAt, 1);
      } else
        hostStart = authStart;
      t4 = J.getInterceptor$n(lastColon);
      if (t4.$ge(lastColon, 0)) {
        if (J.$lt$n(t4.$add(lastColon, 1), t1.index_4))
          for (i = t4.$add(lastColon, 1), portNumber = 0; t4 = J.getInterceptor$n(i), t4.$lt(i, t1.index_4); i = t4.$add(i, 1)) {
            digit = t3.codeUnitAt$1(t2, i);
            if (48 > digit || 57 < digit)
              P.Uri__fail(t2, i, "Invalid port number");
            portNumber = portNumber * 10 + (digit - 48);
          }
        else
          portNumber = null;
        t1.port_3 = P.Uri__makePort(portNumber, t1.scheme_0);
        hostEnd = lastColon;
      }
      t1.host_2 = P.Uri__makeHost(t2, hostStart, hostEnd, true);
      if (J.$lt$n(t1.index_4, t3.get$length(t2)))
        t1.char_5 = t3.codeUnitAt$1(t2, t1.index_4);
    },
    $isFunction: true
  },
  Uri__makePath_closure: {
    "^": "Closure:63;",
    call$1: function(s) {
      return P.Uri__uriEncode(C.List_qg40, s, C.Utf8Codec_false, false);
    },
    $isFunction: true
  },
  Uri__makeQuery_closure: {
    "^": "Closure:935;box_0,result_1",
    call$2: function(key, value) {
      var t1 = this.box_0;
      if (!t1.first_0)
        this.result_1.write$1("&");
      t1.first_0 = false;
      t1 = this.result_1;
      t1.write$1(P.Uri__uriEncode(C.List_nxB, key, C.Utf8Codec_false, true));
      value.get$isEmpty(value);
      t1.write$1("=");
      t1.write$1(P.Uri__uriEncode(C.List_nxB, value, C.Utf8Codec_false, true));
    },
    $isFunction: true
  },
  Uri_hashCode_combine: {
    "^": "Closure:1034;",
    call$2: function(part, current) {
      return current * 31 + J.get$hashCode$(part) & 1073741823;
    },
    $isFunction: true
  },
  Uri_parseIPv4Address_error: {
    "^": "Closure:1705;",
    call$1: function(msg) {
      throw H.wrapException(P.FormatException$("Illegal IPv4 address, " + msg, null, null));
    },
    $isFunction: true
  },
  Uri_parseIPv4Address_closure: {
    "^": "Closure:63;error_0",
    call$1: [function(byteString) {
      var $byte, t1;
      $byte = H.Primitives_parseInt(byteString, null, null);
      t1 = J.getInterceptor$n($byte);
      if (t1.$lt($byte, 0) || t1.$gt($byte, 255))
        this.error_0.call$1("each part must be in the range of `0..255`");
      return $byte;
    }, "call$1", null, 2, 0, null, 1706, [], "call"],
    $isFunction: true
  },
  Uri_parseIPv6Address_error: {
    "^": "Closure:1707;host_0",
    call$2: function(msg, position) {
      throw H.wrapException(P.FormatException$("Illegal IPv6 address, " + msg, this.host_0, position));
    },
    call$1: function(msg) {
      return this.call$2(msg, null);
    },
    $isFunction: true
  },
  Uri_parseIPv6Address_parseHex: {
    "^": "Closure:1091;host_1,error_2",
    call$2: function(start, end) {
      var value, t1;
      if (J.$gt$n(J.$sub$n(end, start), 4))
        this.error_2.call$2("an IPv6 part can only contain a maximum of 4 hex digits", start);
      value = H.Primitives_parseInt(J.substring$2$s(this.host_1, start, end), 16, null);
      t1 = J.getInterceptor$n(value);
      if (t1.$lt(value, 0) || t1.$gt(value, 65535))
        this.error_2.call$2("each part must be in the range of `0x0..0xFFFF`", start);
      return value;
    },
    $isFunction: true
  },
  Uri__uriEncode_byteToHex: {
    "^": "Closure:935;",
    call$2: function($byte, buffer) {
      var t1 = J.getInterceptor$n($byte);
      buffer.write$1(H.Primitives_stringFromCharCode(C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", t1.$shr($byte, 4))));
      buffer.write$1(H.Primitives_stringFromCharCode(C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", t1.$and($byte, 15))));
    },
    $isFunction: true
  },
  "^": "override<"
}],
["dart.dom.html", "dart:html", , W, {
  "^": "",
  AudioElement_AudioElement: function(src) {
    return new Audio();
  },
  CanvasElement_CanvasElement: function(height, width) {
    var e = document.createElement("canvas", null);
    return e;
  },
  CssStyleDeclaration__camelCase: function(hyphenated) {
    return hyphenated.replace(/^-ms-/, "ms-").replace(/-([\da-z])/ig, C.JS_CONST_s8I);
  },
  Element__determineMouseWheelEventType: [function(e) {
    if (e.onwheel !== undefined)
      return "wheel";
    else if (e.onmousewheel !== undefined)
      return "mousewheel";
    else
      return "DOMMouseScroll";
  }, "call$1", "Element__determineMouseWheelEventType$closure", 2, 0, 562, 312, []],
  ImageElement_ImageElement: function(height, src, width) {
    var e = document.createElement("img", null);
    return e;
  },
  _JenkinsSmiHash_combine: function(hash, value) {
    hash = 536870911 & hash + value;
    hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
    return hash ^ hash >>> 6;
  },
  _convertNativeToDart_Window: function(win) {
    if (win == null)
      return;
    return W._DOMWindowCrossFrame__createSafe(win);
  },
  _convertNativeToDart_EventTarget: function(e) {
    var $window;
    if (e == null)
      return;
    if ("postMessage" in e) {
      $window = W._DOMWindowCrossFrame__createSafe(e);
      if (!!J.getInterceptor($window).$isEventTarget)
        return $window;
      return;
    } else
      return e;
  },
  _convertNativeToDart_XHR_Response: function(o) {
    if (!!J.getInterceptor(o).$isDocument)
      return o;
    return P.convertNativeToDart_AcceptStructuredClone(o, true);
  },
  _wrapZone: function(callback) {
    var t1 = $.Zone__current;
    if (t1 === C.C__RootZone)
      return callback;
    if (callback == null)
      return;
    return t1.bindUnaryCallback$2$runGuarded(callback, true);
  },
  HtmlElement: {
    "^": "Element;",
    $isHtmlElement: true,
    "%": "HTMLAppletElement|HTMLBRElement|HTMLContentElement|HTMLDListElement|HTMLDirectoryElement|HTMLDivElement|HTMLFontElement|HTMLFrameElement|HTMLHeadElement|HTMLHeadingElement|HTMLHtmlElement|HTMLLabelElement|HTMLLegendElement|HTMLMarqueeElement|HTMLMenuElement|HTMLModElement|HTMLParagraphElement|HTMLPreElement|HTMLQuoteElement|HTMLShadowElement|HTMLSpanElement|HTMLTableCaptionElement|HTMLTableCellElement|HTMLTableColElement|HTMLTableDataCellElement|HTMLTableHeaderCellElement|HTMLTitleElement|HTMLUListElement|HTMLUnknownElement;HTMLElement"
  },
  AnchorElement: {
    "^": "HtmlElement;target%,type%",
    hash$1: function($receiver, arg0) {
      return $receiver.hash.call$1(arg0);
    },
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "HTMLAnchorElement"
  },
  AnimationEvent: {
    "^": "Event;",
    $isAnimationEvent: true,
    "%": "WebKitAnimationEvent"
  },
  AreaElement: {
    "^": "HtmlElement;target%",
    hash$1: function($receiver, arg0) {
      return $receiver.hash.call$1(arg0);
    },
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "HTMLAreaElement"
  },
  AudioElement: {
    "^": "MediaElement;",
    $isAudioElement: true,
    "%": "HTMLAudioElement"
  },
  BaseElement: {
    "^": "HtmlElement;target%",
    "%": "HTMLBaseElement"
  },
  Blob: {
    "^": "Interceptor;size=,type=",
    size$1: function($receiver, arg0) {
      return $receiver.size.call$1(arg0);
    },
    $isBlob: true,
    "%": ";Blob"
  },
  BodyElement: {
    "^": "HtmlElement;",
    get$onBlur: function(receiver) {
      return C.EventStreamProvider_blur.forElement$1(receiver);
    },
    get$onError: function(receiver) {
      return C.EventStreamProvider_error.forElement$1(receiver);
    },
    onError$0: function($receiver) {
      return this.get$onError($receiver).call$0();
    },
    get$onFocus: function(receiver) {
      return C.EventStreamProvider_focus.forElement$1(receiver);
    },
    get$onLoad: function(receiver) {
      return C.EventStreamProvider_load.forElement$1(receiver);
    },
    $isEventTarget: true,
    "%": "HTMLBodyElement"
  },
  ButtonElement: {
    "^": "HtmlElement;disabled%,name%,type%,value%",
    "%": "HTMLButtonElement"
  },
  CanvasElement: {
    "^": "HtmlElement;height%,width%",
    getContext$2: function(receiver, contextId, attrs) {
      if (attrs != null)
        return receiver.getContext(contextId, P.convertDartToNative_Dictionary(attrs));
      return receiver.getContext(contextId);
    },
    getContext$1: function($receiver, contextId) {
      return this.getContext$2($receiver, contextId, null);
    },
    get$onWebGlContextLost: function(receiver) {
      return C.EventStreamProvider_webglcontextlost.forElement$1(receiver);
    },
    get$onWebGlContextRestored: function(receiver) {
      return C.EventStreamProvider_webglcontextrestored.forElement$1(receiver);
    },
    getContext3d$6$alpha$antialias$depth$premultipliedAlpha$preserveDrawingBuffer$stencil: function(receiver, alpha, antialias, depth, premultipliedAlpha, preserveDrawingBuffer, stencil) {
      var options, context;
      options = P.LinkedHashMap_LinkedHashMap$_literal(["alpha", alpha, "depth", depth, "stencil", stencil, "antialias", antialias, "premultipliedAlpha", premultipliedAlpha, "preserveDrawingBuffer", preserveDrawingBuffer], null, null);
      context = this.getContext$2(receiver, "webgl", options);
      return context == null ? this.getContext$2(receiver, "experimental-webgl", options) : context;
    },
    getContext3d$0: function($receiver) {
      return this.getContext3d$6$alpha$antialias$depth$premultipliedAlpha$preserveDrawingBuffer$stencil($receiver, true, true, true, true, false, false);
    },
    toDataUrl$2: function(receiver, type, quality) {
      return receiver.toDataURL(type, quality);
    },
    toDataUrl$0: function($receiver) {
      return this.toDataUrl$2($receiver, "image/png", null);
    },
    $isCanvasElement: true,
    "%": "HTMLCanvasElement"
  },
  CanvasRenderingContext: {
    "^": "Interceptor;canvas=",
    "%": ";CanvasRenderingContext"
  },
  CanvasRenderingContext2D: {
    "^": "CanvasRenderingContext;fillStyle},font%,globalAlpha%,globalCompositeOperation%,imageSmoothingEnabled},lineCap},lineJoin},lineWidth%,shadowBlur%,shadowColor%,shadowOffsetX%,shadowOffsetY%,strokeStyle},textBaseline}",
    arcTo$5: function(receiver, x1, y1, x2, y2, radius) {
      return receiver.arcTo(x1, y1, x2, y2, radius);
    },
    beginPath$0: function(receiver) {
      return receiver.beginPath();
    },
    bezierCurveTo$6: function(receiver, cp1x, cp1y, cp2x, cp2y, x, y) {
      return receiver.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    },
    clearRect$4: function(receiver, x, y, width, height) {
      return receiver.clearRect(x, y, width, height);
    },
    clip$1: function(receiver, winding) {
      return receiver.clip(winding);
    },
    clip$0: function($receiver) {
      return $receiver.clip();
    },
    closePath$0: function(receiver) {
      return receiver.closePath();
    },
    createPattern$2: function(receiver, canvas, repetitionType) {
      return receiver.createPattern(canvas, repetitionType);
    },
    createPatternFromImage$2: function(receiver, image, repetitionType) {
      return receiver.createPattern(image, repetitionType);
    },
    fillRect$4: function(receiver, x, y, width, height) {
      return receiver.fillRect(x, y, width, height);
    },
    getImageData$4: function(receiver, sx, sy, sw, sh) {
      return P.convertNativeToDart_ImageData(receiver.getImageData(sx, sy, sw, sh));
    },
    lineTo$2: function(receiver, x, y) {
      return receiver.lineTo(x, y);
    },
    measureText$1: function(receiver, text) {
      return receiver.measureText(text);
    },
    moveTo$2: function(receiver, x, y) {
      return receiver.moveTo(x, y);
    },
    putImageData$7: function(receiver, imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
      receiver.putImageData(P.convertDartToNative_ImageData(imagedata), dx, dy);
      return;
    },
    putImageData$3: function($receiver, imagedata, dx, dy) {
      return this.putImageData$7($receiver, imagedata, dx, dy, null, null, null, null);
    },
    quadraticCurveTo$4: function(receiver, cpx, cpy, x, y) {
      return receiver.quadraticCurveTo(cpx, cpy, x, y);
    },
    rect$4: function(receiver, x, y, width, height) {
      return receiver.rect(x, y, width, height);
    },
    restore$0: function(receiver) {
      return receiver.restore();
    },
    rotate$1: [function(receiver, angle) {
      return receiver.rotate(angle);
    }, "call$1", "get$rotate", 2, 0, 569, 373, []],
    save$0: function(receiver) {
      return receiver.save();
    },
    scale$2: [function(receiver, sx, sy) {
      return receiver.scale(sx, sy);
    }, "call$2", "get$scale", 4, 0, 570, 571, [], 572, []],
    setTransform$6: function(receiver, m11, m12, m21, m22, dx, dy) {
      return receiver.setTransform(m11, m12, m21, m22, dx, dy);
    },
    stroke$0: [function(receiver) {
      return receiver.stroke();
    }, "call$0", "get$stroke", 0, 0, 550],
    strokeRect$4: function(receiver, x, y, width, height) {
      return receiver.strokeRect(x, y, width, height);
    },
    strokeText$4: function(receiver, text, x, y, maxWidth) {
      return receiver.strokeText(text, x, y, maxWidth);
    },
    strokeText$3: function($receiver, text, x, y) {
      return $receiver.strokeText(text, x, y);
    },
    transform$6: function(receiver, m11, m12, m21, m22, dx, dy) {
      return receiver.transform(m11, m12, m21, m22, dx, dy);
    },
    translate$2: function(receiver, tx, ty) {
      return receiver.translate(tx, ty);
    },
    arc$6: function(receiver, x, y, radius, startAngle, endAngle, anticlockwise) {
      receiver.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    },
    arc$5: function($receiver, x, y, radius, startAngle, endAngle) {
      return this.arc$6($receiver, x, y, radius, startAngle, endAngle, false);
    },
    drawImage$3: function(receiver, source, destX, destY) {
      return receiver.drawImage(source, destX, destY);
    },
    drawImageScaledFromSource$9: function(receiver, source, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {
      return receiver.drawImage(source, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
    },
    fillText$4: function(receiver, text, x, y, maxWidth) {
      receiver.fillText(text, x, y);
    },
    fillText$3: function($receiver, text, x, y) {
      return this.fillText$4($receiver, text, x, y, null);
    },
    fill$1: [function(receiver, winding) {
      receiver.fill(winding);
    }, function($receiver) {
      return this.fill$1($receiver, "nonzero");
    }, "fill$0", "call$1", "call$0", "get$fill", 0, 2, 573, 574, 575, []],
    "%": "CanvasRenderingContext2D"
  },
  CharacterData: {
    "^": "Node;data%,length=",
    "%": "CDATASection|Comment|Text;CharacterData"
  },
  CompositionEvent: {
    "^": "UIEvent;data=",
    "%": "CompositionEvent"
  },
  CssStyleDeclaration: {
    "^": "Interceptor_CssStyleDeclarationBase;length=",
    getPropertyValue$1: function(receiver, propertyName) {
      var propValue = this._getPropertyValueHelper$1(receiver, propertyName);
      return propValue != null ? propValue : "";
    },
    _getPropertyValueHelper$1: function(receiver, propertyName) {
      var t1;
      if (W.CssStyleDeclaration__camelCase(propertyName) in receiver)
        return receiver.getPropertyValue(propertyName);
      else {
        t1 = P.Device_cssPrefix();
        if (typeof t1 !== "string")
          return t1.$add();
        return receiver.getPropertyValue(t1 + propertyName);
      }
    },
    setProperty$3: function(receiver, propertyName, value, priority) {
      var t1;
      if (W.CssStyleDeclaration__camelCase(propertyName) in receiver)
        return this._setPropertyHelper$3(receiver, propertyName, value, priority);
      else {
        t1 = P.Device_cssPrefix();
        if (typeof t1 !== "string")
          return t1.$add();
        return this._setPropertyHelper$3(receiver, t1 + propertyName, value, priority);
      }
    },
    _setPropertyHelper$3: function(receiver, propertyName, value, priority) {
      var exception;
      try {
        if (value == null)
          value = "";
        if (priority == null)
          priority = "";
        receiver.setProperty(propertyName, value, priority);
        if (!!receiver.setAttribute)
          receiver.setAttribute(propertyName, value);
      } catch (exception) {
        H.unwrapException(exception);
      }

    },
    "%": "CSS2Properties|CSSStyleDeclaration|MSStyleCSSProperties"
  },
  DataListElement: {
    "^": "HtmlElement;options=",
    "%": "HTMLDataListElement"
  },
  DetailsElement: {
    "^": "HtmlElement;",
    open$3$async: function($receiver, arg0, arg1, arg2) {
      return $receiver.open.call$3$async(arg0, arg1, arg2);
    },
    "%": "HTMLDetailsElement"
  },
  DeviceAcceleration: {
    "^": "Interceptor;x=,y=,z=",
    "%": "DeviceAcceleration"
  },
  DeviceMotionEvent: {
    "^": "Event;acceleration=",
    "%": "DeviceMotionEvent"
  },
  DeviceOrientationEvent: {
    "^": "Event;alpha=",
    "%": "DeviceOrientationEvent"
  },
  DialogElement: {
    "^": "HtmlElement;",
    open$3$async: function($receiver, arg0, arg1, arg2) {
      return $receiver.open.call$3$async(arg0, arg1, arg2);
    },
    "%": "HTMLDialogElement"
  },
  Document: {
    "^": "Node;readyState=",
    getElementsByTagName$1: function(receiver, localName) {
      return receiver.getElementsByTagName(localName);
    },
    get$onBlur: function(receiver) {
      return C.EventStreamProvider_blur.forTarget$1(receiver);
    },
    get$onDragStart: function(receiver) {
      return C.EventStreamProvider_dragstart.forTarget$1(receiver);
    },
    get$onError: function(receiver) {
      return C.EventStreamProvider_error.forTarget$1(receiver);
    },
    onError$0: function($receiver) {
      return this.get$onError($receiver).call$0();
    },
    get$onFocus: function(receiver) {
      return C.EventStreamProvider_focus.forTarget$1(receiver);
    },
    get$onLoad: function(receiver) {
      return C.EventStreamProvider_load.forTarget$1(receiver);
    },
    get$onMouseDown: function(receiver) {
      return C.EventStreamProvider_mousedown.forTarget$1(receiver);
    },
    onMouseDown$1: function($receiver, arg0) {
      return this.get$onMouseDown($receiver).call$1(arg0);
    },
    get$onMouseMove: function(receiver) {
      return C.EventStreamProvider_mousemove.forTarget$1(receiver);
    },
    onMouseMove$1: function($receiver, arg0) {
      return this.get$onMouseMove($receiver).call$1(arg0);
    },
    get$onMouseOut: function(receiver) {
      return C.EventStreamProvider_mouseout.forTarget$1(receiver);
    },
    onMouseOut$1: function($receiver, arg0) {
      return this.get$onMouseOut($receiver).call$1(arg0);
    },
    get$onMouseOver: function(receiver) {
      return C.EventStreamProvider_mouseover.forTarget$1(receiver);
    },
    onMouseOver$1: function($receiver, arg0) {
      return this.get$onMouseOver($receiver).call$1(arg0);
    },
    get$onMouseUp: function(receiver) {
      return C.EventStreamProvider_mouseup.forTarget$1(receiver);
    },
    onMouseUp$1: function($receiver, arg0) {
      return this.get$onMouseUp($receiver).call$1(arg0);
    },
    get$onMouseWheel: function(receiver) {
      return C._CustomEventStreamProvider__determineMouseWheelEventType.forTarget$1(receiver);
    },
    onMouseWheel$1: function($receiver, arg0) {
      return this.get$onMouseWheel($receiver).call$1(arg0);
    },
    get$onTouchCancel: function(receiver) {
      return C.EventStreamProvider_touchcancel.forTarget$1(receiver);
    },
    onTouchCancel$1: function($receiver, arg0) {
      return this.get$onTouchCancel($receiver).call$1(arg0);
    },
    get$onTouchEnd: function(receiver) {
      return C.EventStreamProvider_touchend.forTarget$1(receiver);
    },
    onTouchEnd$1: function($receiver, arg0) {
      return this.get$onTouchEnd($receiver).call$1(arg0);
    },
    get$onTouchMove: function(receiver) {
      return C.EventStreamProvider_touchmove.forTarget$1(receiver);
    },
    onTouchMove$1: function($receiver, arg0) {
      return this.get$onTouchMove($receiver).call$1(arg0);
    },
    get$onTouchStart: function(receiver) {
      return C.EventStreamProvider_touchstart.forTarget$1(receiver);
    },
    onTouchStart$1: function($receiver, arg0) {
      return this.get$onTouchStart($receiver).call$1(arg0);
    },
    $isDocument: true,
    "%": "XMLDocument;Document"
  },
  DocumentFragment: {
    "^": "Node;",
    get$children: function(receiver) {
      if (receiver._docChildren == null)
        receiver._docChildren = H.setRuntimeTypeInfo(new P.FilteredElementList(receiver, new W._ChildNodeListLazy(receiver)), [null]);
      return receiver._docChildren;
    },
    set$children: function(receiver, value) {
      var copy, children, t1;
      copy = P.List_List$from(value, true, null);
      children = this.get$children(receiver);
      t1 = J.getInterceptor$ax(children);
      t1.clear$0(children);
      t1.addAll$1(children, copy);
    },
    "%": ";DocumentFragment"
  },
  DomError: {
    "^": "Interceptor;name=",
    "%": "DOMError|FileError"
  },
  DomException: {
    "^": "Interceptor;",
    get$name: function(receiver) {
      var errorName = receiver.name;
      if (P.Device_isWebKit() === true && errorName === "SECURITY_ERR")
        return "SecurityError";
      if (P.Device_isWebKit() === true && errorName === "SYNTAX_ERR")
        return "SyntaxError";
      return errorName;
    },
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "DOMException"
  },
  DomParser: {
    "^": "Interceptor;",
    parseFromString$2: function(receiver, str, contentType) {
      return receiver.parseFromString(str, contentType);
    },
    "%": "DOMParser"
  },
  Element: {
    "^": "Node;draggable%,id%,style=",
    get$attributes: function(receiver) {
      return new W._ElementAttributeMap(receiver);
    },
    set$attributes: function(receiver, value) {
      var t1, key;
      new W._ElementAttributeMap(receiver).clear$0(0);
      for (t1 = value.get$keys(value), t1 = t1.get$iterator(t1); t1.moveNext$0(), false;) {
        key = t1.get$current();
        receiver.setAttribute(key, value.$index(0, key));
      }
    },
    get$children: function(receiver) {
      return new W._ChildrenElementList(receiver, receiver.children);
    },
    set$children: function(receiver, value) {
      var copy, children;
      copy = P.List_List$from(value, true, null);
      children = this.get$children(receiver);
      children.clear$0(0);
      children.addAll$1(0, copy);
    },
    get$dataset: function(receiver) {
      return new W._DataAttributeMap(new W._ElementAttributeMap(receiver));
    },
    get$client: function(receiver) {
      return P.Rectangle$(C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientLeft)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientTop)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientWidth)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientHeight)), null);
    },
    get$offset: function(receiver) {
      return P.Rectangle$(C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.offsetLeft)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.offsetTop)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.offsetWidth)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.offsetHeight)), null);
    },
    offset$2: function($receiver, arg0, arg1) {
      return this.get$offset($receiver).call$2(arg0, arg1);
    },
    toString$0: function(receiver) {
      return receiver.localName;
    },
    get$on: function(receiver) {
      return new W.ElementEvents(receiver, receiver);
    },
    get$clientLeft: function(receiver) {
      return C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientLeft));
    },
    get$clientTop: function(receiver) {
      return C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientTop));
    },
    translate$2: function($receiver, arg0, arg1) {
      return $receiver.translate.call$2(arg0, arg1);
    },
    click$0: [function(receiver) {
      return receiver.click();
    }, "call$0", "get$click", 0, 0, 550],
    blur$0: [function(receiver) {
      return receiver.blur();
    }, "call$0", "get$blur", 0, 0, 550],
    getAttribute$1: function(receiver, $name) {
      return receiver.getAttribute($name);
    },
    getBoundingClientRect$0: function(receiver) {
      return receiver.getBoundingClientRect();
    },
    requestFullscreen$0: [function(receiver) {
      return receiver.webkitRequestFullscreen();
    }, "call$0", "get$requestFullscreen", 0, 0, 550],
    requestPointerLock$0: [function(receiver) {
      return receiver.webkitRequestPointerLock();
    }, "call$0", "get$requestPointerLock", 0, 0, 550],
    get$onBlur: function(receiver) {
      return C.EventStreamProvider_blur.forElement$1(receiver);
    },
    get$onDragStart: function(receiver) {
      return C.EventStreamProvider_dragstart.forElement$1(receiver);
    },
    get$onError: function(receiver) {
      return C.EventStreamProvider_error.forElement$1(receiver);
    },
    onError$0: function($receiver) {
      return this.get$onError($receiver).call$0();
    },
    get$onFocus: function(receiver) {
      return C.EventStreamProvider_focus.forElement$1(receiver);
    },
    get$onLoad: function(receiver) {
      return C.EventStreamProvider_load.forElement$1(receiver);
    },
    get$onMouseDown: function(receiver) {
      return C.EventStreamProvider_mousedown.forElement$1(receiver);
    },
    onMouseDown$1: function($receiver, arg0) {
      return this.get$onMouseDown($receiver).call$1(arg0);
    },
    get$onMouseMove: function(receiver) {
      return C.EventStreamProvider_mousemove.forElement$1(receiver);
    },
    onMouseMove$1: function($receiver, arg0) {
      return this.get$onMouseMove($receiver).call$1(arg0);
    },
    get$onMouseOut: function(receiver) {
      return C.EventStreamProvider_mouseout.forElement$1(receiver);
    },
    onMouseOut$1: function($receiver, arg0) {
      return this.get$onMouseOut($receiver).call$1(arg0);
    },
    get$onMouseOver: function(receiver) {
      return C.EventStreamProvider_mouseover.forElement$1(receiver);
    },
    onMouseOver$1: function($receiver, arg0) {
      return this.get$onMouseOver($receiver).call$1(arg0);
    },
    get$onMouseUp: function(receiver) {
      return C.EventStreamProvider_mouseup.forElement$1(receiver);
    },
    onMouseUp$1: function($receiver, arg0) {
      return this.get$onMouseUp($receiver).call$1(arg0);
    },
    get$onMouseWheel: function(receiver) {
      return C._CustomEventStreamProvider__determineMouseWheelEventType.forElement$1(receiver);
    },
    onMouseWheel$1: function($receiver, arg0) {
      return this.get$onMouseWheel($receiver).call$1(arg0);
    },
    get$onTouchCancel: function(receiver) {
      return C.EventStreamProvider_touchcancel.forElement$1(receiver);
    },
    onTouchCancel$1: function($receiver, arg0) {
      return this.get$onTouchCancel($receiver).call$1(arg0);
    },
    get$onTouchEnd: function(receiver) {
      return C.EventStreamProvider_touchend.forElement$1(receiver);
    },
    onTouchEnd$1: function($receiver, arg0) {
      return this.get$onTouchEnd($receiver).call$1(arg0);
    },
    get$onTouchEnter: function(receiver) {
      return C.EventStreamProvider_touchenter.forElement$1(receiver);
    },
    onTouchEnter$1: function($receiver, arg0) {
      return this.get$onTouchEnter($receiver).call$1(arg0);
    },
    get$onTouchLeave: function(receiver) {
      return C.EventStreamProvider_touchleave.forElement$1(receiver);
    },
    onTouchLeave$1: function($receiver, arg0) {
      return this.get$onTouchLeave($receiver).call$1(arg0);
    },
    get$onTouchMove: function(receiver) {
      return C.EventStreamProvider_touchmove.forElement$1(receiver);
    },
    onTouchMove$1: function($receiver, arg0) {
      return this.get$onTouchMove($receiver).call$1(arg0);
    },
    get$onTouchStart: function(receiver) {
      return C.EventStreamProvider_touchstart.forElement$1(receiver);
    },
    onTouchStart$1: function($receiver, arg0) {
      return this.get$onTouchStart($receiver).call$1(arg0);
    },
    $isElement: true,
    $isEventTarget: true,
    "%": ";Element"
  },
  EmbedElement: {
    "^": "HtmlElement;height%,name%,src},type%,width%",
    "%": "HTMLEmbedElement"
  },
  ErrorEvent: {
    "^": "Event;error=",
    "%": "ErrorEvent"
  },
  Event: {
    "^": "Interceptor;type=",
    get$target: function(receiver) {
      return W._convertNativeToDart_EventTarget(receiver.target);
    },
    preventDefault$0: [function(receiver) {
      return receiver.preventDefault();
    }, "call$0", "get$preventDefault", 0, 0, 550],
    $isEvent: true,
    "%": "AudioProcessingEvent|AutocompleteErrorEvent|BeforeLoadEvent|BeforeUnloadEvent|CSSFontFaceLoadEvent|CloseEvent|CustomEvent|HashChangeEvent|IDBVersionChangeEvent|InstallEvent|InstallPhaseEvent|MIDIConnectionEvent|MediaKeyEvent|MediaKeyMessageEvent|MediaKeyNeededEvent|MediaStreamEvent|MediaStreamTrackEvent|MutationEvent|OfflineAudioCompletionEvent|OverflowEvent|PageTransitionEvent|RTCDTMFToneChangeEvent|RTCDataChannelEvent|RTCIceCandidateEvent|SecurityPolicyViolationEvent|SpeechInputEvent|SpeechRecognitionEvent|TrackEvent|TransitionEvent|WebKitTransitionEvent;ClipboardEvent|Event|InputEvent"
  },
  EventTarget: {
    "^": "Interceptor;",
    get$on: function(receiver) {
      return new W.Events0(receiver);
    },
    addEventListener$3: function(receiver, type, listener, useCapture) {
      return receiver.addEventListener(type, H.convertDartClosureToJS(listener, 1), useCapture);
    },
    addEventListener$2: function($receiver, type, listener) {
      listener = H.convertDartClosureToJS(listener, 1);
      return $receiver.addEventListener(type, listener);
    },
    dispatchEvent$1: function(receiver, $event) {
      return receiver.dispatchEvent($event);
    },
    removeEventListener$3: function(receiver, type, listener, useCapture) {
      return receiver.removeEventListener(type, H.convertDartClosureToJS(listener, 1), useCapture);
    },
    removeEventListener$2: function($receiver, type, listener) {
      listener = H.convertDartClosureToJS(listener, 1);
      return $receiver.removeEventListener(type, listener);
    },
    $isEventTarget: true,
    "%": ";EventTarget"
  },
  "+EventTarget": 0,
  FieldSetElement: {
    "^": "HtmlElement;disabled%,name%,type=",
    "%": "HTMLFieldSetElement"
  },
  File: {
    "^": "Blob;name=",
    $isFile: true,
    "%": "File"
  },
  FormElement: {
    "^": "HtmlElement;length=,name%,target%",
    reset$0: function(receiver) {
      return receiver.reset();
    },
    "%": "HTMLFormElement"
  },
  HRElement: {
    "^": "HtmlElement;color%",
    "%": "HTMLHRElement"
  },
  HtmlCollection: {
    "^": "Interceptor_ListMixin_ImmutableListMixin;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        throw H.wrapException(P.RangeError$range(index, 0, t1));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true,
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "HTMLCollection|HTMLFormControlsCollection|HTMLOptionsCollection"
  },
  HtmlDocument: {
    "^": "Document;body%",
    body$3: function($receiver, arg0, arg1, arg2) {
      return $receiver.body.call$3(arg0, arg1, arg2);
    },
    "%": "HTMLDocument"
  },
  HttpRequest: {
    "^": "HttpRequestEventTarget;readyState=,responseText=,responseType},responseXml:responseXML=,status=",
    get$response: function(receiver) {
      return W._convertNativeToDart_XHR_Response(receiver.response);
    },
    upload$0: function($receiver) {
      return $receiver.upload.call$0();
    },
    open$5$async$password$user: function(receiver, method, url, async, password, user) {
      return receiver.open(method, url, async, user, password);
    },
    open$3$async: function($receiver, method, url, async) {
      return $receiver.open(method, url, async);
    },
    overrideMimeType$1: function(receiver, override) {
      return receiver.overrideMimeType(override);
    },
    send$1: function(receiver, data) {
      return receiver.send(data);
    },
    send$0: function($receiver) {
      return $receiver.send();
    },
    get$onReadyStateChange: function(receiver) {
      return C.EventStreamProvider_readystatechange.forTarget$1(receiver);
    },
    "%": "XMLHttpRequest"
  },
  HttpRequestEventTarget: {
    "^": "EventTarget;",
    get$onError: function(receiver) {
      return C.EventStreamProvider_error0.forTarget$1(receiver);
    },
    onError$0: function($receiver) {
      return this.get$onError($receiver).call$0();
    },
    get$onLoad: function(receiver) {
      return C.EventStreamProvider_load0.forTarget$1(receiver);
    },
    get$onLoadStart: function(receiver) {
      return C.EventStreamProvider_loadstart0.forTarget$1(receiver);
    },
    get$onProgress: function(receiver) {
      return C.EventStreamProvider_progress0.forTarget$1(receiver);
    },
    "%": "XMLHttpRequestUpload;XMLHttpRequestEventTarget"
  },
  IFrameElement: {
    "^": "HtmlElement;height%,name%,src},width%",
    "%": "HTMLIFrameElement"
  },
  ImageData: {
    "^": "Interceptor;data=,height=,width=",
    $isImageData: true,
    "%": "ImageData"
  },
  ImageElement: {
    "^": "HtmlElement;complete=,crossOrigin%,height%,src},width%",
    complete$0: function($receiver) {
      return $receiver.complete.call$0();
    },
    $isImageElement: true,
    "%": "HTMLImageElement"
  },
  InputElement: {
    "^": "HtmlElement;defaultValue=,disabled%,height%,name%,size%,src},step%,type%,value%,width%",
    size$1: function($receiver, arg0) {
      return $receiver.size.call$1(arg0);
    },
    step$0: function($receiver) {
      return $receiver.step.call$0();
    },
    $isElement: true,
    $isEventTarget: true,
    $isNode: true,
    "%": "HTMLInputElement"
  },
  KeyboardEvent: {
    "^": "UIEvent;altKey=,ctrlKey=,shiftKey=",
    get$keyCode: function(receiver) {
      return receiver.keyCode;
    },
    get$charCode: function(receiver) {
      return receiver.charCode;
    },
    repeat$1: function($receiver, arg0) {
      return $receiver.repeat.call$1(arg0);
    },
    repeat$4: function($receiver, arg0, arg1, arg2, arg3) {
      return $receiver.repeat.call$4(arg0, arg1, arg2, arg3);
    },
    "%": "KeyboardEvent"
  },
  KeygenElement: {
    "^": "HtmlElement;disabled%,name%,type=",
    "%": "HTMLKeygenElement"
  },
  LIElement: {
    "^": "HtmlElement;value%",
    "%": "HTMLLIElement"
  },
  LinkElement: {
    "^": "HtmlElement;crossOrigin%,disabled%,type%",
    "%": "HTMLLinkElement"
  },
  Location: {
    "^": "Interceptor;",
    hash$1: function($receiver, arg0) {
      return $receiver.hash.call$1(arg0);
    },
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "Location"
  },
  MapElement: {
    "^": "HtmlElement;name%",
    "%": "HTMLMapElement"
  },
  MediaElement: {
    "^": "HtmlElement;autoplay%,crossOrigin%,currentTime%,duration=,error=,loop%,muted},paused=,preload=,readyState=,src},volume%",
    loop$0: function($receiver) {
      return $receiver.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return $receiver.loop.call$3(arg0, arg1, arg2);
    },
    paused$0: function($receiver) {
      return $receiver.paused.call$0();
    },
    preload$0: function($receiver) {
      return $receiver.preload.call$0();
    },
    load$0: [function(receiver) {
      return receiver.load();
    }, "call$0", "get$load", 0, 0, 550],
    pause$0: function(receiver) {
      return receiver.pause();
    },
    play$0: function(receiver) {
      return receiver.play();
    },
    get$onLoadStart: function(receiver) {
      return C.EventStreamProvider_loadstart.forElement$1(receiver);
    },
    get$onPause: function(receiver) {
      return C.EventStreamProvider_pause.forElement$1(receiver);
    },
    get$onPlay: function(receiver) {
      return C.EventStreamProvider_play.forElement$1(receiver);
    },
    get$onProgress: function(receiver) {
      return C.EventStreamProvider_progress.forElement$1(receiver);
    },
    "%": ";HTMLMediaElement"
  },
  MediaStream: {
    "^": "EventTarget;id=",
    stop$0: [function(receiver) {
      return receiver.stop();
    }, "call$0", "get$stop", 0, 0, 550],
    $isMediaStream: true,
    "%": "MediaStream"
  },
  MessageEvent: {
    "^": "Event;",
    get$data: function(receiver) {
      return P.convertNativeToDart_AcceptStructuredClone(receiver.data, true);
    },
    get$source: function(receiver) {
      return W._convertNativeToDart_EventTarget(receiver.source);
    },
    "%": "MessageEvent"
  },
  MetaElement: {
    "^": "HtmlElement;content%,name%",
    "%": "HTMLMetaElement"
  },
  MeterElement: {
    "^": "HtmlElement;value%",
    "%": "HTMLMeterElement"
  },
  MidiMessageEvent: {
    "^": "Event;data=",
    "%": "MIDIMessageEvent"
  },
  MidiOutput: {
    "^": "MidiPort;",
    send$2: function(receiver, data, timestamp) {
      return receiver.send(data, timestamp);
    },
    send$1: function($receiver, data) {
      return $receiver.send(data);
    },
    "%": "MIDIOutput"
  },
  MidiPort: {
    "^": "EventTarget;id=,name=,type=,version=",
    "%": "MIDIInput;MIDIPort"
  },
  MouseEvent: {
    "^": "UIEvent;altKey=,button=,ctrlKey=,shiftKey=",
    button$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return $receiver.button.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    button$9: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
      return $receiver.button.call$9(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    },
    button$8: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      return $receiver.button.call$8(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
    },
    get$client: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(receiver.clientX, receiver.clientY), [null]);
    },
    get$movement: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(receiver.webkitMovementX, receiver.webkitMovementY), [null]);
    },
    get$offset: function(receiver) {
      var target, point;
      if (!!receiver.offsetX)
        return H.setRuntimeTypeInfo(new P.Point1(receiver.offsetX, receiver.offsetY), [null]);
      else {
        if (!J.getInterceptor(W._convertNativeToDart_EventTarget(receiver.target)).$isElement)
          throw H.wrapException(P.UnsupportedError$("offsetX is only supported on elements"));
        target = W._convertNativeToDart_EventTarget(receiver.target);
        point = H.setRuntimeTypeInfo(new P.Point1(receiver.clientX, receiver.clientY), [null]).$sub(0, J.get$topLeft$x(J.getBoundingClientRect$0$x(target)));
        return H.setRuntimeTypeInfo(new P.Point1(J.toInt$0$n(point.x), J.toInt$0$n(point.y)), [null]);
      }
    },
    offset$2: function($receiver, arg0, arg1) {
      return this.get$offset($receiver).call$2(arg0, arg1);
    },
    get$screen: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(receiver.screenX, receiver.screenY), [null]);
    },
    $isMouseEvent: true,
    "%": ";DragEvent|MSPointerEvent|MouseEvent|PointerEvent"
  },
  Navigator: {
    "^": "Interceptor;",
    getUserMedia$2$audio$video: [function(receiver, audio, video) {
      var t1, completer, options;
      t1 = W.MediaStream;
      completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t1)), [t1]);
      options = P.LinkedHashMap_LinkedHashMap$_literal(["audio", audio, "video", video], null, null);
      if (!receiver.getUserMedia)
        receiver.getUserMedia = receiver.getUserMedia || receiver.webkitGetUserMedia || receiver.mozGetUserMedia || receiver.msGetUserMedia;
      this._getUserMedia$3(receiver, P._convertDartToNative_PrepareForStructuredClone(options), new W.Navigator_getUserMedia_closure(completer), new W.Navigator_getUserMedia_closure0(completer));
      return completer.future;
    }, function($receiver) {
      return this.getUserMedia$2$audio$video($receiver, false, false);
    }, "getUserMedia$0", "call$2$audio$video", "call$0", "get$getUserMedia", 0, 5, 576, 95, 95],
    _getUserMedia$3: function(receiver, options, success, error) {
      return receiver.getUserMedia(options, H.convertDartClosureToJS(success, 1), H.convertDartClosureToJS(error, 1));
    },
    "%": "Navigator"
  },
  NavigatorUserMediaError: {
    "^": "Interceptor;name=",
    "%": "NavigatorUserMediaError"
  },
  Node: {
    "^": "EventTarget;parent:parentElement=,parentNode=,text:textContent%",
    get$nodes: function(receiver) {
      return new W._ChildNodeListLazy(receiver);
    },
    set$nodes: function(receiver, value) {
      var copy, t1;
      copy = P.List_List$from(value, true, null);
      receiver.textContent = "";
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(copy, copy.length, 0, null), [H.getTypeArgumentByIndex(copy, 0)]); t1.moveNext$0();)
        receiver.appendChild(t1._current);
    },
    remove$0: function(receiver) {
      var t1 = receiver.parentNode;
      if (t1 != null)
        t1.removeChild(receiver);
    },
    replaceWith$1: function(receiver, otherNode) {
      var $parent, exception;
      try {
        $parent = receiver.parentNode;
        J._replaceChild$2$x($parent, otherNode, receiver);
      } catch (exception) {
        H.unwrapException(exception);
      }

      return receiver;
    },
    _clearChildren$0: function(receiver) {
      var t1;
      for (; t1 = receiver.firstChild, t1 != null;)
        receiver.removeChild(t1);
    },
    toString$0: function(receiver) {
      var t1 = receiver.nodeValue;
      return t1 == null ? J.Interceptor.prototype.toString$0.call(this, receiver) : t1;
    },
    text$4: function($receiver, arg0, arg1, arg2, arg3) {
      return $receiver.textContent.call$4(arg0, arg1, arg2, arg3);
    },
    text$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return $receiver.textContent.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    text$3: function($receiver, arg0, arg1, arg2) {
      return $receiver.textContent.call$3(arg0, arg1, arg2);
    },
    append$1: function(receiver, newChild) {
      return receiver.appendChild(newChild);
    },
    clone$1: function(receiver, deep) {
      return receiver.cloneNode(deep);
    },
    contains$1: [function(receiver, other) {
      return receiver.contains(other);
    }, "call$1", "get$contains", 2, 0, 577],
    _replaceChild$2: function(receiver, newChild, oldChild) {
      return receiver.replaceChild(newChild, oldChild);
    },
    $isNode: true,
    "%": "DocumentType|Notation;Node"
  },
  NodeList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin0;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        throw H.wrapException(P.RangeError$range(index, 0, t1));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true,
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "NodeList|RadioNodeList"
  },
  OListElement: {
    "^": "HtmlElement;reversed=,start%,type%",
    start$1: function($receiver, arg0) {
      return $receiver.start.call$1(arg0);
    },
    start$0: function($receiver) {
      return $receiver.start.call$0();
    },
    start$3: function($receiver, arg0, arg1, arg2) {
      return $receiver.start.call$3(arg0, arg1, arg2);
    },
    start$2: function($receiver, arg0, arg1) {
      return $receiver.start.call$2(arg0, arg1);
    },
    start$4: function($receiver, arg0, arg1, arg2, arg3) {
      return $receiver.start.call$4(arg0, arg1, arg2, arg3);
    },
    start$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return $receiver.start.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    "%": "HTMLOListElement"
  },
  ObjectElement: {
    "^": "HtmlElement;data%,height%,name%,type%,width%",
    "%": "HTMLObjectElement"
  },
  OptGroupElement: {
    "^": "HtmlElement;disabled%",
    "%": "HTMLOptGroupElement"
  },
  OptionElement: {
    "^": "HtmlElement;disabled%,index=,value%",
    $isOptionElement: true,
    "%": "HTMLOptionElement"
  },
  OutputElement: {
    "^": "HtmlElement;defaultValue=,name%,type=,value%",
    "%": "HTMLOutputElement"
  },
  ParamElement: {
    "^": "HtmlElement;name%,value%",
    "%": "HTMLParamElement"
  },
  PopStateEvent: {
    "^": "Event;",
    get$state: function(receiver) {
      return P.convertNativeToDart_AcceptStructuredClone(receiver.state, true);
    },
    "%": "PopStateEvent"
  },
  ProcessingInstruction: {
    "^": "CharacterData;target=",
    "%": "ProcessingInstruction"
  },
  ProgressElement: {
    "^": "HtmlElement;position=,value%",
    "%": "HTMLProgressElement"
  },
  ProgressEvent: {
    "^": "Event;loaded=,total=",
    $isProgressEvent: true,
    "%": "XMLHttpRequestProgressEvent;ProgressEvent"
  },
  ResourceProgressEvent: {
    "^": "ProgressEvent;url=",
    "%": "ResourceProgressEvent"
  },
  Screen: {
    "^": "EventTarget;height=,orientation=,width=",
    "%": "Screen"
  },
  ScriptElement: {
    "^": "HtmlElement;crossOrigin%,src},type%",
    "%": "HTMLScriptElement"
  },
  SelectElement: {
    "^": "HtmlElement;disabled%,length%,name%,size%,type=,value%",
    size$1: function($receiver, arg0) {
      return $receiver.size.call$1(arg0);
    },
    get$options: function(receiver) {
      var t1 = W._FrozenElementList$_wrap(receiver.querySelectorAll("option"), null);
      t1 = t1.where$1(t1, new W.SelectElement_options_closure());
      return H.setRuntimeTypeInfo(new P.UnmodifiableListView(P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0))), [null]);
    },
    "%": "HTMLSelectElement"
  },
  ShadowRoot: {
    "^": "DocumentFragment;",
    clone$1: function(receiver, deep) {
      return receiver.cloneNode(deep);
    },
    getElementsByTagName$1: function(receiver, tagName) {
      return receiver.getElementsByTagName(tagName);
    },
    "%": "ShadowRoot"
  },
  SourceElement: {
    "^": "HtmlElement;src},type%",
    "%": "HTMLSourceElement"
  },
  SpeechRecognitionError: {
    "^": "Event;error=",
    "%": "SpeechRecognitionError"
  },
  SpeechSynthesisEvent: {
    "^": "Event;name=",
    "%": "SpeechSynthesisEvent"
  },
  Storage: {
    "^": "Interceptor;",
    addAll$1: function(receiver, other) {
      J.forEach$1$ax(other, new W.Storage_addAll_closure(receiver));
    },
    containsKey$1: function(receiver, key) {
      return receiver.getItem(key) != null;
    },
    $index: function(receiver, key) {
      return receiver.getItem(key);
    },
    $indexSet: function(receiver, key, value) {
      receiver.setItem(key, value);
    },
    remove$1: function(receiver, key) {
      var value = receiver.getItem(key);
      receiver.removeItem(key);
      return value;
    },
    clear$0: function(receiver) {
      return receiver.clear();
    },
    forEach$1: function(receiver, f) {
      var i, key;
      for (i = 0; true; ++i) {
        key = receiver.key(i);
        if (key == null)
          return;
        f.call$2(key, receiver.getItem(key));
      }
    },
    get$keys: function(receiver) {
      var keys = [];
      this.forEach$1(receiver, new W.Storage_keys_closure(keys));
      return keys;
    },
    get$values: function(receiver) {
      var values = [];
      this.forEach$1(receiver, new W.Storage_values_closure(values));
      return values;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    get$isEmpty: function(receiver) {
      return receiver.key(0) == null;
    },
    $isMap: true,
    $asMap: function() {
      return [P.String, P.String];
    },
    "%": "Storage"
  },
  StorageEvent: {
    "^": "Event;key=,url=",
    key$4: function($receiver, arg0, arg1, arg2, arg3) {
      return $receiver.key.call$4(arg0, arg1, arg2, arg3);
    },
    "%": "StorageEvent"
  },
  StyleElement: {
    "^": "HtmlElement;disabled%,type%",
    "%": "HTMLStyleElement"
  },
  TableElement: {
    "^": "HtmlElement;",
    get$rows: function(receiver) {
      return H.setRuntimeTypeInfo(new W._WrappedList(receiver.rows), [W.TableRowElement]);
    },
    "%": "HTMLTableElement"
  },
  TableRowElement: {
    "^": "HtmlElement;",
    $isTableRowElement: true,
    "%": "HTMLTableRowElement"
  },
  TableSectionElement: {
    "^": "HtmlElement;",
    get$rows: function(receiver) {
      return H.setRuntimeTypeInfo(new W._WrappedList(receiver.rows), [W.TableRowElement]);
    },
    "%": "HTMLTableSectionElement"
  },
  TemplateElement: {
    "^": "HtmlElement;content=",
    "%": "HTMLTemplateElement"
  },
  TextAreaElement: {
    "^": "HtmlElement;defaultValue=,disabled%,name%,rows%,type=,value%,wrap%",
    wrap$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return $receiver.wrap.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    "%": "HTMLTextAreaElement"
  },
  TextEvent: {
    "^": "UIEvent;data=",
    "%": "TextEvent"
  },
  TextMetrics: {
    "^": "Interceptor;width=",
    "%": "TextMetrics"
  },
  Touch0: {
    "^": "Interceptor;identifier=",
    get$target: function(receiver) {
      return W._convertNativeToDart_EventTarget(receiver.target);
    },
    get$client: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientX)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.clientY))), [null]);
    },
    get$page: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.pageX)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.pageY))), [null]);
    },
    get$screen: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.screenX)), C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(receiver.screenY))), [null]);
    },
    "%": "Touch"
  },
  "+Touch": 0,
  TouchEvent: {
    "^": "UIEvent;altKey=,changedTouches=,ctrlKey=,shiftKey=",
    $isTouchEvent: true,
    "%": "TouchEvent"
  },
  TouchList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin1;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        throw H.wrapException(P.RangeError$range(index, 0, t1));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Touch0];
    },
    $isEfficientLength: true,
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "TouchList"
  },
  TrackElement: {
    "^": "HtmlElement;defaultValue:default=,readyState=,src}",
    "%": "HTMLTrackElement"
  },
  UIEvent: {
    "^": "Event;",
    get$view: function(receiver) {
      return W._convertNativeToDart_Window(receiver.view);
    },
    get$layer: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(receiver.layerX, receiver.layerY), [null]);
    },
    get$page: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(receiver.pageX, receiver.pageY), [null]);
    },
    "%": "FocusEvent|SVGZoomEvent;UIEvent"
  },
  VideoElement: {
    "^": "MediaElement;height%,width%",
    $isVideoElement: true,
    "%": "HTMLVideoElement"
  },
  WheelEvent: {
    "^": "MouseEvent;deltaZ=",
    get$deltaY: function(receiver) {
      var detail;
      if (receiver.deltaY !== undefined)
        return receiver.deltaY;
      else if (receiver.wheelDelta !== undefined)
        return -receiver.wheelDelta;
      else if (receiver.detail !== undefined) {
        if (receiver.axis == MouseScrollEvent.VERTICAL_AXIS) {
          detail = receiver.detail;
          if (Math.abs(detail) < 100)
            return -detail * 40;
          return -detail;
        }
        return 0;
      }
      throw H.wrapException(P.UnsupportedError$("deltaY is not supported"));
    },
    deltaY$0: function($receiver) {
      return this.get$deltaY($receiver).call$0();
    },
    get$deltaX: function(receiver) {
      var detail;
      if (receiver.deltaX !== undefined)
        return receiver.deltaX;
      else if (receiver.wheelDeltaX !== undefined)
        return -receiver.wheelDeltaX;
      else if (receiver.detail !== undefined) {
        if (receiver.axis !== undefined && receiver.axis == MouseScrollEvent.HORIZONTAL_AXIS) {
          detail = receiver.detail;
          if (detail < 100)
            return -detail * 40;
          return -detail;
        }
        return 0;
      }
      throw H.wrapException(P.UnsupportedError$("deltaX is not supported"));
    },
    deltaX$0: function($receiver) {
      return this.get$deltaX($receiver).call$0();
    },
    $isWheelEvent: true,
    "%": "MouseScrollEvent|MouseWheelEvent|WheelEvent"
  },
  Window: {
    "^": "EventTarget;localStorage=,name%,orientation=,screen=,screenX=,screenY=,status=",
    requestAnimationFrame$1: [function(receiver, callback) {
      this._ensureRequestAnimationFrame$0(receiver);
      return this._requestAnimationFrame$1(receiver, W._wrapZone(callback));
    }, "call$1", "get$requestAnimationFrame", 2, 0, 578, 272, []],
    _requestAnimationFrame$1: function(receiver, callback) {
      return receiver.requestAnimationFrame(H.convertDartClosureToJS(callback, 1));
    },
    _ensureRequestAnimationFrame$0: function(receiver) {
      if (!!(receiver.requestAnimationFrame && receiver.cancelAnimationFrame))
        return;
      (function($this) {
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var i = 0; i < vendors.length && !$this.requestAnimationFrame; ++i) {
          $this.requestAnimationFrame = $this[vendors[i] + 'RequestAnimationFrame'];
          $this.cancelAnimationFrame = $this[vendors[i] + 'CancelAnimationFrame'] || $this[vendors[i] + 'CancelRequestAnimationFrame'];
        }
        if ($this.requestAnimationFrame && $this.cancelAnimationFrame)
          return;
        $this.requestAnimationFrame = function(callback) {
          return window.setTimeout(function() {
            callback(Date.now());
          }, 16);
        };
        $this.cancelAnimationFrame = function(id) {
          clearTimeout(id);
        };
      })(receiver);
    },
    get$parent: function(receiver) {
      return W._convertNativeToDart_Window(receiver.parent);
    },
    get$top: function(receiver) {
      return W._convertNativeToDart_Window(receiver.top);
    },
    scrollTo$3: function(receiver, x, y, scrollOptions) {
      receiver.scrollTo(x, y);
      return;
    },
    scrollTo$2: function($receiver, x, y) {
      return this.scrollTo$3($receiver, x, y, null);
    },
    stop$0: [function(receiver) {
      return receiver.stop();
    }, "call$0", "get$stop", 0, 0, 550],
    toString$0: function(receiver) {
      return receiver.toString();
    },
    get$onBlur: function(receiver) {
      return C.EventStreamProvider_blur.forTarget$1(receiver);
    },
    get$onDragStart: function(receiver) {
      return C.EventStreamProvider_dragstart.forTarget$1(receiver);
    },
    get$onError: function(receiver) {
      return C.EventStreamProvider_error.forTarget$1(receiver);
    },
    onError$0: function($receiver) {
      return this.get$onError($receiver).call$0();
    },
    get$onFocus: function(receiver) {
      return C.EventStreamProvider_focus.forTarget$1(receiver);
    },
    get$onLoad: function(receiver) {
      return C.EventStreamProvider_load.forTarget$1(receiver);
    },
    get$onMouseDown: function(receiver) {
      return C.EventStreamProvider_mousedown.forTarget$1(receiver);
    },
    onMouseDown$1: function($receiver, arg0) {
      return this.get$onMouseDown($receiver).call$1(arg0);
    },
    get$onMouseMove: function(receiver) {
      return C.EventStreamProvider_mousemove.forTarget$1(receiver);
    },
    onMouseMove$1: function($receiver, arg0) {
      return this.get$onMouseMove($receiver).call$1(arg0);
    },
    get$onMouseOut: function(receiver) {
      return C.EventStreamProvider_mouseout.forTarget$1(receiver);
    },
    onMouseOut$1: function($receiver, arg0) {
      return this.get$onMouseOut($receiver).call$1(arg0);
    },
    get$onMouseOver: function(receiver) {
      return C.EventStreamProvider_mouseover.forTarget$1(receiver);
    },
    onMouseOver$1: function($receiver, arg0) {
      return this.get$onMouseOver($receiver).call$1(arg0);
    },
    get$onMouseUp: function(receiver) {
      return C.EventStreamProvider_mouseup.forTarget$1(receiver);
    },
    onMouseUp$1: function($receiver, arg0) {
      return this.get$onMouseUp($receiver).call$1(arg0);
    },
    get$onMouseWheel: function(receiver) {
      return C._CustomEventStreamProvider__determineMouseWheelEventType.forTarget$1(receiver);
    },
    onMouseWheel$1: function($receiver, arg0) {
      return this.get$onMouseWheel($receiver).call$1(arg0);
    },
    get$onTouchCancel: function(receiver) {
      return C.EventStreamProvider_touchcancel.forTarget$1(receiver);
    },
    onTouchCancel$1: function($receiver, arg0) {
      return this.get$onTouchCancel($receiver).call$1(arg0);
    },
    get$onTouchEnd: function(receiver) {
      return C.EventStreamProvider_touchend.forTarget$1(receiver);
    },
    onTouchEnd$1: function($receiver, arg0) {
      return this.get$onTouchEnd($receiver).call$1(arg0);
    },
    get$onTouchMove: function(receiver) {
      return C.EventStreamProvider_touchmove.forTarget$1(receiver);
    },
    onTouchMove$1: function($receiver, arg0) {
      return this.get$onTouchMove($receiver).call$1(arg0);
    },
    get$onTouchStart: function(receiver) {
      return C.EventStreamProvider_touchstart.forTarget$1(receiver);
    },
    onTouchStart$1: function($receiver, arg0) {
      return this.get$onTouchStart($receiver).call$1(arg0);
    },
    get$onAnimationStart: function(receiver) {
      return C.EventStreamProvider_webkitAnimationStart.forTarget$1(receiver);
    },
    get$scrollX: function(receiver) {
      var t1;
      if ("scrollX" in receiver)
        t1 = receiver.scrollX;
      else {
        t1 = receiver.document.documentElement;
        t1.toString;
        t1 = C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t1.scrollLeft));
      }
      return t1;
    },
    get$scrollY: function(receiver) {
      var t1;
      if ("scrollY" in receiver)
        t1 = receiver.scrollY;
      else {
        t1 = receiver.document.documentElement;
        t1.toString;
        t1 = C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t1.scrollTop));
      }
      return t1;
    },
    $isWindow: true,
    $isEventTarget: true,
    "%": "DOMWindow|Window"
  },
  _Attr: {
    "^": "Node;name=,value%",
    "%": "Attr"
  },
  _ClientRect: {
    "^": "Interceptor;bottom=,height=,left=,right=,top=,width=",
    toString$0: function(receiver) {
      return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(receiver.width) + " x " + H.S(receiver.height);
    },
    $eq: function(receiver, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isRectangle)
        return false;
      t2 = receiver.left;
      t3 = t1.get$left(other);
      if (t2 == null ? t3 == null : t2 === t3) {
        t2 = receiver.top;
        t3 = t1.get$top(other);
        if (t2 == null ? t3 == null : t2 === t3) {
          t2 = receiver.width;
          t3 = t1.get$width(other);
          if (t2 == null ? t3 == null : t2 === t3) {
            t2 = receiver.height;
            t1 = t1.get$height(other);
            t1 = t2 == null ? t1 == null : t2 === t1;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(receiver) {
      var t1, t2, t3, t4, hash;
      t1 = J.get$hashCode$(receiver.left);
      t2 = J.get$hashCode$(receiver.top);
      t3 = J.get$hashCode$(receiver.width);
      t4 = J.get$hashCode$(receiver.height);
      t4 = W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(0, t1), t2), t3), t4);
      hash = 536870911 & t4 + ((67108863 & t4) << 3 >>> 0);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
    },
    intersects$1: function(receiver, other) {
      var t1, t2, t3, t4;
      t1 = receiver.left;
      t2 = J.getInterceptor$x(other);
      t3 = J.$add$ns(t2.get$left(other), t2.get$width(other));
      if (typeof t1 !== "number")
        return t1.$le();
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (t1 <= t3) {
        t1 = t2.get$left(other);
        t3 = receiver.left;
        t4 = receiver.width;
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (J.$le$n(t1, t3 + t4)) {
          t1 = receiver.top;
          t3 = J.$add$ns(t2.get$top(other), t2.get$height(other));
          if (typeof t1 !== "number")
            return t1.$le();
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (t1 <= t3) {
            t1 = t2.get$top(other);
            t2 = receiver.top;
            t3 = receiver.height;
            if (typeof t2 !== "number")
              return t2.$add();
            if (typeof t3 !== "number")
              return H.iae(t3);
            t3 = J.$le$n(t1, t2 + t3);
            t1 = t3;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$topLeft: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point1(receiver.left, receiver.top), [null]);
    },
    get$bottomRight: function(receiver) {
      var t1, t2, t3, t4;
      t1 = receiver.left;
      t2 = receiver.width;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = receiver.top;
      t4 = receiver.height;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return H.setRuntimeTypeInfo(new P.Point1(t1 + t2, t3 + t4), [null]);
    },
    $isRectangle: true,
    $asRectangle: function() {
      return [null];
    },
    "%": "ClientRect|DOMRect"
  },
  _HTMLFrameSetElement: {
    "^": "HtmlElement;",
    $isEventTarget: true,
    "%": "HTMLFrameSetElement"
  },
  _NamedNodeMap: {
    "^": "Interceptor_ListMixin_ImmutableListMixin2;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        throw H.wrapException(P.RangeError$range(index, 0, t1));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true,
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "MozNamedAttrMap|NamedNodeMap"
  },
  Interceptor_CssStyleDeclarationBase: {
    "^": "Interceptor+CssStyleDeclarationBase;"
  },
  _CssStyleDeclarationSet: {
    "^": "Object_CssStyleDeclarationBase;_elementIterable,_elementCssStyleDeclarationSetIterable",
    getPropertyValue$1: function(_, propertyName) {
      var t1 = this._elementCssStyleDeclarationSetIterable;
      if (J.$eq(t1.get$length(t1), 0))
        H.throwExpression(H.IterableElementError_noElement());
      return J.getPropertyValue$1$x(t1.elementAt$1(0, 0), propertyName);
    },
    setProperty$3: function(_, propertyName, value, priority) {
      this._elementCssStyleDeclarationSetIterable.forEach$1(0, new W._CssStyleDeclarationSet_setProperty_closure(propertyName, value, priority));
    },
    _CssStyleDeclarationSet$1: function(_elementIterable) {
      this._elementCssStyleDeclarationSetIterable = H.setRuntimeTypeInfo(new H.MappedListIterable(P.List_List$from(this._elementIterable, true, null), new W._CssStyleDeclarationSet_closure()), [null, null]);
    },
    static: {_CssStyleDeclarationSet$: function(_elementIterable) {
        var t1 = new W._CssStyleDeclarationSet(_elementIterable, null);
        t1._CssStyleDeclarationSet$1(_elementIterable);
        return t1;
      }}
  },
  Object_CssStyleDeclarationBase: {
    "^": "Object+CssStyleDeclarationBase;"
  },
  _CssStyleDeclarationSet_closure: {
    "^": "Closure:63;",
    call$1: [function(e) {
      return J.get$style$x(e);
    }, "call$1", null, 2, 0, null, 312, [], "call"],
    $isFunction: true
  },
  _CssStyleDeclarationSet_setProperty_closure: {
    "^": "Closure:63;propertyName_0,value_1,priority_2",
    call$1: function(e) {
      return J.setProperty$3$x(e, this.propertyName_0, this.value_1, this.priority_2);
    },
    $isFunction: true
  },
  CssStyleDeclarationBase: {
    "^": "Object;",
    get$animation: function(receiver) {
      return this.getPropertyValue$1(receiver, "animation");
    },
    set$animation: function(receiver, value) {
      this.setProperty$3(receiver, "animation", value, "");
    },
    get$aspectRatio: function(receiver) {
      return this.getPropertyValue$1(receiver, "aspect-ratio");
    },
    set$aspectRatio: function(receiver, value) {
      this.setProperty$3(receiver, "aspect-ratio", value, "");
    },
    get$backgroundColor: function(receiver) {
      return this.getPropertyValue$1(receiver, "background-color");
    },
    set$backgroundColor: function(receiver, value) {
      this.setProperty$3(receiver, "background-color", value, "");
    },
    get$border: function(receiver) {
      return this.getPropertyValue$1(receiver, "border");
    },
    get$bottom: function(receiver) {
      return this.getPropertyValue$1(receiver, "bottom");
    },
    set$bottom: function(receiver, value) {
      this.setProperty$3(receiver, "bottom", value, "");
    },
    get$clear: function(receiver) {
      return this.getPropertyValue$1(receiver, "clear");
    },
    clear$0: function($receiver) {
      return this.get$clear($receiver).call$0();
    },
    clear$1: function($receiver, arg0) {
      return this.get$clear($receiver).call$1(arg0);
    },
    get$clip: function(receiver) {
      return this.getPropertyValue$1(receiver, "clip");
    },
    clip$0: function($receiver) {
      return this.get$clip($receiver).call$0();
    },
    get$color: function(receiver) {
      return this.getPropertyValue$1(receiver, "color");
    },
    set$color: function(receiver, value) {
      this.setProperty$3(receiver, "color", value, "");
    },
    get$columnWidth: function(receiver) {
      return this.getPropertyValue$1(receiver, "column-width");
    },
    set$columnWidth: function(receiver, value) {
      this.setProperty$3(receiver, "column-width", value, "");
    },
    get$columns: function(receiver) {
      return this.getPropertyValue$1(receiver, "columns");
    },
    set$columns: function(receiver, value) {
      this.setProperty$3(receiver, "columns", value, "");
    },
    get$content: function(receiver) {
      return this.getPropertyValue$1(receiver, "content");
    },
    set$content: function(receiver, value) {
      this.setProperty$3(receiver, "content", value, "");
    },
    get$cursor: function(receiver) {
      return this.getPropertyValue$1(receiver, "cursor");
    },
    set$cursor: function(receiver, value) {
      this.setProperty$3(receiver, "cursor", value, "");
    },
    set$display: function(receiver, value) {
      this.setProperty$3(receiver, "display", value, "");
    },
    get$filter: function(receiver) {
      return this.getPropertyValue$1(receiver, "filter");
    },
    filter$2: function($receiver, arg0, arg1) {
      return this.get$filter($receiver).call$2(arg0, arg1);
    },
    filter$1: function($receiver, arg0) {
      return this.get$filter($receiver).call$1(arg0);
    },
    get$font: function(receiver) {
      return this.getPropertyValue$1(receiver, "font");
    },
    set$font: function(receiver, value) {
      this.setProperty$3(receiver, "font", value, "");
    },
    get$fontSize: function(receiver) {
      return this.getPropertyValue$1(receiver, "font-size");
    },
    set$fontSize: function(receiver, value) {
      this.setProperty$3(receiver, "font-size", value, "");
    },
    get$fontWeight: function(receiver) {
      return this.getPropertyValue$1(receiver, "font-weight");
    },
    set$fontWeight: function(receiver, value) {
      this.setProperty$3(receiver, "font-weight", value, "");
    },
    get$height: function(receiver) {
      return this.getPropertyValue$1(receiver, "height");
    },
    set$height: function(receiver, value) {
      this.setProperty$3(receiver, "height", value, "");
    },
    set$imageRendering: function(receiver, value) {
      this.setProperty$3(receiver, "image-rendering", value, "");
    },
    get$left: function(receiver) {
      return this.getPropertyValue$1(receiver, "left");
    },
    set$left: function(receiver, value) {
      this.setProperty$3(receiver, "left", value, "");
    },
    get$lineHeight: function(receiver) {
      return this.getPropertyValue$1(receiver, "line-height");
    },
    set$lineHeight: function(receiver, value) {
      this.setProperty$3(receiver, "line-height", value, "");
    },
    get$margin: function(receiver) {
      return this.getPropertyValue$1(receiver, "margin");
    },
    set$margin: function(receiver, value) {
      this.setProperty$3(receiver, "margin", value, "");
    },
    set$marginLeft: function(receiver, value) {
      this.setProperty$3(receiver, "margin-left", value, "");
    },
    set$marginTop: function(receiver, value) {
      this.setProperty$3(receiver, "margin-top", value, "");
    },
    get$mask: function(receiver) {
      return this.getPropertyValue$1(receiver, "mask");
    },
    set$mask: function(receiver, value) {
      this.setProperty$3(receiver, "mask", value, "");
    },
    get$maskPosition: function(receiver) {
      return this.getPropertyValue$1(receiver, "mask-position");
    },
    set$maskPosition: function(receiver, value) {
      this.setProperty$3(receiver, "mask-position", value, "");
    },
    get$maxHeight: function(receiver) {
      return this.getPropertyValue$1(receiver, "max-height");
    },
    set$maxHeight: function(receiver, value) {
      this.setProperty$3(receiver, "max-height", value, "");
    },
    get$maxWidth: function(receiver) {
      return this.getPropertyValue$1(receiver, "max-width");
    },
    set$maxWidth: function(receiver, value) {
      this.setProperty$3(receiver, "max-width", value, "");
    },
    get$minHeight: function(receiver) {
      return this.getPropertyValue$1(receiver, "min-height");
    },
    set$minHeight: function(receiver, value) {
      this.setProperty$3(receiver, "min-height", value, "");
    },
    get$minWidth: function(receiver) {
      return this.getPropertyValue$1(receiver, "min-width");
    },
    set$minWidth: function(receiver, value) {
      this.setProperty$3(receiver, "min-width", value, "");
    },
    get$order: function(receiver) {
      return this.getPropertyValue$1(receiver, "order");
    },
    order$0: function($receiver) {
      return this.get$order($receiver).call$0();
    },
    get$orientation: function(receiver) {
      return this.getPropertyValue$1(receiver, "orientation");
    },
    set$orientation: function(receiver, value) {
      this.setProperty$3(receiver, "orientation", value, "");
    },
    set$overflow: function(receiver, value) {
      this.setProperty$3(receiver, "overflow", value, "");
    },
    get$padding: function(receiver) {
      return this.getPropertyValue$1(receiver, "padding");
    },
    set$padding: function(receiver, value) {
      this.setProperty$3(receiver, "padding", value, "");
    },
    get$page: function(receiver) {
      return this.getPropertyValue$1(receiver, "page");
    },
    set$page: function(receiver, value) {
      this.setProperty$3(receiver, "page", value, "");
    },
    get$position: function(receiver) {
      return this.getPropertyValue$1(receiver, "position");
    },
    set$position: function(receiver, value) {
      this.setProperty$3(receiver, "position", value, "");
    },
    get$resize: function(receiver) {
      return this.getPropertyValue$1(receiver, "resize");
    },
    resize$2: function($receiver, arg0, arg1) {
      return this.get$resize($receiver).call$2(arg0, arg1);
    },
    resize$3: function($receiver, arg0, arg1, arg2) {
      return this.get$resize($receiver).call$3(arg0, arg1, arg2);
    },
    get$right: function(receiver) {
      return this.getPropertyValue$1(receiver, "right");
    },
    set$right: function(receiver, value) {
      this.setProperty$3(receiver, "right", value, "");
    },
    get$size: function(receiver) {
      return this.getPropertyValue$1(receiver, "size");
    },
    size$1: function($receiver, arg0) {
      return this.get$size($receiver).call$1(arg0);
    },
    set$size: function(receiver, value) {
      this.setProperty$3(receiver, "size", value, "");
    },
    set$src: function(receiver, value) {
      this.setProperty$3(receiver, "src", value, "");
    },
    set$tapHighlightColor: function(receiver, value) {
      this.setProperty$3(receiver, "tap-highlight-color", value, "");
    },
    get$top: function(receiver) {
      return this.getPropertyValue$1(receiver, "top");
    },
    set$top: function(receiver, value) {
      this.setProperty$3(receiver, "top", value, "");
    },
    get$transform: function(receiver) {
      return this.getPropertyValue$1(receiver, "transform");
    },
    transform$6: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5) {
      return this.get$transform($receiver).call$6(arg0, arg1, arg2, arg3, arg4, arg5);
    },
    set$userSelect: function(receiver, value) {
      this.setProperty$3(receiver, "user-select", value, "");
    },
    get$width: function(receiver) {
      return this.getPropertyValue$1(receiver, "width");
    },
    set$width: function(receiver, value) {
      this.setProperty$3(receiver, "width", value, "");
    },
    get$wordWrap: function(receiver) {
      return this.getPropertyValue$1(receiver, "word-wrap");
    },
    wordWrap$1: function($receiver, arg0) {
      return this.get$wordWrap($receiver).call$1(arg0);
    },
    set$wordWrap: function(receiver, value) {
      this.setProperty$3(receiver, "word-wrap", value, "");
    }
  },
  _ChildrenElementList: {
    "^": "ListBase;_element,_childElements",
    contains$1: [function(_, element) {
      return J.contains$1$asx(this._childElements, element);
    }, "call$1", "get$contains", 2, 0, 1677],
    get$isEmpty: function(_) {
      return this._element.firstElementChild == null;
    },
    get$length: function(_) {
      return this._childElements.length;
    },
    $index: function(_, index) {
      var t1 = this._childElements;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      var t1 = this._childElements;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      this._element.replaceChild(value, t1[index]);
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize element lists"));
    },
    add$1: [function(_, value) {
      this._element.appendChild(value);
      return value;
    }, "call$1", "get$add", 2, 0, 1708, 100, []],
    get$iterator: function(_) {
      var t1 = this.toList$0(this);
      return H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]);
    },
    addAll$1: function(_, iterable) {
      var t1, t2;
      for (t1 = J.get$iterator$ax(!!J.getInterceptor(iterable).$is_ChildNodeListLazy ? P.List_List$from(iterable, true, null) : iterable), t2 = this._element; t1.moveNext$0();)
        t2.appendChild(t1.get$current());
    },
    sort$1: function(_, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot sort element lists"));
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    remove$1: function(_, object) {
      var t1;
      if (!!J.getInterceptor(object).$isElement) {
        t1 = this._element;
        if (object.parentNode === t1) {
          t1.removeChild(object);
          return true;
        }
      }
      return false;
    },
    insert$2: function(_, index, element) {
      var t1, t2, t3;
      t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$gt(index, this._childElements.length))
        throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this)));
      t2 = this._childElements;
      t3 = this._element;
      if (t1.$eq(index, t2.length))
        t3.appendChild(element);
      else {
        if (index >>> 0 !== index || index >= t2.length)
          return H.ioore(t2, index);
        t3.insertBefore(element, t2[index]);
      }
    },
    clear$0: function(_) {
      J._clearChildren$0$x(this._element);
    },
    removeAt$1: function(_, index) {
      var t1, result;
      t1 = this._childElements;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      result = t1[index];
      this._element.removeChild(result);
      return result;
    },
    removeLast$0: function(_) {
      var result = this.get$last(this);
      if (result != null)
        this._element.removeChild(result);
      return result;
    },
    get$last: function(_) {
      var result = this._element.lastElementChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    $asListBase: function() {
      return [W.Element];
    },
    $asObject_ListMixin: function() {
      return [W.Element];
    },
    $asList: function() {
      return [W.Element];
    }
  },
  _FrozenElementList: {
    "^": "ListBase;_nodeList,_elementList",
    get$length: function(_) {
      return this._nodeList.length;
    },
    $index: function(_, index) {
      var t1 = this._nodeList;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify list"));
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify list"));
    },
    sort$1: function(_, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot sort list"));
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    get$last: function(_) {
      return C.NodeList_methods.get$last(this._nodeList);
    },
    get$style: function(_) {
      return W._CssStyleDeclarationSet$(this._elementList);
    },
    get$onBlur: function(_) {
      return C.EventStreamProvider_blur._forElementList$1(this);
    },
    get$onDragStart: function(_) {
      return C.EventStreamProvider_dragstart._forElementList$1(this);
    },
    get$onError: function(_) {
      return C.EventStreamProvider_error._forElementList$1(this);
    },
    onError$0: function($receiver) {
      return this.get$onError(this).call$0();
    },
    get$onFocus: function(_) {
      return C.EventStreamProvider_focus._forElementList$1(this);
    },
    get$onLoad: function(_) {
      return C.EventStreamProvider_load._forElementList$1(this);
    },
    get$onMouseDown: function(_) {
      return C.EventStreamProvider_mousedown._forElementList$1(this);
    },
    onMouseDown$1: function($receiver, arg0) {
      return this.get$onMouseDown(this).call$1(arg0);
    },
    get$onMouseMove: function(_) {
      return C.EventStreamProvider_mousemove._forElementList$1(this);
    },
    onMouseMove$1: function($receiver, arg0) {
      return this.get$onMouseMove(this).call$1(arg0);
    },
    get$onMouseOut: function(_) {
      return C.EventStreamProvider_mouseout._forElementList$1(this);
    },
    onMouseOut$1: function($receiver, arg0) {
      return this.get$onMouseOut(this).call$1(arg0);
    },
    get$onMouseOver: function(_) {
      return C.EventStreamProvider_mouseover._forElementList$1(this);
    },
    onMouseOver$1: function($receiver, arg0) {
      return this.get$onMouseOver(this).call$1(arg0);
    },
    get$onMouseUp: function(_) {
      return C.EventStreamProvider_mouseup._forElementList$1(this);
    },
    onMouseUp$1: function($receiver, arg0) {
      return this.get$onMouseUp(this).call$1(arg0);
    },
    get$onMouseWheel: function(_) {
      return C._CustomEventStreamProvider__determineMouseWheelEventType._forElementList$1(this);
    },
    onMouseWheel$1: function($receiver, arg0) {
      return this.get$onMouseWheel(this).call$1(arg0);
    },
    get$onTouchCancel: function(_) {
      return C.EventStreamProvider_touchcancel._forElementList$1(this);
    },
    onTouchCancel$1: function($receiver, arg0) {
      return this.get$onTouchCancel(this).call$1(arg0);
    },
    get$onTouchEnd: function(_) {
      return C.EventStreamProvider_touchend._forElementList$1(this);
    },
    onTouchEnd$1: function($receiver, arg0) {
      return this.get$onTouchEnd(this).call$1(arg0);
    },
    get$onTouchEnter: function(_) {
      return C.EventStreamProvider_touchenter._forElementList$1(this);
    },
    onTouchEnter$1: function($receiver, arg0) {
      return this.get$onTouchEnter(this).call$1(arg0);
    },
    get$onTouchLeave: function(_) {
      return C.EventStreamProvider_touchleave._forElementList$1(this);
    },
    onTouchLeave$1: function($receiver, arg0) {
      return this.get$onTouchLeave(this).call$1(arg0);
    },
    get$onTouchMove: function(_) {
      return C.EventStreamProvider_touchmove._forElementList$1(this);
    },
    onTouchMove$1: function($receiver, arg0) {
      return this.get$onTouchMove(this).call$1(arg0);
    },
    get$onTouchStart: function(_) {
      return C.EventStreamProvider_touchstart._forElementList$1(this);
    },
    onTouchStart$1: function($receiver, arg0) {
      return this.get$onTouchStart(this).call$1(arg0);
    },
    _html$_FrozenElementList$_wrap$1: function(_nodeList, $T) {
      var t1 = C.NodeList_methods.where$1(this._nodeList, new W._FrozenElementList$_wrap_closure());
      this._elementList = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    static: {_FrozenElementList$_wrap: function(_nodeList, $T) {
        var t1 = H.setRuntimeTypeInfo(new W._FrozenElementList(_nodeList, null), [$T]);
        t1._html$_FrozenElementList$_wrap$1(_nodeList, $T);
        return t1;
      }}
  },
  _FrozenElementList$_wrap_closure: {
    "^": "Closure:63;",
    call$1: function(e) {
      return !!J.getInterceptor(e).$isElement;
    },
    $isFunction: true
  },
  Events0: {
    "^": "Object;_ptr<",
    $index: function(_, type) {
      return H.setRuntimeTypeInfo(new W._EventStream(this.get$_ptr(), type, false), [null]);
    }
  },
  "+Events": 0,
  ElementEvents: {
    "^": "Events0;_ptr:html$ElementEvents$_ptr<,_ptr",
    $index: function(_, type) {
      var t1, t2;
      t1 = $.get$ElementEvents_webkitEvents();
      t2 = J.getInterceptor$s(type);
      if (t1.get$keys(t1).contains$1(0, t2.toLowerCase$0(type)))
        if (P.Device_isWebKit() === true)
          return H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(this.html$ElementEvents$_ptr, t1.$index(0, t2.toLowerCase$0(type)), false), [null]);
      return H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(this.html$ElementEvents$_ptr, type, false), [null]);
    },
    static: {"^": "ElementEvents_webkitEvents"}
  },
  Interceptor_ListMixin: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin_ImmutableListMixin: {
    "^": "Interceptor_ListMixin+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true
  },
  Navigator_getUserMedia_closure: {
    "^": "Closure:63;completer_0",
    call$1: [function(stream) {
      var t1 = this.completer_0.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(stream);
    }, "call$1", null, 2, 0, null, 1709, [], "call"],
    $isFunction: true
  },
  Navigator_getUserMedia_closure0: {
    "^": "Closure:63;completer_1",
    call$1: [function(error) {
      this.completer_1.completeError$1(error);
    }, "call$1", null, 2, 0, null, 556, [], "call"],
    $isFunction: true
  },
  _ChildNodeListLazy: {
    "^": "ListBase;_this",
    get$last: function(_) {
      var result = this._this.lastChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    add$1: [function(_, value) {
      this._this.appendChild(value);
    }, "call$1", "get$add", 2, 0, 1710, 100, []],
    addAll$1: function(_, iterable) {
      var t1, t2, len, i;
      t1 = J.getInterceptor(iterable);
      if (!!t1.$is_ChildNodeListLazy) {
        t1 = iterable._this;
        t2 = this._this;
        if (t1 !== t2)
          for (len = t1.childNodes.length, i = 0; i < len; ++i)
            t2.appendChild(t1.firstChild);
        return;
      }
      for (t1 = t1.get$iterator(iterable), t2 = this._this; t1.moveNext$0();)
        t2.appendChild(t1.get$current());
    },
    insert$2: function(_, index, node) {
      var t1, t2;
      t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$gt(index, this._this.childNodes.length))
        throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this)));
      t2 = this._this;
      if (t1.$eq(index, t2.childNodes.length))
        t2.appendChild(node);
      else {
        t1 = t2.childNodes;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        t2.insertBefore(node, t1[index]);
      }
    },
    removeLast$0: function(_) {
      var result = this.get$last(this);
      if (result != null)
        this._this.removeChild(result);
      return result;
    },
    removeAt$1: function(_, index) {
      var t1, t2, result;
      t1 = this._this;
      t2 = t1.childNodes;
      if (index >>> 0 !== index || index >= t2.length)
        return H.ioore(t2, index);
      result = t2[index];
      t1.removeChild(result);
      return result;
    },
    remove$1: function(_, object) {
      var t1;
      if (!J.getInterceptor(object).$isNode)
        return false;
      t1 = this._this;
      if (t1 !== object.parentNode)
        return false;
      t1.removeChild(object);
      return true;
    },
    clear$0: function(_) {
      J._clearChildren$0$x(this._this);
    },
    $indexSet: function(_, index, value) {
      var t1, t2;
      t1 = this._this;
      t2 = t1.childNodes;
      if (index >>> 0 !== index || index >= t2.length)
        return H.ioore(t2, index);
      t1.replaceChild(value, t2[index]);
    },
    get$iterator: function(_) {
      return C.NodeList_methods.get$iterator(this._this.childNodes);
    },
    sort$1: function(_, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot sort Node list"));
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot setRange on Node list"));
    },
    get$length: function(_) {
      return this._this.childNodes.length;
    },
    set$length: function(_, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot set length on immutable List."));
    },
    $index: function(_, index) {
      var t1 = this._this.childNodes;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $is_ChildNodeListLazy: true,
    $asListBase: function() {
      return [W.Node];
    },
    $asObject_ListMixin: function() {
      return [W.Node];
    },
    $asList: function() {
      return [W.Node];
    }
  },
  Interceptor_ListMixin0: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin_ImmutableListMixin0: {
    "^": "Interceptor_ListMixin0+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true
  },
  SelectElement_options_closure: {
    "^": "Closure:63;",
    call$1: function(e) {
      return !!J.getInterceptor(e).$isOptionElement;
    },
    $isFunction: true
  },
  Storage_addAll_closure: {
    "^": "Closure:935;this_0",
    call$2: [function(k, v) {
      this.this_0.setItem(k, v);
    }, "call$2", null, 4, 0, null, 377, [], 376, [], "call"],
    $isFunction: true
  },
  Storage_keys_closure: {
    "^": "Closure:935;keys_0",
    call$2: function(k, v) {
      return this.keys_0.push(k);
    },
    $isFunction: true
  },
  Storage_values_closure: {
    "^": "Closure:935;values_0",
    call$2: function(k, v) {
      return this.values_0.push(v);
    },
    $isFunction: true
  },
  Interceptor_ListMixin1: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Touch0];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin_ImmutableListMixin1: {
    "^": "Interceptor_ListMixin1+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Touch0];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin2: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin_ImmutableListMixin2: {
    "^": "Interceptor_ListMixin2+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true
  },
  _AttributeMap: {
    "^": "Object;",
    addAll$1: function(_, other) {
      J.forEach$1$ax(other, new W._AttributeMap_addAll_closure(this));
    },
    clear$0: function(_) {
      var t1;
      for (t1 = this.get$keys(this), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        this.remove$1(0, t1._current);
    },
    forEach$1: function(_, f) {
      var t1, key;
      for (t1 = this.get$keys(this), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        key = t1._current;
        f.call$2(key, this.$index(0, key));
      }
    },
    get$keys: function(_) {
      var attributes, keys, len, i;
      attributes = this._element.attributes;
      keys = H.setRuntimeTypeInfo([], [P.String]);
      for (len = attributes.length, i = 0; i < len; ++i) {
        if (i >= attributes.length)
          return H.ioore(attributes, i);
        if (this._matches$1(attributes[i])) {
          if (i >= attributes.length)
            return H.ioore(attributes, i);
          keys.push(J.get$name$x(attributes[i]));
        }
      }
      return keys;
    },
    get$values: function(_) {
      var attributes, values, len, i;
      attributes = this._element.attributes;
      values = H.setRuntimeTypeInfo([], [P.String]);
      for (len = attributes.length, i = 0; i < len; ++i) {
        if (i >= attributes.length)
          return H.ioore(attributes, i);
        if (this._matches$1(attributes[i])) {
          if (i >= attributes.length)
            return H.ioore(attributes, i);
          values.push(J.get$value$x(attributes[i]));
        }
      }
      return values;
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    $isMap: true,
    $asMap: function() {
      return [P.String, P.String];
    }
  },
  _AttributeMap_addAll_closure: {
    "^": "Closure:935;this_0",
    call$2: [function(k, v) {
      this.this_0.$indexSet(0, k, v);
    }, "call$2", null, 4, 0, null, 377, [], 376, [], "call"],
    $isFunction: true
  },
  _ElementAttributeMap: {
    "^": "_AttributeMap;_element",
    containsKey$1: function(_, key) {
      return this._element.hasAttribute(key);
    },
    $index: function(_, key) {
      return this._element.getAttribute(key);
    },
    $indexSet: function(_, key, value) {
      this._element.setAttribute(key, value);
    },
    remove$1: function(_, key) {
      var t1, value;
      t1 = this._element;
      value = t1.getAttribute(key);
      t1.removeAttribute(key);
      return value;
    },
    get$length: function(_) {
      return this.get$keys(this).length;
    },
    _matches$1: function(node) {
      return node.namespaceURI == null;
    }
  },
  _DataAttributeMap: {
    "^": "Object;_attributes",
    addAll$1: function(_, other) {
      J.forEach$1$ax(other, new W._DataAttributeMap_addAll_closure(this));
    },
    containsKey$1: function(_, key) {
      return this._attributes._element.hasAttribute("data-" + this._toHyphenedName$1(key));
    },
    $index: function(_, key) {
      return this._attributes._element.getAttribute("data-" + this._toHyphenedName$1(key));
    },
    $indexSet: function(_, key, value) {
      this._attributes._element.setAttribute("data-" + this._toHyphenedName$1(key), value);
    },
    remove$1: function(_, key) {
      var t1, t2, value;
      t1 = "data-" + this._toHyphenedName$1(key);
      t2 = this._attributes._element;
      value = t2.getAttribute(t1);
      t2.removeAttribute(t1);
      return value;
    },
    clear$0: function(_) {
      var t1, t2, t3;
      for (t1 = this.get$keys(this), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this._attributes._element; t1.moveNext$0();) {
        t3 = "data-" + this._toHyphenedName$1(t1._current);
        t2.getAttribute(t3);
        t2.removeAttribute(t3);
      }
    },
    forEach$1: function(_, f) {
      this._attributes.forEach$1(0, new W._DataAttributeMap_forEach_closure(this, f));
    },
    get$keys: function(_) {
      var keys = H.setRuntimeTypeInfo([], [P.String]);
      this._attributes.forEach$1(0, new W._DataAttributeMap_keys_closure(this, keys));
      return keys;
    },
    get$values: function(_) {
      var values = H.setRuntimeTypeInfo([], [P.String]);
      this._attributes.forEach$1(0, new W._DataAttributeMap_values_closure(this, values));
      return values;
    },
    get$length: function(_) {
      return this.get$keys(this).length;
    },
    get$isEmpty: function(_) {
      return this.get$keys(this).length === 0;
    },
    _toCamelCase$2$startUppercase: function(hyphenedName, startUppercase) {
      var segments, start, i, segment, t1;
      segments = hyphenedName.split("-");
      start = startUppercase ? 0 : 1;
      for (i = start; i < segments.length; ++i) {
        segment = segments[i];
        t1 = J.getInterceptor$asx(segment);
        if (J.$gt$n(t1.get$length(segment), 0)) {
          t1 = J.toUpperCase$0$s(t1.$index(segment, 0)) + t1.substring$1(segment, 1);
          if (i >= segments.length)
            return H.ioore(segments, i);
          segments[i] = t1;
        }
      }
      return C.JSArray_methods.join$1(segments, "");
    },
    _toCamelCase$1: function(hyphenedName) {
      return this._toCamelCase$2$startUppercase(hyphenedName, false);
    },
    _toHyphenedName$1: function(word) {
      var sb, t1, i, t2, lower;
      sb = P.StringBuffer$("");
      t1 = J.getInterceptor$asx(word);
      i = 0;
      while (true) {
        t2 = t1.get$length(word);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        lower = J.toLowerCase$0$s(t1.$index(word, i));
        if (!J.$eq(t1.$index(word, i), lower) && i > 0)
          sb._contents += "-";
        sb._contents += lower;
        ++i;
      }
      return sb._contents;
    },
    $isMap: true,
    $asMap: function() {
      return [P.String, P.String];
    }
  },
  _DataAttributeMap_addAll_closure: {
    "^": "Closure:935;this_0",
    call$2: [function(k, v) {
      var t1 = this.this_0;
      t1._attributes._element.setAttribute("data-" + t1._toHyphenedName$1(k), v);
    }, "call$2", null, 4, 0, null, 377, [], 376, [], "call"],
    $isFunction: true
  },
  _DataAttributeMap_forEach_closure: {
    "^": "Closure:743;this_0,f_1",
    call$2: function(key, value) {
      var t1 = J.getInterceptor$s(key);
      if (t1.startsWith$1(key, "data-"))
        this.f_1.call$2(this.this_0._toCamelCase$1(t1.substring$1(key, 5)), value);
    },
    $isFunction: true
  },
  _DataAttributeMap_keys_closure: {
    "^": "Closure:743;this_0,keys_1",
    call$2: function(key, value) {
      var t1 = J.getInterceptor$s(key);
      if (t1.startsWith$1(key, "data-"))
        this.keys_1.push(this.this_0._toCamelCase$1(t1.substring$1(key, 5)));
    },
    $isFunction: true
  },
  _DataAttributeMap_values_closure: {
    "^": "Closure:743;this_0,values_1",
    call$2: function(key, value) {
      if (J.startsWith$1$s(key, "data-"))
        this.values_1.push(value);
    },
    $isFunction: true
  },
  CanvasImageSource: {
    "^": "Object;"
  },
  EventStreamProvider: {
    "^": "Object;_eventType",
    forTarget$2$useCapture: function(e, useCapture) {
      return H.setRuntimeTypeInfo(new W._EventStream(e, this._eventType, useCapture), [null]);
    },
    forTarget$1: function(e) {
      return this.forTarget$2$useCapture(e, false);
    },
    forElement$2$useCapture: function(e, useCapture) {
      return H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(e, this._eventType, useCapture), [null]);
    },
    forElement$1: function(e) {
      return this.forElement$2$useCapture(e, false);
    },
    _forElementList$2$useCapture: function(e, useCapture) {
      return H.setRuntimeTypeInfo(new W._ElementListEventStreamImpl(e, useCapture, this._eventType), [null]);
    },
    _forElementList$1: function(e) {
      return this._forElementList$2$useCapture(e, false);
    }
  },
  _EventStream: {
    "^": "Stream;_target,_eventType,_useCapture",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1 = new W._EventStreamSubscription(0, this._target, this._eventType, W._wrapZone(onData), this._useCapture);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      t1._tryResume$0();
      return t1;
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    }
  },
  _ElementEventStreamImpl: {
    "^": "_EventStream;_target,_eventType,_useCapture",
    capture$1: [function(onData) {
      var t1 = new W._EventStreamSubscription(0, this._target, this._eventType, W._wrapZone(onData), true);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      t1._tryResume$0();
      return t1;
    }, "call$1", "get$capture", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "StreamSubscription__void__T", ret: [P.StreamSubscription, T], args: [{func: "void__T0", void: true, args: [T]}]};
      }, this.$receiver, "_ElementEventStreamImpl");
    }],
    $isStream: true
  },
  _ElementListEventStreamImpl: {
    "^": "Stream;_targetList,_useCapture,_eventType",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var pool, t1, t2, t3, t4;
      pool = W._StreamPool$broadcast(null);
      for (t1 = this._targetList, t1 = t1.get$iterator(t1), t2 = this._eventType, t3 = this._useCapture; t1.moveNext$0();) {
        t4 = new W._EventStream(t1._current, t2, t3);
        t4.$builtinTypeInfo = [null];
        pool.add$1(0, t4);
      }
      t1 = pool._controller;
      t1.toString;
      return H.setRuntimeTypeInfo(new P._BroadcastStream(t1), [H.getTypeArgumentByIndex(t1, 0)]).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    capture$1: [function(onData) {
      var pool, t1, t2, t3;
      pool = W._StreamPool$broadcast(null);
      for (t1 = this._targetList, t1 = t1.get$iterator(t1), t2 = this._eventType; t1.moveNext$0();) {
        t3 = new W._EventStream(t1._current, t2, true);
        t3.$builtinTypeInfo = [null];
        pool.add$1(0, t3);
      }
      t1 = pool._controller;
      t1.toString;
      return H.setRuntimeTypeInfo(new P._BroadcastStream(t1), [H.getTypeArgumentByIndex(t1, 0)]).listen$1(onData);
    }, "call$1", "get$capture", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "StreamSubscription__void__T0", ret: [P.StreamSubscription, T], args: [{func: "void__T1", void: true, args: [T]}]};
      }, this.$receiver, "_ElementListEventStreamImpl");
    }],
    $isStream: true
  },
  _EventStreamSubscription: {
    "^": "StreamSubscription;_pauseCount,_target,_eventType,_onData,_useCapture",
    cancel$0: function() {
      if (this._target == null)
        return;
      this._unlisten$0();
      this._target = null;
      this._onData = null;
      return;
    },
    onError$1: [function(_, handleError) {
    }, "call$1", "get$onError", 2, 0, 1694],
    pause$1: function(_, resumeSignal) {
      if (this._target == null)
        return;
      ++this._pauseCount;
      this._unlisten$0();
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    get$isPaused: function() {
      return this._pauseCount > 0;
    },
    resume$0: function() {
      if (this._target == null || this._pauseCount <= 0)
        return;
      --this._pauseCount;
      this._tryResume$0();
    },
    _tryResume$0: function() {
      var t1 = this._onData;
      if (t1 != null && this._pauseCount <= 0)
        J.addEventListener$3$x(this._target, this._eventType, t1, this._useCapture);
    },
    _unlisten$0: function() {
      var t1 = this._onData;
      if (t1 != null)
        J.removeEventListener$3$x(this._target, this._eventType, t1, this._useCapture);
    }
  },
  _StreamPool: {
    "^": "Object;_controller,_subscriptions",
    add$1: [function(_, stream) {
      var t1, t2;
      t1 = this._subscriptions;
      if (t1.containsKey$1(0, stream))
        return;
      t2 = this._controller;
      t1.$indexSet(0, stream, stream.listen$3$onDone$onError(t2.get$add(t2), new W._StreamPool_add_closure(this, stream), this._controller.get$addError()));
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "void__Stream", void: true, args: [[P.Stream, T]]};
      }, this.$receiver, "_StreamPool");
    }, 1709, []],
    remove$1: function(_, stream) {
      var subscription = this._subscriptions.remove$1(0, stream);
      if (subscription != null)
        subscription.cancel$0();
    },
    close$0: [function(_) {
      var t1, t2;
      for (t1 = this._subscriptions, t2 = t1.get$values(t1), t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t2._iterable), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();)
        t2._current.cancel$0();
      t1.clear$0(0);
      this._controller.close$0(0);
    }, "call$0", "get$close", 0, 0, 550],
    _html$_StreamPool$broadcast$0: function($T) {
      var t1 = this.get$close(this);
      t1 = H.setRuntimeTypeInfo(new P._SyncBroadcastStreamController(null, t1, 0, null, null, null, null), [$T]);
      t1._async$_previous = t1;
      t1._async$_next = t1;
      this._controller = t1;
    },
    static: {_StreamPool$broadcast: function($T) {
        var t1 = H.setRuntimeTypeInfo(new W._StreamPool(null, P.LinkedHashMap_LinkedHashMap(null, null, null, [P.Stream, $T], [P.StreamSubscription, $T])), [$T]);
        t1._html$_StreamPool$broadcast$0($T);
        return t1;
      }}
  },
  _StreamPool_add_closure: {
    "^": "Closure:13;this_0,stream_1",
    call$0: [function() {
      return this.this_0.remove$1(0, this.stream_1);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _CustomEventStreamProvider: {
    "^": "Object;_eventTypeGetter",
    _eventTypeGetter$1: function(arg0) {
      return this._eventTypeGetter.call$1(arg0);
    },
    forTarget$2$useCapture: function(e, useCapture) {
      return H.setRuntimeTypeInfo(new W._EventStream(e, this._eventTypeGetter$1(e), useCapture), [null]);
    },
    forTarget$1: function(e) {
      return this.forTarget$2$useCapture(e, false);
    },
    forElement$2$useCapture: function(e, useCapture) {
      return H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(e, this._eventTypeGetter$1(e), useCapture), [null]);
    },
    forElement$1: function(e) {
      return this.forElement$2$useCapture(e, false);
    },
    _forElementList$2$useCapture: function(e, useCapture) {
      return H.setRuntimeTypeInfo(new W._ElementListEventStreamImpl(e, useCapture, this._eventTypeGetter$1(e)), [null]);
    },
    _forElementList$1: function(e) {
      return this._forElementList$2$useCapture(e, false);
    }
  },
  ImmutableListMixin: {
    "^": "Object;",
    get$iterator: function(receiver) {
      return H.setRuntimeTypeInfo(new W.FixedSizeListIterator(receiver, this.get$length(receiver), -1, null), [H.getRuntimeTypeArgument(receiver, "ImmutableListMixin", 0)]);
    },
    add$1: [function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E5", void: true, args: [E]};
      }, this.$receiver, "ImmutableListMixin");
    }, 100, []],
    addAll$1: function(receiver, iterable) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
    },
    sort$1: function(receiver, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot sort immutable List."));
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    insert$2: function(receiver, index, element) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
    },
    removeAt$1: function(receiver, pos) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from immutable List."));
    },
    removeLast$0: function(receiver) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from immutable List."));
    },
    remove$1: function(receiver, object) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from immutable List."));
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot setRange on immutable List."));
    },
    removeRange$2: function(receiver, start, end) {
      throw H.wrapException(P.UnsupportedError$("Cannot removeRange on immutable List."));
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  _WrappedList: {
    "^": "ListBase;_list",
    get$iterator: function(_) {
      return H.setRuntimeTypeInfo(new W._WrappedIterator(J.get$iterator$ax(this._list)), [null]);
    },
    get$length: function(_) {
      return this._list.length;
    },
    add$1: [function(_, element) {
      J.add$1$ax(this._list, element);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E6", void: true, args: [E]};
      }, this.$receiver, "_WrappedList");
    }, 432, []],
    remove$1: function(_, element) {
      return J.remove$1$ax(this._list, element);
    },
    clear$0: function(_) {
      J.clear$0$ax(this._list);
    },
    $index: function(_, index) {
      var t1 = this._list;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      var t1 = this._list;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      t1[index] = value;
    },
    set$length: function(_, newLength) {
      J.set$length$asx(this._list, newLength);
    },
    sort$1: function(_, compare) {
      J.sort$1$ax(this._list, compare);
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    indexOf$2: function(_, element, start) {
      return J.indexOf$2$asx(this._list, element, start);
    },
    indexOf$1: function($receiver, element) {
      return this.indexOf$2($receiver, element, 0);
    },
    insert$2: function(_, index, element) {
      return J.insert$2$ax(this._list, index, element);
    },
    removeAt$1: function(_, index) {
      return J.removeAt$1$ax(this._list, index);
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      J.setRange$4$ax(this._list, start, end, iterable, skipCount);
    },
    removeRange$2: function(_, start, end) {
      J.removeRange$2$ax(this._list, start, end);
    }
  },
  _WrappedIterator: {
    "^": "Object;_html$_iterator",
    moveNext$0: function() {
      return this._html$_iterator.moveNext$0();
    },
    get$current: function() {
      return this._html$_iterator._html$_current;
    }
  },
  FixedSizeListIterator: {
    "^": "Object;_array,_html$_length,_position,_html$_current",
    moveNext$0: function() {
      var nextPosition, t1;
      nextPosition = this._position + 1;
      t1 = this._html$_length;
      if (nextPosition < t1) {
        this._html$_current = J.$index$asx(this._array, nextPosition);
        this._position = nextPosition;
        return true;
      }
      this._html$_current = null;
      this._position = t1;
      return false;
    },
    get$current: function() {
      return this._html$_current;
    }
  },
  _DOMWindowCrossFrame: {
    "^": "Object;_window",
    get$parent: function(_) {
      return W._DOMWindowCrossFrame__createSafe(this._window.parent);
    },
    get$top: function(_) {
      return W._DOMWindowCrossFrame__createSafe(this._window.top);
    },
    get$on: function(_) {
      return H.throwExpression(P.UnsupportedError$("You can only attach EventListeners to your own window."));
    },
    addEventListener$3: function(_, type, listener, useCapture) {
      return H.throwExpression(P.UnsupportedError$("You can only attach EventListeners to your own window."));
    },
    addEventListener$2: function($receiver, type, listener) {
      return this.addEventListener$3($receiver, type, listener, null);
    },
    dispatchEvent$1: function(_, $event) {
      return H.throwExpression(P.UnsupportedError$("You can only attach EventListeners to your own window."));
    },
    removeEventListener$3: function(_, type, listener, useCapture) {
      return H.throwExpression(P.UnsupportedError$("You can only attach EventListeners to your own window."));
    },
    removeEventListener$2: function($receiver, type, listener) {
      return this.removeEventListener$3($receiver, type, listener, null);
    },
    $isEventTarget: true,
    static: {_DOMWindowCrossFrame__createSafe: function(w) {
        if (w === window)
          return w;
        else
          return new W._DOMWindowCrossFrame(w);
      }}
  }
}],
["dart.dom.indexed_db", "dart:indexed_db", , P, {
  "^": "",
  KeyRange: {
    "^": "Interceptor;",
    $isKeyRange: true,
    "%": "IDBKeyRange"
  }
}],
["dart.dom.svg", "dart:svg", , P, {
  "^": "",
  AElement: {
    "^": "GraphicsElement;target=",
    "%": "SVGAElement"
  },
  AltGlyphElement: {
    "^": "TextPositioningElement;format%",
    "%": "SVGAltGlyphElement"
  },
  CircleElement: {
    "^": "GeometryElement;r=",
    "%": "SVGCircleElement"
  },
  FEBlendElement: {
    "^": "SvgElement;mode=,height=,width=,x=,y=",
    "%": "SVGFEBlendElement"
  },
  FEColorMatrixElement: {
    "^": "SvgElement;type=,values=,height=,width=,x=,y=",
    "%": "SVGFEColorMatrixElement"
  },
  FEComponentTransferElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEComponentTransferElement"
  },
  FECompositeElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFECompositeElement"
  },
  FEConvolveMatrixElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEConvolveMatrixElement"
  },
  FEDiffuseLightingElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEDiffuseLightingElement"
  },
  FEDisplacementMapElement: {
    "^": "SvgElement;scale=,height=,width=,x=,y=",
    scale$2: function($receiver, arg0, arg1) {
      return $receiver.scale.call$2(arg0, arg1);
    },
    "%": "SVGFEDisplacementMapElement"
  },
  FEFloodElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEFloodElement"
  },
  FEGaussianBlurElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEGaussianBlurElement"
  },
  FEImageElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEImageElement"
  },
  FEMergeElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEMergeElement"
  },
  FEMorphologyElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEMorphologyElement"
  },
  FEOffsetElement: {
    "^": "SvgElement;dx=,dy=,height=,width=,x=,y=",
    "%": "SVGFEOffsetElement"
  },
  FEPointLightElement: {
    "^": "SvgElement;x=,y=,z=",
    "%": "SVGFEPointLightElement"
  },
  FESpecularLightingElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFESpecularLightingElement"
  },
  FESpotLightElement: {
    "^": "SvgElement;x=,y=,z=",
    "%": "SVGFESpotLightElement"
  },
  FETileElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFETileElement"
  },
  FETurbulenceElement: {
    "^": "SvgElement;type=,height=,width=,x=,y=",
    "%": "SVGFETurbulenceElement"
  },
  FilterElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFilterElement"
  },
  ForeignObjectElement: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    "%": "SVGForeignObjectElement"
  },
  GeometryElement: {
    "^": "GraphicsElement;",
    "%": "SVGEllipseElement|SVGPathElement;SVGGeometryElement"
  },
  GraphicsElement: {
    "^": "SvgElement;",
    transform$6: function($receiver, arg0, arg1, arg2, arg3, arg4, arg5) {
      return $receiver.transform.call$6(arg0, arg1, arg2, arg3, arg4, arg5);
    },
    "%": "SVGClipPathElement|SVGDefsElement|SVGGElement|SVGSwitchElement;SVGGraphicsElement"
  },
  ImageElement0: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    "%": "SVGImageElement"
  },
  LineElement: {
    "^": "GeometryElement;x1=,x2=,y1=,y2=",
    "%": "SVGLineElement"
  },
  LinearGradientElement: {
    "^": "_GradientElement;x1=,x2=,y1=,y2=",
    "%": "SVGLinearGradientElement"
  },
  MaskElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGMaskElement"
  },
  PatternElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGPatternElement"
  },
  PointList: {
    "^": "Interceptor;",
    clear$0: function(receiver) {
      return receiver.clear();
    },
    "%": "SVGPointList"
  },
  PolygonElement: {
    "^": "GeometryElement;points=",
    "%": "SVGPolygonElement"
  },
  PolylineElement: {
    "^": "GeometryElement;points=",
    "%": "SVGPolylineElement"
  },
  RadialGradientElement: {
    "^": "_GradientElement;r=",
    "%": "SVGRadialGradientElement"
  },
  Rect: {
    "^": "Interceptor;height%,width%,x%,y%",
    "%": "SVGRect"
  },
  RectElement: {
    "^": "GeometryElement;height=,width=,x=,y=",
    "%": "SVGRectElement"
  },
  ScriptElement0: {
    "^": "SvgElement;type%",
    "%": "SVGScriptElement"
  },
  StyleElement0: {
    "^": "SvgElement;disabled%,type%",
    "%": "SVGStyleElement"
  },
  SvgElement: {
    "^": "Element;",
    get$children: function(receiver) {
      return H.setRuntimeTypeInfo(new P.FilteredElementList(receiver, new W._ChildNodeListLazy(receiver)), [W.Element]);
    },
    set$children: function(receiver, value) {
      var children = H.setRuntimeTypeInfo(new P.FilteredElementList(receiver, new W._ChildNodeListLazy(receiver)), [W.Element]);
      J._clearChildren$0$x(children._childNodes._this);
      children.addAll$1(0, value);
    },
    click$0: [function(receiver) {
      throw H.wrapException(P.UnsupportedError$("Cannot invoke click SVG."));
    }, "call$0", "get$click", 0, 0, 550],
    get$onBlur: function(receiver) {
      return C.EventStreamProvider_blur.forElement$1(receiver);
    },
    get$onDragStart: function(receiver) {
      return C.EventStreamProvider_dragstart.forElement$1(receiver);
    },
    get$onError: function(receiver) {
      return C.EventStreamProvider_error.forElement$1(receiver);
    },
    onError$0: function($receiver) {
      return this.get$onError($receiver).call$0();
    },
    get$onFocus: function(receiver) {
      return C.EventStreamProvider_focus.forElement$1(receiver);
    },
    get$onLoad: function(receiver) {
      return C.EventStreamProvider_load.forElement$1(receiver);
    },
    get$onMouseDown: function(receiver) {
      return C.EventStreamProvider_mousedown.forElement$1(receiver);
    },
    onMouseDown$1: function($receiver, arg0) {
      return this.get$onMouseDown($receiver).call$1(arg0);
    },
    get$onMouseMove: function(receiver) {
      return C.EventStreamProvider_mousemove.forElement$1(receiver);
    },
    onMouseMove$1: function($receiver, arg0) {
      return this.get$onMouseMove($receiver).call$1(arg0);
    },
    get$onMouseOut: function(receiver) {
      return C.EventStreamProvider_mouseout.forElement$1(receiver);
    },
    onMouseOut$1: function($receiver, arg0) {
      return this.get$onMouseOut($receiver).call$1(arg0);
    },
    get$onMouseOver: function(receiver) {
      return C.EventStreamProvider_mouseover.forElement$1(receiver);
    },
    onMouseOver$1: function($receiver, arg0) {
      return this.get$onMouseOver($receiver).call$1(arg0);
    },
    get$onMouseUp: function(receiver) {
      return C.EventStreamProvider_mouseup.forElement$1(receiver);
    },
    onMouseUp$1: function($receiver, arg0) {
      return this.get$onMouseUp($receiver).call$1(arg0);
    },
    get$onMouseWheel: function(receiver) {
      return C.EventStreamProvider_mousewheel.forElement$1(receiver);
    },
    onMouseWheel$1: function($receiver, arg0) {
      return this.get$onMouseWheel($receiver).call$1(arg0);
    },
    get$onPause: function(receiver) {
      return C.EventStreamProvider_pause.forElement$1(receiver);
    },
    get$onPlay: function(receiver) {
      return C.EventStreamProvider_play.forElement$1(receiver);
    },
    $isEventTarget: true,
    "%": "SVGAltGlyphDefElement|SVGAltGlyphItemElement|SVGAnimateElement|SVGAnimateMotionElement|SVGAnimateTransformElement|SVGAnimationElement|SVGComponentTransferFunctionElement|SVGCursorElement|SVGDescElement|SVGDiscardElement|SVGFEDistantLightElement|SVGFEDropShadowElement|SVGFEFuncAElement|SVGFEFuncBElement|SVGFEFuncGElement|SVGFEFuncRElement|SVGFEMergeNodeElement|SVGFontElement|SVGFontFaceElement|SVGFontFaceFormatElement|SVGFontFaceNameElement|SVGFontFaceSrcElement|SVGFontFaceUriElement|SVGGlyphElement|SVGGlyphRefElement|SVGHKernElement|SVGMPathElement|SVGMarkerElement|SVGMetadataElement|SVGMissingGlyphElement|SVGSetElement|SVGStopElement|SVGSymbolElement|SVGTitleElement|SVGVKernElement|SVGViewElement;SVGElement"
  },
  SvgSvgElement: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    viewport$4: function($receiver, arg0, arg1, arg2, arg3) {
      return $receiver.viewport.call$4(arg0, arg1, arg2, arg3);
    },
    "%": "SVGSVGElement"
  },
  TextContentElement: {
    "^": "GraphicsElement;",
    "%": "SVGTextPathElement;SVGTextContentElement"
  },
  TextPositioningElement: {
    "^": "TextContentElement;dx=,dy=,rotate=,x=,y=",
    rotate$5: function($receiver, arg0, arg1, arg2, arg3, arg4) {
      return $receiver.rotate.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    "%": "SVGTSpanElement|SVGTextElement;SVGTextPositioningElement"
  },
  UseElement: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    "%": "SVGUseElement"
  },
  _GradientElement: {
    "^": "SvgElement;",
    "%": ";SVGGradientElement"
  }
}],
["dart.dom.web_audio", "dart:web_audio", , P, {
  "^": "",
  AudioBuffer: {
    "^": "Interceptor;duration=,length=",
    $isAudioBuffer: true,
    "%": "AudioBuffer"
  },
  AudioBufferSourceNode: {
    "^": "AudioSourceNode;buffer%,loop%",
    start$3: [function(receiver, when, grainOffset, grainDuration) {
      if (!!receiver.start)
        if (grainDuration != null)
          receiver.start(when, grainOffset, grainDuration);
        else if (grainOffset != null)
          receiver.start(when, grainOffset);
        else
          receiver.start(when);
      else if (grainDuration != null)
        receiver.noteOn(when, grainOffset, grainDuration);
      else if (grainOffset != null)
        receiver.noteOn(when, grainOffset);
      else
        receiver.noteOn(when);
    }, function($receiver, when) {
      return this.start$3($receiver, when, null, null);
    }, "start$1", function($receiver, when, grainOffset) {
      return this.start$3($receiver, when, grainOffset, null);
    }, "start$2", "call$3", "call$1", "call$2", "get$start", 2, 4, 579, 32, 32, 580, [], 581, [], 582, []],
    stop$1: [function(receiver, when) {
      if (!!receiver.stop)
        receiver.stop(when);
      else
        receiver.noteOff(when);
    }, "call$1", "get$stop", 2, 0, 569],
    loop$0: function($receiver) {
      return $receiver.loop.call$0();
    },
    loop$3: function($receiver, arg0, arg1, arg2) {
      return $receiver.loop.call$3(arg0, arg1, arg2);
    },
    noteGrainOn$3: function(receiver, when, grainOffset, grainDuration) {
      return receiver.noteGrainOn(when, grainOffset, grainDuration);
    },
    noteOff$1: function(receiver, when) {
      return receiver.noteOff(when);
    },
    noteOn$1: function(receiver, when) {
      return receiver.noteOn(when);
    },
    "%": "AudioBufferSourceNode"
  },
  AudioContext: {
    "^": "EventTarget;currentTime=,destination=",
    createBuffer$3: function(receiver, numberOfChannels, numberOfFrames, sampleRate) {
      return receiver.createBuffer(numberOfChannels, numberOfFrames, sampleRate);
    },
    createBufferSource$0: function(receiver) {
      return receiver.createBufferSource();
    },
    _decodeAudioData$3: function(receiver, audioData, successCallback, errorCallback) {
      return receiver.decodeAudioData(audioData, H.convertDartClosureToJS(successCallback, 1), H.convertDartClosureToJS(errorCallback, 1));
    },
    get$onComplete: function(receiver) {
      return C.EventStreamProvider_complete.forTarget$1(receiver);
    },
    createGain$0: function(receiver) {
      if (receiver.createGain !== undefined)
        return receiver.createGain();
      else
        return receiver.createGainNode();
    },
    decodeAudioData$1: function(receiver, audioData) {
      var t1, completer;
      t1 = P.AudioBuffer;
      completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t1)), [t1]);
      this._decodeAudioData$3(receiver, audioData, new P.AudioContext_decodeAudioData_closure(completer), new P.AudioContext_decodeAudioData_closure0(completer));
      return completer.future;
    },
    "%": "AudioContext|OfflineAudioContext|webkitAudioContext"
  },
  AudioNode: {
    "^": "EventTarget;context=",
    connectNode$3: function(receiver, destination, output, input) {
      return receiver.connect(destination, output, input);
    },
    connectNode$1: function($receiver, destination) {
      return this.connectNode$3($receiver, destination, 0, 0);
    },
    "%": "AudioDestinationNode;AudioNode"
  },
  AudioParam: {
    "^": "Interceptor;defaultValue=,name=,value%",
    "%": "AudioParam"
  },
  AudioSourceNode: {
    "^": "AudioNode;",
    "%": ";AudioSourceNode"
  },
  GainNode: {
    "^": "AudioNode;gain=",
    "%": "AudioGainNode|GainNode"
  },
  AudioContext_decodeAudioData_closure: {
    "^": "Closure:63;completer_0",
    call$1: [function(value) {
      var t1 = this.completer_0.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(value);
    }, "call$1", null, 2, 0, null, 100, [], "call"],
    $isFunction: true
  },
  AudioContext_decodeAudioData_closure0: {
    "^": "Closure:63;completer_1",
    call$1: [function(error) {
      var t1 = this.completer_1;
      if (error == null)
        t1.completeError$1("");
      else
        t1.completeError$1(error);
    }, "call$1", null, 2, 0, null, 556, [], "call"],
    $isFunction: true
  }
}],
["dart.dom.web_gl", "dart:web_gl", , P, {
  "^": "",
  ContextEvent: {
    "^": "Event;",
    $isContextEvent: true,
    "%": "WebGLContextEvent"
  },
  RenderingContext: {
    "^": "CanvasRenderingContext;",
    activeTexture$1: function(receiver, texture) {
      return receiver.activeTexture(texture);
    },
    attachShader$2: function(receiver, program, shader) {
      return receiver.attachShader(program, shader);
    },
    bindBuffer$2: function(receiver, target, buffer) {
      return receiver.bindBuffer(target, buffer);
    },
    bindFramebuffer$2: function(receiver, target, framebuffer) {
      return receiver.bindFramebuffer(target, framebuffer);
    },
    bindRenderbuffer$2: function(receiver, target, renderbuffer) {
      return receiver.bindRenderbuffer(target, renderbuffer);
    },
    bindTexture$2: function(receiver, target, texture) {
      return receiver.bindTexture(target, texture);
    },
    blendFunc$2: function(receiver, sfactor, dfactor) {
      return receiver.blendFunc(sfactor, dfactor);
    },
    bufferData$3: function(receiver, target, data_OR_size, usage) {
      return receiver.bufferData(target, data_OR_size, usage);
    },
    bufferSubData$3: function(receiver, target, offset, data) {
      return receiver.bufferSubData(target, offset, data);
    },
    clear$1: function(receiver, mask) {
      return receiver.clear(mask);
    },
    clearColor$4: function(receiver, red, green, blue, alpha) {
      return receiver.clearColor(red, green, blue, alpha);
    },
    colorMask$4: function(receiver, red, green, blue, alpha) {
      return receiver.colorMask(red, green, blue, alpha);
    },
    compileShader$1: function(receiver, shader) {
      return receiver.compileShader(shader);
    },
    createBuffer$0: function(receiver) {
      return receiver.createBuffer();
    },
    createFramebuffer$0: function(receiver) {
      return receiver.createFramebuffer();
    },
    createProgram$0: function(receiver) {
      return receiver.createProgram();
    },
    createRenderbuffer$0: function(receiver) {
      return receiver.createRenderbuffer();
    },
    createShader$1: function(receiver, type) {
      return receiver.createShader(type);
    },
    createTexture$0: function(receiver) {
      return receiver.createTexture();
    },
    deleteBuffer$1: function(receiver, buffer) {
      return receiver.deleteBuffer(buffer);
    },
    deleteFramebuffer$1: function(receiver, framebuffer) {
      return receiver.deleteFramebuffer(framebuffer);
    },
    deleteProgram$1: function(receiver, program) {
      return receiver.deleteProgram(program);
    },
    deleteTexture$1: function(receiver, texture) {
      return receiver.deleteTexture(texture);
    },
    disable$1: function(receiver, cap) {
      return receiver.disable(cap);
    },
    disableVertexAttribArray$1: function(receiver, index) {
      return receiver.disableVertexAttribArray(index);
    },
    drawElements$4: function(receiver, mode, count, type, offset) {
      return receiver.drawElements(mode, count, type, offset);
    },
    enable$1: [function(receiver, cap) {
      return receiver.enable(cap);
    }, "call$1", "get$enable", 2, 0, 583],
    enableVertexAttribArray$1: function(receiver, index) {
      return receiver.enableVertexAttribArray(index);
    },
    flush$0: function(receiver) {
      return receiver.flush();
    },
    framebufferRenderbuffer$4: function(receiver, target, attachment, renderbuffertarget, renderbuffer) {
      return receiver.framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
    },
    framebufferTexture2D$5: function(receiver, target, attachment, textarget, texture, level) {
      return receiver.framebufferTexture2D(target, attachment, textarget, texture, level);
    },
    getAttribLocation$2: function(receiver, program, $name) {
      return receiver.getAttribLocation(program, $name);
    },
    getProgramParameter$2: function(receiver, program, pname) {
      return receiver.getProgramParameter(program, pname);
    },
    getShaderInfoLog$1: function(receiver, shader) {
      return receiver.getShaderInfoLog(shader);
    },
    getShaderParameter$2: function(receiver, shader, pname) {
      return receiver.getShaderParameter(shader, pname);
    },
    getUniformLocation$2: function(receiver, program, $name) {
      return receiver.getUniformLocation(program, $name);
    },
    lineWidth$1: [function(receiver, width) {
      return receiver.lineWidth(width);
    }, "call$1", "get$lineWidth", 2, 0, 569, 10, []],
    linkProgram$1: function(receiver, program) {
      return receiver.linkProgram(program);
    },
    pixelStorei$2: function(receiver, pname, param) {
      return receiver.pixelStorei(pname, param);
    },
    renderbufferStorage$4: function(receiver, target, internalformat, width, height) {
      return receiver.renderbufferStorage(target, internalformat, width, height);
    },
    shaderSource$2: function(receiver, shader, string) {
      return receiver.shaderSource(shader, string);
    },
    stencilFunc$3: function(receiver, func, ref, mask) {
      return receiver.stencilFunc(func, ref, mask);
    },
    stencilOp$3: function(receiver, fail, zfail, zpass) {
      return receiver.stencilOp(fail, zfail, zpass);
    },
    texImage2D$9: function(receiver, target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels) {
      var t1 = J.getInterceptor(border_OR_canvas_OR_image_OR_pixels_OR_video);
      if ((!!t1.$isImageData || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && format == null && type == null && true) {
        receiver.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, P.convertDartToNative_ImageData(border_OR_canvas_OR_image_OR_pixels_OR_video));
        return;
      }
      if ((!!t1.$isImageElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && format == null && type == null && true) {
        receiver.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
        return;
      }
      if ((!!t1.$isCanvasElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && format == null && type == null && true) {
        receiver.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
        return;
      }
      if ((!!t1.$isVideoElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && format == null && type == null && true) {
        receiver.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
        return;
      }
      throw H.wrapException(P.ArgumentError$("Incorrect number or type of arguments"));
    },
    texImage2D$6: function($receiver, target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video) {
      return this.texImage2D$9($receiver, target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, null, null, null);
    },
    texParameteri$3: function(receiver, target, pname, param) {
      return receiver.texParameteri(target, pname, param);
    },
    uniform1f$2: [function(receiver, $location, x) {
      return receiver.uniform1f($location, x);
    }, "call$2", "get$uniform1f", 4, 0, 584, 585, [], 6, []],
    uniform1i$2: [function(receiver, $location, x) {
      return receiver.uniform1i($location, x);
    }, "call$2", "get$uniform1i", 4, 0, 586, 585, [], 6, []],
    uniform2f$3: [function(receiver, $location, x, y) {
      return receiver.uniform2f($location, x, y);
    }, "call$3", "get$uniform2f", 6, 0, 587, 585, [], 6, [], 7, []],
    uniform2fv$2: [function(receiver, $location, v) {
      return receiver.uniform2fv($location, v);
    }, "call$2", "get$uniform2fv", 4, 0, 588, 585, [], 376, []],
    uniform2i$3: [function(receiver, $location, x, y) {
      return receiver.uniform2i($location, x, y);
    }, "call$3", "get$uniform2i", 6, 0, 589, 585, [], 6, [], 7, []],
    uniform3f$4: [function(receiver, $location, x, y, z) {
      return receiver.uniform3f($location, x, y, z);
    }, "call$4", "get$uniform3f", 8, 0, 590, 585, [], 6, [], 7, [], 591, []],
    uniform3fv$2: [function(receiver, $location, v) {
      return receiver.uniform3fv($location, v);
    }, "call$2", "get$uniform3fv", 4, 0, 588, 585, [], 376, []],
    uniform3i$4: [function(receiver, $location, x, y, z) {
      return receiver.uniform3i($location, x, y, z);
    }, "call$4", "get$uniform3i", 8, 0, 592, 585, [], 6, [], 7, [], 591, []],
    uniform4f$5: [function(receiver, $location, x, y, z, w) {
      return receiver.uniform4f($location, x, y, z, w);
    }, "call$5", "get$uniform4f", 10, 0, 593, 585, [], 6, [], 7, [], 591, [], 594, []],
    uniform4fv$2: [function(receiver, $location, v) {
      return receiver.uniform4fv($location, v);
    }, "call$2", "get$uniform4fv", 4, 0, 588, 585, [], 376, []],
    uniform4i$5: [function(receiver, $location, x, y, z, w) {
      return receiver.uniform4i($location, x, y, z, w);
    }, "call$5", "get$uniform4i", 10, 0, 595, 585, [], 6, [], 7, [], 591, [], 594, []],
    uniformMatrix2fv$3: [function(receiver, $location, transpose, array) {
      return receiver.uniformMatrix2fv($location, transpose, array);
    }, "call$3", "get$uniformMatrix2fv", 6, 0, 596, 585, [], 597, [], 15, []],
    uniformMatrix3fv$3: [function(receiver, $location, transpose, array) {
      return receiver.uniformMatrix3fv($location, transpose, array);
    }, "call$3", "get$uniformMatrix3fv", 6, 0, 596, 585, [], 597, [], 15, []],
    uniformMatrix4fv$3: [function(receiver, $location, transpose, array) {
      return receiver.uniformMatrix4fv($location, transpose, array);
    }, "call$3", "get$uniformMatrix4fv", 6, 0, 596, 585, [], 597, [], 15, []],
    useProgram$1: function(receiver, program) {
      return receiver.useProgram(program);
    },
    vertexAttribPointer$6: function(receiver, indx, size, type, normalized, stride, offset) {
      return receiver.vertexAttribPointer(indx, size, type, normalized, stride, offset);
    },
    viewport$4: function(receiver, x, y, width, height) {
      return receiver.viewport(x, y, width, height);
    },
    texImage2DTyped$9: function(receiver, targetTexture, levelOfDetail, internalFormat, width, height, border, format, type, data) {
      return receiver.texImage2D(targetTexture, levelOfDetail, internalFormat, width, height, border, format, type, data);
    },
    $isRenderingContext: true,
    "%": "WebGLRenderingContext"
  },
  UniformLocation: {
    "^": "Interceptor;",
    "%": "WebGLUniformLocation"
  }
}],
["dart.isolate", "dart:isolate", , P, {
  "^": "",
  Capability: {
    "^": "Object;",
    $isCapability: true
  }
}],
["dart.js", "dart:js", , P, {
  "^": "",
  _callDartFunction: [function(callback, captureThis, $self, $arguments) {
    var arguments0;
    if (captureThis === true) {
      arguments0 = [$self];
      C.JSArray_methods.addAll$1(arguments0, $arguments);
      $arguments = arguments0;
    }
    return P._convertToJS(H.Primitives_applyFunction(callback, P.List_List$from(J.map$1$ax($arguments, P._convertToDart$closure()), true, null), P.Function__toMangledNames(null)));
  }, "call$4", "_callDartFunction$closure", 8, 0, null, 272, [], 563, [], 564, [], 565, []],
  _defineProperty: function(o, $name, value) {
    var exception;
    if (Object.isExtensible(o))
      try {
        Object.defineProperty(o, $name, {value: value});
        return true;
      } catch (exception) {
        H.unwrapException(exception);
      }

    return false;
  },
  _getOwnProperty: function(o, $name) {
    if (Object.prototype.hasOwnProperty.call(o, $name))
      return o[$name];
    return;
  },
  _convertToJS: [function(o) {
    var t1;
    if (o == null || typeof o === "string" || typeof o === "number" || typeof o === "boolean")
      return o;
    else {
      t1 = J.getInterceptor(o);
      if (!!t1.$isBlob || !!t1.$isEvent || !!t1.$isKeyRange || !!t1.$isImageData || !!t1.$isNode || !!t1.$isTypedData || !!t1.$isWindow)
        return o;
      else if (!!t1.$isDateTime)
        return H.Primitives_lazyAsJsDate(o);
      else if (!!t1.$isJsObject)
        return o._js$_jsObject;
      else if (!!t1.$isFunction)
        return P._getJsProxy(o, "$dart_jsFunction", new P._convertToJS_closure());
      else
        return P._getJsProxy(o, "_$dart_jsObject", new P._convertToJS_closure0($.get$_dartProxyCtor()));
    }
  }, "call$1", "_convertToJS$closure", 2, 0, 63, 566, []],
  _getJsProxy: function(o, propertyName, createProxy) {
    var jsProxy = P._getOwnProperty(o, propertyName);
    if (jsProxy == null) {
      jsProxy = createProxy.call$1(o);
      P._defineProperty(o, propertyName, jsProxy);
    }
    return jsProxy;
  },
  _convertToDart: [function(o) {
    var t1;
    if (o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean")
      return o;
    else {
      if (o instanceof Object) {
        t1 = J.getInterceptor(o);
        t1 = !!t1.$isBlob || !!t1.$isEvent || !!t1.$isKeyRange || !!t1.$isImageData || !!t1.$isNode || !!t1.$isTypedData || !!t1.$isWindow;
      } else
        t1 = false;
      if (t1)
        return o;
      else if (o instanceof Date)
        return P.DateTime$fromMillisecondsSinceEpoch(o.getTime(), false);
      else if (o.constructor === $.get$_dartProxyCtor())
        return o.o;
      else
        return P._wrapToDart(o);
    }
  }, "call$1", "_convertToDart$closure", 2, 0, 567, 566, []],
  _wrapToDart: function(o) {
    if (typeof o == "function")
      return P._getDartProxy(o, $.get$_DART_CLOSURE_PROPERTY_NAME(), new P._wrapToDart_closure());
    else if (o instanceof Array)
      return P._getDartProxy(o, $.get$_DART_OBJECT_PROPERTY_NAME(), new P._wrapToDart_closure0());
    else
      return P._getDartProxy(o, $.get$_DART_OBJECT_PROPERTY_NAME(), new P._wrapToDart_closure1());
  },
  _getDartProxy: function(o, propertyName, createProxy) {
    var dartProxy = P._getOwnProperty(o, propertyName);
    if (dartProxy == null || !(o instanceof Object)) {
      dartProxy = createProxy.call$1(o);
      P._defineProperty(o, propertyName, dartProxy);
    }
    return dartProxy;
  },
  JsObject: {
    "^": "Object;_js$_jsObject",
    $index: function(_, property) {
      if (typeof property !== "string" && typeof property !== "number")
        throw H.wrapException(P.ArgumentError$("property is not a String or num"));
      return P._convertToDart(this._js$_jsObject[property]);
    },
    $indexSet: function(_, property, value) {
      if (typeof property !== "string" && typeof property !== "number")
        throw H.wrapException(P.ArgumentError$("property is not a String or num"));
      this._js$_jsObject[property] = P._convertToJS(value);
    },
    get$hashCode: function(_) {
      return 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isJsObject && this._js$_jsObject === other._js$_jsObject;
    },
    toString$0: function(_) {
      var t1, exception;
      try {
        t1 = String(this._js$_jsObject);
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
        return P.Object.prototype.toString$0.call(this, this);
      }

    },
    callMethod$2: function(method, args) {
      var t1, t2;
      t1 = this._js$_jsObject;
      t2 = args == null ? null : P.List_List$from(J.map$1$ax(args, P._convertToJS$closure()), true, null);
      return P._convertToDart(t1[method].apply(t1, t2));
    },
    callMethod$1: function(method) {
      return this.callMethod$2(method, null);
    },
    $isJsObject: true,
    static: {JsObject_JsObject$fromBrowserObject: function(object) {
        if (typeof object === "number" || typeof object === "string" || typeof object === "boolean" || object == null)
          throw H.wrapException(P.ArgumentError$("object cannot be a num, string, bool, or null"));
        return P._wrapToDart(P._convertToJS(object));
      }}
  },
  JsFunction: {
    "^": "JsObject;_js$_jsObject",
    apply$2$thisArg: function(args, thisArg) {
      var t1, t2;
      t1 = P._convertToJS(thisArg);
      t2 = args == null ? null : P.List_List$from(J.map$1$ax(args, P._convertToJS$closure()), true, null);
      return P._convertToDart(this._js$_jsObject.apply(t1, t2));
    },
    apply$1: function(args) {
      return this.apply$2$thisArg(args, null);
    }
  },
  JsArray: {
    "^": "JsObject_ListMixin;_js$_jsObject",
    _js$_checkIndex$1: function(_, index) {
      var t1;
      if (typeof index === "number" && Math.floor(index) === index)
        t1 = index < 0 || index >= this.get$length(this);
      else
        t1 = false;
      if (t1)
        throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this)));
    },
    $index: function(_, index) {
      var t1;
      if (typeof index === "number" && index === C.JSNumber_methods.toInt$0(index)) {
        if (typeof index === "number" && Math.floor(index) === index)
          t1 = index < 0 || index >= this.get$length(this);
        else
          t1 = false;
        if (t1)
          H.throwExpression(P.RangeError$range(index, 0, this.get$length(this)));
      }
      return P.JsObject.prototype.$index.call(this, this, index);
    },
    $indexSet: function(_, index, value) {
      var t1;
      if (typeof index === "number" && index === C.JSNumber_methods.toInt$0(index)) {
        if (typeof index === "number" && Math.floor(index) === index)
          t1 = index < 0 || index >= this.get$length(this);
        else
          t1 = false;
        if (t1)
          H.throwExpression(P.RangeError$range(index, 0, this.get$length(this)));
      }
      P.JsObject.prototype.$indexSet.call(this, this, index, value);
    },
    get$length: function(_) {
      var len = this._js$_jsObject.length;
      if (typeof len === "number" && len >>> 0 === len)
        return len;
      throw H.wrapException(P.StateError$("Bad JsArray length"));
    },
    set$length: function(_, $length) {
      P.JsObject.prototype.$indexSet.call(this, this, "length", $length);
    },
    add$1: [function(_, value) {
      this.callMethod$2("push", [value]);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E7", void: true, args: [E]};
      }, this.$receiver, "JsArray");
    }, 100, []],
    addAll$1: function(_, iterable) {
      this.callMethod$2("push", iterable instanceof Array ? iterable : P.List_List$from(iterable, true, null));
    },
    insert$2: function(_, index, element) {
      var t1;
      if (typeof index === "number" && Math.floor(index) === index)
        t1 = index < 0 || index >= this.get$length(this) + 1;
      else
        t1 = false;
      if (t1)
        H.throwExpression(P.RangeError$range(index, 0, this.get$length(this)));
      this.callMethod$2("splice", [index, 0, element]);
    },
    removeAt$1: function(_, index) {
      this._js$_checkIndex$1(0, index);
      return J.$index$asx(this.callMethod$2("splice", [index, 1]), 0);
    },
    removeLast$0: function(_) {
      if (this.get$length(this) === 0)
        throw H.wrapException(P.RangeError$(-1));
      return this.callMethod$1("pop");
    },
    removeRange$2: function(_, start, end) {
      P.JsArray__checkRange(start, end, this.get$length(this));
      this.callMethod$2("splice", [start, J.$sub$n(end, start)]);
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      var t1, t2, $length, args;
      t1 = this.get$length(this);
      t2 = J.getInterceptor$n(start);
      if (t2.$lt(start, 0) || t2.$gt(start, t1))
        H.throwExpression(P.RangeError$range(start, 0, t1));
      t2 = J.getInterceptor$n(end);
      if (t2.$lt(end, start) || t2.$gt(end, t1))
        H.throwExpression(P.RangeError$range(end, start, t1));
      $length = t2.$sub(end, start);
      if (J.$eq($length, 0))
        return;
      if (J.$lt$n(skipCount, 0))
        throw H.wrapException(P.ArgumentError$(skipCount));
      args = [start, $length];
      t1 = new H.SubListIterable(iterable, skipCount, null);
      t1.$builtinTypeInfo = [null];
      if (J.$lt$n(skipCount, 0))
        H.throwExpression(P.RangeError$value(skipCount));
      C.JSArray_methods.addAll$1(args, t1.take$1(0, $length));
      this.callMethod$2("splice", args);
    },
    sort$1: function(_, compare) {
      this.callMethod$2("sort", compare == null ? [] : [compare]);
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    static: {JsArray__checkRange: function(start, end, $length) {
        var t1 = J.getInterceptor$n(start);
        if (t1.$lt(start, 0) || t1.$gt(start, $length))
          throw H.wrapException(P.RangeError$range(start, 0, $length));
        t1 = J.getInterceptor$n(end);
        if (t1.$lt(end, start) || t1.$gt(end, $length))
          throw H.wrapException(P.RangeError$range(end, start, $length));
      }}
  },
  JsObject_ListMixin: {
    "^": "JsObject+ListMixin;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  _convertToJS_closure: {
    "^": "Closure:63;",
    call$1: function(o) {
      var jsFunction = function(_call, f, captureThis) {
        return function() {
          return _call(f, captureThis, this, Array.prototype.slice.apply(arguments));
        };
      }(P._callDartFunction, o, false);
      P._defineProperty(jsFunction, $.get$_DART_CLOSURE_PROPERTY_NAME(), o);
      return jsFunction;
    },
    $isFunction: true
  },
  _convertToJS_closure0: {
    "^": "Closure:63;ctor_0",
    call$1: function(o) {
      return new this.ctor_0(o);
    },
    $isFunction: true
  },
  _wrapToDart_closure: {
    "^": "Closure:63;",
    call$1: function(o) {
      return new P.JsFunction(o);
    },
    $isFunction: true
  },
  _wrapToDart_closure0: {
    "^": "Closure:63;",
    call$1: function(o) {
      return H.setRuntimeTypeInfo(new P.JsArray(o), [null]);
    },
    $isFunction: true
  },
  _wrapToDart_closure1: {
    "^": "Closure:63;",
    call$1: function(o) {
      return new P.JsObject(o);
    },
    $isFunction: true
  },
  "^": "context<"
}],
["dart.math", "dart:math", , P, {
  "^": "",
  _JenkinsSmiHash_combine0: function(hash, value) {
    hash = 536870911 & hash + value;
    hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
    return hash ^ hash >>> 6;
  },
  _JenkinsSmiHash_finish: function(hash) {
    hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
    hash ^= hash >>> 11;
    return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
  },
  min: function(a, b) {
    if (typeof a !== "number")
      throw H.wrapException(P.ArgumentError$(a));
    if (typeof b !== "number")
      throw H.wrapException(P.ArgumentError$(b));
    if (a > b)
      return b;
    if (a < b)
      return a;
    if (typeof b === "number") {
      if (typeof a === "number")
        if (a === 0)
          return (a + b) * a * b;
      if (a === 0 && C.JSDouble_methods.get$isNegative(b) || C.JSDouble_methods.get$isNaN(b))
        return b;
      return a;
    }
    return a;
  },
  max: function(a, b) {
    if (typeof a !== "number")
      throw H.wrapException(P.ArgumentError$(a));
    if (typeof b !== "number")
      throw H.wrapException(P.ArgumentError$(b));
    if (a > b)
      return a;
    if (a < b)
      return b;
    if (typeof b === "number") {
      if (typeof a === "number")
        if (a === 0)
          return a + b;
      if (C.JSDouble_methods.get$isNaN(b))
        return b;
      return a;
    }
    if (b === 0 && C.JSNumber_methods.get$isNegative(a))
      return b;
    return a;
  },
  _JSRandom: {
    "^": "Object;",
    nextInt$1: function(max) {
      var t1 = J.getInterceptor$n(max);
      if (t1.$le(max, 0) || t1.$gt(max, 4294967296))
        throw H.wrapException(P.RangeError$("max must be in range 0 < max \u2264 2^32, was " + H.S(max)));
      return Math.random() * max >>> 0;
    },
    nextDouble$0: [function() {
      return Math.random();
    }, "call$0", "get$nextDouble", 0, 0, 1337]
  },
  Point1: {
    "^": "Object;x>,y>",
    toString$0: function(_) {
      return "Point(" + H.S(this.x) + ", " + H.S(this.y) + ")";
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isPoint1)
        return false;
      t1 = this.x;
      t2 = other.x;
      if (t1 == null ? t2 == null : t1 === t2) {
        t1 = this.y;
        t2 = other.y;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1, t2;
      t1 = J.get$hashCode$(this.x);
      t2 = J.get$hashCode$(this.y);
      return P._JenkinsSmiHash_finish(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(0, t1), t2));
    },
    $add: function(_, other) {
      var t1, t2, t3, t4;
      t1 = this.x;
      t2 = J.getInterceptor$x(other);
      t3 = t2.get$x(other);
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = this.y;
      t2 = t2.get$y(other);
      if (typeof t4 !== "number")
        return t4.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = new P.Point1(t1 + t3, t4 + t2);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      return t2;
    },
    $sub: function(_, other) {
      var t1, t2, t3, t4;
      t1 = this.x;
      t2 = J.getInterceptor$x(other);
      t3 = t2.get$x(other);
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = this.y;
      t2 = t2.get$y(other);
      if (typeof t4 !== "number")
        return t4.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = new P.Point1(t1 - t3, t4 - t2);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      return t2;
    },
    $mul: function(_, factor) {
      var t1, t2;
      t1 = this.x;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof factor !== "number")
        return H.iae(factor);
      t2 = this.y;
      if (typeof t2 !== "number")
        return t2.$mul();
      t2 = new P.Point1(t1 * factor, t2 * factor);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      return t2;
    },
    $isPoint1: true
  },
  "+Point": 0,
  _RectangleBase: {
    "^": "Object;",
    get$right: function(_) {
      return this.get$left(this) + this.width;
    },
    get$bottom: function(_) {
      return this.get$top(this) + this.height;
    },
    toString$0: function(_) {
      return "Rectangle (" + this.get$left(this) + ", " + this.top + ") " + this.width + " x " + this.height;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isRectangle)
        return false;
      if (this.get$left(this) === t1.get$left(other)) {
        t2 = this.top;
        t1 = t2 === t1.get$top(other) && this.left + this.width === t1.get$right(other) && t2 + this.height === t1.get$bottom(other);
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1 = this.top;
      return P._JenkinsSmiHash_finish(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(0, this.get$left(this) & 0x1FFFFFFF), t1 & 0x1FFFFFFF), this.left + this.width & 0x1FFFFFFF), t1 + this.height & 0x1FFFFFFF));
    },
    intersects$1: function(_, other) {
      var t1, t2, t3;
      t1 = this.get$left(this);
      t2 = J.getInterceptor$x(other);
      t3 = J.$add$ns(t2.get$left(other), t2.get$width(other));
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (t1 <= t3)
        if (J.$le$n(t2.get$left(other), this.left + this.width)) {
          t1 = this.top;
          t3 = J.$add$ns(t2.get$top(other), t2.get$height(other));
          if (typeof t3 !== "number")
            return H.iae(t3);
          t1 = t1 <= t3 && J.$le$n(t2.get$top(other), t1 + this.height);
        } else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$topLeft: function(_) {
      var t1 = new P.Point1(this.get$left(this), this.top);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$bottomRight: function(_) {
      var t1 = new P.Point1(this.get$left(this) + this.width, this.top + this.height);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    }
  },
  Rectangle: {
    "^": "_RectangleBase;left>,top>,width>,height>",
    $isRectangle: true,
    $asRectangle: null,
    static: {Rectangle$: function(left, $top, width, height, $T) {
        var t1, t2;
        t1 = width < 0 ? -width * 0 : width;
        t2 = height < 0 ? -height * 0 : height;
        return H.setRuntimeTypeInfo(new P.Rectangle(left, $top, t1, t2), [$T]);
      }}
  },
  "+Rectangle": 0
}],
["dart.mirrors", "dart:mirrors", , P, {
  "^": "",
  reflectClass: function(key) {
    var t1, tm;
    t1 = J.getInterceptor(key);
    if (!t1.$isType || t1.$eq(key, C.Type_dynamic))
      throw H.wrapException(P.ArgumentError$(H.S(key) + " does not denote a class"));
    tm = P.reflectType(key);
    if (!J.getInterceptor(tm).$isClassMirror)
      throw H.wrapException(P.ArgumentError$(H.S(key) + " does not denote a class"));
    return tm.get$originalDeclaration();
  },
  reflectType: function(key) {
    if (J.$eq(key, C.Type_dynamic)) {
      $.get$currentJsMirrorSystem().toString;
      return $.get$JsMirrorSystem__dynamicType();
    }
    return H.reflectClassByMangledName(key.get$_typeName());
  },
  InstanceMirror: {
    "^": "Object;"
  },
  LibraryMirror: {
    "^": "Object;",
    $isLibraryMirror: true
  },
  TypeMirror: {
    "^": "Object;",
    $isTypeMirror: true
  },
  ClassMirror: {
    "^": "Object;",
    $isClassMirror: true,
    $isTypeMirror: true
  },
  TypeVariableMirror: {
    "^": "TypeMirror;",
    $isTypeVariableMirror: true
  },
  MethodMirror: {
    "^": "Object;",
    $isMethodMirror: true
  },
  ParameterMirror: {
    "^": "Object;",
    $isParameterMirror: true
  },
  MirrorsUsed: {
    "^": "Object;symbols,targets,metaTargets,override<"
  }
}],
["dart.typed_data", "dart:typed_data", , P, {
  "^": "",
  Float32List: {
    "^": "Object;",
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$double];
    },
    $isEfficientLength: true
  }
}],
["dart.typed_data.implementation", "dart:_native_typed_data", , H, {
  "^": "",
  _ensureNativeList: function(list) {
    var t1, t2, result, i, t3;
    t1 = J.getInterceptor(list);
    if (!!t1.$isJSIndexable)
      return list;
    t2 = t1.get$length(list);
    if (typeof t2 !== "number")
      return H.iae(t2);
    result = Array(t2);
    result.fixed$length = init;
    t2 = result.length;
    i = 0;
    while (true) {
      t3 = t1.get$length(list);
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (!(i < t3))
        break;
      t3 = t1.$index(list, i);
      if (i >= t2)
        return H.ioore(result, i);
      result[i] = t3;
      ++i;
    }
    return result;
  },
  NativeByteBuffer: {
    "^": "Interceptor;",
    get$runtimeType: function(receiver) {
      return C.Type_wAg;
    },
    $isNativeByteBuffer: true,
    "%": "ArrayBuffer"
  },
  NativeTypedData: {
    "^": "Interceptor;buffer=",
    _invalidIndex$2: function(receiver, index, $length) {
      var t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$ge(index, $length))
        throw H.wrapException(P.RangeError$range(index, 0, $length));
      else
        throw H.wrapException(P.ArgumentError$("Invalid list index " + H.S(index)));
    },
    _checkIndex$2: function(receiver, index, $length) {
      if (index >>> 0 !== index || index >= $length)
        this._invalidIndex$2(receiver, index, $length);
    },
    _checkSublistArguments$3: function(receiver, start, end, $length) {
      var t1 = $length + 1;
      this._checkIndex$2(receiver, start, t1);
      if (end == null)
        return $length;
      this._checkIndex$2(receiver, end, t1);
      if (typeof end !== "number")
        return H.iae(end);
      if (start > end)
        throw H.wrapException(P.RangeError$range(start, 0, end));
      return end;
    },
    $isNativeTypedData: true,
    $isTypedData: true,
    "%": ";ArrayBufferView;NativeTypedArray|NativeTypedArray_ListMixin|NativeTypedArray_ListMixin_FixedLengthListMixin|NativeTypedArrayOfDouble|NativeTypedArray_ListMixin0|NativeTypedArray_ListMixin_FixedLengthListMixin0|NativeTypedArrayOfInt"
  },
  NativeByteData: {
    "^": "NativeTypedData;",
    get$runtimeType: function(receiver) {
      return C.Type_oGP;
    },
    $isTypedData: true,
    "%": "DataView"
  },
  NativeFloat32List: {
    "^": "NativeTypedArrayOfDouble;",
    get$runtimeType: function(receiver) {
      return C.Type_Art;
    },
    sublist$2: function(receiver, start, end) {
      return new Float32Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$double];
    },
    $isEfficientLength: true,
    "%": "Float32Array"
  },
  NativeFloat64List: {
    "^": "NativeTypedArrayOfDouble;",
    get$runtimeType: function(receiver) {
      return C.Type_ckn;
    },
    sublist$2: function(receiver, start, end) {
      return new Float64Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$double];
    },
    $isEfficientLength: true,
    "%": "Float64Array"
  },
  NativeInt16List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_UoK;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Int16Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    "%": "Int16Array"
  },
  NativeInt32List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_dTZ;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Int32Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    "%": "Int32Array"
  },
  NativeInt8List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_mp3;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Int8Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    "%": "Int8Array"
  },
  NativeUint16List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_CAk;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint16Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    "%": "Uint16Array"
  },
  NativeUint32List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_irB;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint32Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    "%": "Uint32Array"
  },
  NativeUint8ClampedList: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_QuW;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint8ClampedArray(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    "%": "CanvasPixelArray|Uint8ClampedArray"
  },
  NativeUint8List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_6L0;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint8Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    "%": ";Uint8Array"
  },
  NativeTypedArray: {
    "^": "NativeTypedData;",
    get$length: function(receiver) {
      return receiver.length;
    },
    _setRangeFast$4: function(receiver, start, end, source, skipCount) {
      var t1, count, sourceLength;
      t1 = receiver.length + 1;
      this._checkIndex$2(receiver, start, t1);
      this._checkIndex$2(receiver, end, t1);
      if (J.$gt$n(start, end))
        throw H.wrapException(P.RangeError$range(start, 0, end));
      count = J.$sub$n(end, start);
      if (J.$lt$n(skipCount, 0))
        throw H.wrapException(P.ArgumentError$(skipCount));
      sourceLength = source.length;
      if (typeof skipCount !== "number")
        return H.iae(skipCount);
      if (typeof count !== "number")
        return H.iae(count);
      if (sourceLength - skipCount < count)
        throw H.wrapException(P.StateError$("Not enough elements"));
      if (skipCount !== 0 || sourceLength !== count)
        source = source.subarray(skipCount, skipCount + count);
      receiver.set(source, start);
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true
  },
  NativeTypedArrayOfDouble: {
    "^": "NativeTypedArray_ListMixin_FixedLengthListMixin;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfDouble) {
        this._setRangeFast$4(receiver, start, end, iterable, skipCount);
        return;
      }
      P.ListMixin.prototype.setRange$4.call(this, receiver, start, end, iterable, skipCount);
    },
    $isNativeTypedArrayOfDouble: true
  },
  NativeTypedArray_ListMixin: {
    "^": "NativeTypedArray+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.$double];
    },
    $isEfficientLength: true
  },
  NativeTypedArray_ListMixin_FixedLengthListMixin: {
    "^": "NativeTypedArray_ListMixin+FixedLengthListMixin;"
  },
  NativeTypedArrayOfInt: {
    "^": "NativeTypedArray_ListMixin_FixedLengthListMixin0;",
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfInt) {
        this._setRangeFast$4(receiver, start, end, iterable, skipCount);
        return;
      }
      P.ListMixin.prototype.setRange$4.call(this, receiver, start, end, iterable, skipCount);
    },
    $isNativeTypedArrayOfInt: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true
  },
  NativeTypedArray_ListMixin0: {
    "^": "NativeTypedArray+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true
  },
  NativeTypedArray_ListMixin_FixedLengthListMixin0: {
    "^": "NativeTypedArray_ListMixin0+FixedLengthListMixin;"
  }
}],
["dart2js._js_primitives", "dart:_js_primitives", , H, {
  "^": "",
  printString: function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log != "undefined") {
      console.log(string);
      return;
    }
    if (typeof window == "object")
      return;
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  }
}],
["html_common", "dart:html_common", , P, {
  "^": "",
  convertDartToNative_Dictionary: function(dict) {
    var object;
    if (dict == null)
      return;
    object = {};
    J.forEach$1$ax(dict, new P.convertDartToNative_Dictionary_closure(object));
    return object;
  },
  _convertDartToNative_PrepareForStructuredClone: function(value) {
    var copies, copy;
    copies = [];
    copy = new P._convertDartToNative_PrepareForStructuredClone_walk(new P._convertDartToNative_PrepareForStructuredClone_findSlot([], copies), new P._convertDartToNative_PrepareForStructuredClone_readSlot(copies), new P._convertDartToNative_PrepareForStructuredClone_writeSlot(copies)).call$1(value);
    new P._convertDartToNative_PrepareForStructuredClone_cleanupSlots().call$0();
    return copy;
  },
  convertNativeToDart_AcceptStructuredClone: function(object, mustCopy) {
    var copies = [];
    return new P.convertNativeToDart_AcceptStructuredClone_walk(mustCopy, new P.convertNativeToDart_AcceptStructuredClone_findSlot([], copies), new P.convertNativeToDart_AcceptStructuredClone_readSlot(copies), new P.convertNativeToDart_AcceptStructuredClone_writeSlot(copies)).call$1(object);
  },
  convertNativeToDart_ImageData: function(nativeImageData) {
    var t1, data;
    t1 = J.getInterceptor(nativeImageData);
    if (!!t1.$isImageData) {
      data = t1.get$data(nativeImageData);
      if (data.constructor === Array)
        if (typeof CanvasPixelArray !== "undefined") {
          data.constructor = CanvasPixelArray;
          data.BYTES_PER_ELEMENT = 1;
        }
      return nativeImageData;
    }
    return new P._TypedImageData(nativeImageData.data, nativeImageData.height, nativeImageData.width);
  },
  convertDartToNative_ImageData: function(imageData) {
    if (!!J.getInterceptor(imageData).$is_TypedImageData)
      return {data: imageData.data, height: imageData.height, width: imageData.width};
    return imageData;
  },
  Device_isOpera: function() {
    var t1 = $.Device__isOpera;
    if (t1 == null) {
      t1 = J.contains$2$asx(window.navigator.userAgent, "Opera", 0);
      $.Device__isOpera = t1;
    }
    return t1;
  },
  Device_isWebKit: function() {
    var t1 = $.Device__isWebKit;
    if (t1 == null) {
      t1 = P.Device_isOpera() !== true && J.contains$2$asx(window.navigator.userAgent, "WebKit", 0);
      $.Device__isWebKit = t1;
    }
    return t1;
  },
  Device_cssPrefix: function() {
    var t1 = $.Device__cachedCssPrefix;
    if (t1 == null) {
      t1 = $.Device__isFirefox;
      if (t1 == null) {
        t1 = J.contains$2$asx(window.navigator.userAgent, "Firefox", 0);
        $.Device__isFirefox = t1;
      }
      if (t1 === true) {
        $.Device__cachedCssPrefix = "-moz-";
        t1 = "-moz-";
      } else {
        t1 = $.Device__isIE;
        if (t1 == null) {
          t1 = P.Device_isOpera() !== true && J.contains$2$asx(window.navigator.userAgent, "Trident/", 0);
          $.Device__isIE = t1;
        }
        if (t1 === true) {
          $.Device__cachedCssPrefix = "-ms-";
          t1 = "-ms-";
        } else if (P.Device_isOpera() === true) {
          $.Device__cachedCssPrefix = "-o-";
          t1 = "-o-";
        } else {
          $.Device__cachedCssPrefix = "-webkit-";
          t1 = "-webkit-";
        }
      }
    }
    return t1;
  },
  convertDartToNative_Dictionary_closure: {
    "^": "Closure:80;object_0",
    call$2: [function(key, value) {
      this.object_0[key] = value;
    }, "call$2", null, 4, 0, null, 231, [], 100, [], "call"],
    $isFunction: true
  },
  _convertDartToNative_PrepareForStructuredClone_findSlot: {
    "^": "Closure:118;values_1,copies_2",
    call$1: function(value) {
      var t1, $length, i;
      t1 = this.values_1;
      $length = t1.length;
      for (i = 0; i < $length; ++i)
        if (t1[i] === value)
          return i;
      t1.push(value);
      this.copies_2.push(null);
      return $length;
    },
    $isFunction: true
  },
  _convertDartToNative_PrepareForStructuredClone_readSlot: {
    "^": "Closure:60;copies_3",
    call$1: function(i) {
      var t1 = this.copies_3;
      if (i >= t1.length)
        return H.ioore(t1, i);
      return t1[i];
    },
    $isFunction: true
  },
  _convertDartToNative_PrepareForStructuredClone_writeSlot: {
    "^": "Closure:744;copies_4",
    call$2: function(i, x) {
      var t1 = this.copies_4;
      if (i >= t1.length)
        return H.ioore(t1, i);
      t1[i] = x;
    },
    $isFunction: true
  },
  _convertDartToNative_PrepareForStructuredClone_cleanupSlots: {
    "^": "Closure:13;",
    call$0: function() {
    },
    $isFunction: true
  },
  _convertDartToNative_PrepareForStructuredClone_walk: {
    "^": "Closure:63;findSlot_5,readSlot_6,writeSlot_7",
    call$1: function(e) {
      var t1, t2, slot, copy, $length, i;
      t1 = {};
      if (e == null)
        return e;
      if (typeof e === "boolean")
        return e;
      if (typeof e === "number")
        return e;
      if (typeof e === "string")
        return e;
      t2 = J.getInterceptor(e);
      if (!!t2.$isDateTime)
        return new Date(e.millisecondsSinceEpoch);
      if (!!t2.$isRegExp)
        throw H.wrapException(P.UnimplementedError$("structured clone of RegExp"));
      if (!!t2.$isFile)
        return e;
      if (!!t2.$isBlob)
        return e;
      if (!!t2.$isImageData)
        return e;
      if (!!t2.$isNativeByteBuffer)
        return e;
      if (!!t2.$isNativeTypedData)
        return e;
      if (!!t2.$isMap) {
        slot = this.findSlot_5.call$1(e);
        copy = this.readSlot_6.call$1(slot);
        t1.copy_0 = copy;
        if (copy != null)
          return copy;
        copy = {};
        t1.copy_0 = copy;
        this.writeSlot_7.call$2(slot, copy);
        t2.forEach$1(e, new P._convertDartToNative_PrepareForStructuredClone_walk_closure(t1, this));
        return t1.copy_0;
      }
      if (!!t2.$isList) {
        $length = t2.get$length(e);
        slot = this.findSlot_5.call$1(e);
        copy = this.readSlot_6.call$1(slot);
        if (copy != null) {
          if (true === copy) {
            copy = new Array($length);
            this.writeSlot_7.call$2(slot, copy);
          }
          return copy;
        }
        copy = new Array($length);
        this.writeSlot_7.call$2(slot, copy);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          t1 = this.call$1(t2.$index(e, i));
          if (i >= copy.length)
            return H.ioore(copy, i);
          copy[i] = t1;
        }
        return copy;
      }
      throw H.wrapException(P.UnimplementedError$("structured clone of other type"));
    },
    $isFunction: true
  },
  _convertDartToNative_PrepareForStructuredClone_walk_closure: {
    "^": "Closure:935;box_0,walk_8",
    call$2: [function(key, value) {
      this.box_0.copy_0[key] = this.walk_8.call$1(value);
    }, "call$2", null, 4, 0, null, 231, [], 100, [], "call"],
    $isFunction: true
  },
  convertNativeToDart_AcceptStructuredClone_findSlot: {
    "^": "Closure:118;values_0,copies_1",
    call$1: function(value) {
      var t1, $length, i, t2;
      t1 = this.values_0;
      $length = t1.length;
      for (i = 0; i < $length; ++i) {
        t2 = t1[i];
        if (t2 == null ? value == null : t2 === value)
          return i;
      }
      t1.push(value);
      this.copies_1.push(null);
      return $length;
    },
    $isFunction: true
  },
  convertNativeToDart_AcceptStructuredClone_readSlot: {
    "^": "Closure:60;copies_2",
    call$1: function(i) {
      var t1 = this.copies_2;
      if (i >= t1.length)
        return H.ioore(t1, i);
      return t1[i];
    },
    $isFunction: true
  },
  convertNativeToDart_AcceptStructuredClone_writeSlot: {
    "^": "Closure:744;copies_3",
    call$2: function(i, x) {
      var t1 = this.copies_3;
      if (i >= t1.length)
        return H.ioore(t1, i);
      t1[i] = x;
    },
    $isFunction: true
  },
  convertNativeToDart_AcceptStructuredClone_walk: {
    "^": "Closure:63;mustCopy_4,findSlot_5,readSlot_6,writeSlot_7",
    call$1: function(e) {
      var slot, copy, t1, key, $length, t2, i;
      if (e == null)
        return e;
      if (typeof e === "boolean")
        return e;
      if (typeof e === "number")
        return e;
      if (typeof e === "string")
        return e;
      if (e instanceof Date)
        return P.DateTime$fromMillisecondsSinceEpoch(e.getTime(), true);
      if (e instanceof RegExp)
        throw H.wrapException(P.UnimplementedError$("structured clone of RegExp"));
      if (Object.getPrototypeOf(e) === Object.prototype) {
        slot = this.findSlot_5.call$1(e);
        copy = this.readSlot_6.call$1(slot);
        if (copy != null)
          return copy;
        copy = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        this.writeSlot_7.call$2(slot, copy);
        for (t1 = Object.keys(e), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
          key = t1._current;
          copy.$indexSet(0, key, this.call$1(e[key]));
        }
        return copy;
      }
      if (e instanceof Array) {
        slot = this.findSlot_5.call$1(e);
        copy = this.readSlot_6.call$1(slot);
        if (copy != null)
          return copy;
        t1 = J.getInterceptor$asx(e);
        $length = t1.get$length(e);
        copy = this.mustCopy_4 ? new Array($length) : e;
        this.writeSlot_7.call$2(slot, copy);
        if (typeof $length !== "number")
          return H.iae($length);
        t2 = J.getInterceptor$ax(copy);
        i = 0;
        for (; i < $length; ++i)
          t2.$indexSet(copy, i, this.call$1(t1.$index(e, i)));
        return copy;
      }
      return e;
    },
    $isFunction: true
  },
  _TypedImageData: {
    "^": "Object;data>,height>,width>",
    $is_TypedImageData: true,
    $isImageData: true
  },
  FilteredElementList: {
    "^": "ListBase;_node,_childNodes",
    get$_filtered: function() {
      var t1 = this._childNodes;
      return P.List_List$from(t1.where$1(t1, new P.FilteredElementList__filtered_closure()), true, W.Element);
    },
    forEach$1: function(_, f) {
      H.IterableMixinWorkaround_forEach(this.get$_filtered(), f);
    },
    $indexSet: function(_, index, value) {
      var t1 = this.get$_filtered();
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      J.replaceWith$1$x(t1[index], value);
    },
    set$length: function(_, newLength) {
      var len, t1;
      len = this.get$_filtered().length;
      t1 = J.getInterceptor$n(newLength);
      if (t1.$ge(newLength, len))
        return;
      else if (t1.$lt(newLength, 0))
        throw H.wrapException(P.ArgumentError$("Invalid list length"));
      this.removeRange$2(0, newLength, len);
    },
    add$1: [function(_, value) {
      this._childNodes._this.appendChild(value);
    }, "call$1", "get$add", 2, 0, 813, 100, []],
    addAll$1: function(_, iterable) {
      var t1, t2;
      for (t1 = J.get$iterator$ax(iterable), t2 = this._childNodes._this; t1.moveNext$0();)
        t2.appendChild(t1.get$current());
    },
    contains$1: [function(_, needle) {
      return false;
    }, "call$1", "get$contains", 2, 0, 1677],
    get$reversed: function(_) {
      var t1 = this.get$_filtered();
      return H.setRuntimeTypeInfo(new H.ReversedListIterable(t1), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t1, 0)]), 0)]);
    },
    sort$1: function(_, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot sort filtered list"));
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot setRange on filtered list"));
    },
    removeRange$2: function(_, start, end) {
      H.IterableMixinWorkaround_forEach(C.JSArray_methods.sublist$2(this.get$_filtered(), start, end), new P.FilteredElementList_removeRange_closure());
    },
    clear$0: function(_) {
      J._clearChildren$0$x(this._childNodes._this);
    },
    removeLast$0: function(_) {
      var result = this.get$last(this);
      if (result != null)
        J.remove$0$ax(result);
      return result;
    },
    insert$2: function(_, index, value) {
      this._childNodes.insert$2(0, index, value);
    },
    removeAt$1: function(_, index) {
      var t1, result;
      t1 = this.get$_filtered();
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      result = t1[index];
      J.remove$0$ax(result);
      return result;
    },
    remove$1: function(_, element) {
      var i, t1, indexElement;
      if (!J.getInterceptor(element).$isElement)
        return false;
      for (i = 0; i < this.get$_filtered().length; ++i) {
        t1 = this.get$_filtered();
        if (i >= t1.length)
          return H.ioore(t1, i);
        indexElement = t1[i];
        if (indexElement === element) {
          J.remove$0$ax(indexElement);
          return true;
        }
      }
      return false;
    },
    get$length: function(_) {
      return this.get$_filtered().length;
    },
    $index: function(_, index) {
      var t1 = this.get$_filtered();
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    get$iterator: function(_) {
      var t1 = this.get$_filtered();
      return H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]);
    }
  },
  FilteredElementList__filtered_closure: {
    "^": "Closure:63;",
    call$1: function(n) {
      return !!J.getInterceptor(n).$isElement;
    },
    $isFunction: true
  },
  FilteredElementList_removeRange_closure: {
    "^": "Closure:63;",
    call$1: function(el) {
      return J.remove$0$ax(el);
    },
    $isFunction: true
  }
}],
["match3", "match3/match3.dart", , M, {
  "^": "",
  Grid: {
    "^": "Object;width*,height*,gravity@,pieces,directions",
    getPiece$1: function(point) {
      var t1, t2;
      if (J.$ge$n(point.x, 0) && J.$ge$n(point.y, 0) && J.$lt$n(point.x, this.width) && J.$lt$n(point.y, this.height)) {
        t1 = this.pieces;
        t2 = point.x;
        if (t2 >>> 0 !== t2 || t2 >= t1.length)
          return H.ioore(t1, t2);
        t2 = t1[t2];
        t1 = point.y;
        if (t1 >>> 0 !== t1 || t1 >= t2.length)
          return H.ioore(t2, t1);
        return t2[t1];
      } else
        return;
    },
    neighboursOf$1: function(piece) {
      var result = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      this.directions.forEach$1(0, new M.Grid_neighboursOf_closure(this, piece, result));
      return result;
    },
    forEachMatch$1: function(callback) {
      var matches = this.getMatches$0();
      matches.toString;
      H.IterableMixinWorkaround_forEach(matches, new M.Grid_forEachMatch_closure(callback));
    },
    getMatches$0: function() {
      var matches, t1;
      matches = [];
      t1 = this.pieces;
      t1.toString;
      H.IterableMixinWorkaround_forEach(t1, new M.Grid_getMatches_closure([], matches));
      return matches.length > 0 ? matches : null;
    },
    getRow$2: function(row, reverse) {
      var pieces, t1, t2;
      pieces = [];
      H.IterableMixinWorkaround_forEach(pieces, new M.Grid_getRow_closure(row, pieces));
      if (reverse) {
        t1 = new H.IterableMixinWorkaround();
        t1.$builtinTypeInfo = [H.getTypeArgumentByIndex(pieces, 0)];
        t2 = new H.ReversedListIterable(pieces);
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
        t1 = t2.toList$0(0);
      } else
        t1 = pieces;
      return t1;
    },
    getColumn$2: function(column, reverse) {
      var pieces, i, t1, t2;
      pieces = [];
      i = 0;
      while (true) {
        t1 = this.height;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        t1 = this.pieces;
        if (column >>> 0 !== column || column >= t1.length)
          return H.ioore(t1, column);
        t1 = t1[column];
        if (i >= t1.length)
          return H.ioore(t1, i);
        pieces.push(t1[i]);
        ++i;
      }
      if (reverse === true) {
        t1 = new H.IterableMixinWorkaround();
        t1.$builtinTypeInfo = [H.getTypeArgumentByIndex(pieces, 0)];
        t2 = new H.ReversedListIterable(pieces);
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
        t1 = t2.toList$0(0);
      } else
        t1 = pieces;
      return t1;
    },
    clearMatches$0: function() {
      var matches = this.getMatches$0();
      if (matches.length === 0)
        return false;
      matches.toString;
      H.IterableMixinWorkaround_forEach(matches, new M.Grid_clearMatches_closure());
      return true;
    },
    applyGravity$0: function() {
      var t1, t2, direction, horizontal, reverse, fallingPieces, limit, i, applyGravity, fallingPiecesWithoutEmpty;
      t1 = {};
      t2 = this.gravity;
      if (t2 !== "none") {
        direction = this.directions.$index(0, t2);
        horizontal = !J.$eq(direction.x, 0);
        reverse = horizontal ? J.$eq(direction.x, 1) : J.$eq(direction.y, 1);
        fallingPieces = [];
        limit = horizontal ? this.height : this.width;
        t1.chunk_2 = null;
        if (typeof limit !== "number")
          return H.iae(limit);
        i = 0;
        for (; i < limit; ++i) {
          t2 = {};
          t1.chunk_2 = horizontal ? this.getRow$2(i, reverse) : this.getColumn$2(i, reverse);
          t2.applyGravity_1 = null;
          applyGravity = new M.Grid_applyGravity_closure(t1, t2, direction, fallingPieces);
          t2.applyGravity_1 = applyGravity;
          applyGravity.call$1(this);
        }
        fallingPiecesWithoutEmpty = [];
        H.IterableMixinWorkaround_forEach(fallingPieces, new M.Grid_applyGravity_closure0(fallingPiecesWithoutEmpty));
        return fallingPiecesWithoutEmpty;
      }
      return;
    },
    Grid$3$gravity$height$width: function(gravity, height, width) {
      var i, t1, t2, y, x;
      this.gravity = gravity;
      this.height = height;
      this.width = width;
      this.pieces = [];
      for (i = 0; i < width; ++i) {
        t1 = this.pieces;
        t2 = Array(height);
        t2.fixed$length = init;
        t1.push(t2);
      }
      for (y = 0; y < height; ++y)
        for (x = 0; x < width; ++x) {
          t1 = this.pieces;
          if (x >= t1.length)
            return H.ioore(t1, x);
          t1 = t1[x];
          t2 = new M.Piece(this, null, x, y);
          t2.object = new M.MatchObject("__empty__");
          if (y >= t1.length)
            return H.ioore(t1, y);
          t1[y] = t2;
        }
    },
    static: {"^": "Grid_emptyObject", Grid$: function(gravity, height, width) {
        var t1 = new M.Grid(null, null, null, null, P.LinkedHashMap_LinkedHashMap$_literal(["up", new M.Locus(0, -1), "down", new M.Locus(0, 1), "right", new M.Locus(1, 0), "left", new M.Locus(-1, 0)], null, null));
        t1.Grid$3$gravity$height$width(gravity, height, width);
        return t1;
      }, Grid_getLastEmptyPiece: function(pieces) {
        var t1 = {};
        t1.lastEmpty_0 = null;
        H.IterableMixinWorkaround_forEach(pieces, new M.Grid_getLastEmptyPiece_closure(t1));
        return t1.lastEmpty_0;
      }}
  },
  Grid_getLastEmptyPiece_closure: {
    "^": "Closure:63;box_0",
    call$1: function(piece) {
      if (piece.get$object().type === $.get$Grid_emptyObject().type)
        this.box_0.lastEmpty_0 = piece;
    },
    $isFunction: true
  },
  Grid_neighboursOf_closure: {
    "^": "Closure:935;this_0,piece_1,result_2",
    call$2: function(directionName, direction) {
      this.result_2.$indexSet(0, directionName, this.this_0.getPiece$1(this.piece_1.relativeCoordinates$2(direction, 1)));
    },
    $isFunction: true
  },
  Grid_forEachMatch_closure: {
    "^": "Closure:63;callback_0",
    call$1: function(match) {
      return this.callback_0.call$2(match, J.$index$asx(match, 0).get$object().type);
    },
    $isFunction: true
  },
  Grid_getMatches_closure: {
    "^": "Closure:63;checked_0,matches_1",
    call$1: function(pieces) {
      J.forEach$1$ax(pieces, new M.Grid_getMatches__closure(this.checked_0, this.matches_1));
    },
    $isFunction: true
  },
  Grid_getMatches__closure: {
    "^": "Closure:63;checked_2,matches_3",
    call$1: [function(piece) {
      var t1, match;
      t1 = this.checked_2;
      if (J.$eq(H.Lists_indexOf(t1, piece, 0, t1.length), -1)) {
        match = piece.deepMatchingNeighbours$0();
        H.IterableMixinWorkaround_forEach(match, new M.Grid_getMatches___closure(t1));
        if (match.length >= 3)
          if (piece.get$object().type !== $.get$Grid_emptyObject().type)
            this.matches_3.push(match);
      }
    }, "call$1", null, 2, 0, null, 1711, [], "call"],
    $isFunction: true
  },
  Grid_getMatches___closure: {
    "^": "Closure:63;checked_4",
    call$1: function(m) {
      return this.checked_4.push(m);
    },
    $isFunction: true
  },
  Grid_getRow_closure: {
    "^": "Closure:63;row_0,pieces_1",
    call$1: function(piece) {
      return this.pieces_1.push(J.$index$asx(piece, this.row_0));
    },
    $isFunction: true
  },
  Grid_clearMatches_closure: {
    "^": "Closure:63;",
    call$1: function(pieces) {
      J.forEach$1$ax(pieces, new M.Grid_clearMatches__closure());
    },
    $isFunction: true
  },
  Grid_clearMatches__closure: {
    "^": "Closure:63;",
    call$1: [function(p) {
      return J.clear$0$ax(p);
    }, "call$1", null, 2, 0, null, 192, [], "call"],
    $isFunction: true
  },
  Grid_applyGravity_closure: {
    "^": "Closure:63;box_2,box_1,direction_3,fallingPieces_4",
    call$1: function(grid) {
      var t1, t2;
      t1 = {};
      t1.swaps_0 = 0;
      t2 = this.box_2.chunk_2;
      t2.toString;
      H.IterableMixinWorkaround_forEach(t2, new M.Grid_applyGravity__closure(t1, this.direction_3, this.fallingPieces_4, grid));
      if (t1.swaps_0 > 0)
        this.box_1.applyGravity_1.call$1(grid);
    },
    $isFunction: true
  },
  Grid_applyGravity__closure: {
    "^": "Closure:63;box_0,direction_5,fallingPieces_6,grid_7",
    call$1: function(piece) {
      var neighbour, tmp1, t1;
      neighbour = piece.neighbour$1(this.direction_5);
      if (neighbour != null)
        if (piece.get$object().type !== $.get$Grid_emptyObject().type && neighbour.get$object().type === $.get$Grid_emptyObject().type) {
          tmp1 = piece.get$object();
          piece.set$object(neighbour.get$object());
          neighbour.set$object(tmp1);
          t1 = this.fallingPieces_6;
          if (J.$eq(H.Lists_indexOf(t1, neighbour, 0, t1.length), -1))
            t1.push(neighbour);
          ++this.box_0.swaps_0;
        }
    },
    $isFunction: true
  },
  Grid_applyGravity_closure0: {
    "^": "Closure:63;fallingPiecesWithoutEmpty_8",
    call$1: function(piece) {
      if (piece.get$object().type !== $.get$Grid_emptyObject().type)
        this.fallingPiecesWithoutEmpty_8.push(piece);
    },
    $isFunction: true
  },
  Locus: {
    "^": "Object;x*,y*",
    toString$0: function(_) {
      return "Locus(" + H.S(this.x) + ", " + H.S(this.y) + ")";
    }
  },
  MatchObject: {
    "^": "Object;type*"
  },
  Pair: {
    "^": "Object;order,first,second<,ordinals",
    order$0: function($receiver) {
      return this.order.call$0();
    }
  },
  Piece: {
    "^": "Locus;grid,object@,x,y",
    clear$0: function(_) {
      this.object = new M.MatchObject("__empty__");
    },
    relativeCoordinates$2: function(direction, distance) {
      var t1, t2, t3;
      t1 = this.x;
      t2 = J.getInterceptor$x(direction);
      t3 = t2.get$x(direction);
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = J.$add$ns(t1, distance * t3);
      t1 = this.y;
      t2 = t2.get$y(direction);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return new M.Locus(t3, J.$add$ns(t1, distance * t2));
    },
    neighbour$1: function(direction) {
      return this.grid.getPiece$1(this.relativeCoordinates$2(direction, 1));
    },
    matchingNeighbours$0: function() {
      var matches = [];
      this.grid.neighboursOf$1(this).forEach$1(0, new M.Piece_matchingNeighbours_closure(this, matches));
      return matches;
    },
    deepMatchingNeighbours$0: function() {
      var t1, deepMatches, deepMatchingNeighbours;
      t1 = {};
      deepMatches = [];
      t1.deepMatchingNeighbours_0 = null;
      deepMatchingNeighbours = new M.Piece_deepMatchingNeighbours_closure(t1, deepMatches);
      t1.deepMatchingNeighbours_0 = deepMatchingNeighbours;
      deepMatchingNeighbours.call$1(this);
      return deepMatches;
    }
  },
  Piece_matchingNeighbours_closure: {
    "^": "Closure:935;this_0,matches_1",
    call$2: function(direction, neighbour) {
      if (neighbour != null)
        if (neighbour.get$object().type === this.this_0.object.type)
          this.matches_1.push(neighbour);
    },
    $isFunction: true
  },
  Piece_deepMatchingNeighbours_closure: {
    "^": "Closure:63;box_0,deepMatches_1",
    call$1: function(piece) {
      H.IterableMixinWorkaround_forEach(piece.matchingNeighbours$0(), new M.Piece_deepMatchingNeighbours__closure(this.box_0, this.deepMatches_1));
    },
    $isFunction: true
  },
  Piece_deepMatchingNeighbours__closure: {
    "^": "Closure:63;box_0,deepMatches_2",
    call$1: function(matchingNeighbour) {
      var t1 = this.deepMatches_2;
      if (J.$eq(H.Lists_indexOf(t1, matchingNeighbour, 0, t1.length), -1)) {
        t1.push(matchingNeighbour);
        this.box_0.deepMatchingNeighbours_0.call$1(matchingNeighbour);
      }
    },
    $isFunction: true
  }
}],
["metadata", "packages/$sdk/lib/html/html_common/metadata.dart", , B, {
  "^": "",
  SupportedBrowser: {
    "^": "Object;browserName,minimumVersion",
    static: {"^": "SupportedBrowser_CHROME,SupportedBrowser_FIREFOX,SupportedBrowser_IE,SupportedBrowser_OPERA,SupportedBrowser_SAFARI"}
  },
  Experimental: {
    "^": "Object;"
  },
  DomName: {
    "^": "Object;name>"
  },
  DocsEditable: {
    "^": "Object;"
  },
  Unstable: {
    "^": "Object;"
  }
}],
["tweenengine", "package:alienzed/tween/tweenengine.dart", , B, {
  "^": "",
  Back: {
    "^": "TweenEquation;compute,name",
    static: {"^": "Back__param_s,Back_IN,Back_OUT,Back_INOUT", Back__computeIN: [function(time) {
        var s, t1;
        s = $.Back__param_s;
        t1 = J.$mul$ns(time, time);
        if (typeof time !== "number")
          return H.iae(time);
        return J.$mul$ns(t1, (s + 1) * time - s);
      }, "call$1", "Back__computeIN$closure", 2, 0, 331, 568, []], Back__computeOUT: [function(time) {
        var s, t1;
        s = $.Back__param_s;
        time = J.$sub$n(time, 1);
        t1 = J.$mul$ns(time, time);
        if (typeof time !== "number")
          return H.iae(time);
        return J.$add$ns(J.$mul$ns(t1, (s + 1) * time + s), 1);
      }, "call$1", "Back__computeOUT$closure", 2, 0, 331, 568, []], Back__computeINOUT: [function(time) {
        var s, t1;
        s = $.Back__param_s;
        time = J.$mul$ns(time, 2);
        t1 = J.getInterceptor$n(time);
        if (t1.$lt(time, 1)) {
          t1 = t1.$mul(time, time);
          s *= 1.525;
          if (typeof time !== "number")
            return H.iae(time);
          t1 = J.$mul$ns(t1, (s + 1) * time - s);
          if (typeof t1 !== "number")
            return H.iae(t1);
          return 0.5 * t1;
        }
        time = t1.$sub(time, 2);
        t1 = J.$mul$ns(time, time);
        s *= 1.525;
        if (typeof time !== "number")
          return H.iae(time);
        t1 = J.$add$ns(J.$mul$ns(t1, (s + 1) * time + s), 2);
        if (typeof t1 !== "number")
          return H.iae(t1);
        return 0.5 * t1;
      }, "call$1", "Back__computeINOUT$closure", 2, 0, 331, 568, []]}
  },
  "+Back": 0,
  Bounce: {
    "^": "TweenEquation;compute,name",
    static: {"^": "Bounce_IN,Bounce_OUT,Bounce_INOUT", Bounce__computeIN: [function(time) {
        if (typeof time !== "number")
          return H.iae(time);
        return 1 - B.Bounce__computeOUT(1 - time);
      }, "call$1", "Bounce__computeIN$closure", 2, 0, 331, 568, []], Bounce__computeOUT: [function(t) {
        var t1 = J.getInterceptor$n(t);
        if (t1.$lt(t, 0.36363636363636365)) {
          if (typeof t !== "number")
            return H.iae(t);
          return 7.5625 * t * t;
        } else if (t1.$lt(t, 0.7272727272727273)) {
          t = t1.$sub(t, 0.5454545454545454);
          if (typeof t !== "number")
            return H.iae(t);
          return 7.5625 * t * t + 0.75;
        } else if (t1.$lt(t, 0.9090909090909091)) {
          t = t1.$sub(t, 0.8181818181818182);
          if (typeof t !== "number")
            return H.iae(t);
          return 7.5625 * t * t + 0.9375;
        } else {
          t = t1.$sub(t, 0.9545454545454546);
          if (typeof t !== "number")
            return H.iae(t);
          return 7.5625 * t * t + 0.984375;
        }
      }, "call$1", "Bounce__computeOUT$closure", 2, 0, 331, 380, []], Bounce__computeINOUT: [function(t) {
        var t1 = J.getInterceptor$n(t);
        if (t1.$lt(t, 0.5)) {
          t1 = t1.$mul(t, 2);
          if (typeof t1 !== "number")
            return H.iae(t1);
          return (1 - B.Bounce__computeOUT(1 - t1)) * 0.5;
        } else
          return B.Bounce__computeOUT(J.$sub$n(t1.$mul(t, 2), 1)) * 0.5 + 0.5;
      }, "call$1", "Bounce__computeINOUT$closure", 2, 0, 331, 380, []]}
  },
  "+Bounce": 0,
  Circ: {
    "^": "TweenEquation;compute,name",
    static: {"^": "Circ_IN,Circ_OUT,Circ_INOUT", Circ__computeIN: [function(time) {
        var t1 = J.$mul$ns(time, time);
        if (typeof t1 !== "number")
          return H.iae(t1);
        return -Math.sqrt(1 - t1) - 1;
      }, "call$1", "Circ__computeIN$closure", 2, 0, 331, 568, []], Circ__computeOUT: [function(t) {
        var t1;
        t = J.$sub$n(t, 1);
        t1 = J.$mul$ns(t, t);
        if (typeof t1 !== "number")
          return H.iae(t1);
        return Math.sqrt(1 - t1);
      }, "call$1", "Circ__computeOUT$closure", 2, 0, 331, 380, []], Circ__computeINOUT: [function(t) {
        var t1;
        t = J.$mul$ns(t, 2);
        t1 = J.getInterceptor$n(t);
        if (t1.$lt(t, 1)) {
          t1 = t1.$mul(t, t);
          if (typeof t1 !== "number")
            return H.iae(t1);
          return -0.5 * (Math.sqrt(1 - t1) - 1);
        }
        t = t1.$sub(t, 2);
        t1 = J.$mul$ns(t, t);
        if (typeof t1 !== "number")
          return H.iae(t1);
        return 0.5 * (Math.sqrt(1 - t1) + 1);
      }, "call$1", "Circ__computeINOUT$closure", 2, 0, 331, 380, []]}
  },
  "+Circ": 0,
  Elastic: {
    "^": "TweenEquation;param_a,param_p,setA,setP,compute,name",
    a$1: [function(_, a) {
      this.param_a = a;
      this.setA = true;
    }, "call$1", "get$a", 2, 0, 569, 304, []],
    static: {"^": "Elastic_IN,Elastic_OUT,Elastic_INOUT", Elastic__computeIN: [function(t) {
        var t1 = J.getInterceptor(t);
        if (t1.$eq(t, 0))
          return 0;
        if (t1.$eq(t, 1))
          return 1;
        t = t1.$sub(t, 1);
        if (typeof t !== "number")
          return H.iae(t);
        t1 = Math.pow(2, 10 * t);
        return -(t1 * Math.sin((t - 0.075) * 6.283185307179586 / 0.3));
      }, "call$1", "Elastic__computeIN$closure", 2, 0, 331, 380, []], Elastic__computeOUT: [function(t) {
        var t1 = J.getInterceptor(t);
        if (t1.$eq(t, 0))
          return 0;
        if (t1.$eq(t, 1))
          return 1;
        if (typeof t !== "number")
          return H.iae(t);
        t1 = Math.pow(2, -10 * t);
        return t1 * Math.sin((t - 0.075) * 6.283185307179586 / 0.3) + 1;
      }, "call$1", "Elastic__computeOUT$closure", 2, 0, 331, 380, []], Elastic__computeINOUT: [function(t) {
        var t1 = J.getInterceptor(t);
        if (t1.$eq(t, 0))
          return 0;
        t = t1.$mul(t, 2);
        t1 = J.getInterceptor(t);
        if (t1.$eq(t, 2))
          return 1;
        if (t1.$lt(t, 1)) {
          t = t1.$sub(t, 1);
          if (typeof t !== "number")
            return H.iae(t);
          t1 = Math.pow(2, 10 * t);
          return -0.5 * (t1 * Math.sin((t - 0.11249999999999999) * 6.283185307179586 / 0.44999999999999996));
        }
        t = t1.$sub(t, 1);
        if (typeof t !== "number")
          return H.iae(t);
        t1 = Math.pow(2, -10 * t);
        return t1 * Math.sin((t - 0.11249999999999999) * 6.283185307179586 / 0.44999999999999996) * 0.5 + 1;
      }, "call$1", "Elastic__computeINOUT$closure", 2, 0, 331, 380, []]}
  },
  "+Elastic": 0,
  Expo: {
    "^": "TweenEquation;compute,name",
    static: {"^": "Expo_IN,Expo_OUT,Expo_INOUT", Expo__computeIN: [function(t) {
        var t1 = J.getInterceptor(t);
        if (t1.$eq(t, 0))
          t1 = 0;
        else {
          t1 = t1.$sub(t, 1);
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = Math.pow(2, 10 * t1);
        }
        return t1;
      }, "call$1", "Expo__computeIN$closure", 2, 0, 331, 380, []], Expo__computeOUT: [function(t) {
        var t1;
        if (J.$eq(t, 1))
          t1 = 1;
        else {
          if (typeof t !== "number")
            return H.iae(t);
          t1 = -Math.pow(2, -10 * t) + 1;
        }
        return t1;
      }, "call$1", "Expo__computeOUT$closure", 2, 0, 331, 380, []], Expo__computeINOUT: [function(t) {
        var t1 = J.getInterceptor(t);
        if (t1.$eq(t, 0))
          return 0;
        if (t1.$eq(t, 1))
          return 1;
        t = t1.$mul(t, 2);
        t1 = J.getInterceptor$n(t);
        if (t1.$lt(t, 1)) {
          t1 = t1.$sub(t, 1);
          if (typeof t1 !== "number")
            return H.iae(t1);
          return 0.5 * Math.pow(2, 10 * t1);
        }
        t = t1.$sub(t, 1);
        if (typeof t !== "number")
          return H.iae(t);
        return 0.5 * (-Math.pow(2, -10 * t) + 2);
      }, "call$1", "Expo__computeINOUT$closure", 2, 0, 331, 380, []]}
  },
  Linear: {
    "^": "TweenEquation;compute,name",
    static: {"^": "Linear_INOUT"}
  },
  "+Linear": 0,
  closure: {
    "^": "Closure:605;",
    call$1: [function(t) {
      return t;
    }, "call$1", null, 2, 0, null, 380, [], "call"],
    $isFunction: true
  },
  Quad: {
    "^": "TweenEquation;compute,name",
    static: {"^": "Quad_IN,Quad_OUT,Quad_INOUT", Quad__computeINOUT: [function(t) {
        var t1;
        t = J.$mul$ns(t, 2);
        t1 = J.getInterceptor$n(t);
        if (t1.$lt(t, 1)) {
          if (typeof t !== "number")
            return H.iae(t);
          return 0.5 * t * t;
        }
        t = t1.$sub(t, 1);
        t1 = J.getInterceptor$n(t);
        t1 = J.$sub$n(t1.$mul(t, t1.$sub(t, 2)), 1);
        if (typeof t1 !== "number")
          return H.iae(t1);
        return -0.5 * t1;
      }, "call$1", "Quad__computeINOUT$closure", 2, 0, 331, 380, []]}
  },
  closure1: {
    "^": "Closure:605;",
    call$1: [function(t) {
      return J.$mul$ns(t, t);
    }, "call$1", null, 2, 0, null, 380, [], "call"],
    $isFunction: true
  },
  closure0: {
    "^": "Closure:605;",
    call$1: [function(t) {
      var t1 = J.getInterceptor$n(t);
      return J.$mul$ns(t1.$negate(t), t1.$sub(t, 2));
    }, "call$1", null, 2, 0, null, 380, [], "call"],
    $isFunction: true
  },
  Quart: {
    "^": "TweenEquation;compute,name",
    static: {"^": "Quart_IN,Quart_OUT,Quart_INOUT", Quart__computeINOUT: [function(t) {
        var t1;
        t = J.$mul$ns(t, 2);
        t1 = J.getInterceptor$n(t);
        if (t1.$lt(t, 1)) {
          if (typeof t !== "number")
            return H.iae(t);
          return 0.5 * t * t * t * t;
        }
        t = t1.$sub(t, 2);
        t1 = J.$sub$n(J.$mul$ns(J.$mul$ns(J.$mul$ns(t, t), t), t), 2);
        if (typeof t1 !== "number")
          return H.iae(t1);
        return -0.5 * t1;
      }, "call$1", "Quart__computeINOUT$closure", 2, 0, 331, 380, []]}
  },
  closure3: {
    "^": "Closure:605;",
    call$1: [function(t) {
      return J.$mul$ns(J.$mul$ns(J.$mul$ns(t, t), t), t);
    }, "call$1", null, 2, 0, null, 380, [], "call"],
    $isFunction: true
  },
  closure2: {
    "^": "Closure:605;",
    call$1: [function(t) {
      t = J.$sub$n(t, 1);
      return J.$negate$n(J.$sub$n(J.$mul$ns(J.$mul$ns(J.$mul$ns(t, t), t), t), 1));
    }, "call$1", null, 2, 0, null, 380, [], "call"],
    $isFunction: true
  },
  Quint: {
    "^": "TweenEquation;compute,name",
    static: {"^": "Quint_IN,Quint_OUT,Quint_INOUT", Quint__computeINOUT: [function(t) {
        var t1;
        t = J.$mul$ns(t, 2);
        t1 = J.getInterceptor$n(t);
        if (t1.$lt(t, 1)) {
          if (typeof t !== "number")
            return H.iae(t);
          return 0.5 * t * t * t * t * t;
        }
        t = t1.$sub(t, 2);
        t1 = J.$add$ns(J.$mul$ns(J.$mul$ns(J.$mul$ns(J.$mul$ns(t, t), t), t), t), 2);
        if (typeof t1 !== "number")
          return H.iae(t1);
        return 0.5 * t1;
      }, "call$1", "Quint__computeINOUT$closure", 2, 0, 331, 380, []]}
  },
  closure7: {
    "^": "Closure:605;",
    call$1: [function(t) {
      return J.$mul$ns(J.$mul$ns(J.$mul$ns(J.$mul$ns(t, t), t), t), t);
    }, "call$1", null, 2, 0, null, 380, [], "call"],
    $isFunction: true
  },
  closure8: {
    "^": "Closure:605;",
    call$1: [function(t) {
      t = J.$sub$n(t, 1);
      return J.$add$ns(J.$mul$ns(J.$mul$ns(J.$mul$ns(J.$mul$ns(t, t), t), t), t), 1);
    }, "call$1", null, 2, 0, null, 380, [], "call"],
    $isFunction: true
  },
  Sine: {
    "^": "TweenEquation;compute,name",
    static: {"^": "Sine_IN,Sine_OUT,Sine_INOUT"}
  },
  closure6: {
    "^": "Closure:605;",
    call$1: [function(t) {
      var t1 = J.$mul$ns(t, 1.5707963267948966);
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      return -Math.cos(t1) + 1;
    }, "call$1", null, 2, 0, null, 380, [], "call"],
    $isFunction: true
  },
  closure4: {
    "^": "Closure:605;",
    call$1: [function(t) {
      var t1 = J.$mul$ns(t, 1.5707963267948966);
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      return Math.sin(t1);
    }, "call$1", null, 2, 0, null, 380, [], "call"],
    $isFunction: true
  },
  closure5: {
    "^": "Closure:605;",
    call$1: [function(t) {
      if (typeof t !== "number")
        return H.iae(t);
      return -0.5 * (Math.cos(3.141592653589793 * t) - 1);
    }, "call$1", null, 2, 0, null, 380, [], "call"],
    $isFunction: true
  },
  TweenEquation: {
    "^": "Object;name*"
  }
}],
]);
Isolate.$finishClasses($$, $, null);
$$ = null;

// Runtime type support
;(function() {
  var TRUE = !0, _;
  _ = P.$int;
  _.$is$int = TRUE;
  _.$isnum = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.num];
  _.$isObject = TRUE;
  _ = P.$double;
  _.$is$double = TRUE;
  _.$isnum = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.num];
  _.$isObject = TRUE;
  _ = W.Node;
  _.$isNode = TRUE;
  _.$isEventTarget = TRUE;
  _.$isObject = TRUE;
  W.Touch0.$isObject = TRUE;
  _ = P.String;
  _.$isString = TRUE;
  _.$isPattern = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.String];
  _.$isObject = TRUE;
  _ = P.num;
  _.$isnum = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.num];
  _.$isObject = TRUE;
  _ = P.Duration;
  _.$isDuration = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.Duration];
  _.$isObject = TRUE;
  P.Object.$isObject = TRUE;
  _ = W.Element;
  _.$isElement = TRUE;
  _.$isNode = TRUE;
  _.$isEventTarget = TRUE;
  _.$isEventTarget = TRUE;
  _.$isObject = TRUE;
  _ = P.List;
  _.$isList = TRUE;
  _.$isIterable = TRUE;
  _.$isObject = TRUE;
  P.Match.$isObject = TRUE;
  W.Event.$isObject = TRUE;
  _ = R.SignalBinding;
  _.$isSignalBinding = TRUE;
  _.$isObject = TRUE;
  _ = R.Pointer;
  _.$isPointer = TRUE;
  _.$isObject = TRUE;
  P.RenderingContext.$isObject = TRUE;
  W.ProgressEvent.$isObject = TRUE;
  _ = P.AudioBuffer;
  _.$isAudioBuffer = TRUE;
  _.$isObject = TRUE;
  W.AnimationEvent.$isObject = TRUE;
  _ = P.bool;
  _.$isbool = TRUE;
  _.$isObject = TRUE;
  _ = W.MouseEvent;
  _.$isMouseEvent = TRUE;
  _.$isObject = TRUE;
  _ = P.Symbol0;
  _.$isSymbol0 = TRUE;
  _.$isObject = TRUE;
  _ = P.LibraryMirror;
  _.$isLibraryMirror = TRUE;
  _.$isObject = TRUE;
  _ = P.ClassMirror;
  _.$isTypeMirror = TRUE;
  _.$isObject = TRUE;
  _ = W.TouchEvent;
  _.$isTouchEvent = TRUE;
  _.$isObject = TRUE;
  _ = R.Body0;
  _.$isRectangle1 = TRUE;
  _.$isObject = TRUE;
  _ = R.QuadTree;
  _.$isQuadTree = TRUE;
  _.$isObject = TRUE;
  P.ContextEvent.$isObject = TRUE;
  H.RawReceivePortImpl.$isObject = TRUE;
  H._IsolateEvent.$isObject = TRUE;
  H._IsolateContext.$isObject = TRUE;
  _ = P.Stream;
  _.$isStream = TRUE;
  _.$isObject = TRUE;
  _ = P.StreamSubscription;
  _.$isStreamSubscription = TRUE;
  _.$isObject = TRUE;
  _ = W.WheelEvent;
  _.$isMouseEvent = TRUE;
  _.$isObject = TRUE;
  P.MethodMirror.$isObject = TRUE;
  H.JsMethodMirror.$isObject = TRUE;
  P.ParameterMirror.$isObject = TRUE;
  _ = P.TypeVariableMirror;
  _.$isTypeMirror = TRUE;
  _.$isObject = TRUE;
  _ = P.TypeMirror;
  _.$isTypeMirror = TRUE;
  _.$isObject = TRUE;
  _ = W.TableRowElement;
  _.$isElement = TRUE;
  _.$isNode = TRUE;
  _.$isEventTarget = TRUE;
  _.$isEventTarget = TRUE;
  _.$isObject = TRUE;
  _ = W.MediaStream;
  _.$isMediaStream = TRUE;
  _.$isEventTarget = TRUE;
  _.$isObject = TRUE;
  _ = P.StackTrace;
  _.$isStackTrace = TRUE;
  _.$isObject = TRUE;
  _ = R.Sprite0;
  _.$isSprite0 = TRUE;
  _.$isSprite = TRUE;
  _.$isGameObject = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isSpriteInterface = TRUE;
  _.$isObject = TRUE;
  _ = M.PixiEvent;
  _.$isPixiEvent = TRUE;
  _.$isObject = TRUE;
  _ = P._BufferingStreamSubscription;
  _.$is_BufferingStreamSubscription = TRUE;
  _.$is_EventSink = TRUE;
  _.$isStreamSubscription = TRUE;
  _.$isObject = TRUE;
  _ = P._BroadcastSubscription;
  _.$is_BroadcastSubscription = TRUE;
  _.$is_BufferingStreamSubscription = TRUE;
  _.$is_EventSink = TRUE;
  _.$isStreamSubscription = TRUE;
  _.$isObject = TRUE;
  _ = P.Map;
  _.$isMap = TRUE;
  _.$isObject = TRUE;
  _ = R.Tween;
  _.$isTween = TRUE;
  _.$isObject = TRUE;
  _ = M.Texture;
  _.$isTexture = TRUE;
  _.$isObject = TRUE;
  _ = W.CanvasElement;
  _.$isCanvasElement = TRUE;
  _.$isElement = TRUE;
  _.$isNode = TRUE;
  _.$isEventTarget = TRUE;
  _.$isEventTarget = TRUE;
  _.$isObject = TRUE;
  _ = P.Comparable;
  _.$isComparable = TRUE;
  _.$isObject = TRUE;
  _ = W.EventTarget;
  _.$isEventTarget = TRUE;
  _.$isObject = TRUE;
  _ = P.InstanceMirror;
  _.$isInstanceMirror = TRUE;
  _.$isObject = TRUE;
  _ = P._EventSink;
  _.$is_EventSink = TRUE;
  _.$isObject = TRUE;
  _ = P.Future;
  _.$isFuture = TRUE;
  _.$isObject = TRUE;
  _ = P._DelayedEvent;
  _.$is_DelayedEvent = TRUE;
  _.$isObject = TRUE;
  _ = R.State;
  _.$isState = TRUE;
  _.$isObject = TRUE;
  _ = P.DateTime;
  _.$isDateTime = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [null];
  _.$isObject = TRUE;
  _ = R.Timer;
  _.$isTimer = TRUE;
  _.$isObject = TRUE;
  _ = R.Emitter;
  _.$isEmitter = TRUE;
  _.$isGroup = TRUE;
  _.$asGroup = [null];
  _.$isDisplayObjectContainer = TRUE;
  _.$isGameObject = TRUE;
  _.$isObject = TRUE;
  _ = R.Plugin;
  _.$isPlugin = TRUE;
  _.$isObject = TRUE;
  _ = R.Sound;
  _.$isSound = TRUE;
  _.$isObject = TRUE;
  _ = R.Loader;
  _.$isLoader = TRUE;
  _.$isObject = TRUE;
  _ = R.Point;
  _.$isPoint = TRUE;
  _.$isPoint0 = TRUE;
  _.$isObject = TRUE;
  _ = R.Key;
  _.$isKey = TRUE;
  _.$isObject = TRUE;
  _ = R.Group;
  _.$isGroup = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isGameObject = TRUE;
  _.$isObject = TRUE;
  _ = R.Animation;
  _.$isAnimation = TRUE;
  _.$isObject = TRUE;
  _ = R.Rectangle1;
  _.$isRectangle1 = TRUE;
  _.$isObject = TRUE;
  _ = P.Function;
  _.$isFunction = TRUE;
  _.$isObject = TRUE;
  _ = R.Button;
  _.$isButton = TRUE;
  _.$isImage = TRUE;
  _.$isSprite = TRUE;
  _.$isSpriteInterface = TRUE;
  _.$isGameObject = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  _ = R.GameObject;
  _.$isGameObject = TRUE;
  _.$isObject = TRUE;
  _ = R.Circle0;
  _.$isCircle0 = TRUE;
  _.$isObject = TRUE;
  _ = R.Text0;
  _.$isText0 = TRUE;
  _.$isGameObject = TRUE;
  _.$isSprite = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  _ = R.TextStyle0;
  _.$isTextStyle0 = TRUE;
  _.$isObject = TRUE;
  _ = R.TimerEvent;
  _.$isTimerEvent = TRUE;
  _.$isObject = TRUE;
  _ = M.DisplayObjectContainer;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  _ = M.Point0;
  _.$isPoint0 = TRUE;
  _.$isObject = TRUE;
  _ = W.CanvasRenderingContext2D;
  _.$isCanvasRenderingContext2D = TRUE;
  _.$isObject = TRUE;
  _ = R.TilemapLayer;
  _.$isTilemapLayer = TRUE;
  _.$isImage = TRUE;
  _.$isSprite = TRUE;
  _.$isSpriteInterface = TRUE;
  _.$isGameObject = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  _ = P.Iterable;
  _.$isIterable = TRUE;
  _.$isObject = TRUE;
  _ = R.Image;
  _.$isImage = TRUE;
  _.$isSprite = TRUE;
  _.$isSpriteInterface = TRUE;
  _.$isGameObject = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  _ = M.Stage0;
  _.$isStage0 = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  _ = M.Sprite;
  _.$isSprite = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  _ = P.UniformLocation;
  _.$isUniformLocation = TRUE;
  _.$isObject = TRUE;
  _ = P.Float32List;
  _.$isFloat32List = TRUE;
  _.$isList = TRUE;
  _.$asList = [P.$double];
  _.$isIterable = TRUE;
  _.$asIterable = [P.$double];
  _.$isObject = TRUE;
  _ = P.Pattern;
  _.$isPattern = TRUE;
  _.$isObject = TRUE;
  _ = R.SpriteInterface;
  _.$isSpriteInterface = TRUE;
  _.$isObject = TRUE;
  _ = M.Locus;
  _.$isLocus = TRUE;
  _.$isObject = TRUE;
  _ = M.SpriteBatch0;
  _.$isSpriteBatch0 = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  _ = M.Graphics0;
  _.$isGraphics0 = TRUE;
  _.$isDisplayObjectContainer = TRUE;
  _.$isObject = TRUE;
  _ = E.Circle1;
  _.$isCircle1 = TRUE;
  _.$isObject = TRUE;
  _ = E.Tile0;
  _.$isTile0 = TRUE;
  _.$isObject = TRUE;
  _ = E.AABB;
  _.$isAABB = TRUE;
  _.$isObject = TRUE;
  _ = R.Tile;
  _.$isTile = TRUE;
  _.$isObject = TRUE;
})();
;
// getInterceptor methods
J.getInterceptor = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSDouble.prototype;
  }
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return J.JSNull.prototype;
  if (typeof receiver == "boolean")
    return J.JSBool.prototype;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$asx = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$ax = function(receiver) {
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$i = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSNumber.prototype;
  }
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$n = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$ns = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$s = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$x = function(receiver) {
  if (receiver == null)
    return receiver;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.$add$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver + a0;
  return J.getInterceptor$ns(receiver).$add(receiver, a0);
};
J.$and$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return (receiver & a0) >>> 0;
  return J.getInterceptor$n(receiver).$and(receiver, a0);
};
J.$div$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver / a0;
  return J.getInterceptor$n(receiver).$div(receiver, a0);
};
J.$eq = function(receiver, a0) {
  if (receiver == null)
    return a0 == null;
  if (typeof receiver != "object")
    return a0 != null && receiver === a0;
  return J.getInterceptor(receiver).$eq(receiver, a0);
};
J.$ge$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver >= a0;
  return J.getInterceptor$n(receiver).$ge(receiver, a0);
};
J.$gt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver > a0;
  return J.getInterceptor$n(receiver).$gt(receiver, a0);
};
J.$index$asx = function(receiver, a0) {
  if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
    if (a0 >>> 0 === a0 && a0 < receiver.length)
      return receiver[a0];
  return J.getInterceptor$asx(receiver).$index(receiver, a0);
};
J.$indexSet$ax = function(receiver, a0, a1) {
  if ((receiver.constructor == Array || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName])) && !receiver.immutable$list && a0 >>> 0 === a0 && a0 < receiver.length)
    return receiver[a0] = a1;
  return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
};
J.$le$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver <= a0;
  return J.getInterceptor$n(receiver).$le(receiver, a0);
};
J.$lt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver < a0;
  return J.getInterceptor$n(receiver).$lt(receiver, a0);
};
J.$mod$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).$mod(receiver, a0);
};
J.$mul$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver * a0;
  return J.getInterceptor$ns(receiver).$mul(receiver, a0);
};
J.$negate$n = function(receiver) {
  if (typeof receiver == "number")
    return -receiver;
  return J.getInterceptor$n(receiver).$negate(receiver);
};
J.$not$i = function(receiver) {
  if (typeof receiver == "number" && Math.floor(receiver) == receiver)
    return ~receiver >>> 0;
  return J.getInterceptor$i(receiver).$not(receiver);
};
J.$shl$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).$shl(receiver, a0);
};
J.$shr$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).$shr(receiver, a0);
};
J.$sub$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver - a0;
  return J.getInterceptor$n(receiver).$sub(receiver, a0);
};
J.$tdiv$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).$tdiv(receiver, a0);
};
J.$xor$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return (receiver ^ a0) >>> 0;
  return J.getInterceptor$n(receiver).$xor(receiver, a0);
};
J._clearChildren$0$x = function(receiver) {
  return J.getInterceptor$x(receiver)._clearChildren$0(receiver);
};
J._replaceChild$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver)._replaceChild$2(receiver, a0, a1);
};
J.abs$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).abs$0(receiver);
};
J.activeTexture$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).activeTexture$1(receiver, a0);
};
J.add$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).add$1(receiver, a0);
};
J.add$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).add$2(receiver, a0, a1);
};
J.add$4$ax = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$ax(receiver).add$4(receiver, a0, a1, a2, a3);
};
J.addAll$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).addAll$1(receiver, a0);
};
J.addEventListener$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).addEventListener$2(receiver, a0, a1);
};
J.addEventListener$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).addEventListener$3(receiver, a0, a1, a2);
};
J.any$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).any$1(receiver, a0);
};
J.append$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).append$1(receiver, a0);
};
J.arc$5$x = function(receiver, a0, a1, a2, a3, a4) {
  return J.getInterceptor$x(receiver).arc$5(receiver, a0, a1, a2, a3, a4);
};
J.arc$6$x = function(receiver, a0, a1, a2, a3, a4, a5) {
  return J.getInterceptor$x(receiver).arc$6(receiver, a0, a1, a2, a3, a4, a5);
};
J.beginPath$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).beginPath$0(receiver);
};
J.bindBuffer$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).bindBuffer$2(receiver, a0, a1);
};
J.bindFramebuffer$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).bindFramebuffer$2(receiver, a0, a1);
};
J.bindRenderbuffer$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).bindRenderbuffer$2(receiver, a0, a1);
};
J.bindTexture$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).bindTexture$2(receiver, a0, a1);
};
J.blendFunc$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).blendFunc$2(receiver, a0, a1);
};
J.bufferSubData$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).bufferSubData$3(receiver, a0, a1, a2);
};
J.button$5$x = function(receiver, a0, a1, a2, a3, a4) {
  return J.getInterceptor$x(receiver).button$5(receiver, a0, a1, a2, a3, a4);
};
J.ceil$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).ceil$0(receiver);
};
J.clear$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).clear$0(receiver);
};
J.clear$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).clear$1(receiver, a0);
};
J.clearColor$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).clearColor$4(receiver, a0, a1, a2, a3);
};
J.clearRect$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).clearRect$4(receiver, a0, a1, a2, a3);
};
J.clone$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).clone$0(receiver);
};
J.closePath$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).closePath$0(receiver);
};
J.codeUnitAt$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).codeUnitAt$1(receiver, a0);
};
J.colorMask$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).colorMask$4(receiver, a0, a1, a2, a3);
};
J.compareTo$1$ns = function(receiver, a0) {
  return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
};
J.connectNode$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).connectNode$1(receiver, a0);
};
J.contains$1$asx = function(receiver, a0) {
  return J.getInterceptor$asx(receiver).contains$1(receiver, a0);
};
J.contains$2$asx = function(receiver, a0, a1) {
  return J.getInterceptor$asx(receiver).contains$2(receiver, a0, a1);
};
J.containsKey$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).containsKey$1(receiver, a0);
};
J.containsPoint$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).containsPoint$2(receiver, a0, a1);
};
J.createBuffer$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createBuffer$0(receiver);
};
J.createBuffer$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).createBuffer$3(receiver, a0, a1, a2);
};
J.createBufferSource$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createBufferSource$0(receiver);
};
J.createFramebuffer$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createFramebuffer$0(receiver);
};
J.createGain$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createGain$0(receiver);
};
J.createRenderbuffer$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createRenderbuffer$0(receiver);
};
J.createTexture$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createTexture$0(receiver);
};
J.decodeAudioData$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).decodeAudioData$1(receiver, a0);
};
J.deleteBuffer$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).deleteBuffer$1(receiver, a0);
};
J.deleteProgram$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).deleteProgram$1(receiver, a0);
};
J.deltaX$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).deltaX$0(receiver);
};
J.deltaY$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).deltaY$0(receiver);
};
J.disable$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).disable$1(receiver, a0);
};
J.disableVertexAttribArray$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).disableVertexAttribArray$1(receiver, a0);
};
J.dispatchEvent$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).dispatchEvent$1(receiver, a0);
};
J.drawElements$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).drawElements$4(receiver, a0, a1, a2, a3);
};
J.drawImageScaledFromSource$9$x = function(receiver, a0, a1, a2, a3, a4, a5, a6, a7, a8) {
  return J.getInterceptor$x(receiver).drawImageScaledFromSource$9(receiver, a0, a1, a2, a3, a4, a5, a6, a7, a8);
};
J.elementAt$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
};
J.enable$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).enable$1(receiver, a0);
};
J.enable$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).enable$2(receiver, a0, a1);
};
J.enableVertexAttribArray$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).enableVertexAttribArray$1(receiver, a0);
};
J.endsWith$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).endsWith$1(receiver, a0);
};
J.fill$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).fill$0(receiver);
};
J.fillRect$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).fillRect$4(receiver, a0, a1, a2, a3);
};
J.fillText$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).fillText$3(receiver, a0, a1, a2);
};
J.firstWhere$2$orElse$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).firstWhere$2$orElse(receiver, a0, a1);
};
J.floor$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).floor$0(receiver);
};
J.flush$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).flush$0(receiver);
};
J.fold$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).fold$2(receiver, a0, a1);
};
J.forEach$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
};
J.forEach$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).forEach$2(receiver, a0, a1);
};
J.framebufferRenderbuffer$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).framebufferRenderbuffer$4(receiver, a0, a1, a2, a3);
};
J.framebufferTexture2D$5$x = function(receiver, a0, a1, a2, a3, a4) {
  return J.getInterceptor$x(receiver).framebufferTexture2D$5(receiver, a0, a1, a2, a3, a4);
};
J.get$_key$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$_key(receiver);
};
J.get$a$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$a(receiver);
};
J.get$acceleration$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$acceleration(receiver);
};
J.get$add$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$add(receiver);
};
J.get$alpha$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$alpha(receiver);
};
J.get$animation$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$animation(receiver);
};
J.get$attributes$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$attributes(receiver);
};
J.get$blur$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$blur(receiver);
};
J.get$body$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$body(receiver);
};
J.get$bottom$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$bottom(receiver);
};
J.get$buffer$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$buffer(receiver);
};
J.get$button$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$button(receiver);
};
J.get$canvas$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$canvas(receiver);
};
J.get$changedTouches$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$changedTouches(receiver);
};
J.get$charCode$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$charCode(receiver);
};
J.get$children$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$children(receiver);
};
J.get$click$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$click(receiver);
};
J.get$contains$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$contains(receiver);
};
J.get$content$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$content(receiver);
};
J.get$context$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$context(receiver);
};
J.get$cursor$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$cursor(receiver);
};
J.get$data$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$data(receiver);
};
J.get$dataset$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$dataset(receiver);
};
J.get$defaultValue$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$defaultValue(receiver);
};
J.get$destination$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$destination(receiver);
};
J.get$disabled$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$disabled(receiver);
};
J.get$duration$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$duration(receiver);
};
J.get$dx$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$dx(receiver);
};
J.get$dy$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$dy(receiver);
};
J.get$enable$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$enable(receiver);
};
J.get$error$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$error(receiver);
};
J.get$fill$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$fill(receiver);
};
J.get$font$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$font(receiver);
};
J.get$gain$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$gain(receiver);
};
J.get$globalAlpha$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$globalAlpha(receiver);
};
J.get$globalCompositeOperation$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$globalCompositeOperation(receiver);
};
J.get$hashCode$ = function(receiver) {
  return J.getInterceptor(receiver).get$hashCode(receiver);
};
J.get$height$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$height(receiver);
};
J.get$id$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$id(receiver);
};
J.get$identifier$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$identifier(receiver);
};
J.get$index$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$index(receiver);
};
J.get$isEmpty$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
};
J.get$isNotEmpty$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$isNotEmpty(receiver);
};
J.get$iterator$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$iterator(receiver);
};
J.get$key$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$key(receiver);
};
J.get$keys$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$keys(receiver);
};
J.get$last$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$last(receiver);
};
J.get$left$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$left(receiver);
};
J.get$length$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$length(receiver);
};
J.get$lineWidth$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$lineWidth(receiver);
};
J.get$load$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$load(receiver);
};
J.get$loop$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$loop(receiver);
};
J.get$mode$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$mode(receiver);
};
J.get$name$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$name(receiver);
};
J.get$offset$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$offset(receiver);
};
J.get$onAnimationStart$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onAnimationStart(receiver);
};
J.get$onDragStart$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onDragStart(receiver);
};
J.get$onError$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onError(receiver);
};
J.get$onLoad$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onLoad(receiver);
};
J.get$onPause$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onPause(receiver);
};
J.get$onTouchEnter$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onTouchEnter(receiver);
};
J.get$onTouchLeave$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onTouchLeave(receiver);
};
J.get$onWebGlContextLost$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onWebGlContextLost(receiver);
};
J.get$onWebGlContextRestored$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onWebGlContextRestored(receiver);
};
J.get$padding$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$padding(receiver);
};
J.get$parent$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$parent(receiver);
};
J.get$parentNode$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$parentNode(receiver);
};
J.get$paused$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$paused(receiver);
};
J.get$points$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$points(receiver);
};
J.get$position$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$position(receiver);
};
J.get$preload$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$preload(receiver);
};
J.get$r$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$r(receiver);
};
J.get$readyState$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$readyState(receiver);
};
J.get$response$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$response(receiver);
};
J.get$responseText$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$responseText(receiver);
};
J.get$responseXml$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$responseXml(receiver);
};
J.get$reversed$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$reversed(receiver);
};
J.get$right$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$right(receiver);
};
J.get$scale$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$scale(receiver);
};
J.get$screenX$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$screenX(receiver);
};
J.get$screenY$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$screenY(receiver);
};
J.get$shadowBlur$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$shadowBlur(receiver);
};
J.get$shadowColor$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$shadowColor(receiver);
};
J.get$shadowOffsetX$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$shadowOffsetX(receiver);
};
J.get$shadowOffsetY$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$shadowOffsetY(receiver);
};
J.get$sign$n = function(receiver) {
  return J.getInterceptor$n(receiver).get$sign(receiver);
};
J.get$size$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$size(receiver);
};
J.get$source$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$source(receiver);
};
J.get$start$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$start(receiver);
};
J.get$status$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$status(receiver);
};
J.get$stop$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$stop(receiver);
};
J.get$stroke$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$stroke(receiver);
};
J.get$style$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$style(receiver);
};
J.get$target$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$target(receiver);
};
J.get$th$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$th(receiver);
};
J.get$top$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$top(receiver);
};
J.get$topLeft$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$topLeft(receiver);
};
J.get$total$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$total(receiver);
};
J.get$trim$s = function(receiver) {
  return J.getInterceptor$s(receiver).get$trim(receiver);
};
J.get$type$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$type(receiver);
};
J.get$url$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$url(receiver);
};
J.get$value$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$value(receiver);
};
J.get$values$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$values(receiver);
};
J.get$view$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$view(receiver);
};
J.get$volume$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$volume(receiver);
};
J.get$width$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$width(receiver);
};
J.get$wordWrap$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$wordWrap(receiver);
};
J.get$x$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$x(receiver);
};
J.get$y$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$y(receiver);
};
J.getAttribLocation$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).getAttribLocation$2(receiver, a0, a1);
};
J.getAttribute$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).getAttribute$1(receiver, a0);
};
J.getBoundingClientRect$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).getBoundingClientRect$0(receiver);
};
J.getContext$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).getContext$1(receiver, a0);
};
J.getContext$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).getContext$2(receiver, a0, a1);
};
J.getContext3d$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).getContext3d$0(receiver);
};
J.getImageData$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).getImageData$4(receiver, a0, a1, a2, a3);
};
J.getPropertyValue$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).getPropertyValue$1(receiver, a0);
};
J.getRange$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).getRange$2(receiver, a0, a1);
};
J.getUniformLocation$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).getUniformLocation$2(receiver, a0, a1);
};
J.indexOf$1$asx = function(receiver, a0) {
  return J.getInterceptor$asx(receiver).indexOf$1(receiver, a0);
};
J.indexOf$2$asx = function(receiver, a0, a1) {
  return J.getInterceptor$asx(receiver).indexOf$2(receiver, a0, a1);
};
J.insert$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).insert$1(receiver, a0);
};
J.insert$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).insert$2(receiver, a0, a1);
};
J.intersects$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).intersects$1(receiver, a0);
};
J.intersects$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).intersects$4(receiver, a0, a1, a2, a3);
};
J.join$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).join$1(receiver, a0);
};
J.lineTo$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).lineTo$2(receiver, a0, a1);
};
J.load$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).load$0(receiver);
};
J.load$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).load$2(receiver, a0, a1);
};
J.map$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).map$1(receiver, a0);
};
J.measureText$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).measureText$1(receiver, a0);
};
J.moveTo$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).moveTo$2(receiver, a0, a1);
};
J.noSuchMethod$1 = function(receiver, a0) {
  return J.getInterceptor(receiver).noSuchMethod$1(receiver, a0);
};
J.noteGrainOn$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).noteGrainOn$3(receiver, a0, a1, a2);
};
J.noteOff$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).noteOff$1(receiver, a0);
};
J.noteOn$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).noteOn$1(receiver, a0);
};
J.open$3$async$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).open$3$async(receiver, a0, a1, a2);
};
J.overrideMimeType$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).overrideMimeType$1(receiver, a0);
};
J.padLeft$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).padLeft$2(receiver, a0, a1);
};
J.parseFromString$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).parseFromString$2(receiver, a0, a1);
};
J.pause$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).pause$0(receiver);
};
J.pixelStorei$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).pixelStorei$2(receiver, a0, a1);
};
J.play$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).play$0(receiver);
};
J.play$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).play$1(receiver, a0);
};
J.play$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).play$3(receiver, a0, a1, a2);
};
J.play$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).play$4(receiver, a0, a1, a2, a3);
};
J.preventDefault$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).preventDefault$0(receiver);
};
J.putImageData$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).putImageData$3(receiver, a0, a1, a2);
};
J.remove$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).remove$0(receiver);
};
J.remove$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).remove$1(receiver, a0);
};
J.removeAt$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).removeAt$1(receiver, a0);
};
J.removeEventListener$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).removeEventListener$2(receiver, a0, a1);
};
J.removeEventListener$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).removeEventListener$3(receiver, a0, a1, a2);
};
J.removeLast$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).removeLast$0(receiver);
};
J.removeRange$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).removeRange$2(receiver, a0, a1);
};
J.repeat$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).repeat$1(receiver, a0);
};
J.replace$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).replace$2(receiver, a0, a1);
};
J.replaceAll$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).replaceAll$2(receiver, a0, a1);
};
J.replaceFirst$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).replaceFirst$2(receiver, a0, a1);
};
J.replaceWith$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).replaceWith$1(receiver, a0);
};
J.reset$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).reset$0(receiver);
};
J.reset$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).reset$1(receiver, a0);
};
J.reset$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).reset$4(receiver, a0, a1, a2, a3);
};
J.reset$6$x = function(receiver, a0, a1, a2, a3, a4, a5) {
  return J.getInterceptor$x(receiver).reset$6(receiver, a0, a1, a2, a3, a4, a5);
};
J.resize$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).resize$2(receiver, a0, a1);
};
J.restore$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).restore$0(receiver);
};
J.round$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).round$0(receiver);
};
J.save$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).save$0(receiver);
};
J.send$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).send$0(receiver);
};
J.send$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).send$1(receiver, a0);
};
J.set$a$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$a(receiver, value);
};
J.set$add$ax = function(receiver, value) {
  return J.getInterceptor$ax(receiver).set$add(receiver, value);
};
J.set$alpha$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$alpha(receiver, value);
};
J.set$any$ax = function(receiver, value) {
  return J.getInterceptor$ax(receiver).set$any(receiver, value);
};
J.set$backgroundColor$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$backgroundColor(receiver, value);
};
J.set$blur$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$blur(receiver, value);
};
J.set$context$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$context(receiver, value);
};
J.set$crossOrigin$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$crossOrigin(receiver, value);
};
J.set$currentTime$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$currentTime(receiver, value);
};
J.set$cursor$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$cursor(receiver, value);
};
J.set$data$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$data(receiver, value);
};
J.set$display$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$display(receiver, value);
};
J.set$fill$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$fill(receiver, value);
};
J.set$fillStyle$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$fillStyle(receiver, value);
};
J.set$font$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$font(receiver, value);
};
J.set$globalAlpha$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$globalAlpha(receiver, value);
};
J.set$globalCompositeOperation$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$globalCompositeOperation(receiver, value);
};
J.set$height$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$height(receiver, value);
};
J.set$imageRendering$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$imageRendering(receiver, value);
};
J.set$imageSmoothingEnabled$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$imageSmoothingEnabled(receiver, value);
};
J.set$index$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$index(receiver, value);
};
J.set$left$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$left(receiver, value);
};
J.set$length$asx = function(receiver, value) {
  return J.getInterceptor$asx(receiver).set$length(receiver, value);
};
J.set$lineCap$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$lineCap(receiver, value);
};
J.set$lineJoin$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$lineJoin(receiver, value);
};
J.set$lineWidth$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$lineWidth(receiver, value);
};
J.set$load$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$load(receiver, value);
};
J.set$loop$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$loop(receiver, value);
};
J.set$marginLeft$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$marginLeft(receiver, value);
};
J.set$marginTop$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$marginTop(receiver, value);
};
J.set$minHeight$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$minHeight(receiver, value);
};
J.set$mode$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$mode(receiver, value);
};
J.set$muted$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$muted(receiver, value);
};
J.set$offset$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$offset(receiver, value);
};
J.set$onAnimationStart$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$onAnimationStart(receiver, value);
};
J.set$onDragStart$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$onDragStart(receiver, value);
};
J.set$overflow$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$overflow(receiver, value);
};
J.set$parent$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$parent(receiver, value);
};
J.set$paused$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$paused(receiver, value);
};
J.set$r$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$r(receiver, value);
};
J.set$responseType$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$responseType(receiver, value);
};
J.set$right$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$right(receiver, value);
};
J.set$scale$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$scale(receiver, value);
};
J.set$shadowBlur$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$shadowBlur(receiver, value);
};
J.set$shadowColor$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$shadowColor(receiver, value);
};
J.set$shadowOffsetX$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$shadowOffsetX(receiver, value);
};
J.set$shadowOffsetY$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$shadowOffsetY(receiver, value);
};
J.set$source$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$source(receiver, value);
};
J.set$src$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$src(receiver, value);
};
J.set$state$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$state(receiver, value);
};
J.set$stroke$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$stroke(receiver, value);
};
J.set$strokeStyle$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$strokeStyle(receiver, value);
};
J.set$tapHighlightColor$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$tapHighlightColor(receiver, value);
};
J.set$target$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$target(receiver, value);
};
J.set$text$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$text(receiver, value);
};
J.set$textBaseline$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$textBaseline(receiver, value);
};
J.set$th$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$th(receiver, value);
};
J.set$trim$s = function(receiver, value) {
  return J.getInterceptor$s(receiver).set$trim(receiver, value);
};
J.set$userSelect$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$userSelect(receiver, value);
};
J.set$volume$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$volume(receiver, value);
};
J.set$width$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$width(receiver, value);
};
J.set$wordWrap$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$wordWrap(receiver, value);
};
J.set$x$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$x(receiver, value);
};
J.set$x1$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$x1(receiver, value);
};
J.set$x2$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$x2(receiver, value);
};
J.set$y$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$y(receiver, value);
};
J.set$y1$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$y1(receiver, value);
};
J.set$y2$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$y2(receiver, value);
};
J.set$z$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$z(receiver, value);
};
J.setProperty$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).setProperty$3(receiver, a0, a1, a2);
};
J.setRange$4$ax = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$ax(receiver).setRange$4(receiver, a0, a1, a2, a3);
};
J.setTransform$6$x = function(receiver, a0, a1, a2, a3, a4, a5) {
  return J.getInterceptor$x(receiver).setTransform$6(receiver, a0, a1, a2, a3, a4, a5);
};
J.sort$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).sort$0(receiver);
};
J.sort$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).sort$1(receiver, a0);
};
J.split$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).split$1(receiver, a0);
};
J.start$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).start$0(receiver);
};
J.start$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).start$1(receiver, a0);
};
J.start$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).start$2(receiver, a0, a1);
};
J.start$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).start$3(receiver, a0, a1, a2);
};
J.startsWith$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).startsWith$1(receiver, a0);
};
J.stop$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).stop$0(receiver);
};
J.stop$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).stop$1(receiver, a0);
};
J.stroke$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).stroke$0(receiver);
};
J.strokeRect$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).strokeRect$4(receiver, a0, a1, a2, a3);
};
J.strokeText$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).strokeText$3(receiver, a0, a1, a2);
};
J.sublist$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).sublist$2(receiver, a0, a1);
};
J.substring$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).substring$1(receiver, a0);
};
J.substring$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
};
J.texImage2D$6$x = function(receiver, a0, a1, a2, a3, a4, a5) {
  return J.getInterceptor$x(receiver).texImage2D$6(receiver, a0, a1, a2, a3, a4, a5);
};
J.texImage2D$9$x = function(receiver, a0, a1, a2, a3, a4, a5, a6, a7, a8) {
  return J.getInterceptor$x(receiver).texImage2D$9(receiver, a0, a1, a2, a3, a4, a5, a6, a7, a8);
};
J.texParameteri$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).texParameteri$3(receiver, a0, a1, a2);
};
J.text$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).text$4(receiver, a0, a1, a2, a3);
};
J.toDataUrl$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).toDataUrl$0(receiver);
};
J.toDouble$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).toDouble$0(receiver);
};
J.toInt$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).toInt$0(receiver);
};
J.toList$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).toList$0(receiver);
};
J.toLowerCase$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).toLowerCase$0(receiver);
};
J.toRadixString$1$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).toRadixString$1(receiver, a0);
};
J.toString$0 = function(receiver) {
  return J.getInterceptor(receiver).toString$0(receiver);
};
J.toStringAsFixed$1$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).toStringAsFixed$1(receiver, a0);
};
J.toUpperCase$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).toUpperCase$0(receiver);
};
J.translate$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).translate$2(receiver, a0, a1);
};
J.trim$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).trim$0(receiver);
};
J.uniform1f$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).uniform1f$2(receiver, a0, a1);
};
J.uniform1i$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).uniform1i$2(receiver, a0, a1);
};
J.uniform2f$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).uniform2f$3(receiver, a0, a1, a2);
};
J.uniform3fv$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).uniform3fv$2(receiver, a0, a1);
};
J.uniformMatrix3fv$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).uniformMatrix3fv$3(receiver, a0, a1, a2);
};
J.upload$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).upload$0(receiver);
};
J.useProgram$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).useProgram$1(receiver, a0);
};
J.vertexAttribPointer$6$x = function(receiver, a0, a1, a2, a3, a4, a5) {
  return J.getInterceptor$x(receiver).vertexAttribPointer$6(receiver, a0, a1, a2, a3, a4, a5);
};
J.viewport$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).viewport$4(receiver, a0, a1, a2, a3);
};
J.where$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).where$1(receiver, a0);
};
C.HtmlDocument_methods = W.HtmlDocument.prototype;
C.HttpRequest_methods = W.HttpRequest.prototype;
C.JSArray_methods = J.JSArray.prototype;
C.JSDouble_methods = J.JSDouble.prototype;
C.JSInt_methods = J.JSInt.prototype;
C.JSNull_methods = J.JSNull.prototype;
C.JSNumber_methods = J.JSNumber.prototype;
C.JSString_methods = J.JSString.prototype;
C.NodeList_methods = W.NodeList.prototype;
C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
C.Window_methods = W.Window.prototype;
C.BlendModes_0 = new M.BlendModes(0);
C.BlendModes_1 = new M.BlendModes(1);
C.BlendModes_10 = new M.BlendModes(10);
C.BlendModes_11 = new M.BlendModes(11);
C.BlendModes_12 = new M.BlendModes(12);
C.BlendModes_13 = new M.BlendModes(13);
C.BlendModes_14 = new M.BlendModes(14);
C.BlendModes_15 = new M.BlendModes(15);
C.BlendModes_16 = new M.BlendModes(16);
C.BlendModes_2 = new M.BlendModes(2);
C.BlendModes_3 = new M.BlendModes(3);
C.BlendModes_4 = new M.BlendModes(4);
C.BlendModes_5 = new M.BlendModes(5);
C.BlendModes_6 = new M.BlendModes(6);
C.BlendModes_7 = new M.BlendModes(7);
C.BlendModes_8 = new M.BlendModes(8);
C.BlendModes_9 = new M.BlendModes(9);
C.BlendModes_99999 = new M.BlendModes(99999);
C.C_DynamicRuntimeType = new H.DynamicRuntimeType();
C.C_OutOfMemoryError = new P.OutOfMemoryError();
C.C__DelayedDone = new P._DelayedDone();
C.C__JSRandom = new P._JSRandom();
C.C__RootZone = new P._RootZone();
C.Duration_0 = new P.Duration(0);
C.Duration_10000 = new P.Duration(10000);
C.EventStreamProvider_blur = H.setRuntimeTypeInfo(new W.EventStreamProvider("blur"), [W.Event]);
C.EventStreamProvider_canplaythrough = H.setRuntimeTypeInfo(new W.EventStreamProvider("canplaythrough"), [W.Event]);
C.EventStreamProvider_complete = H.setRuntimeTypeInfo(new W.EventStreamProvider("complete"), [W.Event]);
C.EventStreamProvider_dragstart = H.setRuntimeTypeInfo(new W.EventStreamProvider("dragstart"), [W.MouseEvent]);
C.EventStreamProvider_error = H.setRuntimeTypeInfo(new W.EventStreamProvider("error"), [W.Event]);
C.EventStreamProvider_error0 = H.setRuntimeTypeInfo(new W.EventStreamProvider("error"), [W.ProgressEvent]);
C.EventStreamProvider_focus = H.setRuntimeTypeInfo(new W.EventStreamProvider("focus"), [W.Event]);
C.EventStreamProvider_load = H.setRuntimeTypeInfo(new W.EventStreamProvider("load"), [W.Event]);
C.EventStreamProvider_load0 = H.setRuntimeTypeInfo(new W.EventStreamProvider("load"), [W.ProgressEvent]);
C.EventStreamProvider_loadstart = H.setRuntimeTypeInfo(new W.EventStreamProvider("loadstart"), [W.Event]);
C.EventStreamProvider_loadstart0 = H.setRuntimeTypeInfo(new W.EventStreamProvider("loadstart"), [W.ProgressEvent]);
C.EventStreamProvider_mousedown = H.setRuntimeTypeInfo(new W.EventStreamProvider("mousedown"), [W.MouseEvent]);
C.EventStreamProvider_mousemove = H.setRuntimeTypeInfo(new W.EventStreamProvider("mousemove"), [W.MouseEvent]);
C.EventStreamProvider_mouseout = H.setRuntimeTypeInfo(new W.EventStreamProvider("mouseout"), [W.MouseEvent]);
C.EventStreamProvider_mouseover = H.setRuntimeTypeInfo(new W.EventStreamProvider("mouseover"), [W.MouseEvent]);
C.EventStreamProvider_mouseup = H.setRuntimeTypeInfo(new W.EventStreamProvider("mouseup"), [W.MouseEvent]);
C.EventStreamProvider_mousewheel = H.setRuntimeTypeInfo(new W.EventStreamProvider("mousewheel"), [W.WheelEvent]);
C.EventStreamProvider_pagehide = H.setRuntimeTypeInfo(new W.EventStreamProvider("pagehide"), [W.Event]);
C.EventStreamProvider_pageshow = H.setRuntimeTypeInfo(new W.EventStreamProvider("pageshow"), [W.Event]);
C.EventStreamProvider_pause = H.setRuntimeTypeInfo(new W.EventStreamProvider("pause"), [W.Event]);
C.EventStreamProvider_play = H.setRuntimeTypeInfo(new W.EventStreamProvider("play"), [W.Event]);
C.EventStreamProvider_progress = H.setRuntimeTypeInfo(new W.EventStreamProvider("progress"), [W.Event]);
C.EventStreamProvider_progress0 = H.setRuntimeTypeInfo(new W.EventStreamProvider("progress"), [W.ProgressEvent]);
C.EventStreamProvider_readystatechange = H.setRuntimeTypeInfo(new W.EventStreamProvider("readystatechange"), [W.ProgressEvent]);
C.EventStreamProvider_resize = H.setRuntimeTypeInfo(new W.EventStreamProvider("resize"), [W.Event]);
C.EventStreamProvider_touchcancel = H.setRuntimeTypeInfo(new W.EventStreamProvider("touchcancel"), [W.TouchEvent]);
C.EventStreamProvider_touchend = H.setRuntimeTypeInfo(new W.EventStreamProvider("touchend"), [W.TouchEvent]);
C.EventStreamProvider_touchenter = H.setRuntimeTypeInfo(new W.EventStreamProvider("touchenter"), [W.TouchEvent]);
C.EventStreamProvider_touchleave = H.setRuntimeTypeInfo(new W.EventStreamProvider("touchleave"), [W.TouchEvent]);
C.EventStreamProvider_touchmove = H.setRuntimeTypeInfo(new W.EventStreamProvider("touchmove"), [W.TouchEvent]);
C.EventStreamProvider_touchstart = H.setRuntimeTypeInfo(new W.EventStreamProvider("touchstart"), [W.TouchEvent]);
C.EventStreamProvider_webglcontextlost = H.setRuntimeTypeInfo(new W.EventStreamProvider("webglcontextlost"), [P.ContextEvent]);
C.EventStreamProvider_webglcontextrestored = H.setRuntimeTypeInfo(new W.EventStreamProvider("webglcontextrestored"), [P.ContextEvent]);
C.EventStreamProvider_webkitAnimationStart = H.setRuntimeTypeInfo(new W.EventStreamProvider("webkitAnimationStart"), [W.AnimationEvent]);
C.EventStreamProvider_webkitfullscreenchange = H.setRuntimeTypeInfo(new W.EventStreamProvider("webkitfullscreenchange"), [W.Event]);
C.JS_CONST_0 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
C.JS_CONST_4hp = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
C.JS_CONST_8ZY = function getTagFallback(o) {
  var constructor = o.constructor;
  if (typeof constructor == "function") {
    var name = constructor.name;
    if (typeof name == "string" &&
        name.length > 2 &&
        name !== "Object" &&
        name !== "Function.prototype") {
      return name;
    }
  }
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
C.JS_CONST_Fs4 = function(hooks) { return hooks; }
;
C.JS_CONST_QJm = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var ua = navigator.userAgent;
    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
    if (ua.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
C.JS_CONST_gkc = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
C.JS_CONST_oRe = function() {
  function typeNameInChrome(o) {
    var name = o.constructor.name;
    if (name) return name;
    var s = Object.prototype.toString.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = Object.prototype.toString.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof navigator == "object";
  return {
    getTag: typeNameInChrome,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
C.JS_CONST_rr7 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
C.JS_CONST_s8I = function(_, letter) { return letter.toUpperCase(); };
C.JsonCodec_null_null = new P.JsonCodec(null, null);
C.JsonDecoder_null = new P.JsonDecoder(null);
Isolate.makeConstantList = function(list) {
  list.immutable$list = init;
  list.fixed$length = init;
  return list;
};
;
C.List_127_2047_65535_1114111 = H.setRuntimeTypeInfo(Isolate.makeConstantList([127, 2047, 65535, 1114111]), [P.$int]);
C.List_2Vk = Isolate.makeConstantList([0, 0, 32776, 33792, 1, 10240, 0, 0]);
C.List_CVk = Isolate.makeConstantList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431]);
C.List_JYB = Isolate.makeConstantList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047]);
C.List_empty = Isolate.makeConstantList([]);
C.List_empty0 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.TypeVariableMirror]);
C.List_empty1 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.TypeMirror]);
C.List_empty2 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.$int]);
C.List_gRj = Isolate.makeConstantList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431]);
C.List_nxB = Isolate.makeConstantList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431]);
C.List_qNA = Isolate.makeConstantList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431]);
C.List_qg4 = Isolate.makeConstantList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431]);
C.List_qg40 = Isolate.makeConstantList([0, 0, 32722, 12287, 65535, 34815, 65534, 18431]);
C.List_F9d = Isolate.makeConstantList(["TEXTURE_ATLAS_JSON_ARRAY", "TEXTURE_ATLAS_JSON_HASH", "TEXTURE_ATLAS_XML_STARLING", "PHYSICS_LIME_CORONA_JSON", "PHYSICS_PHASER_JSON"]);
C.Map_F9OTV = new H.ConstantStringMap(5, {TEXTURE_ATLAS_JSON_ARRAY: 0, TEXTURE_ATLAS_JSON_HASH: 1, TEXTURE_ATLAS_XML_STARLING: 2, PHYSICS_LIME_CORONA_JSON: 3, PHYSICS_PHASER_JSON: 3}, C.List_F9d);
C.List_CSV_TILED_JSON = Isolate.makeConstantList(["CSV", "TILED_JSON"]);
C.Map_do86y = new H.ConstantStringMap(2, {CSV: 0, TILED_JSON: 1}, C.List_CSV_TILED_JSON);
C.Map_empty = new H.ConstantStringMap(0, {}, C.List_empty);
C.Symbol_0c4 = new H.Symbol("");
C.Symbol_call = new H.Symbol("call");
C.Symbol_dynamic = new H.Symbol("dynamic");
C.Symbol_void = new H.Symbol("void");
C.Type_9jE = H.createRuntimeType('Group');
C.TypeVariable_2Uu = new H.TypeVariable(C.Type_9jE, "T", 2);
C.Type_nZF = H.createRuntimeType('Signal');
C.TypeVariable_eTF = new H.TypeVariable(C.Type_nZF, "T", 0);
C.Type_1Od = H.createRuntimeType('Particle');
C.Type_6L0 = H.createRuntimeType('Uint8List');
C.Type_AGr = H.createRuntimeType('JsTypeVariableMirror');
C.Type_AHF = H.createRuntimeType('NativeTypedArray');
C.Type_Art = H.createRuntimeType('Float32List');
C.Type_CAk = H.createRuntimeType('Uint16List');
C.Type_EQs = H.createRuntimeType('GlobalEventHandlers');
C.Type_EjN = H.createRuntimeType('Function');
C.Type_Ejg = H.createRuntimeType('String');
C.Type_EsU = H.createRuntimeType('bool');
C.Type_NlB = H.createRuntimeType('NativeTypedArrayOfDouble');
C.Type_QuW = H.createRuntimeType('Uint8ClampedList');
C.Type_QyU = H.createRuntimeType('WindowEventHandlers');
C.Type_SnA = H.createRuntimeType('$int');
C.Type_UoK = H.createRuntimeType('Int16List');
C.Type_XXD = H.createRuntimeType('JSObject');
C.Type_ckn = H.createRuntimeType('Float64List');
C.Type_dTZ = H.createRuntimeType('Int32List');
C.Type_dynamic = H.createRuntimeType('dynamic');
C.Type_eZO = H.createRuntimeType('Null');
C.Type_irB = H.createRuntimeType('Uint32List');
C.Type_mp3 = H.createRuntimeType('Int8List');
C.Type_oGP = H.createRuntimeType('ByteData');
C.Type_qq1 = H.createRuntimeType('$double');
C.Type_wAg = H.createRuntimeType('ByteBuffer');
C.Type_wOW = H.createRuntimeType('NativeTypedArrayOfInt');
C.Type_xM7 = H.createRuntimeType('num');
C.Utf8Codec_false = new P.Utf8Codec(false);
C._CustomEventStreamProvider__determineMouseWheelEventType = H.setRuntimeTypeInfo(new W._CustomEventStreamProvider(W.Element__determineMouseWheelEventType$closure()), [W.WheelEvent]);
C.scaleModes_0 = new M.scaleModes(0);
C.scaleModes_1 = new M.scaleModes(1);
C.scaleModes_2 = new M.scaleModes(2);
$.libraries_to_load = {};
$.Bone_yDown = true;
$.defaultRenderer = null;
$.blendModesWebGL = null;
$.blendModesCanvas = null;
$._UID = 0;
$.Graphics_POLY = 0;
$.Graphics_RECT = 1;
$.Graphics_CIRC = 2;
$.Graphics_ELIP = 3;
$.Graphics_RREC = 4;
$.CanvasTinter_cacheStepsPerColorChannel = 8;
$.CanvasTinter_convertTintToImage = false;
$.CanvasTinter_canvas = null;
$.WebGLGraphics_last = null;
$.BaseTextureCacheIdGenerator = 0;
$.TextureCacheIdGenerator = 0;
$.Group_RETURN_NONE = 0;
$.Group_RETURN_TOTAL = 1;
$.Group_RETURN_CHILD = 2;
$.Group_SORT_ASCENDING = -1;
$.Group_SORT_DESCENDING = 1;
$.RandomDataGenerator_UUID = 0;
$.Particles_ID = 0;
$.Device_LITTLE_ENDIAN = false;
$.IsolateNatives_enableSpawnWorker = null;
$.RawReceivePortImpl__nextFreeId = 1;
$.Primitives_mirrorFunctionCacheName = "$cachedFunction";
$.Primitives_mirrorInvokeCacheName = "$cachedInvocation";
$.Closure_functionCounter = 0;
$.BoundClosure_selfFieldNameCache = null;
$.BoundClosure_receiverFieldNameCache = null;
$.RuntimeFunctionType_inAssert = false;
$.getTagFunction = null;
$.alternateTagFunction = null;
$.prototypeForTagFunction = null;
$.dispatchRecordsForInstanceTags = null;
$.interceptorsForUncacheableTags = null;
$.initNativeDispatchFlag = null;
$.printToZone = null;
$.classMirrors = null;
$._nextCallback = null;
$._lastCallback = null;
$._lastPriorityCallback = null;
$._isInCallbackLoop = false;
$.Zone__current = C.C__RootZone;
$.Expando__keyCount = 0;
$.Device__isOpera = null;
$.Device__isIE = null;
$.Device__isFirefox = null;
$.Device__isWebKit = null;
$.Device__cachedCssPrefix = null;
$.Back__param_s = 1.70158;
$.interceptedNames = ["$add", "$and", "$div", "$eq", "$ge", "$gt", "$index", "$indexSet", "$le", "$lt", "$mod", "$mul", "$negate", "$not", "$or", "$shl", "$shr", "$sub", "$tdiv", "$xor", "_checkIndex$2", "_checkSublistArguments$3", "_clearChildren$0", "_decodeAudioData$3", "_ensureRequestAnimationFrame$0", "_getPropertyValueHelper$1", "_getUserMedia$3", "_invalidIndex$2", "_js$_checkIndex$1", "_rangeCheck$2", "_replaceChild$2", "_requestAnimationFrame$1", "_setPropertyHelper$3", "_setRangeFast$4", "_shlPositive$1", "_shrOtherPositive$1", "_shrReceiverPositive$1", "_tdivFast$1", "a$1", "abs$0", "activeTexture$1", "add$1", "add$2", "add$3", "add$4", "add$5", "addAll$1", "addEventListener$2", "addEventListener$3", "addKey$1", "allMatches$1", "allMatches$2", "any$1", "append$1", "arc$5", "arc$6", "arcTo$5", "attachShader$2", "audio$1", "audio$2", "audio$3", "audio$4", "beginPath$0", "bezierCurveTo$6", "bindBuffer$2", "bindFramebuffer$2", "bindRenderbuffer$2", "bindTexture$2", "blendFunc$2", "blur$0", "body$1", "body$2", "body$3", "bufferData$3", "bufferSubData$3", "button$0", "button$1", "button$2", "button$3", "button$4", "button$5", "button$6", "button$7", "button$8", "button$9", "ceil$0", "clamp$2", "clear$0", "clear$1", "clearColor$4", "clearRect$4", "click$0", "clip$0", "clip$1", "clone$0", "clone$1", "close$0", "closePath$0", "codeUnitAt$1", "colorMask$4", "compareTo$1", "compileShader$1", "complete$0", "complete$1", "connectNode$1", "connectNode$3", "contains$1", "contains$2", "containsKey$1", "containsPoint$2", "createBuffer$0", "createBuffer$3", "createBufferSource$0", "createFramebuffer$0", "createGain$0", "createPattern$2", "createPatternFromImage$2", "createProgram$0", "createRenderbuffer$0", "createShader$1", "createTexture$0", "decodeAudioData$1", "defaultValue$1", "deleteBuffer$1", "deleteFramebuffer$1", "deleteProgram$1", "deleteTexture$1", "deltaX$0", "deltaY$0", "deltaZ$0", "disable$1", "disableVertexAttribArray$1", "dispatchEvent$1", "drawElements$4", "drawImage$3", "drawImageScaledFromSource$9", "elementAt$1", "enable$1", "enable$2", "enable$3", "enable$4", "enable$5", "enableVertexAttribArray$1", "endsWith$1", "fill$0", "fill$1", "fill$3", "fill$4", "fill$5", "fill$6", "fillRect$4", "fillText$3", "fillText$4", "filter$1", "filter$2", "firstWhere$2$orElse", "floor$0", "flush$0", "fold$2", "forEach$1", "forEach$2", "forEach$5", "forEach$6", "framebufferRenderbuffer$4", "framebufferTexture2D$5", "get$LINEAR", "get$NEAREST", "get$NONE", "get$ONE", "get$TEXTURE", "get$VERSION", "get$ZERO", "get$_created", "get$_key", "get$a", "get$acceleration", "get$add", "get$alpha", "get$altKey", "get$animation", "get$any", "get$aspectRatio", "get$attributes", "get$autoplay", "get$backgroundColor", "get$blur", "get$body", "get$border", "get$bottom", "get$bottomRight", "get$buffer", "get$button", "get$canvas", "get$changedTouches", "get$charCode", "get$children", "get$clear", "get$click", "get$client", "get$clientLeft", "get$clientTop", "get$clip", "get$color", "get$columnWidth", "get$columns", "get$complete", "get$content", "get$context", "get$crossOrigin", "get$ctrlKey", "get$currentTime", "get$cursor", "get$data", "get$dataset", "get$defaultValue", "get$deltaX", "get$deltaY", "get$deltaZ", "get$destination", "get$disabled", "get$draggable", "get$duration", "get$dx", "get$dy", "get$enable", "get$error", "get$fill", "get$fillStyle", "get$filter", "get$font", "get$fontSize", "get$fontWeight", "get$fonts", "get$format", "get$gain", "get$getUserMedia", "get$globalAlpha", "get$globalCompositeOperation", "get$hashCode", "get$height", "get$host", "get$id", "get$identifier", "get$imageSmoothingEnabled", "get$index", "get$isEmpty", "get$isNaN", "get$isNegative", "get$isNotEmpty", "get$iterator", "get$key", "get$keyCode", "get$keys", "get$last", "get$layer", "get$left", "get$length", "get$lineCap", "get$lineHeight", "get$lineJoin", "get$lineWidth", "get$load", "get$loaded", "get$localStorage", "get$loop", "get$map", "get$margin", "get$mask", "get$maskPosition", "get$maxHeight", "get$maxWidth", "get$minHeight", "get$minWidth", "get$mode", "get$movement", "get$muted", "get$name", "get$nodes", "get$offset", "get$on", "get$onAnimationStart", "get$onBlur", "get$onComplete", "get$onDragStart", "get$onError", "get$onFocus", "get$onLoad", "get$onLoadStart", "get$onMouseDown", "get$onMouseMove", "get$onMouseOut", "get$onMouseOver", "get$onMouseUp", "get$onMouseWheel", "get$onPause", "get$onPlay", "get$onProgress", "get$onReadyStateChange", "get$onTouchCancel", "get$onTouchEnd", "get$onTouchEnter", "get$onTouchLeave", "get$onTouchMove", "get$onTouchStart", "get$onWebGlContextLost", "get$onWebGlContextRestored", "get$options", "get$order", "get$orientation", "get$padding", "get$page", "get$parent", "get$parentNode", "get$paused", "get$points", "get$port", "get$position", "get$preload", "get$preventDefault", "get$r", "get$readyState", "get$requestFullscreen", "get$resize", "get$response", "get$responseText", "get$responseType", "get$responseXml", "get$reversed", "get$right", "get$rotate", "get$rows", "get$runtimeType", "get$scale", "get$screen", "get$screenX", "get$screenY", "get$scrollX", "get$scrollY", "get$shadowBlur", "get$shadowColor", "get$shadowOffsetX", "get$shadowOffsetY", "get$shiftKey", "get$sign", "get$size", "get$source", "get$src", "get$start", "get$state", "get$status", "get$step", "get$stop", "get$stroke", "get$strokeStyle", "get$style", "get$target", "get$text", "get$textBaseline", "get$th", "get$top", "get$topLeft", "get$total", "get$transform", "get$trim", "get$type", "get$url", "get$value", "get$values", "get$version", "get$view", "get$volume", "get$width", "get$wordWrap", "get$wrap", "get$x", "get$x1", "get$x2", "get$y", "get$y1", "get$y2", "get$z", "getAttribLocation$2", "getAttribute$1", "getBoundingClientRect$0", "getContext$1", "getContext$2", "getContext3d$0", "getContext3d$6$alpha$antialias$depth$premultipliedAlpha$preserveDrawingBuffer$stencil", "getElementsByTagName$1", "getImageData$4", "getProgramParameter$2", "getPropertyValue$1", "getRange$2", "getShaderInfoLog$1", "getShaderParameter$2", "getUniformLocation$2", "getUserMedia$0", "getUserMedia$2$audio$video", "hash$1", "indexOf$1", "indexOf$2", "insert$1", "insert$2", "intersection$1", "intersection$2", "intersects$1", "intersects$2", "intersects$3", "intersects$4", "join$1", "key$3", "key$4", "lineTo$2", "lineWidth$1", "linkProgram$1", "load$0", "load$1", "loop$0", "loop$3", "map$1", "matchAsPrefix$2", "measureText$1", "moveTo$2", "noSuchMethod$1", "noteGrainOn$3", "noteOff$1", "noteOn$1", "offset$2", "onError$0", "onError$1", "onMouseDown$1", "onMouseMove$1", "onMouseOut$1", "onMouseOver$1", "onMouseUp$1", "onMouseWheel$1", "onTouchCancel$1", "onTouchEnd$1", "onTouchEnter$1", "onTouchLeave$1", "onTouchMove$1", "onTouchStart$1", "open$3$async", "open$5$async$password$user", "order$0", "overrideMimeType$1", "padLeft$2", "parseFromString$2", "pause$0", "pause$1", "paused$0", "pixelStorei$2", "play$0", "play$1", "play$2", "play$3", "play$4", "play$5", "preload$0", "preventDefault$0", "putIfAbsent$2", "putImageData$3", "putImageData$7", "quadraticCurveTo$4", "rect$4", "rect$5", "remainder$1", "remove$0", "remove$1", "remove$2", "remove$3", "removeAt$1", "removeEventListener$2", "removeEventListener$3", "removeLast$0", "removeRange$2", "renderbufferStorage$4", "repeat$1", "repeat$4", "replace$2", "replace$6", "replace$7", "replaceAll$2", "replaceFirst$2", "replaceWith$1", "requestAnimationFrame$1", "requestFullscreen$0", "requestPointerLock$0", "reset$0", "reset$1", "reset$2", "reset$3", "reset$4", "reset$5", "reset$6", "reset$7", "resize$2", "resize$3", "restore$0", "rotate$1", "rotate$3", "rotate$4", "rotate$5", "round$0", "roundToDouble$0", "save$0", "scale$2", "scrollTo$2", "scrollTo$3", "send$0", "send$1", "send$2", "set$LINEAR", "set$NEAREST", "set$NONE", "set$ONE", "set$TEXTURE", "set$VERSION", "set$ZERO", "set$_created", "set$_key", "set$a", "set$acceleration", "set$add", "set$alpha", "set$altKey", "set$animation", "set$any", "set$aspectRatio", "set$attributes", "set$autoplay", "set$backgroundColor", "set$blur", "set$body", "set$bottom", "set$bottomRight", "set$buffer", "set$button", "set$canvas", "set$changedTouches", "set$charCode", "set$children", "set$click", "set$color", "set$columnWidth", "set$columns", "set$complete", "set$content", "set$context", "set$crossOrigin", "set$ctrlKey", "set$currentTime", "set$cursor", "set$data", "set$defaultValue", "set$deltaZ", "set$destination", "set$disabled", "set$display", "set$draggable", "set$duration", "set$dx", "set$dy", "set$enable", "set$error", "set$fill", "set$fillStyle", "set$font", "set$fontSize", "set$fontWeight", "set$fonts", "set$format", "set$gain", "set$getUserMedia", "set$globalAlpha", "set$globalCompositeOperation", "set$height", "set$id", "set$identifier", "set$imageRendering", "set$imageSmoothingEnabled", "set$index", "set$key", "set$keyCode", "set$last", "set$layer", "set$left", "set$length", "set$lineCap", "set$lineHeight", "set$lineJoin", "set$lineWidth", "set$load", "set$loaded", "set$localStorage", "set$loop", "set$map", "set$margin", "set$marginLeft", "set$marginTop", "set$mask", "set$maskPosition", "set$maxHeight", "set$maxWidth", "set$minHeight", "set$minWidth", "set$mode", "set$muted", "set$name", "set$nodes", "set$offset", "set$on", "set$onAnimationStart", "set$onBlur", "set$onComplete", "set$onDragStart", "set$onFocus", "set$onLoadStart", "set$onPause", "set$onPlay", "set$onProgress", "set$options", "set$orientation", "set$overflow", "set$padding", "set$page", "set$parent", "set$parentNode", "set$paused", "set$points", "set$position", "set$preload", "set$preventDefault", "set$r", "set$readyState", "set$requestFullscreen", "set$responseText", "set$responseType", "set$responseXml", "set$reversed", "set$right", "set$rotate", "set$rows", "set$scale", "set$screen", "set$screenX", "set$screenY", "set$scrollX", "set$scrollY", "set$shadowBlur", "set$shadowColor", "set$shadowOffsetX", "set$shadowOffsetY", "set$shiftKey", "set$size", "set$source", "set$src", "set$start", "set$state", "set$status", "set$step", "set$stop", "set$stroke", "set$strokeStyle", "set$style", "set$tapHighlightColor", "set$target", "set$text", "set$textBaseline", "set$th", "set$top", "set$topLeft", "set$total", "set$trim", "set$type", "set$url", "set$userSelect", "set$value", "set$values", "set$version", "set$view", "set$volume", "set$width", "set$wordWrap", "set$wrap", "set$x", "set$x1", "set$x2", "set$y", "set$y1", "set$y2", "set$z", "setProperty$3", "setRange$4", "setTransform$6", "shaderSource$2", "shuffle$4", "shuffle$5", "size$0", "size$1", "sort$0", "sort$1", "sort$2", "split$0", "split$1", "start$0", "start$1", "start$2", "start$3", "start$4", "start$5", "startsWith$1", "startsWith$2", "stencilFunc$3", "stencilOp$3", "step$0", "stop$0", "stop$1", "stop$2", "stroke$0", "strokeRect$4", "strokeText$3", "strokeText$4", "sublist$2", "substring$1", "substring$2", "take$1", "texImage2D$6", "texImage2D$9", "texImage2DTyped$9", "texParameteri$3", "text$2", "text$3", "text$4", "text$5", "toDataUrl$0", "toDataUrl$2", "toDouble$0", "toInt$0", "toList$0", "toList$1$growable", "toLowerCase$0", "toRadixString$1", "toString$0", "toStringAsFixed$1", "toUpperCase$0", "transform$6", "translate$2", "trim$0", "trim$1", "uniform1f$2", "uniform1i$2", "uniform2f$3", "uniform2fv$2", "uniform2i$3", "uniform3f$4", "uniform3fv$2", "uniform3i$4", "uniform4f$5", "uniform4fv$2", "uniform4i$5", "uniformMatrix2fv$3", "uniformMatrix3fv$3", "uniformMatrix4fv$3", "upload$0", "useProgram$1", "vertexAttribPointer$6", "viewport$4", "where$1", "wordWrap$1", "wrap$1", "wrap$2", "wrap$3", "wrap$4", "wrap$5"];
Isolate.$lazy($, "IdentityMatrix", "IdentityMatrix", "get$IdentityMatrix", function() {
  return new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9));
});
Isolate.$lazy($, "Matrix2", "Matrix2", "get$Matrix2", function() {
  return C.Type_Art;
});
Isolate.$lazy($, "EmptyRectangle", "EmptyRectangle", "get$EmptyRectangle", function() {
  return new M.Rectangle0(0, 0, 0, 0);
});
Isolate.$lazy($, "AnimCache", "AnimCache", "get$AnimCache", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "AttachmentType", "AttachmentType", "get$AttachmentType", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["region", 0], null, null);
});
Isolate.$lazy($, "Format", "Atlas_Format", "get$Atlas_Format", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["alpha", 0, "intensity", 1, "luminanceAlpha", 2, "rgb565", 3, "rgba4444", 4, "rgb888", 5, "rgba8888", 6], null, null);
});
Isolate.$lazy($, "TextureFilter", "Atlas_TextureFilter", "get$Atlas_TextureFilter", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["nearest", 0, "linear", 1, "mipMap", 2, "mipMapNearestNearest", 3, "mipMapLinearNearest", 4, "mipMapNearestLinear", 5, "mipMapLinearLinear", 6], null, null);
});
Isolate.$lazy($, "TextureWrap", "Atlas_TextureWrap", "get$Atlas_TextureWrap", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["mirroredRepeat", 0, "clampToEdge", 1, "repeat", 2], null, null);
});
Isolate.$lazy($, "splitReg", "AtlasReader_splitReg", "get$AtlasReader_splitReg", function() {
  return new H.JSSyntaxRegExp("\r\n|\r|\n", H.JSSyntaxRegExp_makeNative("\r\n|\r|\n", false, true, false), null, null);
});
Isolate.$lazy($, "replaceReg", "AtlasReader_replaceReg", "get$AtlasReader_replaceReg", function() {
  return new H.JSSyntaxRegExp("^s+|s+$", H.JSSyntaxRegExp_makeNative("^s+|s+$", true, true, false), null, null);
});
Isolate.$lazy($, "baseReg", "Loader_baseReg", "get$Loader_baseReg", function() {
  return new H.JSSyntaxRegExp("[^/]*$", H.JSSyntaxRegExp_makeNative("[^/]*$", false, true, false), null, null);
});
Isolate.$lazy($, "resultReg", "Loader_resultReg", "get$Loader_resultReg", function() {
  return new H.JSSyntaxRegExp("\r?\n", H.JSSyntaxRegExp_makeNative("\r?\n", false, true, false), null, null);
});
Isolate.$lazy($, "resultSplit", "Loader_resultSplit", "get$Loader_resultSplit", function() {
  return new H.JSSyntaxRegExp("^s+|s+$", H.JSSyntaxRegExp_makeNative("^s+|s+$", true, true, false), null, null);
});
Isolate.$lazy($, "requestAnimFrame", "requestAnimFrame", "get$requestAnimFrame", function() {
  return C.Window_methods.get$requestAnimationFrame(window);
});
Isolate.$lazy($, "canUseMultiply", "CanvasTinter_canUseMultiply", "get$CanvasTinter_canUseMultiply", function() {
  return M.canUseNewCanvasBlendModes();
});
Isolate.$lazy($, "tintMethod", "CanvasTinter_tintMethod", "get$CanvasTinter_tintMethod", function() {
  return $.get$CanvasTinter_canUseMultiply() != null ? M.CanvasTinter_tintWithMultiply$closure() : M.CanvasTinter_tintWithPerPixel$closure();
});
Isolate.$lazy($, "defaultVertexSrc", "PixiShader_defaultVertexSrc", "get$PixiShader_defaultVertexSrc", function() {
  return ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec2 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;", "   vColor = vec4(color * aColor.x, aColor.x);", "}"];
});
Isolate.$lazy($, "graphicsDataPool", "WebGLGraphics_graphicsDataPool", "get$WebGLGraphics_graphicsDataPool", function() {
  return [];
});
Isolate.$lazy($, "glContexts", "glContexts", "get$glContexts", function() {
  return P.LinkedHashSet_LinkedHashSet(null, null, null, null);
});
Isolate.$lazy($, "fonts", "BitmapText_fonts", "get$BitmapText_fonts", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_charCodeReg", "BitmapText__charCodeReg", "get$BitmapText__charCodeReg", function() {
  return new H.JSSyntaxRegExp("(?:\r\n|\r|\n)", H.JSSyntaxRegExp_makeNative("(?:\r\n|\r|\n)", false, true, false), null, null);
});
Isolate.$lazy($, "_numReg", "BitmapText__numReg", "get$BitmapText__numReg", function() {
  return new H.JSSyntaxRegExp("[a-zA-Z]", H.JSSyntaxRegExp_makeNative("[a-zA-Z]", false, true, false), null, null);
});
Isolate.$lazy($, "splitReg", "Text_splitReg", "get$Text_splitReg", function() {
  return new H.JSSyntaxRegExp("(?:\r\n|\r|\n)", H.JSSyntaxRegExp_makeNative("(?:\r\n|\r|\n)", false, true, false), null, null);
});
Isolate.$lazy($, "heightCache", "Text_heightCache", "get$Text_heightCache", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "BaseTextureCache", "BaseTextureCache", "get$BaseTextureCache", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "texturesToUpdate", "texturesToUpdate", "get$texturesToUpdate", function() {
  return [];
});
Isolate.$lazy($, "texturesToDestroy", "texturesToDestroy", "get$texturesToDestroy", function() {
  return [];
});
Isolate.$lazy($, "tempMatrix", "RenderTexture_tempMatrix", "get$RenderTexture_tempMatrix", function() {
  return new M.Matrix(1, 0, 0, 1, 0, 0, new Float32Array(9));
});
Isolate.$lazy($, "TextureCache", "TextureCache", "get$TextureCache", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "FrameCache", "FrameCache", "get$FrameCache", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "frameUpdates", "Texture_frameUpdates", "get$Texture_frameUpdates", function() {
  return [];
});
Isolate.$lazy($, "linesReg", "Text_linesReg", "get$Text_linesReg", function() {
  return new H.JSSyntaxRegExp("(?:\r\n|\r|\n)", H.JSSyntaxRegExp_makeNative("(?:\r\n|\r|\n)", false, true, false), null, null);
});
Isolate.$lazy($, "random", "Math_random", "get$Math_random", function() {
  return C.C__JSRandom.get$nextDouble();
});
Isolate.$lazy($, "GAMES", "GAMES", "get$GAMES", function() {
  return [];
});
Isolate.$lazy($, "Linear", "Easing_Linear", "get$Easing_Linear", function() {
  return new R.Linears();
});
Isolate.$lazy($, "Quadratic", "Easing_Quadratic", "get$Easing_Quadratic", function() {
  return new R.Quads();
});
Isolate.$lazy($, "Cubic", "Easing_Cubic", "get$Easing_Cubic", function() {
  return new R.Cubics();
});
Isolate.$lazy($, "Quartic", "Easing_Quartic", "get$Easing_Quartic", function() {
  return new R.Quarts();
});
Isolate.$lazy($, "Circ", "Easing_Circ", "get$Easing_Circ", function() {
  return new R.Circs();
});
Isolate.$lazy($, "Quintic", "Easing_Quintic", "get$Easing_Quintic", function() {
  return new R.Quints();
});
Isolate.$lazy($, "Sinusoidal", "Easing_Sinusoidal", "get$Easing_Sinusoidal", function() {
  return new R.Sines();
});
Isolate.$lazy($, "Exponential", "Easing_Exponential", "get$Easing_Exponential", function() {
  return new R.Expos();
});
Isolate.$lazy($, "Back", "Easing_Back", "get$Easing_Back", function() {
  return new R.Backs();
});
Isolate.$lazy($, "Bounce", "Easing_Bounce", "get$Easing_Bounce", function() {
  return new R.Bounces();
});
Isolate.$lazy($, "Elastic", "Easing_Elastic", "get$Easing_Elastic", function() {
  return new R.Elastics();
});
Isolate.$lazy($, "thisScript", "IsolateNatives_thisScript", "get$IsolateNatives_thisScript", function() {
  return H.IsolateNatives_computeThisScript();
});
Isolate.$lazy($, "workerIds", "IsolateNatives_workerIds", "get$IsolateNatives_workerIds", function() {
  return H.setRuntimeTypeInfo(new P.Expando(null), [P.$int]);
});
Isolate.$lazy($, "noSuchMethodPattern", "TypeErrorDecoder_noSuchMethodPattern", "get$TypeErrorDecoder_noSuchMethodPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({toString: function() {
      return "$receiver$";
    }}));
});
Isolate.$lazy($, "notClosurePattern", "TypeErrorDecoder_notClosurePattern", "get$TypeErrorDecoder_notClosurePattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null, toString: function() {
      return "$receiver$";
    }}));
});
Isolate.$lazy($, "nullCallPattern", "TypeErrorDecoder_nullCallPattern", "get$TypeErrorDecoder_nullCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
});
Isolate.$lazy($, "nullLiteralCallPattern", "TypeErrorDecoder_nullLiteralCallPattern", "get$TypeErrorDecoder_nullLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      null.$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "undefinedCallPattern", "TypeErrorDecoder_undefinedCallPattern", "get$TypeErrorDecoder_undefinedCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
});
Isolate.$lazy($, "undefinedLiteralCallPattern", "TypeErrorDecoder_undefinedLiteralCallPattern", "get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      (void 0).$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "nullPropertyPattern", "TypeErrorDecoder_nullPropertyPattern", "get$TypeErrorDecoder_nullPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
});
Isolate.$lazy($, "nullLiteralPropertyPattern", "TypeErrorDecoder_nullLiteralPropertyPattern", "get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      null.$method$;
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "undefinedPropertyPattern", "TypeErrorDecoder_undefinedPropertyPattern", "get$TypeErrorDecoder_undefinedPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
});
Isolate.$lazy($, "undefinedLiteralPropertyPattern", "TypeErrorDecoder_undefinedLiteralPropertyPattern", "get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      (void 0).$method$;
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "GEMTYPES", "Alienzed_GEMTYPES", "get$Alienzed_GEMTYPES", function() {
  return ["blue", "cyan", "green", "magenta", "orange", "pink", "red", "yellow"];
});
Isolate.$lazy($, "publicSymbolPattern", "Symbol_publicSymbolPattern", "get$Symbol_publicSymbolPattern", function() {
  return new H.JSSyntaxRegExp("^(?:(?:[\\-+*/%&|^]|\\[\\]=?|==|~/?|<[<=]?|>[>=]?|unary-)$|(?!(?:assert|break|c(?:a(?:se|tch)|lass|on(?:st|tinue))|d(?:efault|o)|e(?:lse|num|xtends)|f(?:alse|inal(?:ly)?|or)|i[fns]|n(?:ew|ull)|ret(?:hrow|urn)|s(?:uper|witch)|t(?:h(?:is|row)|r(?:ue|y))|v(?:ar|oid)|w(?:hile|ith))\\b(?!\\$))[a-zA-Z$][\\w$]*(?:=?$|[.](?!$)))+?$", H.JSSyntaxRegExp_makeNative("^(?:(?:[\\-+*/%&|^]|\\[\\]=?|==|~/?|<[<=]?|>[>=]?|unary-)$|(?!(?:assert|break|c(?:a(?:se|tch)|lass|on(?:st|tinue))|d(?:efault|o)|e(?:lse|num|xtends)|f(?:alse|inal(?:ly)?|or)|i[fns]|n(?:ew|ull)|ret(?:hrow|urn)|s(?:uper|witch)|t(?:h(?:is|row)|r(?:ue|y))|v(?:ar|oid)|w(?:hile|ith))\\b(?!\\$))[a-zA-Z$][\\w$]*(?:=?$|[.](?!$)))+?$", false, true, false), null, null);
});
Isolate.$lazy($, "_dynamicType", "JsMirrorSystem__dynamicType", "get$JsMirrorSystem__dynamicType", function() {
  return new H.JsTypeMirror(C.Symbol_dynamic);
});
Isolate.$lazy($, "_voidType", "JsMirrorSystem__voidType", "get$JsMirrorSystem__voidType", function() {
  return new H.JsTypeMirror(C.Symbol_void);
});
Isolate.$lazy($, "librariesByName", "JsMirrorSystem_librariesByName", "get$JsMirrorSystem_librariesByName", function() {
  return H.JsMirrorSystem_computeLibrariesByName();
});
Isolate.$lazy($, "currentJsMirrorSystem", "currentJsMirrorSystem", "get$currentJsMirrorSystem", function() {
  return new H.JsMirrorSystem(null, new H.JsIsolateMirror(init.globalState.currentContext));
});
Isolate.$lazy($, "mangledNames", "mangledNames", "get$mangledNames", function() {
  return H.computeMangledNames(init.mangledNames, false);
});
Isolate.$lazy($, "reflectiveNames", "reflectiveNames", "get$reflectiveNames", function() {
  return H.computeReflectiveNames($.get$mangledNames());
});
Isolate.$lazy($, "mangledGlobalNames", "mangledGlobalNames", "get$mangledGlobalNames", function() {
  return H.computeMangledNames(init.mangledGlobalNames, true);
});
Isolate.$lazy($, "scheduleImmediateClosure", "_AsyncRun_scheduleImmediateClosure", "get$_AsyncRun_scheduleImmediateClosure", function() {
  return P._AsyncRun__initializeScheduleImmediate();
});
Isolate.$lazy($, "_toStringVisiting", "IterableBase__toStringVisiting", "get$IterableBase__toStringVisiting", function() {
  return [];
});
Isolate.$lazy($, "webkitEvents", "ElementEvents_webkitEvents", "get$ElementEvents_webkitEvents", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["animationend", "webkitAnimationEnd", "animationiteration", "webkitAnimationIteration", "animationstart", "webkitAnimationStart", "fullscreenchange", "webkitfullscreenchange", "fullscreenerror", "webkitfullscreenerror", "keyadded", "webkitkeyadded", "keyerror", "webkitkeyerror", "keymessage", "webkitkeymessage", "needkey", "webkitneedkey", "pointerlockchange", "webkitpointerlockchange", "pointerlockerror", "webkitpointerlockerror", "resourcetimingbufferfull", "webkitresourcetimingbufferfull", "transitionend", "webkitTransitionEnd", "speechchange", "webkitSpeechChange"], null, null);
});
Isolate.$lazy($, "_DART_OBJECT_PROPERTY_NAME", "_DART_OBJECT_PROPERTY_NAME", "get$_DART_OBJECT_PROPERTY_NAME", function() {
  return init.getIsolateTag("_$dart_dartObject");
});
Isolate.$lazy($, "_DART_CLOSURE_PROPERTY_NAME", "_DART_CLOSURE_PROPERTY_NAME", "get$_DART_CLOSURE_PROPERTY_NAME", function() {
  return init.getIsolateTag("_$dart_dartClosure");
});
Isolate.$lazy($, "_dartProxyCtor", "_dartProxyCtor", "get$_dartProxyCtor", function() {
  return function DartObject(o) {
    this.o = o;
  };
});
Isolate.$lazy($, "emptyObject", "Grid_emptyObject", "get$Grid_emptyObject", function() {
  return new M.MatchObject("__empty__");
});
Isolate.$lazy($, "IN", "Back_IN", "get$Back_IN", function() {
  var t1 = new B.Back(null, null);
  t1.compute = B.Back__computeIN$closure();
  t1.name = "BACK.IN";
  return t1;
});
Isolate.$lazy($, "OUT", "Back_OUT", "get$Back_OUT", function() {
  var t1 = new B.Back(null, null);
  t1.compute = B.Back__computeOUT$closure();
  t1.name = "BACK.OUT";
  return t1;
});
Isolate.$lazy($, "INOUT", "Back_INOUT", "get$Back_INOUT", function() {
  var t1 = new B.Back(null, null);
  t1.compute = B.Back__computeINOUT$closure();
  t1.name = "BACK.INOUT";
  return t1;
});
Isolate.$lazy($, "IN", "Bounce_IN", "get$Bounce_IN", function() {
  var t1 = new B.Bounce(null, null);
  t1.name = "Bounce.IN";
  t1.compute = B.Bounce__computeIN$closure();
  return t1;
});
Isolate.$lazy($, "OUT", "Bounce_OUT", "get$Bounce_OUT", function() {
  var t1 = new B.Bounce(null, null);
  t1.name = "Bounce.OUT";
  t1.compute = B.Bounce__computeOUT$closure();
  return t1;
});
Isolate.$lazy($, "INOUT", "Bounce_INOUT", "get$Bounce_INOUT", function() {
  var t1 = new B.Bounce(null, null);
  t1.name = "Bounce.INOUT";
  t1.compute = B.Bounce__computeINOUT$closure();
  return t1;
});
Isolate.$lazy($, "IN", "Circ_IN", "get$Circ_IN", function() {
  var t1 = new B.Circ(null, null);
  t1.compute = B.Circ__computeIN$closure();
  t1.name = "CIRC.IN";
  return t1;
});
Isolate.$lazy($, "OUT", "Circ_OUT", "get$Circ_OUT", function() {
  var t1 = new B.Circ(null, null);
  t1.name = "Circ.OUT";
  t1.compute = B.Circ__computeOUT$closure();
  return t1;
});
Isolate.$lazy($, "INOUT", "Circ_INOUT", "get$Circ_INOUT", function() {
  var t1 = new B.Circ(null, null);
  t1.name = "Circ.INOUT";
  t1.compute = B.Circ__computeINOUT$closure();
  return t1;
});
Isolate.$lazy($, "IN", "Elastic_IN", "get$Elastic_IN", function() {
  var t1 = new B.Elastic(0, 0, false, false, null, null);
  t1.name = "Elastic.IN";
  t1.compute = B.Elastic__computeIN$closure();
  return t1;
});
Isolate.$lazy($, "OUT", "Elastic_OUT", "get$Elastic_OUT", function() {
  var t1 = new B.Elastic(0, 0, false, false, null, null);
  t1.name = "Elastic.OUT";
  t1.compute = B.Elastic__computeOUT$closure();
  return t1;
});
Isolate.$lazy($, "INOUT", "Elastic_INOUT", "get$Elastic_INOUT", function() {
  var t1 = new B.Elastic(0, 0, false, false, null, null);
  t1.name = "Elastic.INOUT";
  t1.compute = B.Elastic__computeINOUT$closure();
  return t1;
});
Isolate.$lazy($, "IN", "Expo_IN", "get$Expo_IN", function() {
  var t1 = new B.Expo(null, null);
  t1.name = "Expo.IN";
  t1.compute = B.Expo__computeIN$closure();
  return t1;
});
Isolate.$lazy($, "OUT", "Expo_OUT", "get$Expo_OUT", function() {
  var t1 = new B.Expo(null, null);
  t1.name = "Expo.OUT";
  t1.compute = B.Expo__computeOUT$closure();
  return t1;
});
Isolate.$lazy($, "INOUT", "Expo_INOUT", "get$Expo_INOUT", function() {
  var t1 = new B.Expo(null, null);
  t1.name = "Expo.INOUT";
  t1.compute = B.Expo__computeINOUT$closure();
  return t1;
});
Isolate.$lazy($, "INOUT", "Linear_INOUT", "get$Linear_INOUT", function() {
  var t1 = new B.Linear(null, null);
  t1.name = "Linear.INOUT";
  t1.compute = new B.closure();
  return t1;
});
Isolate.$lazy($, "IN", "Quad_IN", "get$Quad_IN", function() {
  var t1 = new B.Quad(null, null);
  t1.name = "Quad.IN";
  t1.compute = new B.closure1();
  return t1;
});
Isolate.$lazy($, "OUT", "Quad_OUT", "get$Quad_OUT", function() {
  var t1 = new B.Quad(null, null);
  t1.name = "Quad.OUT";
  t1.compute = new B.closure0();
  return t1;
});
Isolate.$lazy($, "INOUT", "Quad_INOUT", "get$Quad_INOUT", function() {
  var t1 = new B.Quad(null, null);
  t1.name = "Quad.INOUT";
  t1.compute = B.Quad__computeINOUT$closure();
  return t1;
});
Isolate.$lazy($, "IN", "Quart_IN", "get$Quart_IN", function() {
  var t1 = new B.Quart(null, null);
  t1.name = "Quart.IN";
  t1.compute = new B.closure3();
  return t1;
});
Isolate.$lazy($, "OUT", "Quart_OUT", "get$Quart_OUT", function() {
  var t1 = new B.Quart(null, null);
  t1.name = "Quart.OUT";
  t1.compute = new B.closure2();
  return t1;
});
Isolate.$lazy($, "INOUT", "Quart_INOUT", "get$Quart_INOUT", function() {
  var t1 = new B.Quart(null, null);
  t1.name = "Quart.INOUT";
  t1.compute = B.Quart__computeINOUT$closure();
  return t1;
});
Isolate.$lazy($, "IN", "Quint_IN", "get$Quint_IN", function() {
  var t1 = new B.Quint(null, null);
  t1.name = "Quint.IN";
  t1.compute = new B.closure7();
  return t1;
});
Isolate.$lazy($, "OUT", "Quint_OUT", "get$Quint_OUT", function() {
  var t1 = new B.Quint(null, null);
  t1.name = "Quint.OUT";
  t1.compute = new B.closure8();
  return t1;
});
Isolate.$lazy($, "INOUT", "Quint_INOUT", "get$Quint_INOUT", function() {
  var t1 = new B.Quint(null, null);
  t1.name = "Quint.INOUT";
  t1.compute = B.Quint__computeINOUT$closure();
  return t1;
});
Isolate.$lazy($, "IN", "Sine_IN", "get$Sine_IN", function() {
  var t1 = new B.Sine(null, null);
  t1.name = "Sine.IN";
  t1.compute = new B.closure6();
  return t1;
});
Isolate.$lazy($, "OUT", "Sine_OUT", "get$Sine_OUT", function() {
  var t1 = new B.Sine(null, null);
  t1.name = "Sine.OUT";
  t1.compute = new B.closure4();
  return t1;
});
Isolate.$lazy($, "INOUT", "Sine_INOUT", "get$Sine_INOUT", function() {
  var t1 = new B.Sine(null, null);
  t1.name = "Sine.INOUT";
  t1.compute = new B.closure5();
  return t1;
});
// Native classes

init.metadata = [P.Function,
C.TypeVariable_eTF,
R.GameObject,
C.TypeVariable_2Uu,
{func: "dynamic___num_num_num", opt: [P.num, P.num, P.num]},
0,
"x",
"y",
"radius",
{func: "dynamic___num_num_num_num", opt: [P.num, P.num, P.num, P.num]},
"width",
"height",
{func: "Type_", ret: P.Type},
{func: "args0"},
{func: "dynamic__List", args: [P.List]},
"array",
{func: "dynamic___num_num", opt: [P.num, P.num]},
"points",
{func: "Shape_", ret: M.Shape},
{func: "DisplayInterface_", ret: M.DisplayInterface},
{func: "DisplayObject_", ret: M.DisplayObject},
{func: "DisplayObjectContainer_", ret: M.DisplayObjectContainer},
{func: "dynamic__List0", args: [[P.List, M.Texture]]},
"textures",
{func: "MovieClip__List", ret: M.MovieClip, args: [[P.List, P.String]]},
"frames",
"images",
{func: "dynamic__Texture", args: [M.Texture]},
"texture",
{func: "Sprite__String", ret: M.Sprite, args: [P.String]},
"frameId",
{func: "Sprite__String__bool_scaleModes", ret: M.Sprite, args: [P.String], opt: [P.bool, M.scaleModes]},
,
"imageId",
"crossorigin",
"scaleMode",
{func: "dynamic___RenderTexture", opt: [M.RenderTexture0]},
"textureThing",
{func: "dynamic___int_bool", opt: [P.$int, P.bool]},
true,
"backgroundColor",
"interactive",
{func: "dynamic__Texture_List", args: [M.Texture, [P.List, M.Point0]]},
{func: "dynamic__String_BoneData", args: [P.String, M.BoneData]},
"name",
"parent",
"boneData",
{func: "dynamic__BoneData_Bone", args: [M.BoneData, M.Bone]},
"data",
{func: "dynamic__SlotData_Skeleton_Bone", args: [M.SlotData, M.Skeleton, M.Bone]},
"skeleton",
"bone",
{func: "dynamic__String", args: [P.String]},
{func: "dynamic__String_List_num", args: [P.String, [P.List, M.Timeline], P.num]},
"timelines",
"duration",
{func: "int__List_num_int", ret: P.$int, args: [[P.List, P.num], P.num, P.$int]},
"values",
"target",
"step",
{func: "dynamic__int", args: [P.$int]},
"frameCount",
{func: "Timeline_", ret: M.Timeline},
{func: "args1", args: [null]},
{func: "dynamic__SkeletonData", args: [M.SkeletonData]},
"skeletonData",
{func: "Attachment_", ret: M.Attachment},
{func: "dynamic___String", opt: [P.String]},
{func: "Entry_", ret: M.Entry},
{func: "dynamic__AnimationStateData", args: [M.AnimationStateData]},
"stateData",
{func: "dynamic___AtlasAttachmentLoader", opt: [M.AtlasAttachmentLoader]},
"attachmentLoader",
{func: "dynamic__Timeline_int_Map", args: [M.Timeline, P.$int, P.Map]},
"timeline",
"frameIndex",
"valueMap",
{func: "dynamic__String_int", args: [P.String, P.$int]},
"hexString",
"colorIndex",
{func: "dynamic__String_dynamic", args: [P.String, null]},
"atlasText",
"textureLoader",
{func: "AtlasPage_", ret: M.AtlasPage},
{func: "AtlasRegion_", ret: M.AtlasRegion},
"text",
{func: "dynamic__Atlas", args: [M.Atlas]},
"atlas",
"url",
{func: "dynamic__Texture__num_num", args: [M.Texture], opt: [P.num, P.num]},
100,
{func: "InteractionData_", ret: M.InteractionData},
{func: "dynamic__Stage", args: [M.Stage0]},
"stage",
{func: "dynamic__List__bool", args: [[P.List, P.String]], opt: [P.bool]},
false,
"assetURLs",
{func: "dynamic__String_bool", args: [P.String, P.bool]},
{func: "Loader__String_String_bool", ret: M.Loader0, args: [P.String, P.String, P.bool]},
"type",
"value",
{func: "GraphicsData_", ret: M.GraphicsData},
{func: "dynamic__Graphics_CanvasRenderingContext2D", args: [M.Graphics0, W.CanvasRenderingContext2D]},
"graphics",
"context",
{func: "dynamic___num_num_CanvasElement_bool_bool", opt: [P.num, P.num, W.CanvasElement, P.bool, P.bool]},
800,
600,
"view",
"transparent",
"antialias",
{func: "dynamic__num_num", args: [P.num, P.num]},
{func: "CanvasImageSource__Sprite_int", ret: W.CanvasImageSource, args: [M.Sprite, P.$int]},
"sprite",
"color",
{func: "dynamic__Texture_int_CanvasElement", args: [M.Texture, P.$int, W.CanvasElement]},
"canvas",
{func: "args3", args: [null, null, null]},
{func: "int__dynamic", ret: P.$int, args: [null]},
{func: "MaskManager_", ret: M.MaskManager},
{func: "RenderSession_", ret: M.RenderSession},
{func: "dynamic__RenderingContext", args: [P.RenderingContext]},
"gl",
{func: "Shader_", ret: M.Shader},
{func: "dynamic__RenderingContext_int_int__dynamic", args: [P.RenderingContext, P.$int, P.$int], opt: [null]},
C.scaleModes_0,
{func: "dynamic__RenderingContext_bool", args: [P.RenderingContext, P.bool]},
{func: "dynamic__Graphics_RenderSession", args: [M.Graphics0, M.RenderSession]},
"renderSession",
{func: "dynamic__Graphics_RenderingContext", args: [M.Graphics0, P.RenderingContext]},
{func: "WebGLGraphicsData__WebGLGraphicsData_int", ret: M.WebGLGraphicsData, args: [M.WebGLGraphicsData, P.$int]},
"webGL",
{func: "dynamic__GraphicsData_WebGLGraphicsData", args: [M.GraphicsData, M.WebGLGraphicsData]},
"graphicsData",
"webGLData",
{func: "List__num_num_num_num_num_num", ret: [P.List, P.num], args: [P.num, P.num, P.num, P.num, P.num, P.num]},
"fromX",
"fromY",
"cpX",
"cpY",
"toX",
"toY",
{func: "dynamic__RenderingContext_List", args: [P.RenderingContext, [P.List, P.String]]},
"shaderSrc",
{func: "dynamic__RenderingContext_List_int", args: [P.RenderingContext, [P.List, P.String], P.$int]},
"shaderType",
{func: "dynamic__RenderingContext_List_List", args: [P.RenderingContext, [P.List, P.String], [P.List, P.String]]},
"vertexSrc",
"fragmentSrc",
{func: "dynamic___num_num_CanvasElement_bool_bool_bool", opt: [P.num, P.num, W.CanvasElement, P.bool, P.bool, P.bool]},
"preserveDrawingBuffer",
{func: "void__RenderingContext", void: true, args: [P.RenderingContext]},
{func: "dynamic__BaseTexture_RenderingContext", args: [M.BaseTexture, P.RenderingContext]},
{func: "ChartData_", ret: M.ChartData},
{func: "Char_", ret: M.Char},
{func: "dynamic__String__TextStyle", args: [P.String], opt: [M.TextStyle]},
"style",
{func: "dynamic___String_String_String_String_num_num", named: {align: P.String, fill: P.String, font: P.String, stroke: P.String, strokeThickness: P.num, tint: P.num}},
"black",
"bold 20pt Arial",
"left",
16777215,
"fill",
"font",
"align",
"stroke",
"strokeThickness",
"tint",
{func: "dynamic__String_TextStyle", args: [P.String, M.TextStyle]},
{func: "dynamic___dynamic_scaleModes", opt: [null, M.scaleModes]},
"source",
{func: "BaseTexture__String_bool_scaleModes", ret: M.BaseTexture, args: [P.String, P.bool, M.scaleModes]},
"imageUrl",
{func: "BaseTexture__CanvasElement_scaleModes", ret: M.BaseTexture, args: [W.CanvasElement, M.scaleModes]},
{func: "dynamic___num_num_Renderer_scaleModes", opt: [P.num, P.num, M.Renderer, M.scaleModes]},
"renderer",
{func: "dynamic__BaseTexture__Rectangle", args: [M.BaseTexture], opt: [M.Rectangle0]},
"baseTexture",
"frame",
{func: "Texture__String__bool_scaleModes", ret: M.Texture, args: [P.String], opt: [P.bool, M.scaleModes]},
{func: "Texture__String", ret: M.Texture, args: [P.String]},
{func: "Texture__CanvasElement__scaleModes", ret: M.Texture, args: [W.CanvasElement], opt: [M.scaleModes]},
{func: "void__dynamic_dynamic", void: true, args: [null, null]},
"id",
{func: "Texture__dynamic", ret: M.Texture, args: [null]},
{func: "TextureUvs_", ret: M.TextureUvs},
{func: "Renderer___num_num_dynamic_dynamic_dynamic", ret: M.Renderer, opt: [P.num, P.num, null, null, null]},
{func: "dynamic___dynamic_dynamic_String", named: {content: null, loader: null, type: P.String}},
"content",
"loader",
{func: "EventTarget_", ret: M.EventTarget0},
{func: "List__dynamic", ret: [P.List, P.num], args: [null]},
"p",
{func: "bool__dynamic_dynamic_dynamic_dynamic_dynamic_dynamic_dynamic_dynamic", ret: P.bool, args: [null, null, null, null, null, null, null, null]},
"px",
"py",
"ax",
"ay",
"bx",
"by",
"cx",
"cy",
{func: "bool__num_num_num_num_num_num_bool", ret: P.bool, args: [P.num, P.num, P.num, P.num, P.num, P.num, P.bool]},
"sign",
{func: "List__int", ret: [P.List, P.num], args: [P.$int]},
"hex",
{func: "int__List", ret: P.$int, args: [[P.List, P.num]]},
"rgb",
{func: "HttpRequest_", ret: W.HttpRequest},
{func: "bool_", ret: P.bool},
{func: "int__int", ret: P.$int, args: [P.$int]},
"number",
{func: "dynamic__Game_Sprite_String_FrameData__List_num_bool", args: [R.Game, R.Sprite0, P.String, R.FrameData], opt: [[P.List, P.num], P.num, P.bool]},
60,
"game",
"_parent",
"_frameData",
"_frames",
"frameRate",
"loop",
{func: "List___String_int_int_String_dynamic", ret: [P.List, P.String], opt: [P.String, P.$int, P.$int, P.String, null]},
"",
"prefix",
"start",
"stop",
"suffix",
"zeroPad",
{func: "dynamic__AnimationInterface", args: [R.AnimationInterface]},
{func: "AnimationParser_", ret: R.AnimationParser},
{func: "FrameData__Game_String_num_num__int_num_num", ret: R.FrameData, args: [R.Game, P.String, P.num, P.num], opt: [P.$int, P.num, P.num]},
-1,
"key",
"frameWidth",
"frameHeight",
"frameMax",
"margin",
"spacing",
{func: "FrameData__dynamic_dynamic_dynamic", ret: R.FrameData, args: [null, null, null]},
"json",
"cacheKey",
{func: "FrameData__Game_Document_String", ret: R.FrameData, args: [R.Game, W.Document, P.String]},
"xml",
{func: "dynamic__int_num_num_num_num_String_String", args: [P.$int, P.num, P.num, P.num, P.num, P.String, P.String]},
"index",
"uuid",
{func: "AtLimit_", ret: R.AtLimit},
{func: "dynamic__Game_dynamic_dynamic_dynamic_dynamic_dynamic", args: [R.Game, null, null, null, null, null]},
{func: "dynamic__Game__Map_List", args: [R.Game], opt: [P.Map, [P.List, P.String]]},
"uniforms",
{func: "dynamic___num_num_int_String_State_bool_bool_Map", opt: [P.num, P.num, P.$int, P.String, R.State, P.bool, P.bool, P.Map]},
"state",
"physicsConfig",
{func: "dynamic__Game__Group_String_bool_bool_num", args: [R.Game], opt: [R.Group, P.String, P.bool, P.bool, P.num]},
"group",
"addToStage",
"enableBody",
"physicsBodyType",
{func: "dynamic__Game_PluginManager", args: [R.Game, R.PluginManager]},
{func: "dynamic__Game", args: [R.Game]},
{func: "dynamic__Game_num_num", args: [R.Game, P.num, P.num]},
{func: "dynamic__Signal_Function__bool_int", args: [R.Signal, P.Function], opt: [P.bool, P.$int]},
"_signal",
"_listener",
"_isOnce",
"_priority",
{func: "dynamic__Game__State", args: [R.Game], opt: [R.State]},
"pendingState",
{func: "dynamic__Game_String_int_int", args: [R.Game, P.String, P.$int, P.$int]},
{func: "dynamic__dynamic__num_num_String_String_int", args: [null], opt: [P.num, P.num, P.String, P.String, P.$int]},
32,
"size",
{func: "dynamic__Game__num_num_String_Function_dynamic_dynamic_dynamic_dynamic", args: [R.Game], opt: [P.num, P.num, P.String, P.Function, null, null, null, null]},
"callback",
"overFrame",
"outFrame",
"downFrame",
"upFrame",
{func: "dynamic__GameObject", args: [R.GameObject]},
{func: "CoreInterfact_", ret: R.CoreInterfact},
{func: "SpriteInterface_", ret: R.SpriteInterface},
{func: "AnimationInterface_", ret: R.AnimationInterface},
{func: "GameObject_", ret: R.GameObject},
{func: "dynamic__Game__num_num", args: [R.Game], opt: [P.num, P.num]},
{func: "dynamic__Game__int_int_dynamic_dynamic", args: [R.Game], opt: [P.$int, P.$int, null, null]},
{func: "dynamic__Game_num_num_String_num", args: [R.Game, P.num, P.num, P.String, P.num]},
{func: "dynamic__Game_num_num__String_scaleModes", args: [R.Game, P.num, P.num], opt: [P.String, M.scaleModes]},
{func: "dynamic__Game_String_num_num_String__num_int_int_int_int", args: [R.Game, P.String, P.num, P.num, P.String], opt: [P.num, P.$int, P.$int, P.$int, P.$int]},
"characterWidth",
"characterHeight",
"chars",
"charsPerRow",
"xSpacing",
"ySpacing",
"xOffset",
"yOffset",
{func: "dynamic__Game_dynamic_dynamic_dynamic", args: [R.Game, null, null, null]},
{func: "dynamic__Game__num_num_String_TextStyle", args: [R.Game], opt: [P.num, P.num, P.String, R.TextStyle0]},
{func: "dynamic__Game__num_num_num_num_dynamic_dynamic", args: [R.Game], opt: [P.num, P.num, P.num, P.num, null, null]},
256,
"_diameter",
{func: "bool__Circle_Rectangle", ret: P.bool, args: [R.Circle0, R.Rectangle1]},
"c",
"r",
{func: "bool__Circle_Circle", ret: P.bool, args: [R.Circle0, R.Circle0]},
"a",
"b",
{func: "dynamic__num_num_num_num", args: [P.num, P.num, P.num, P.num]},
"x1",
"y1",
"x2",
"y2",
{func: "Point__Point_Point_Point_Point__bool_Point", ret: R.Point, args: [R.Point, R.Point, R.Point, R.Point], opt: [P.bool, R.Point]},
"e",
"f",
"asSegment",
"result",
{func: "Point__Point_Point_num__Point", ret: R.Point, args: [R.Point, R.Point, P.num], opt: [R.Point]},
"out",
{func: "Point__Point_Point__Point", ret: R.Point, args: [R.Point, R.Point], opt: [R.Point]},
{func: "Point__List__Point", ret: R.Point, args: [[P.List, R.Point]], opt: [R.Point]},
{func: "dynamic__List1", args: [[P.List, R.Point]]},
"_points",
{func: "dynamic__Game_int", args: [R.Game, P.$int]},
"keycode",
{func: "CursorKeys_", ret: R.CursorKeys},
{func: "LoaderParser_", ret: R.LoaderParser},
{func: "dynamic__Game_Document_String_int_int", args: [R.Game, W.Document, P.String, P.$int, P.$int]},
{func: "SinCosTable_", ret: R.SinCosTable},
{func: "num__num_num", ret: P.num, args: [P.num, P.num]},
"th",
"exp",
{func: "num__num", ret: P.num, args: [P.num]},
"val",
{func: "bool__num_num__num", ret: P.bool, args: [P.num, P.num], opt: [P.num]},
0.0001,
"epsilon",
{func: "int__num__num", ret: P.$int, args: [P.num], opt: [P.num]},
{func: "double__List", ret: P.$double, args: [[P.List, P.num]]},
"args",
{func: "int__num", ret: P.$int, args: [P.num]},
"n",
{func: "int__num_num__num", ret: P.$int, args: [P.num, P.num], opt: [P.num]},
"input",
"gap",
{func: "num__num_List__dynamic", ret: P.num, args: [P.num, [P.List, P.num]], opt: [null]},
"arr",
"sort",
{func: "int__num__int_int", ret: P.$int, args: [P.num], opt: [P.$int, P.$int]},
10,
"place",
"base",
{func: "num__num_num_num", ret: P.num, args: [P.num, P.num, P.num]},
"weight",
{func: "num__num_num_num_num", ret: P.num, args: [P.num, P.num, P.num, P.num]},
{func: "num__Point_Point", ret: P.num, args: [R.Point, R.Point]},
"point1",
"point2",
"angleRad",
"lat",
"lng",
{func: "bool___num", ret: P.bool, opt: [P.num]},
50,
"chance",
{func: "List__int_int", ret: [P.List, P.$int], args: [P.$int, P.$int]},
"min",
"max",
"amount",
{func: "int_", ret: P.$int},
{func: "bool__int", ret: P.bool, args: [P.$int]},
{func: "num__Iterable", ret: P.num, args: [[P.Iterable, P.num]]},
{func: "num__Iterable_args1", ret: P.num, args: [P.Iterable, {func: "args1", args: [null]}]},
"prop",
{func: "num__num__bool", ret: P.num, args: [P.num], opt: [P.bool]},
"angle",
"radians",
{func: "num__List_num", ret: P.num, args: [[P.List, P.num], P.num]},
"v",
"k",
"p0",
"p1",
"t",
"i",
{func: "num__num_num_num_num_num", ret: P.num, args: [P.num, P.num, P.num, P.num, P.num]},
"p2",
"p3",
{func: "Object__List__int_int", ret: P.Object, args: [P.List], opt: [P.$int, P.$int]},
"objects",
"startIndex",
"length",
{func: "dynamic__int__num_num_num", args: [P.$int], opt: [P.num, P.num, P.num]},
1,
"sinAmplitude",
"cosAmplitude",
"frequency",
{func: "Object__DoubleLinkedQueue", ret: P.Object, args: [P.DoubleLinkedQueue]},
"stack",
{func: "List__List", ret: P.List, args: [P.List]},
{func: "num__num_num_num_num__num", ret: P.num, args: [P.num, P.num, P.num, P.num], opt: [P.num]},
2,
"power",
{func: "bool__num_num_num", ret: P.bool, args: [P.num, P.num, P.num]},
"tolerance",
"a1",
"a2",
"b1",
"b2",
{func: "num__num_num__num", ret: P.num, args: [P.num, P.num], opt: [P.num]},
"degrees",
{func: "Bounds_", ret: R.Bounds},
{func: "dynamic__num_num_num_num__int_int_int", args: [P.num, P.num, P.num, P.num], opt: [P.$int, P.$int, P.$int]},
"maxObjects",
"maxLevels",
"level",
"seeds",
{func: "dynamic__Game__num_num_int", args: [R.Game], opt: [P.num, P.num, P.$int]},
"maxParticles",
{func: "dynamic___bool_bool_bool_bool", named: {down: P.bool, left: P.bool, right: P.bool, up: P.bool}},
"up",
"down",
"right",
{func: "Body_", ret: R.Body0},
{func: "dynamic__dynamic__Map", args: [null], opt: [P.Map]},
C.Map_empty,
"config",
{func: "Marker_", ret: R.Marker},
{func: "dynamic__Game_String__num_bool_bool", args: [R.Game, P.String], opt: [P.num, P.bool, P.bool]},
"volume",
"connect",
{func: "Canvas_", ret: R.Canvas},
{func: "CanvasElement___num_num_String_bool", ret: W.CanvasElement, opt: [P.num, P.num, P.String, P.bool]},
"noCocoon",
{func: "Point__CanvasElement__Point", ret: R.Point, args: [W.CanvasElement], opt: [R.Point]},
"element",
"point",
{func: "num__CanvasElement", ret: P.num, args: [W.CanvasElement]},
{func: "CanvasElement__CanvasElement__String", ret: W.CanvasElement, args: [W.CanvasElement], opt: [P.String]},
"rgb(0,0,0)",
"none",
{func: "CanvasElement__CanvasElement__dynamic_bool", ret: W.CanvasElement, args: [W.CanvasElement], opt: [null, P.bool]},
"overflowHidden",
{func: "CanvasRenderingContext2D__CanvasRenderingContext2D_num_num_num_num_num_num", ret: W.CanvasRenderingContext2D, args: [W.CanvasRenderingContext2D, P.num, P.num, P.num, P.num, P.num, P.num]},
"translateX",
"translateY",
"scaleX",
"scaleY",
"skewX",
"skewY",
{func: "CanvasRenderingContext2D__CanvasRenderingContext2D__bool", ret: W.CanvasRenderingContext2D, args: [W.CanvasRenderingContext2D], opt: [P.bool]},
{func: "CanvasElement__CanvasElement", ret: W.CanvasElement, args: [W.CanvasElement]},
{func: "dynamic__Game__bool", args: [R.Game], opt: [P.bool]},
"forceSetTimeOut",
{func: "dynamic__TilemapLayerData_int_num_num_num_num", args: [R.TilemapLayerData, P.$int, P.num, P.num, P.num, P.num]},
"layer",
{func: "TilemapData_", ret: R.TilemapData},
{func: "dynamic__Game__String_num_num_num_num", args: [R.Game], opt: [P.String, P.num, P.num, P.num, P.num]},
"tileWidth",
"tileHeight",
{func: "MapCache_", ret: R.MapCache},
{func: "TilemapLayerData_", ret: R.TilemapLayerData},
{func: "dynamic__Game__Tilemap_int_num_num", args: [R.Game], opt: [R.Tilemap, P.$int, P.num, P.num]},
"tilemap",
{func: "TilemapImageData_", ret: R.TilemapImageData},
{func: "TilemapParser_", ret: R.TilemapParser},
{func: "TilemapData__Game__String_num_num_num_num", ret: R.TilemapData, args: [R.Game], opt: [P.String, P.num, P.num, P.num, P.num]},
{func: "TilemapData__String_String__num_num", ret: R.TilemapData, args: [P.String, P.String], opt: [P.num, P.num]},
{func: "TilemapData___num_num_num_num", ret: R.TilemapData, opt: [P.num, P.num, P.num, P.num]},
{func: "TilemapData__Map", ret: R.TilemapData, args: [P.Map]},
{func: "dynamic__String_int__num_num_num_num_Map", args: [P.String, P.$int], opt: [P.num, P.num, P.num, P.num, P.Map]},
"firstgid",
"properties",
"autoDestroy",
{func: "dynamic__Timer_num_num_int_bool_Function_List", args: [R.Timer, P.num, P.num, P.$int, P.bool, P.Function, P.List]},
"timer",
"delay",
"tick",
"repeatCount",
{func: "Linears_", ret: R.Linears},
{func: "Quads_", ret: R.Quads},
{func: "Cubics_", ret: R.Cubics},
{func: "Quarts_", ret: R.Quarts},
{func: "Circs_", ret: R.Circs},
{func: "Sines_", ret: R.Sines},
{func: "Expos_", ret: R.Expos},
{func: "Backs_", ret: R.Backs},
{func: "Bounces_", ret: R.Bounces},
{func: "Elastics_", ret: R.Elastics},
{func: "Quints_", ret: R.Quints},
{func: "Easing_", ret: R.Easing},
{func: "dynamic__dynamic_Game__TweenManager", args: [null, R.Game], opt: [R.TweenManager]},
"_object",
"_manager",
{func: "Color_", ret: R.Color},
{func: "int__int_int_int_int", ret: P.$int, args: [P.$int, P.$int, P.$int, P.$int]},
"g",
{func: "Color__int__Color_bool_bool", ret: R.Color, args: [P.$int], opt: [R.Color, P.bool, P.bool]},
"rgba",
"hsl",
"hsv",
{func: "Color__int_Color", ret: R.Color, args: [P.$int, R.Color]},
{func: "Color__int_int_int__Color", ret: R.Color, args: [P.$int, P.$int, P.$int], opt: [R.Color]},
{func: "Color__double_double_double__Color", ret: R.Color, args: [P.$double, P.$double, P.$double], opt: [R.Color]},
"h",
"s",
"l",
{func: "Color__int_int_int_Color", ret: R.Color, args: [P.$int, P.$int, P.$int, R.Color]},
{func: "double__double_double_double", ret: P.$double, args: [P.$double, P.$double, P.$double]},
"q",
{func: "Color___int_int_int_int_double_double_double_double", ret: R.Color, opt: [P.$int, P.$int, P.$int, P.$int, P.$double, P.$double, P.$double, P.$double]},
255,
{func: "Color__Color", ret: R.Color, args: [R.Color]},
{func: "int__dynamic_dynamic_dynamic_dynamic", ret: P.$int, args: [null, null, null, null]},
{func: "int__dynamic_dynamic_dynamic", ret: P.$int, args: [null, null, null]},
{func: "String__int_int_int__int_String", ret: P.String, args: [P.$int, P.$int, P.$int], opt: [P.$int, P.String]},
"#",
{func: "int__String", ret: P.$int, args: [P.String]},
{func: "Color__String__Color", ret: R.Color, args: [P.String], opt: [R.Color]},
{func: "String__int", ret: P.String, args: [P.$int]},
{func: "List___double_double", ret: P.List, opt: [P.$double, P.$double]},
0.5,
{func: "int__dynamic_dynamic_dynamic_dynamic__int", ret: P.$int, args: [null, null, null, null], opt: [P.$int]},
"color1",
"color2",
"steps",
"currentStep",
"alpha",
{func: "num__dynamic_dynamic_dynamic_dynamic_dynamic_dynamic", ret: P.num, args: [null, null, null, null, null, null]},
{func: "num__dynamic_dynamic_dynamic_dynamic_dynamic_dynamic_dynamic_dynamic", ret: P.num, args: [null, null, null, null, null, null, null, null]},
"r1",
"g1",
"r2",
"g2",
{func: "int___int_int_int", ret: P.$int, opt: [P.$int, P.$int, P.$int]},
{func: "Color__int", ret: R.Color, args: [P.$int]},
{func: "String__dynamic", ret: P.String, args: [null]},
{func: "double__int", ret: P.$double, args: [P.$int]},
{func: "List__List0", ret: [P.List, P.List], args: [[P.List, P.List]]},
{func: "List__List_dynamic", ret: [P.List, P.List], args: [[P.List, P.List], null]},
"matrix",
"direction",
{func: "num__dynamic_num", ret: P.num, args: [null, P.num]},
"dimension",
"object",
"sender",
"closure",
"isolate",
"numberOfArguments",
"arg1",
"arg2",
"arg3",
"arg4",
{func: "void_", void: true},
{func: "InstanceMirror__Object", ret: P.InstanceMirror, args: [P.Object]},
"reflectee",
{func: "void__void_", void: true, args: [{func: "void_", void: true}]},
{func: "void__dynamic", void: true, args: [null]},
{func: "void__dynamic__StackTrace", void: true, args: [null], opt: [P.StackTrace]},
"error",
"stackTrace",
{func: "bool__dynamic_dynamic", ret: P.bool, args: [null, null]},
{func: "int__Comparable_Comparable", ret: P.$int, args: [P.Comparable, P.Comparable]},
{func: "bool__Object_Object", ret: P.bool, args: [P.Object, P.Object]},
{func: "int__Object", ret: P.$int, args: [P.Object]},
{func: "String__EventTarget", ret: P.String, args: [W.EventTarget]},
"captureThis",
"self",
"arguments",
"o",
{func: "Object__dynamic", ret: P.Object, args: [null]},
"time",
{func: "void__num", void: true, args: [P.num]},
{func: "void__num_num", void: true, args: [P.num, P.num]},
"sx",
"sy",
{func: "void___String", void: true, opt: [P.String]},
"nonzero",
"winding",
{func: "Future___dynamic_dynamic", ret: [P.Future, W.MediaStream], named: {audio: null, video: null}},
{func: "bool__Node", ret: P.bool, args: [W.Node]},
{func: "int__RequestAnimationFrameCallback", ret: P.$int, args: [{func: "void__num", void: true, args: [P.num]}]},
{func: "void__num__num_num", void: true, args: [P.num], opt: [P.num, P.num]},
"when",
"grainOffset",
"grainDuration",
{func: "void__int", void: true, args: [P.$int]},
{func: "void__UniformLocation_num", void: true, args: [P.UniformLocation, P.num]},
"location",
{func: "void__UniformLocation_int", void: true, args: [P.UniformLocation, P.$int]},
{func: "void__UniformLocation_num_num", void: true, args: [P.UniformLocation, P.num, P.num]},
{func: "void__UniformLocation_Float32List", void: true, args: [P.UniformLocation, P.Float32List]},
{func: "void__UniformLocation_int_int", void: true, args: [P.UniformLocation, P.$int, P.$int]},
{func: "void__UniformLocation_num_num_num", void: true, args: [P.UniformLocation, P.num, P.num, P.num]},
"z",
{func: "void__UniformLocation_int_int_int", void: true, args: [P.UniformLocation, P.$int, P.$int, P.$int]},
{func: "void__UniformLocation_num_num_num_num", void: true, args: [P.UniformLocation, P.num, P.num, P.num, P.num]},
"w",
{func: "void__UniformLocation_int_int_int_int", void: true, args: [P.UniformLocation, P.$int, P.$int, P.$int, P.$int]},
{func: "void__UniformLocation_bool_Float32List", void: true, args: [P.UniformLocation, P.bool, P.Float32List]},
"transpose",
R.Game,
P.$int,
R.Point,
P.num,
P.bool,
R.CollisionInfo,
{func: "num_", ret: P.num},
{func: "dynamic__num", args: [P.num]},
{func: "dynamic__dynamic__String_bool", args: [null], opt: [P.String, P.bool]},
"rgba(0,255,0,0.4)",
"filled",
{func: "dynamic__Debug", args: [R.Debug]},
"debug",
"speed",
{func: "dynamic__num_num__num_num", args: [P.num, P.num], opt: [P.num, P.num]},
"offsetX",
"offsetY",
{func: "dynamic__num_num__bool_bool", args: [P.num, P.num], opt: [P.bool, P.bool]},
{func: "dynamic__num_num_AABB", args: [P.num, P.num, E.AABB]},
"obj",
{func: "dynamic__num_num_AABB_Tile", args: [P.num, P.num, E.AABB, E.Tile0]},
{func: "dynamic__CanvasRenderingContext2D_num_num_String_bool", args: [W.CanvasRenderingContext2D, P.num, P.num, P.String, P.bool]},
{func: "dynamic__CanvasRenderingContext2D__String_bool", args: [W.CanvasRenderingContext2D], opt: [P.String, P.bool]},
{func: "dynamic__num_num_num_num_Circle_Tile", args: [P.num, P.num, P.num, P.num, E.Circle1, E.Tile0]},
"oH",
"oV",
{func: "Circle_", ret: M.Circle},
{func: "bool__num_num", ret: P.bool, args: [P.num, P.num]},
{func: "Rectangle_", ret: M.Rectangle0},
M.Shape,
{func: "Ellipse_", ret: M.Ellipse},
P.$double,
P.Float32List,
{func: "Float32List__bool", ret: P.Float32List, args: [P.bool]},
P.Object,
[P.List, M.Point0],
M.Point0,
M.DisplayInterface,
{func: "void__InteractionData", void: true, args: [M.InteractionData]},
[P.Map, P.$int, M.InteractionData],
M.Stage0,
P.String,
M.Matrix,
M.Rectangle0,
M.Graphics0,
M.Sprite,
M.FilterBlock,
[P.List, M.AbstractFilter],
{func: "Stage_", ret: M.Stage0},
{func: "Matrix_", ret: M.Matrix},
{func: "Graphics_", ret: M.Graphics0},
{func: "dynamic__Graphics", args: [M.Graphics0]},
{func: "dynamic__bool", args: [P.bool]},
{func: "List_", ret: [P.List, M.AbstractFilter]},
{func: "dynamic__List2", args: [[P.List, M.AbstractFilter]]},
{func: "Rectangle___Matrix", ret: M.Rectangle0, opt: [M.Matrix]},
{func: "RenderTexture__Renderer", ret: M.RenderTexture0, args: [M.Renderer]},
{func: "dynamic__RenderSession", args: [M.RenderSession]},
{func: "void__RenderSession", void: true, args: [M.RenderSession]},
[P.List, M.DisplayInterface],
{func: "DisplayInterface__DisplayInterface", ret: M.DisplayInterface, args: [M.DisplayInterface]},
"child",
{func: "DisplayInterface__DisplayInterface_int", ret: M.DisplayInterface, args: [M.DisplayInterface, P.$int]},
{func: "bool__DisplayInterface_DisplayInterface", ret: P.bool, args: [M.DisplayInterface, M.DisplayInterface]},
"child2",
{func: "DisplayInterface__int", ret: M.DisplayInterface, args: [P.$int]},
{func: "List___int_int", ret: [P.List, M.DisplayInterface], opt: [P.$int, P.$int]},
"begin",
"end",
{func: "void__Stage", void: true, args: [M.Stage0]},
M.DisplayObject,
[P.List, M.Texture],
M.Texture,
M.TextureUvs,
W.CanvasImageSource,
M.CanvasBuffer,
M.BlendModes,
"frameNumber",
{func: "void__Texture", void: true, args: [M.Texture]},
{func: "dynamic__PixiEvent", args: [M.PixiEvent]},
M.DisplayObjectContainer,
M.RenderTexture0,
M.WebGLFastSpriteBatch,
[P.List, P.num],
M.InteractionManager,
"domElement",
{func: "Point_", ret: M.Point0},
P.Uint16List,
P.Buffer,
M.Strip,
M.BoneData,
M.Bone,
{func: "dynamic__bool_bool", args: [P.bool, P.bool]},
"flipX",
"flipY",
M.SlotData,
M.Skeleton,
[P.Map, P.String, M.Sprite],
M.Attachment,
"attachment",
[P.Map, P.String, M.Attachment],
{func: "dynamic__int_String_dynamic", args: [P.$int, P.String, null]},
"slotIndex",
{func: "dynamic__int_String", args: [P.$int, P.String]},
{func: "dynamic__Skeleton_Skin", args: [M.Skeleton, M.Skin]},
"oldSkin",
[P.List, M.Timeline],
{func: "dynamic__Skeleton_num_bool", args: [M.Skeleton, P.num, P.bool]},
{func: "dynamic__Skeleton_num_bool_num", args: [M.Skeleton, P.num, P.bool, P.num]},
{func: "dynamic__int_num_num_num_num", args: [P.$int, P.num, P.num, P.num, P.num]},
"cx1",
"cy1",
"cx2",
"cy2",
{func: "num__int_num", ret: P.num, args: [P.$int, P.num]},
"percent",
M.Curves,
[P.List, P.$int],
{func: "dynamic__int_num_num__dynamic_dynamic_dynamic", args: [P.$int, P.num, P.num], opt: [null, null, null]},
{func: "dynamic__Skeleton_num_num", args: [M.Skeleton, P.num, P.num]},
M.Timeline,
{func: "dynamic__int_dynamic_dynamic__dynamic_dynamic_dynamic", args: [P.$int, null, null], opt: [null, null, null]},
P.List,
{func: "dynamic__int_dynamic_String__dynamic_dynamic_dynamic", args: [P.$int, null, P.String], opt: [null, null, null]},
"attachmentName",
[P.List, M.BoneData],
[P.List, M.SlotData],
[P.List, M.Animation0],
M.Skin,
{func: "BoneData__String", ret: M.BoneData, args: [P.String]},
"boneName",
{func: "SlotData__String", ret: M.SlotData, args: [P.String]},
"slotName",
{func: "Skin__String", ret: M.Skin, args: [P.String]},
"skinName",
{func: "Animation__String", ret: M.Animation0, args: [P.String]},
"animationName",
M.SkeletonData,
[P.List, M.Bone],
[P.List, M.Slot],
{func: "Bone_", ret: M.Bone},
{func: "Bone__String", ret: M.Bone, args: [P.String]},
{func: "Slot__String", ret: M.Slot, args: [P.String]},
{func: "dynamic__Skin", args: [M.Skin]},
"newSkin",
{func: "dynamic__String_String", args: [P.String, P.String]},
{func: "dynamic__int_dynamic", args: [P.$int, null]},
"delta",
M.AtlasRegion,
{func: "dynamic__num_num_num_num_bool", args: [P.num, P.num, P.num, P.num, P.bool]},
"u",
"u2",
"v2",
"rotate",
{func: "dynamic__num_num_Bone_dynamic", args: [P.num, P.num, M.Bone, null]},
"vertices",
P.Map,
{func: "dynamic__String_String_num", args: [P.String, P.String, P.num]},
"fromName",
"toName",
{func: "dynamic__Animation_Animation_num", args: [M.Animation0, M.Animation0, P.num]},
"from",
"to",
{func: "dynamic__Animation_Animation", args: [M.Animation0, M.Animation0]},
M.Animation0,
M.AnimationStateData,
[P.List, M.Entry],
{func: "dynamic__Skeleton", args: [M.Skeleton]},
{func: "dynamic__Animation__bool", args: [M.Animation0], opt: [P.bool]},
"animation",
{func: "dynamic__String__bool_num", args: [P.String], opt: [P.bool, P.num]},
{func: "dynamic__Animation__bool_num", args: [M.Animation0], opt: [P.bool, P.num]},
M.AtlasAttachmentLoader,
{func: "dynamic__Map", args: [P.Map]},
"root",
{func: "dynamic__Skin_String_Map", args: [M.Skin, P.String, P.Map]},
"skin",
"map",
{func: "dynamic__String_Map_SkeletonData", args: [P.String, P.Map, M.SkeletonData]},
[P.List, M.AtlasPage],
[P.List, M.AtlasRegion],
{func: "dynamic__AtlasPage", args: [M.AtlasPage]},
"page",
M.AtlasPage,
{func: "String_", ret: P.String},
{func: "int__List0", ret: P.$int, args: [P.List]},
"tuple",
P.RegExp,
M.Atlas,
{func: "dynamic__Skin_String_String", args: [M.Skin, P.String, P.String]},
M.AnimationState,
[P.List, M.DisplayObjectContainer],
P.DateTime,
{func: "Sprite__Slot_AtlasRegion", ret: M.Sprite, args: [M.Slot, M.AtlasRegion]},
"slot",
"descriptor",
W.CanvasPattern,
"forcePowerOfTwo",
{func: "Texture_", ret: M.Texture},
M.AbstractFilter,
M.BlurXFilter,
M.BlurYFilter,
{func: "List_0", ret: [P.List, P.num]},
{func: "dynamic__Point", args: [M.Point0]},
M.FilterTexture,
W.Event,
{func: "Point__DisplayObject", ret: M.Point0, args: [M.DisplayObject]},
"displayObject",
M.InteractionData,
[P.List, M.InteractionData],
W.CanvasElement,
M.Renderer,
{func: "void__DisplayObjectContainer_DisplayObjectContainer", void: true, args: [M.DisplayObjectContainer, M.DisplayObjectContainer]},
"iParent",
{func: "void__Renderer", void: true, args: [M.Renderer]},
{func: "void__Element", void: true, args: [W.Element]},
{func: "dynamic__MouseEvent", args: [W.MouseEvent]},
"event",
{func: "void__MouseEvent", void: true, args: [W.MouseEvent]},
{func: "bool__DisplayObjectContainer_InteractionData", ret: P.bool, args: [M.DisplayObjectContainer, M.InteractionData]},
"item",
"interactionData",
[P.List, P.String],
[P.Map, P.String, [P.List, {func: "void__PixiEvent", void: true, args: [M.PixiEvent]}]],
"str",
M.EventTarget0,
"evt",
W.HttpRequest,
M.BaseTexture,
M.Loader0,
"textureName",
[P.List, M.GraphicsData],
M.GraphicsData,
[P.Map, P.RenderingContext, M.WebGLGraphicsData],
{func: "Graphics___int_num_num", ret: M.Graphics0, opt: [P.$int, P.num, P.num]},
"lineWidth",
{func: "Graphics__num_num", ret: M.Graphics0, args: [P.num, P.num]},
{func: "Graphics__num_num_num_num", ret: M.Graphics0, args: [P.num, P.num, P.num, P.num]},
{func: "Graphics__num_num_num_num_num_num", ret: M.Graphics0, args: [P.num, P.num, P.num, P.num, P.num, P.num]},
"cpX2",
"cpY2",
{func: "Graphics__num_num_num_num_num", ret: M.Graphics0, args: [P.num, P.num, P.num, P.num, P.num]},
{func: "Graphics__num_num_num_num_num__bool", ret: M.Graphics0, args: [P.num, P.num, P.num, P.num, P.num], opt: [P.bool]},
"startAngle",
"endAngle",
"anticlockwise",
{func: "Graphics__List", ret: M.Graphics0, args: [[P.List, P.num]]},
"path",
{func: "Graphics___num_num", ret: M.Graphics0, opt: [P.num, P.num]},
{func: "Graphics__num_num_num", ret: M.Graphics0, args: [P.num, P.num, P.num]},
{func: "Graphics__dynamic_dynamic_dynamic_dynamic", ret: M.Graphics0, args: [null, null, null, null]},
{func: "Texture___Renderer", ret: M.Texture, opt: [M.Renderer]},
W.CanvasRenderingContext2D,
P.RenderingContext,
M.WebGLShaderManager,
M.WebGLSpriteBatch,
M.MaskManager,
M.WebGLFilterManager,
M.WebGLStencilManager,
M.WebGLBlendModeManager,
M.RenderSession,
{func: "dynamic__DisplayInterface__CanvasRenderingContext2D_dynamic", args: [M.DisplayInterface], opt: [W.CanvasRenderingContext2D, null]},
"buffer",
"strip",
{func: "dynamic__dynamic__dynamic", args: [null], opt: [null]},
"maskData",
{func: "dynamic__dynamic__RenderSession", args: [null], opt: [M.RenderSession]},
M.scaleModes,
P.Program,
P.UniformLocation,
M.Shader,
"uniform",
P.Framebuffer,
P.Renderbuffer,
{func: "bool__BlendModes", ret: P.bool, args: [M.BlendModes]},
"blendMode",
{func: "dynamic__SpriteBatch_RenderSession", args: [M.SpriteBatch0, M.RenderSession]},
"spriteBatch",
{func: "dynamic__SpriteBatch", args: [M.SpriteBatch0]},
{func: "dynamic__Sprite", args: [M.Sprite]},
{func: "dynamic__BlendModes", args: [M.BlendModes]},
[P.List, M.FilterBlock],
[P.List, M.FilterTexture],
M.PixiShader,
{func: "dynamic__RenderSession_Framebuffer", args: [M.RenderSession, P.Framebuffer]},
{func: "dynamic__FilterBlock", args: [M.FilterBlock]},
"filterBlock",
{func: "dynamic__AbstractFilter_Rectangle_num_num", args: [M.AbstractFilter, M.Rectangle0, P.num, P.num]},
"filter",
"filterArea",
[P.List, M.WebGLGraphicsData],
"n1",
"n2",
"perc",
{func: "dynamic__Graphics__RenderSession", args: [M.Graphics0], opt: [M.RenderSession]},
[P.Map, P.$int, P.bool],
M.PrimitiveShader,
M.PixiFastShader,
M.ComplexPrimitiveShader,
M.StripShader,
{func: "dynamic__List3", args: [[P.List, P.$int]]},
"attribs",
"shader",
[P.List, M.BaseTexture],
[P.List, M.BlendModes],
{func: "dynamic__TilingSprite", args: [M.TilingSprite]},
"tilingSprite",
{func: "dynamic__BaseTexture_int_int", args: [M.BaseTexture, P.$int, P.$int]},
{func: "dynamic__Graphics_WebGLGraphicsData_RenderSession", args: [M.Graphics0, M.WebGLGraphicsData, M.RenderSession]},
{func: "dynamic__DisplayInterface__Point_dynamic", args: [M.DisplayInterface], opt: [M.Point0, null]},
"projection",
{func: "dynamic__int_int", args: [P.$int, P.$int]},
M.TextStyle,
{func: "TextStyle_", ret: M.TextStyle},
{func: "dynamic__TextStyle", args: [M.TextStyle]},
{func: "CanvasElement_", ret: W.CanvasElement},
{func: "CanvasRenderingContext2D_", ret: W.CanvasRenderingContext2D},
{func: "dynamic__Object", args: [P.Object]},
{func: "num__String", ret: P.num, args: [P.String]},
"fontStyle",
{func: "String__String", ret: P.String, args: [P.String]},
{func: "dynamic___dynamic", opt: [null]},
"destroyBaseTexture",
[P.Map, P.String, P.$int],
[P.Map, P.RenderingContext, null],
{func: "void__PixiEvent", void: true, args: [M.PixiEvent]},
"newSrc",
{func: "void__DisplayInterface_Point__bool", void: true, args: [M.DisplayInterface, M.Point0], opt: [P.bool]},
{func: "dynamic__num_num__bool", args: [P.num, P.num], opt: [P.bool]},
"updateBase",
{func: "dynamic__DisplayObjectContainer_Point__bool", args: [M.DisplayObjectContainer, M.Point0], opt: [P.bool]},
"position",
"clear",
{func: "void__DisplayObjectContainer_Point__bool", void: true, args: [M.DisplayObjectContainer, M.Point0], opt: [P.bool]},
{func: "dynamic___bool", opt: [P.bool]},
"destroyBase",
{func: "dynamic__Rectangle", args: [M.Rectangle0]},
{func: "args2", args: [null, null]},
"listener",
R.Sprite0,
R.FrameData,
R.Frame,
[R.Signal, {func: "void__GameObject_Animation", void: true, args: [R.GameObject, R.Animation]}],
{func: "dynamic___num_bool_bool", opt: [P.num, P.bool, P.bool]},
"killOnComplete",
{func: "dynamic__dynamic__bool", args: [null], opt: [P.bool]},
"useLocalFrameIndex",
{func: "dynamic___bool_bool", opt: [P.bool, P.bool]},
"resetFrame",
"dispatchComplete",
{func: "dynamic___int", opt: [P.$int]},
"quantity",
{func: "dynamic__FrameData", args: [R.FrameData]},
"frameData",
R.AnimationInterface,
R.Animation,
[P.Map, P.String, R.Animation],
{func: "FrameData_", ret: R.FrameData},
{func: "bool__FrameData__dynamic", ret: P.bool, args: [R.FrameData], opt: [null]},
{func: "Animation__String__List_num_bool_bool", ret: R.Animation, args: [P.String], opt: [P.List, P.num, P.bool, P.bool]},
"useNumericIndex",
{func: "bool__List__bool", ret: P.bool, args: [P.List], opt: [P.bool]},
{func: "dynamic__dynamic__num_bool_bool", args: [null], opt: [P.num, P.bool, P.bool]},
{func: "dynamic___dynamic_dynamic", opt: [null, null]},
{func: "Animation__String0", ret: R.Animation, args: [P.String]},
{func: "dynamic__bool_num_num_num_num_num_num", args: [P.bool, P.num, P.num, P.num, P.num, P.num, P.num]},
"trimmed",
"actualWidth",
"actualHeight",
"destX",
"destY",
"destWidth",
"destHeight",
{func: "Rectangle___Rectangle", ret: R.Rectangle1, opt: [R.Rectangle1]},
{func: "Frame___Frame", ret: R.Frame, opt: [R.Frame]},
"output",
R.Rectangle1,
[P.List, R.Frame],
{func: "Frame__dynamic", ret: R.Frame, args: [null]},
{func: "Frame__int", ret: R.Frame, args: [P.$int]},
{func: "Frame__String", ret: R.Frame, args: [P.String]},
{func: "bool__dynamic", ret: P.bool, args: [null]},
{func: "List__int_int__List", ret: [P.List, R.Frame], args: [P.$int, P.$int], opt: [[P.List, R.Frame]]},
{func: "List___List_bool_List", ret: [P.List, R.Frame], opt: [P.List, P.bool, [P.List, R.Frame]]},
{func: "List___List_bool_List0", ret: [P.List, P.$int], opt: [P.List, P.bool, [P.List, P.$int]]},
R.World,
R.AtLimit,
{func: "dynamic__dynamic__int", args: [null], opt: [P.$int]},
[P.List, R.SignalBinding],
"fnName",
"isOnce",
"priority",
{func: "dynamic__SignalBinding", args: [R.SignalBinding]},
"binding",
[P.List, R.Filter],
{func: "dynamic___Pointer", opt: [R.Pointer]},
"pointer",
R.StateManager,
R.RequestAnimationFrame,
R.GameObjectFactory,
R.GameObjectCreator,
R.Cache,
R.Input,
R.Loader,
R.Net,
R.ScaleManager,
R.SoundManager,
R.PluginManager,
R.Stage,
R.Time,
R.Physics,
R.TweenManager,
R.RandomDataGenerator,
R.Device,
R.Camera,
R.Debug,
R.Particles,
[R.Signal, {func: "void_", void: true}],
{func: "dynamic__double", args: [P.$double]},
[P.List, 3],
R.Events,
{func: "Point_0", ret: R.Point},
{func: "dynamic__Point0", args: [R.Point]},
"silent",
"exists",
{func: "dynamic__int__dynamic_dynamic_bool", args: [P.$int], opt: [null, null, P.bool]},
"child1",
{func: "dynamic__int_num_num", args: [P.$int, P.num, P.num]},
"oldChild",
"newChild",
{func: "dynamic__Function__bool", args: [P.Function], opt: [P.bool]},
"checkExists",
{func: "dynamic__Function", args: [P.Function]},
{func: "dynamic___String_int", opt: [P.String, P.$int]},
"order",
"sortHandler",
{func: "int__dynamic_dynamic", ret: P.$int, args: [null, null]},
"where",
"destroy",
{func: "dynamic__int__int_bool_bool", args: [P.$int], opt: [P.$int, P.bool, P.bool]},
"endIndex",
"destroyChildren",
"soft",
{func: "Rectangle___Matrix0", ret: R.Rectangle1, opt: [M.Matrix]},
[P.List, R.Plugin],
{func: "Plugin__Plugin__List", ret: R.Plugin, args: [R.Plugin], opt: [P.List]},
"plugin",
{func: "dynamic__Plugin", args: [R.Plugin]},
[R.Signal, {func: "void__int_bool_bool", void: true, args: [P.$int, P.bool, P.bool]}],
[R.Signal, {func: "void__num_num", void: true, args: [P.num, P.num]}],
W.Element,
P.Timer0,
{func: "dynamic__bool__bool_String", args: [P.bool], opt: [P.bool, P.String]},
"forceLandscape",
"forcePortrait",
"orientationImage",
"force",
R.Signal,
"params",
P.Type,
[P.List, R.GameObject],
{func: "GameObject___GameObject", ret: R.GameObject, opt: [R.GameObject]},
R.Math,
[P.Map, P.String, R.State],
R.State,
{func: "dynamic__String_State__bool", args: [P.String, R.State], opt: [P.bool]},
"autoStart",
{func: "dynamic__String__bool_bool_List", args: [P.String], opt: [P.bool, P.bool, P.List]},
"clearWorld",
"clearCache",
{func: "dynamic___bool_bool_List", opt: [P.bool, P.bool, P.List]},
{func: "dynamic__GameObject__num_bool_bool_bool", args: [R.GameObject], opt: [P.num, P.bool, P.bool, P.bool]},
"padding",
"useBounds",
"horizontal",
"vertical",
R.Group,
W.ImageData,
P.Uint32List,
{func: "dynamic__int_int_int__double", args: [P.$int, P.$int, P.$int], opt: [P.$double]},
{func: "dynamic___int_int_int_int", opt: [P.$int, P.$int, P.$int, P.$int]},
{func: "dynamic__Function__int_int_int_int", args: [P.Function], opt: [P.$int, P.$int, P.$int, P.$int]},
{func: "args5", args: [null, null, null, null, null]},
{func: "dynamic__int_int_int_int_int_int_int_int__Rectangle", args: [P.$int, P.$int, P.$int, P.$int, P.$int, P.$int, P.$int, P.$int], opt: [R.Rectangle1]},
"region",
{func: "dynamic___double_double_double_Rectangle", opt: [P.$double, P.$double, P.$double, R.Rectangle1]},
{func: "dynamic__int_int_int_int_int_int__bool", args: [P.$int, P.$int, P.$int, P.$int, P.$int, P.$int], opt: [P.bool]},
"red",
"green",
"blue",
"immediate",
{func: "dynamic__int_int_int_int_int__bool", args: [P.$int, P.$int, P.$int, P.$int, P.$int], opt: [P.bool]},
{func: "Color__int_int_Color", ret: R.Color, args: [P.$int, P.$int, R.Color]},
{func: "int__int_int", ret: P.$int, args: [P.$int, P.$int]},
{func: "Color__int_int__Color_bool_bool", ret: R.Color, args: [P.$int, P.$int], opt: [R.Color, P.bool, P.bool]},
{func: "ImageData__Rectangle", ret: W.ImageData, args: [R.Rectangle1]},
"rect",
{func: "GameObject___int_int", ret: R.GameObject, opt: [P.$int, P.$int]},
{func: "dynamic__dynamic_Rectangle_int_int", args: [null, R.Rectangle1, P.$int, P.$int]},
"area",
{func: "dynamic__dynamic__num_num_num_num", args: [null], opt: [P.num, P.num, P.num, P.num]},
{func: "dynamic__dynamic__int_int", args: [null], opt: [P.$int, P.$int]},
{func: "dynamic__dynamic_dynamic__Rectangle_Rectangle", args: [null, null], opt: [R.Rectangle1, R.Rectangle1]},
"mask",
"sourceRect",
"maskRect",
{func: "BitmapData__BitmapData_int_int_int__int_bool_int_int_int", ret: R.BitmapData, args: [R.BitmapData, P.$int, P.$int, P.$int], opt: [P.$int, P.bool, P.$int, P.$int, P.$int]},
"destination",
"resize",
{func: "dynamic__int_int_int_int__String", args: [P.$int, P.$int, P.$int, P.$int], opt: [P.String]},
"fillStyle",
{func: "dynamic__int_int_num__String", args: [P.$int, P.$int, P.num], opt: [P.String]},
"pixel",
R.InputHandler,
{func: "dynamic___TextStyle", opt: [M.TextStyle]},
M.BitmapText,
R.Sound,
[R.Signal, {func: "void__GameObject_Pointer", void: true, args: [R.GameObject, R.Pointer]}],
[R.Signal, {func: "void__GameObject_Pointer_bool", void: true, args: [R.GameObject, R.Pointer, P.bool]}],
R.Body0,
{func: "args4", args: [null, null, null, null]},
{func: "dynamic___Sound_String_Sound_String_Sound_String_Sound_String", opt: [R.Sound, P.String, R.Sound, P.String, R.Sound, P.String, R.Sound, P.String]},
"overSound",
"overMarker",
"downSound",
"downMarker",
"outSound",
"outMarker",
"upSound",
"upMarker",
{func: "dynamic___Sound_String", opt: [R.Sound, P.String]},
"sound",
"marker",
{func: "dynamic__Button_Pointer", args: [R.Button, R.Pointer]},
{func: "dynamic__Button_Pointer_bool", args: [R.Button, R.Pointer, P.bool]},
"isOver",
"newState",
R.Image,
[R.Signal, {func: "void__GameObject_Group", void: true, args: [R.GameObject, R.Group]}],
[R.Signal, {func: "void__GameObject", void: true, args: [R.GameObject]}],
R.CoreInterfact,
R.SpriteInterface,
{func: "Image__num_num_dynamic__dynamic", ret: R.Image, args: [P.num, P.num, null], opt: [null]},
{func: "Sprite__num_num__Object_Object", ret: R.Sprite0, args: [P.num, P.num], opt: [P.Object, P.Object]},
{func: "Tween__dynamic", ret: R.Tween, args: [null]},
{func: "Group___String_bool_bool_num", ret: R.Group, opt: [P.String, P.bool, P.bool, P.num]},
{func: "Group__Group__String_bool", ret: R.Group, args: [R.Group], opt: [P.String, P.bool]},
{func: "Sound__String__num_bool_bool", ret: R.Sound, args: [P.String], opt: [P.num, P.bool, P.bool]},
{func: "TileSprite__num_num_num_num_dynamic_dynamic", ret: R.TileSprite, args: [P.num, P.num, P.num, P.num, null, null]},
{func: "Text__num_num_String_TextStyle", ret: R.Text0, args: [P.num, P.num, P.String, R.TextStyle0]},
{func: "Button___num_num_String_Function_dynamic_dynamic_dynamic_dynamic", ret: R.Button, opt: [P.num, P.num, P.String, P.Function, null, null, null, null]},
{func: "Graphics___num_num0", ret: R.Graphics, opt: [P.num, P.num]},
{func: "Emitter___num_num_num", ret: R.Emitter, opt: [P.num, P.num, P.num]},
{func: "RetroFont__String_num_num_String_num__num_num_num_num", ret: R.RetroFont, args: [P.String, P.num, P.num, P.String, P.num], opt: [P.num, P.num, P.num, P.num]},
{func: "BitmapText__num_num_String__String_num", ret: R.BitmapText0, args: [P.num, P.num, P.String], opt: [P.String, P.num]},
{func: "Tilemap__String__num_num_num_num", ret: R.Tilemap, args: [P.String], opt: [P.num, P.num, P.num, P.num]},
{func: "RenderTexture___int_int_String_bool", ret: R.RenderTexture, opt: [P.$int, P.$int, P.String, P.bool]},
"addToCache",
{func: "BitmapData___int_int_String_bool", ret: R.BitmapData, opt: [P.$int, P.$int, P.String, P.bool]},
{func: "Filter__dynamic", ret: R.Filter, args: [null]},
{func: "GameObject__num_num_dynamic__dynamic_Group", ret: R.GameObject, args: [P.num, P.num, null], opt: [null, R.Group]},
{func: "Sprite__num_num__Object_Object_Group", ret: R.Sprite0, args: [P.num, P.num], opt: [P.Object, P.Object, R.Group]},
{func: "Tween__Object", ret: R.Tween, args: [P.Object]},
{func: "Group___Group_String_bool_bool_int", ret: R.Group, opt: [R.Group, P.String, P.bool, P.bool, P.$int]},
{func: "dynamic___int_Group_String_bool", opt: [P.$int, R.Group, P.String, P.bool]},
{func: "Group___Group_String_bool", ret: R.Group, opt: [R.Group, P.String, P.bool]},
{func: "Sound__String__double_bool_bool", ret: R.Sound, args: [P.String], opt: [P.$double, P.bool, P.bool]},
{func: "TileSprite__int_int_int_int_String__dynamic_Group", ret: R.TileSprite, args: [P.$int, P.$int, P.$int, P.$int, P.String], opt: [null, R.Group]},
{func: "Text__int_int_String_TextStyle__Group", ret: R.Text0, args: [P.$int, P.$int, P.String, R.TextStyle0], opt: [R.Group]},
{func: "Button___num_num_String_Function_dynamic_dynamic_dynamic_dynamic_Group", ret: R.Button, opt: [P.num, P.num, P.String, P.Function, null, null, null, null, R.Group]},
{func: "Graphics___int_int_Group", ret: R.Graphics, opt: [P.$int, P.$int, R.Group]},
{func: "Emitter___int_int_int", ret: R.Emitter, opt: [P.$int, P.$int, P.$int]},
{func: "RetroFont__String_int_int_String_int__int_int_int_int", ret: R.RetroFont, args: [P.String, P.$int, P.$int, P.String, P.$int], opt: [P.$int, P.$int, P.$int, P.$int]},
{func: "BitmapText__int_int_String__String_int_Group", ret: R.BitmapText0, args: [P.$int, P.$int, P.String], opt: [P.String, P.$int, R.Group]},
{func: "Tilemap___String_int_int_int_int", ret: R.Tilemap, opt: [P.String, P.$int, P.$int, P.$int, P.$int]},
{func: "Filter__Type__List", ret: R.Filter, args: [P.Type], opt: [P.List]},
"filterType",
{func: "Plugin__Plugin", ret: R.Plugin, args: [R.Plugin]},
{func: "dynamic__Polygon", args: [R.Polygon0]},
"poly",
{func: "dynamic__List__bool0", args: [[P.List, R.Point]], opt: [P.bool]},
"cull",
{func: "dynamic__dynamic__List_bool", args: [null], opt: [[P.List, P.$int], P.bool]},
"indices",
[P.List, [P.Map, P.String, P.num]],
R.AnimationManager,
{func: "dynamic__List4", args: [[P.List, [P.Map, P.String, P.num]]]},
{func: "Particle__num_num__num", ret: R.Particle, args: [P.num, P.num], opt: [P.num]},
"health",
{func: "dynamic__DisplayObject_dynamic_dynamic_dynamic", args: [M.DisplayObject, null, null, null]},
W.ImageElement,
{func: "dynamic__num__String", args: [P.num], opt: [P.String]},
"lineAlignment",
{func: "dynamic__String__bool_num_int_String_bool", args: [P.String], opt: [P.bool, P.num, P.$int, P.String, P.bool]},
"multiLine",
"characterSpacing",
"lineSpacing",
"allowLowerCase",
{func: "dynamic__String_num_num_num", args: [P.String, P.num, P.num, P.num]},
"line",
"customSpacingX",
{func: "String__bool", ret: P.String, args: [P.bool]},
"stripCR",
R.RenderTexture,
{func: "dynamic__dynamic__dynamic_bool", args: [null], opt: [null, P.bool]},
"stopAnimation",
{func: "dynamic__Frame", args: [R.Frame]},
{func: "dynamic___Rectangle_bool", opt: [R.Rectangle1, P.bool]},
"copy",
{func: "Sprite__num_num__num", ret: R.Sprite0, args: [P.num, P.num], opt: [P.num]},
{func: "dynamic__String__num_bool_bool", args: [P.String], opt: [P.num, P.bool, P.bool]},
{func: "bool__GameObject", ret: P.bool, args: [R.GameObject]},
R.TextStyle0,
{func: "dynamic___num_num_String_num", opt: [P.num, P.num, P.String, P.num]},
"rgba(0,0,0,0)",
"blur",
{func: "dynamic__TextStyle0", args: [R.TextStyle0]},
M.Text,
{func: "Animation__String_num__bool_bool", ret: R.Animation, args: [P.String, P.num], opt: [P.bool, P.bool]},
M.TilingSprite,
{func: "Circle__num_num_num", ret: R.Circle0, args: [P.num, P.num, P.num]},
"diameter",
{func: "Circle__Circle", ret: R.Circle0, args: [R.Circle0]},
"dest",
"round",
{func: "Circle___Circle", ret: R.Circle0, opt: [R.Circle0]},
{func: "Point__dynamic__dynamic_dynamic", ret: R.Point, args: [null], opt: [null, null]},
"asDegrees",
{func: "Circle__num_num", ret: R.Circle0, args: [P.num, P.num]},
"dx",
"dy",
{func: "Circle__Point", ret: R.Circle0, args: [R.Point]},
M.Circle,
{func: "Ellipse__num_num_num_num", ret: R.Ellipse0, args: [P.num, P.num, P.num, P.num]},
{func: "Ellipse__Ellipse", ret: R.Ellipse0, args: [R.Ellipse0]},
{func: "Ellipse___Ellipse", ret: R.Ellipse0, opt: [R.Ellipse0]},
{func: "Rectangle_0", ret: R.Rectangle1},
M.Ellipse,
{func: "Line__Sprite_Sprite__bool", ret: R.Line, args: [R.Sprite0, R.Sprite0], opt: [P.bool]},
"startSprite",
"endSprite",
"useCenter",
{func: "Point__Line__bool_Point", ret: R.Point, args: [R.Line], opt: [P.bool, R.Point]},
{func: "List___int_List", ret: [P.List, [P.List, P.num]], opt: [P.$int, [P.List, [P.List, P.num]]]},
"stepRate",
"results",
{func: "Point__Point", ret: R.Point, args: [R.Point]},
{func: "Point___num_num", ret: R.Point, opt: [P.num, P.num]},
{func: "Point__num_num", ret: R.Point, args: [P.num, P.num]},
{func: "Point___Point", ret: R.Point, opt: [R.Point]},
{func: "num__Point__bool", ret: P.num, args: [R.Point], opt: [P.bool]},
{func: "bool__Point", ret: P.bool, args: [R.Point]},
{func: "num__Point__dynamic", ret: P.num, args: [R.Point], opt: [null]},
{func: "num__Point", ret: P.num, args: [R.Point]},
{func: "Point__num_num_num__bool_num", ret: R.Point, args: [P.num, P.num, P.num], opt: [P.bool, P.num]},
"distance",
{func: "Point__num", ret: R.Point, args: [P.num]},
"magnitude",
{func: "num__dynamic", ret: P.num, args: [null]},
[P.List, R.Point],
{func: "List_1", ret: [P.List, R.Point]},
{func: "Rectangle__num_num", ret: R.Rectangle1, args: [P.num, P.num]},
{func: "Rectangle__Point", ret: R.Rectangle1, args: [R.Point]},
{func: "Rectangle__num_num_num_num", ret: R.Rectangle1, args: [P.num, P.num, P.num, P.num]},
{func: "Rectangle__dynamic", ret: R.Rectangle1, args: [null]},
{func: "dynamic__Rectangle0", args: [R.Rectangle1]},
{func: "bool__Rectangle", ret: P.bool, args: [R.Rectangle1]},
{func: "Rectangle__Rectangle__Rectangle", ret: R.Rectangle1, args: [R.Rectangle1], opt: [R.Rectangle1]},
{func: "bool__Rectangle__num", ret: P.bool, args: [R.Rectangle1], opt: [P.num]},
{func: "bool__num_num_num_num__num", ret: P.bool, args: [P.num, P.num, P.num, P.num], opt: [P.num]},
"top",
"bottom",
{func: "Rectangle__Rectangle_Rectangle", ret: R.Rectangle1, args: [R.Rectangle1, R.Rectangle1]},
R.Circle0,
[P.List, R.Pointer],
R.Pointer,
R.Mouse,
R.Keyboard,
R.Touch,
[R.Signal, {func: "void__Pointer_dynamic", void: true, args: [R.Pointer, null]}],
[P.List, R.InputHandler],
{func: "int__Function_dynamic", ret: P.$int, args: [P.Function, null]},
"callbackContext",
{func: "Pointer_", ret: R.Pointer},
"hard",
{func: "dynamic__double_double", args: [P.$double, P.$double]},
{func: "Pointer__dynamic", ret: R.Pointer, args: [null]},
{func: "Pointer___bool", ret: R.Pointer, opt: [P.bool]},
{func: "Pointer__int", ret: R.Pointer, args: [P.$int]},
"identifier",
"pointerId",
{func: "Point__dynamic_Pointer_Point", ret: R.Point, args: [null, R.Pointer, R.Point]},
{func: "bool__GameObject_Pointer_Point", ret: P.bool, args: [R.GameObject, R.Pointer, R.Point]},
"localPoint",
{func: "GameObject___int_bool", ret: R.GameObject, opt: [P.$int, P.bool]},
"useHandCursor",
{func: "dynamic__GameObject_Group", args: [R.GameObject, R.Group]},
{func: "bool__int_int__bool", ret: P.bool, args: [P.$int, P.$int], opt: [P.bool]},
"highestID",
"highestRenderID",
"includePixelPerfect",
{func: "num___int", ret: P.num, opt: [P.$int]},
{func: "bool___int", ret: P.bool, opt: [P.$int]},
{func: "double___int", ret: P.$double, opt: [P.$int]},
{func: "bool__Pointer", ret: P.bool, args: [R.Pointer]},
{func: "bool__num_num__Pointer", ret: P.bool, args: [P.num, P.num], opt: [R.Pointer]},
{func: "dynamic__Pointer", args: [R.Pointer]},
{func: "bool___int_int", ret: P.bool, opt: [P.$int, P.$int]},
500,
{func: "dynamic___bool_bool_bool_int_Rectangle_Sprite", opt: [P.bool, P.bool, P.bool, P.$int, R.Rectangle1, R.Sprite0]},
"lockCenter",
"bringToTop",
"pixelPerfect",
"alphaThreshold",
"boundsRect",
"boundsSprite",
"allowHorizontal",
"allowVertical",
{func: "dynamic__num_num__bool_bool_num_num", args: [P.num, P.num], opt: [P.bool, P.bool, P.num, P.num]},
"snapX",
"snapY",
"onDrag",
"onRelease",
"snapOffsetX",
"snapOffsetY",
[R.Signal, {func: "void__Key", void: true, args: [R.Key]}],
{func: "dynamic__KeyboardEvent", args: [W.KeyboardEvent]},
R.Key,
[P.Map, P.$int, R.Key],
{func: "Key_", ret: R.Key},
{func: "dynamic__dynamic__Function_Function_Function", args: [null], opt: [P.Function, P.Function, P.Function]},
"onDown",
"onUp",
"onPress",
{func: "Key__int", ret: R.Key, args: [P.$int]},
{func: "bool__dynamic__int", ret: P.bool, args: [null], opt: [P.$int]},
{func: "dynamic__int__int", args: [P.$int], opt: [P.$int]},
W.MouseEvent,
{func: "dynamic__WheelEvent", args: [W.WheelEvent]},
{func: "double_", ret: P.$double},
{func: "Pointer__dynamic__bool", ret: R.Pointer, args: [null], opt: [P.bool]},
"fromClick",
W.TouchEvent,
P.StreamSubscription,
{func: "dynamic__TouchEvent", args: [W.TouchEvent]},
[R.Signal, {func: "void__Sound", void: true, args: [R.Sound]}],
{func: "dynamic__String_CanvasElement_CanvasRenderingContext2D", args: [P.String, W.CanvasElement, W.CanvasRenderingContext2D]},
"binaryData",
{func: "BitmapData__String_BitmapData", ret: R.BitmapData, args: [P.String, R.BitmapData]},
"bitmapData",
{func: "dynamic__String_RenderTexture", args: [P.String, R.RenderTexture]},
{func: "dynamic__String_String_dynamic_int_int__int_int_int", args: [P.String, P.String, null, P.$int, P.$int], opt: [P.$int, P.$int, P.$int]},
{func: "dynamic__String_String_dynamic_int", args: [P.String, P.String, null, P.$int]},
"mapData",
"format",
{func: "dynamic__String_String_dynamic_dynamic_int", args: [P.String, P.String, null, null, P.$int]},
"atlasData",
{func: "dynamic__String_String_dynamic_dynamic__int_int", args: [P.String, P.String, null, null], opt: [P.$int, P.$int]},
"xmlData",
"JSONData",
{func: "dynamic__String_String_dynamic", args: [P.String, P.String, null]},
{func: "dynamic__String_String_dynamic__bool_bool", args: [P.String, P.String, null], opt: [P.bool, P.bool]},
"webAudio",
"audioTag",
"property",
{func: "Map__String", ret: P.Map, args: [P.String]},
{func: "dynamic__String_String_String", args: [P.String, P.String, P.String]},
"fixtureKey",
{func: "bool__int_String", ret: P.bool, args: [P.$int, P.String]},
{func: "bool__String", ret: P.bool, args: [P.String]},
{func: "ImageElement__String", ret: W.ImageElement, args: [P.String]},
{func: "FrameData__String", ret: R.FrameData, args: [P.String]},
{func: "dynamic__String_FrameData", args: [P.String, R.FrameData]},
{func: "Frame__String_Frame", ret: R.Frame, args: [P.String, R.Frame]},
{func: "RenderTexture__String", ret: R.RenderTexture, args: [P.String]},
{func: "List__int0", ret: [P.List, P.String], args: [P.$int]},
[R.Signal, {func: "void__int", void: true, args: [P.$int]}],
[R.Signal, {func: "void__int_String", void: true, args: [P.$int, P.String]}],
[R.Signal, {func: "void__int_String_bool_int_int", void: true, args: [P.$int, P.String, P.bool, P.$int, P.$int]}],
[R.Signal, {func: "void__dynamic_Map", void: true, args: [null, P.Map]}],
[R.Signal, {func: "void__dynamic_bool_int_int", void: true, args: [null, P.bool, P.$int, P.$int]}],
[P.List, P.Map],
{func: "bool__String_String", ret: P.bool, args: [P.String, P.String]},
{func: "int__String_String", ret: P.$int, args: [P.String, P.String]},
{func: "Map__dynamic_dynamic", ret: P.Map, args: [null, null]},
{func: "dynamic__String_String_dynamic__Map", args: [P.String, P.String, null], opt: [P.Map]},
{func: "dynamic__String_String_String__Map", args: [P.String, P.String, P.String], opt: [P.Map]},
{func: "Loader__String__String_dynamic", ret: R.Loader, args: [P.String], opt: [P.String, null]},
{func: "Loader__String_String__bool", ret: R.Loader, args: [P.String, P.String], opt: [P.bool]},
"overwrite",
{func: "Loader__String_String__Function", ret: R.Loader, args: [P.String, P.String], opt: [P.Function]},
{func: "Loader__String_String_int__int_int_int_int", ret: R.Loader, args: [P.String, P.String, P.$int], opt: [P.$int, P.$int, P.$int, P.$int]},
{func: "Loader__String_dynamic__bool", ret: R.Loader, args: [P.String, null], opt: [P.bool]},
"autoDecode",
{func: "Loader__String__String_dynamic_int", ret: R.Loader, args: [P.String], opt: [P.String, null, P.$int]},
{func: "Loader__String_String__String_dynamic_int_int", ret: R.Loader, args: [P.String, P.String], opt: [P.String, null, P.$int, P.$int]},
"textureURL",
"xmlURL",
{func: "Loader__String_String__String_dynamic", ret: R.Loader, args: [P.String, P.String], opt: [P.String, null]},
"atlasURL",
{func: "Loader__String_String__String_dynamic_int", ret: R.Loader, args: [P.String, P.String], opt: [P.String, null, P.$int]},
{func: "dynamic__int__bool", args: [P.$int], opt: [P.bool]},
"parse",
{func: "dynamic__int_bool", args: [P.$int, P.bool]},
"success",
{func: "dynamic__int_String_String_Function_Function", args: [P.$int, P.String, P.String, P.Function, P.Function]},
"onLoad",
"onError",
"urls",
"previousIndex",
{func: "dynamic__AudioBuffer", args: [P.AudioBuffer]},
[P.DoubleLinkedQueue, P.num],
R.Bounds,
[P.List, R.Body0],
[P.List, R.QuadTree],
{func: "dynamic__int_int_int_int__int_int_int", args: [P.$int, P.$int, P.$int, P.$int], opt: [P.$int, P.$int, P.$int]},
{func: "dynamic__Group", args: [R.Group]},
{func: "dynamic__Sprite0", args: [R.Sprite0]},
{func: "dynamic__Body", args: [R.Body0]},
"body",
{func: "List__dynamic0", ret: P.List, args: [null]},
{func: "int__num_num", ret: P.$int, args: [P.num, P.num]},
"ary",
{func: "num___num_num", ret: P.num, opt: [P.num, P.num]},
946684800000,
1577862000000,
"domain",
{func: "String__String_String_bool_String", ret: P.String, args: [P.String, P.String, P.bool, P.String]},
"redirect",
"parameter",
{func: "dynamic__dynamic__dynamic_int_bool_bool", args: [null], opt: [null, P.$int, P.bool, P.bool]},
"keys",
"collide",
"collideWorldBounds",
"lifespan",
{func: "dynamic___bool_num_num_int_bool", opt: [P.bool, P.num, P.num, P.$int, P.bool]},
250,
"explode",
"forceQuantity",
{func: "dynamic___num_num_num_EasingFunction_bool", opt: [P.num, P.num, P.num, {func: "double__double", ret: P.$double, args: [P.$double]}, P.bool]},
"rate",
"ease",
"yoyo",
{func: "dynamic___num_num_num_num_num_EasingFunction_bool", opt: [P.num, P.num, P.num, P.num, P.num, {func: "double__double", ret: P.$double, args: [P.$double]}, P.bool]},
"minX",
"maxX",
"minY",
"maxY",
[P.Map, P.String, R.Emitter],
{func: "Emitter__Emitter", ret: R.Emitter, args: [R.Emitter]},
"emitter",
R.QuadTree,
"children",
{func: "dynamic__Body0", args: [O.Body]},
{func: "num__int_Body_num_num_num__num", ret: P.num, args: [P.$int, O.Body, P.num, P.num, P.num], opt: [P.num]},
10000,
"axis",
"velocity",
"acceleration",
"drag",
{func: "bool__GameObject_dynamic__CollideFunc_ProcessFunc", ret: P.bool, args: [R.GameObject, null], opt: [{func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]}, {func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]}]},
"object1",
"object2",
"overlapCallback",
"processCallback",
"collideCallback",
{func: "dynamic__GameObject_dynamic__CollideFunc_ProcessFunc_bool", args: [R.GameObject, null], opt: [{func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]}, {func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]}, P.bool]},
"overlapOnly",
{func: "bool__Sprite_Sprite__CollideFunc_ProcessFunc_bool", ret: P.bool, args: [R.Sprite0, R.Sprite0], opt: [{func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]}, {func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]}, P.bool]},
"sprite1",
"sprite2",
{func: "dynamic__Sprite_Group__CollideFunc_ProcessFunc_bool", args: [R.Sprite0, R.Group], opt: [{func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]}, {func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]}, P.bool]},
{func: "bool__Group__CollideFunc_ProcessFunc_bool", ret: P.bool, args: [R.Group], opt: [{func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]}, {func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]}, P.bool]},
{func: "bool__Group_Group__CollideFunc_ProcessFunc_bool", ret: P.bool, args: [R.Group, R.Group], opt: [{func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]}, {func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]}, P.bool]},
"group1",
"group2",
{func: "bool__Sprite_TilemapLayer__CollideFunc_ProcessFunc", ret: P.bool, args: [R.Sprite0, R.TilemapLayer], opt: [{func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]}, {func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]}]},
"tilemapLayer",
{func: "bool__Group_TilemapLayer__CollideFunc_ProcessFunc", ret: P.bool, args: [R.Group, R.TilemapLayer], opt: [{func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]}, {func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]}]},
{func: "dynamic__Body_Body__ProcessFunc_bool", args: [O.Body, O.Body], opt: [{func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]}, P.bool]},
"body1",
"body2",
{func: "bool__Body_Body", ret: P.bool, args: [O.Body, O.Body]},
{func: "bool__Body_Body_bool", ret: P.bool, args: [O.Body, O.Body, P.bool]},
{func: "bool__int_Body_Tile", ret: P.bool, args: [P.$int, O.Body, R.Tile]},
"tile",
{func: "num__Body_Tile", ret: P.num, args: [O.Body, R.Tile]},
{func: "bool__Body_num", ret: P.bool, args: [O.Body, P.num]},
{func: "List__Pointer_Group_Function", ret: [P.List, R.Sprite0], args: [R.Pointer, R.Group, P.Function]},
{func: "dynamic__Sprite_GameObject__num_int", args: [R.Sprite0, R.GameObject], opt: [P.num, P.$int]},
"maxTime",
{func: "num__Sprite__num_Pointer_int", ret: P.num, args: [R.Sprite0], opt: [P.num, R.Pointer, P.$int]},
{func: "num__Sprite_num_num__num_int", ret: P.num, args: [R.Sprite0, P.num, P.num], opt: [P.num, P.$int]},
{func: "Point__num__num_Point", ret: R.Point, args: [P.num], opt: [P.num, R.Point]},
"rotation",
{func: "num__Sprite_GameObject__num_num_num", ret: P.num, args: [R.Sprite0, R.GameObject], opt: [P.num, P.num, P.num]},
"xSpeedMax",
"ySpeedMax",
{func: "num__Sprite__Pointer_num_num_num", ret: P.num, args: [R.Sprite0], opt: [R.Pointer, P.num, P.num, P.num]},
{func: "num__Sprite_num_num__num_num_num", ret: P.num, args: [R.Sprite0, P.num, P.num], opt: [P.num, P.num, P.num]},
1000,
{func: "num__GameObject_GameObject", ret: P.num, args: [R.GameObject, R.GameObject]},
{func: "num__GameObject_num_num", ret: P.num, args: [R.GameObject, P.num, P.num]},
{func: "num__GameObject__Pointer", ret: P.num, args: [R.GameObject], opt: [R.Pointer]},
{func: "dynamic__dynamic_dynamic__bool", args: [null, null], opt: [P.bool]},
{func: "dynamic__dynamic__int_bool", args: [null], opt: [P.$int, P.bool]},
{func: "dynamic__dynamic__int_int_num_bool", args: [null], opt: [P.$int, P.$int, P.num, P.bool]},
{func: "dynamic__SpriteInterface__int_int_num", args: [R.SpriteInterface], opt: [P.$int, P.$int, P.num]},
{func: "dynamic__Tilemap_dynamic", args: [R.Tilemap, null]},
{func: "List__Tilemap_dynamic_Map", ret: [P.List, R.Body0], args: [R.Tilemap, null, [P.Map, P.$int, P.$int]]},
"slopeMap",
{func: "dynamic__GameObject_GameObject__CollideFunc_ProcessFunc_bool", args: [R.GameObject, R.GameObject], opt: [{func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]}, {func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]}, P.bool]},
{func: "dynamic__Sprite_Sprite_CollideFunc_ProcessFunc_bool", args: [R.Sprite0, R.Sprite0, {func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]}, {func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]}, P.bool]},
{func: "dynamic__Sprite_Group_CollideFunc_ProcessFunc_bool", args: [R.Sprite0, R.Group, {func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]}, {func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]}, P.bool]},
{func: "dynamic__Group_CollideFunc_ProcessFunc_bool", args: [R.Group, {func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]}, {func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]}, P.bool]},
{func: "dynamic__Group_Group_CollideFunc_ProcessFunc_dynamic", args: [R.Group, R.Group, {func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]}, {func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]}, null]},
{func: "bool__Body_Body0", ret: P.bool, args: [E.Body2, E.Body2]},
R.Arcade0,
R.Ninja,
"system",
[P.Map, P.String, R.Marker],
P.AudioContext,
P.AudioNode,
P.GainNode,
{func: "dynamic__String_num_num__num_bool", args: [P.String, P.num, P.num], opt: [P.num, P.bool]},
{func: "Sound___String_int_double_bool_bool", ret: R.Sound, opt: [P.String, P.$int, P.$double, P.bool, P.bool]},
"forceRestart",
{func: "dynamic___String_int_double_bool", opt: [P.String, P.$int, P.$double, P.bool]},
"remove",
[P.List, R.Sound],
P.AudioBufferSourceNode,
{func: "dynamic__String__Sound", args: [P.String], opt: [R.Sound]},
{func: "dynamic__String__num_bool_dynamic", args: [P.String], opt: [P.num, P.bool, null]},
{func: "bool__Sound", ret: P.bool, args: [R.Sound]},
{func: "Sound__String__num_bool", ret: R.Sound, args: [P.String], opt: [P.num, P.bool]},
R.TilemapLayerData,
[P.Map, P.String, P.String],
{func: "dynamic__bool_bool_bool_bool", args: [P.bool, P.bool, P.bool, P.bool]},
{func: "bool__bool_bool", ret: P.bool, args: [P.bool, P.bool]},
"collides",
"faces",
{func: "dynamic__Tile", args: [R.Tile]},
[P.Map, P.String, P.List],
[P.List, R.TilemapImageData],
[P.List, R.TilemapLayerData],
[P.List, R.Tileset],
[P.List, [P.List, P.$int]],
[P.Map, R.Tile, P.String],
{func: "TilemapLayer__String_num_num_num_num__Group", ret: R.TilemapLayer, args: [P.String, P.num, P.num, P.num, P.num], opt: [R.Group]},
{func: "Tileset__dynamic__String_num_num_num_num_int", ret: R.Tileset, args: [null], opt: [P.String, P.num, P.num, P.num, P.num, P.$int]},
"tileset",
"tileMargin",
"tileSpacing",
"gid",
{func: "dynamic__String_num_String__dynamic_bool_bool_Group_Type_bool", args: [P.String, P.num, P.String], opt: [null, P.bool, P.bool, R.Group, P.Type, P.bool]},
"autoCull",
"CustomClass",
"adjustY",
{func: "TilemapLayer__dynamic__num_num_Group", ret: R.TilemapLayer, args: [null], opt: [P.num, P.num, R.Group]},
{func: "int__List_String", ret: P.$int, args: [P.List, P.String]},
{func: "dynamic__dynamic_Function__dynamic", args: [null, P.Function], opt: [null]},
"indexes",
{func: "dynamic__num_num_num_num_Function__dynamic", args: [P.num, P.num, P.num, P.num, P.Function], opt: [null]},
{func: "dynamic__dynamic__bool_dynamic_bool", args: [null], opt: [P.bool, null, P.bool]},
"recalculate",
{func: "dynamic__num_num__bool_dynamic_bool", args: [P.num, P.num], opt: [P.bool, null, P.bool]},
{func: "dynamic__List__bool_dynamic_bool", args: [[P.List, P.$int]], opt: [P.bool, null, P.bool]},
{func: "dynamic__int__bool_dynamic_bool", args: [P.$int], opt: [P.bool, null, P.bool]},
{func: "int___dynamic", ret: P.$int, opt: [null]},
{func: "Tile__int_num_num", ret: R.Tile, args: [P.$int, P.num, P.num]},
{func: "bool__num_num_dynamic", ret: P.bool, args: [P.num, P.num, null]},
{func: "Tile__num_num_dynamic", ret: R.Tile, args: [P.num, P.num, null]},
{func: "Tile__num_num_num_num_dynamic", ret: R.Tile, args: [P.num, P.num, P.num, P.num, null]},
{func: "Tile__dynamic_num_num__dynamic", ret: R.Tile, args: [null, P.num, P.num], opt: [null]},
{func: "Tile__dynamic_num_num_num_num__dynamic", ret: R.Tile, args: [null, P.num, P.num, P.num, P.num], opt: [null]},
{func: "Tile__int__int_bool_dynamic", ret: R.Tile, args: [P.$int], opt: [P.$int, P.bool, null]},
"skip",
"reverse",
{func: "Tile__num_num__dynamic_bool", ret: R.Tile, args: [P.num, P.num], opt: [null, P.bool]},
"nonNull",
{func: "Tile__num_num__num_num_dynamic", ret: R.Tile, args: [P.num, P.num], opt: [P.num, P.num, null]},
{func: "List__num_num_num_num__dynamic", ret: [P.List, R.Tile], args: [P.num, P.num, P.num, P.num], opt: [null]},
{func: "dynamic___num_num_List_dynamic", opt: [P.num, P.num, P.List, null]},
"tileblock",
{func: "dynamic__int_int_num_num_num_num__dynamic", args: [P.$int, P.$int, P.num, P.num, P.num, P.num], opt: [null]},
"tileA",
"tileB",
{func: "dynamic__Function_num_num_num_num__dynamic", args: [P.Function, P.num, P.num, P.num, P.num], opt: [null]},
{func: "dynamic__num_num_num_num__dynamic", args: [P.num, P.num, P.num, P.num], opt: [null]},
{func: "dynamic__int_num_num_num_num__dynamic", args: [P.$int, P.num, P.num, P.num, P.num], opt: [null]},
[P.List, P.Function],
[P.List, [P.List, R.Tile]],
R.Tilemap,
R.MapCache,
[P.List, R.Tile],
{func: "Point__dynamic_dynamic_Point", ret: R.Point, args: [null, null, R.Point]},
{func: "List__Line__num_bool_bool", ret: [P.List, R.Tile], args: [R.Line], opt: [P.num, P.bool, P.bool]},
"interestingFace",
{func: "List__num_num_num_num__bool_bool", ret: [P.List, R.Tile], args: [P.num, P.num, P.num, P.num], opt: [P.bool, P.bool]},
{func: "Map__Map_List", ret: P.Map, args: [P.Map, P.List]},
"fields",
[P.List, P.List],
{func: "dynamic__CanvasRenderingContext2D_num_num_int", args: [W.CanvasRenderingContext2D, P.num, P.num, P.$int]},
"image",
R.Timer,
[P.List, R.Timer],
{func: "dynamic__Timer", args: [R.Timer]},
{func: "Timer___bool", ret: R.Timer, opt: [P.bool]},
"since",
[P.List, R.TimerEvent],
[R.Signal, {func: "void__Timer", void: true, args: [R.Timer]}],
{func: "TimerEvent__num_bool_int_Function_dynamic", ret: R.TimerEvent, args: [P.num, P.bool, P.$int, P.Function, null]},
{func: "TimerEvent__num_Function__List", ret: R.TimerEvent, args: [P.num, P.Function], opt: [P.List]},
{func: "TimerEvent__double_int_Function_List", ret: R.TimerEvent, args: [P.$double, P.$int, P.Function, P.List]},
{func: "TimerEvent__dynamic_dynamic_List", ret: R.TimerEvent, args: [null, null, P.List]},
"clearEvents",
{func: "dynamic__TimerEvent", args: [R.TimerEvent]},
"events",
"baseTime",
{func: "EasingFunction_", ret: {func: "double__double", ret: P.$double, args: [P.$double]}},
R.Linears,
R.Quads,
R.Cubics,
R.Quarts,
R.Circs,
R.Quints,
R.Sines,
R.Expos,
R.Backs,
R.Bounces,
R.Elastics,
{func: "double__double", ret: P.$double, args: [P.$double]},
[P.List, R.Tween],
R.Tween,
{func: "Tween__Map__int_EasingFunction_bool_num_int_bool", ret: R.Tween, args: [[P.Map, P.String, P.num]], opt: [P.$int, {func: "double__double", ret: P.$double, args: [P.$double]}, P.bool, P.num, P.$int, P.bool]},
"repeat",
{func: "Tween__Map__int_EasingFunction_bool_double_int_bool", ret: R.Tween, args: [P.Map], opt: [P.$int, {func: "double__double", ret: P.$double, args: [P.$double]}, P.bool, P.$double, P.$int, P.bool]},
{func: "List___int_List0", ret: P.List, opt: [P.$int, P.List]},
"times",
"easing",
"interpolation",
{func: "Tween__List", ret: R.Tween, args: [[P.List, R.Tween]]},
"tweens",
{func: "Tween__Tween", ret: R.Tween, args: [R.Tween]},
"tween",
{func: "bool__num", ret: P.bool, args: [P.num]},
{func: "dynamic__Tween", args: [R.Tween]},
"rgb(255,255,255)",
"columnWidth",
"strs",
{func: "dynamic__Sound_num_num__String", args: [R.Sound, P.num, P.num], opt: [P.String]},
{func: "dynamic__Camera_num_num__String", args: [R.Camera, P.num, P.num], opt: [P.String]},
"camera",
{func: "dynamic__Timer_num_num__String", args: [R.Timer, P.num, P.num], opt: [P.String]},
{func: "dynamic__Pointer__bool_String_String_String", args: [R.Pointer], opt: [P.bool, P.String, P.String, P.String]},
"rgba(0,255,0,0.5)",
"rgba(255,0,0,0.5)",
"hideIfUp",
"downColor",
"upColor",
{func: "dynamic__dynamic_num_num__String", args: [null, P.num, P.num], opt: [P.String]},
{func: "dynamic__Key_num_num__String", args: [R.Key, P.num, P.num], opt: [P.String]},
{func: "dynamic__num_num__String", args: [P.num, P.num], opt: [P.String]},
"rgba(255,255,255,0.2)",
{func: "dynamic__Sprite_num_num__String", args: [R.Sprite0, P.num, P.num], opt: [P.String]},
{func: "dynamic__Line_num_num__String", args: [R.Line, P.num, P.num], opt: [P.String]},
{func: "dynamic__num_num__String_int", args: [P.num, P.num], opt: [P.String, P.$int]},
{func: "dynamic__dynamic__String_bool_int", args: [null], opt: [P.String, P.bool, P.$int]},
"forceType",
{func: "dynamic__Rectangle__String_bool", args: [R.Rectangle1], opt: [P.String, P.bool]},
"rgba(0, 255, 0, 0.4)",
{func: "dynamic__String_num_num__String_String", args: [P.String, P.num, P.num], opt: [P.String, P.String]},
"16px Courier",
{func: "dynamic__QuadTree__String", args: [R.QuadTree], opt: [P.String]},
"rgba(255,0,0,0.3)",
"quadtree",
{func: "dynamic__Sprite__String_bool", args: [R.Sprite0], opt: [P.String, P.bool]},
{func: "dynamic__Sprite_num_num_String", args: [R.Sprite0, P.num, P.num, P.String]},
"invocation",
{func: "bool__Object", ret: P.bool, args: [P.Object]},
{func: "bool__Pattern__int", ret: P.bool, args: [P.Pattern], opt: [P.$int]},
H.TearOffClosure,
{func: "dynamic__dynamic_String", args: [null, P.String]},
"flag",
{func: "void__Locus", void: true, args: [M.Locus]},
P.Random,
"matchingPiece",
{func: "dynamic__Symbol_dynamic", args: [P.Symbol0, null]},
{func: "TypeMirror__int", ret: P.TypeMirror, args: [P.$int]},
"_",
{func: "dynamic__void_", args: [{func: "void_", void: true}]},
{func: "void__Object__StackTrace", void: true, args: [P.Object], opt: [P.StackTrace]},
{func: "void___dynamic", void: true, opt: [null]},
"ignored",
{func: "Future__Object", ret: [P.Future, P.bool], args: [P.Object]},
"st",
{func: "void__Function", void: true, args: [P.Function]},
{func: "void___DelayedEvent", void: true, args: [P._DelayedEvent]},
{func: "dynamic__dynamic_StackTrace", args: [null, P.StackTrace]},
{func: "void__dynamic_StackTrace", void: true, args: [null, P.StackTrace]},
"arg",
"each",
{func: "int__dynamic_int", ret: P.$int, args: [null, P.$int]},
{func: "void__int_int", void: true, args: [P.$int, P.$int]},
{func: "DateTime__Duration", ret: P.DateTime, args: [P.Duration]},
"other",
{func: "dynamic__Invocation", args: [P.Invocation]},
{func: "void__String", void: true, args: [P.String]},
"byteString",
{func: "void__String__dynamic", void: true, args: [P.String], opt: [null]},
{func: "Element__Element", ret: W.Element, args: [W.Element]},
"stream",
{func: "void__Node", void: true, args: [W.Node]},
"piece",
[P.Map, P.String, M.BaseTexture],
P.Set,
[P.List, R.Game],
{func: "void__int_bool_bool", void: true, args: [P.$int, P.bool, P.bool]},
{func: "void__GameObject", void: true, args: [R.GameObject]},
{func: "void__GameObject_Pointer", void: true, args: [R.GameObject, R.Pointer]},
{func: "void__GameObject_Pointer_bool", void: true, args: [R.GameObject, R.Pointer, P.bool]},
{func: "void__GameObject_Group", void: true, args: [R.GameObject, R.Group]},
{func: "void__GameObject_Animation", void: true, args: [R.GameObject, R.Animation]},
{func: "void__Pointer_dynamic", void: true, args: [R.Pointer, null]},
{func: "void__Key", void: true, args: [R.Key]},
{func: "void__int_String", void: true, args: [P.$int, P.String]},
{func: "void__int_String_bool_int_int", void: true, args: [P.$int, P.String, P.bool, P.$int, P.$int]},
{func: "void__dynamic_Map", void: true, args: [null, P.Map]},
{func: "void__dynamic_bool_int_int", void: true, args: [null, P.bool, P.$int, P.$int]},
{func: "void__GameObject_GameObject", void: true, args: [R.GameObject, R.GameObject]},
{func: "bool__GameObject_GameObject", ret: P.bool, args: [R.GameObject, R.GameObject]},
{func: "void__Sound", void: true, args: [R.Sound]},
{func: "void__Timer", void: true, args: [R.Timer]},
];
$ = null;
Isolate = Isolate.$finishIsolateConstructor(Isolate);
$ = new Isolate();
function convertToFastObject(properties) {
  function MyClass() {
  }
  MyClass.prototype = properties;
  new MyClass();
  return properties;
}
;
A = convertToFastObject(A);
B = convertToFastObject(B);
C = convertToFastObject(C);
D = convertToFastObject(D);
E = convertToFastObject(E);
F = convertToFastObject(F);
G = convertToFastObject(G);
H = convertToFastObject(H);
J = convertToFastObject(J);
K = convertToFastObject(K);
L = convertToFastObject(L);
M = convertToFastObject(M);
N = convertToFastObject(N);
O = convertToFastObject(O);
P = convertToFastObject(P);
Q = convertToFastObject(Q);
R = convertToFastObject(R);
S = convertToFastObject(S);
T = convertToFastObject(T);
U = convertToFastObject(U);
V = convertToFastObject(V);
W = convertToFastObject(W);
X = convertToFastObject(X);
Y = convertToFastObject(Y);
Z = convertToFastObject(Z);
function init() {
  Isolate.$isolateProperties = {};
  function generateAccessor(fieldDescriptor, accessors, cls) {
    var fieldInformation = fieldDescriptor.split("-");
    var field = fieldInformation[0];
    var len = field.length;
    var code = field.charCodeAt(len - 1);
    var reflectable;
    if (fieldInformation.length > 1)
      reflectable = true;
    else
      reflectable = false;
    code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
    if (code) {
      var getterCode = code & 3;
      var setterCode = code >> 2;
      var accessorName = field = field.substring(0, len - 1);
      var divider = field.indexOf(":");
      if (divider > 0) {
        accessorName = field.substring(0, divider);
        field = field.substring(divider + 1);
      }
      if (getterCode) {
        var args = getterCode & 2 ? "receiver" : "";
        var receiver = getterCode & 1 ? "this" : "receiver";
        var body = "return " + receiver + "." + field;
        var property = cls + ".prototype.get$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
      if (setterCode) {
        var args = setterCode & 2 ? "receiver, value" : "value";
        var receiver = setterCode & 1 ? "this" : "receiver";
        var body = receiver + "." + field + " = value";
        var property = cls + ".prototype.set$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
    }
    return field;
  }
  Isolate.$isolateProperties.$generateAccessor = generateAccessor;
  function defineClass(name, cls, fields) {
    var accessors = [];
    var str = "function " + cls + "(";
    var body = "";
    for (var i = 0; i < fields.length; i++) {
      if (i != 0)
        str += ", ";
      var field = generateAccessor(fields[i], accessors, cls);
      var parameter = "parameter_" + field;
      str += parameter;
      body += "this." + field + " = " + parameter + ";\n";
    }
    str += ") {\n" + body + "}\n";
    str += cls + ".builtin$cls=\"" + name + "\";\n";
    str += "$desc=$collectedClasses." + cls + ";\n";
    str += "if($desc instanceof Array) $desc = $desc[1];\n";
    str += cls + ".prototype = $desc;\n";
    if (typeof defineClass.name != "string") {
      str += cls + ".name=\"" + cls + "\";\n";
    }
    str += accessors.join("");
    return str;
  }
  var inheritFrom = function() {
    function tmp() {
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    return function(constructor, superConstructor) {
      tmp.prototype = superConstructor.prototype;
      var object = new tmp();
      var properties = constructor.prototype;
      for (var member in properties)
        if (hasOwnProperty.call(properties, member))
          object[member] = properties[member];
      object.constructor = constructor;
      constructor.prototype = object;
      return object;
    };
  }();
  Isolate.$finishClasses = function(collectedClasses, isolateProperties, existingIsolateProperties) {
    var pendingClasses = {};
    if (!init.allClasses)
      init.allClasses = {};
    var allClasses = init.allClasses;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    if (typeof dart_precompiled == "function") {
      var constructors = dart_precompiled(collectedClasses);
    } else {
      var combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
      var constructorsList = [];
    }
    for (var cls in collectedClasses) {
      if (hasOwnProperty.call(collectedClasses, cls)) {
        var desc = collectedClasses[cls];
        if (desc instanceof Array)
          desc = desc[1];
        var classData = desc["^"], supr, name = cls, fields = classData;
        if (typeof classData == "object" && classData instanceof Array) {
          classData = fields = classData[0];
        }
        if (typeof classData == "string") {
          var split = classData.split("/");
          if (split.length == 2) {
            name = split[0];
            fields = split[1];
          }
        }
        var s = fields.split(";");
        fields = s[1] == "" ? [] : s[1].split(",");
        supr = s[0];
        split = supr.split(":");
        if (split.length == 2) {
          supr = split[0];
          var functionSignature = split[1];
          if (functionSignature)
            desc.$signature = function(s) {
              return function() {
                return init.metadata[s];
              };
            }(functionSignature);
        }
        if (supr && supr.indexOf("+") > 0) {
          s = supr.split("+");
          supr = s[0];
          var mixin = collectedClasses[s[1]];
          if (mixin instanceof Array)
            mixin = mixin[1];
          for (var d in mixin) {
            if (hasOwnProperty.call(mixin, d) && !hasOwnProperty.call(desc, d))
              desc[d] = mixin[d];
          }
        }
        if (typeof dart_precompiled != "function") {
          combinedConstructorFunction += defineClass(name, cls, fields);
          constructorsList.push(cls);
        }
        if (supr)
          pendingClasses[cls] = supr;
      }
    }
    if (typeof dart_precompiled != "function") {
      combinedConstructorFunction += "return [\n  " + constructorsList.join(",\n  ") + "\n]";
      var constructors = new Function("$collectedClasses", combinedConstructorFunction)(collectedClasses);
      combinedConstructorFunction = null;
    }
    for (var i = 0; i < constructors.length; i++) {
      var constructor = constructors[i];
      var cls = constructor.name;
      var desc = collectedClasses[cls];
      var globalObject = isolateProperties;
      if (desc instanceof Array) {
        globalObject = desc[0] || isolateProperties;
        desc = desc[1];
      }
      constructor["@"] = desc;
      allClasses[cls] = constructor;
      globalObject[cls] = constructor;
    }
    constructors = null;
    var finishedClasses = {};
    init.interceptorsByTag = Object.create(null);
    init.leafTags = {};
    function finishClass(cls) {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      if (hasOwnProperty.call(finishedClasses, cls))
        return;
      finishedClasses[cls] = true;
      var superclass = pendingClasses[cls];
      if (!superclass || typeof superclass != "string")
        return;
      finishClass(superclass);
      var constructor = allClasses[cls];
      var superConstructor = allClasses[superclass];
      if (!superConstructor)
        superConstructor = existingIsolateProperties[superclass];
      var prototype = inheritFrom(constructor, superConstructor);
      if (hasOwnProperty.call(prototype, "%")) {
        var nativeSpec = prototype["%"].split(";");
        if (nativeSpec[0]) {
          var tags = nativeSpec[0].split("|");
          for (var i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = true;
          }
        }
        if (nativeSpec[1]) {
          tags = nativeSpec[1].split("|");
          if (nativeSpec[2]) {
            var subclasses = nativeSpec[2].split("|");
            for (var i = 0; i < subclasses.length; i++) {
              var subclass = allClasses[subclasses[i]];
              subclass.$nativeSuperclassTag = tags[0];
            }
          }
          for (i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = false;
          }
        }
      }
    }
    for (var cls in pendingClasses)
      finishClass(cls);
  };
  Isolate.$lazy = function(prototype, staticName, fieldName, getterName, lazyValue) {
    if (!init.lazies)
      init.lazies = {};
    init.lazies[fieldName] = getterName;
    var sentinelUndefined = {};
    var sentinelInProgress = {};
    prototype[fieldName] = sentinelUndefined;
    prototype[getterName] = function() {
      var result = $[fieldName];
      try {
        if (result === sentinelUndefined) {
          $[fieldName] = sentinelInProgress;
          try {
            result = $[fieldName] = lazyValue();
          } finally {
            if (result === sentinelUndefined)
              if ($[fieldName] === sentinelInProgress)
                $[fieldName] = null;
          }
        } else {
          if (result === sentinelInProgress)
            H.throwCyclicInit(staticName);
        }
        return result;
      } finally {
        $[getterName] = function() {
          return this[fieldName];
        };
      }
    };
  };
  Isolate.$finishIsolateConstructor = function(oldIsolate) {
    var isolateProperties = oldIsolate.$isolateProperties;
    function Isolate() {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      for (var staticName in isolateProperties)
        if (hasOwnProperty.call(isolateProperties, staticName))
          this[staticName] = isolateProperties[staticName];
      function ForceEfficientMap() {
      }
      ForceEfficientMap.prototype = this;
      new ForceEfficientMap();
    }
    Isolate.prototype = oldIsolate.prototype;
    Isolate.prototype.constructor = Isolate;
    Isolate.$isolateProperties = isolateProperties;
    Isolate.$finishClasses = oldIsolate.$finishClasses;
    Isolate.makeConstantList = oldIsolate.makeConstantList;
    return Isolate;
  };
}
!function() {
  function intern(s) {
    var o = {};
    o[s] = 1;
    return Object.keys(convertToFastObject(o))[0];
  }
  init.getIsolateTag = function(name) {
    return intern("___dart_" + name + init.isolateTag);
  };
  var tableProperty = "___dart_isolate_tags_";
  var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
  var rootProperty = "_ZxYxX";
  for (var i = 0;; i++) {
    var property = intern(rootProperty + "_" + i + "_");
    if (!(property in usedProperties)) {
      usedProperties[property] = 1;
      init.isolateTag = property;
      break;
    }
  }
}();
init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
// BEGIN invoke [main].
;(function(callback) {
  if (typeof document === "undefined") {
    callback(null);
    return;
  }
  if (document.currentScript) {
    callback(document.currentScript);
    return;
  }
  var scripts = document.scripts;
  function onLoad(event) {
    for (var i = 0; i < scripts.length; ++i) {
      scripts[i].removeEventListener("load", onLoad, false);
    }
    callback(event.target);
  }
  for (var i = 0; i < scripts.length; ++i) {
    scripts[i].addEventListener("load", onLoad, false);
  }
})(function(currentScript) {
  init.currentScript = currentScript;
  if (typeof dartMainRunner === "function") {
    dartMainRunner(function(a) {
      H.startRootIsolate(Z.main$closure(), a);
    }, []);
  } else {
    (function(a) {
      H.startRootIsolate(Z.main$closure(), a);
    })([]);
  }
});
;
// END invoke [main].
})()
